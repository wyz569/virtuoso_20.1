
<html><head><title>Statements for the Analog Block</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jommy" />
<meta name="CreateDate" content="2019-09-18" />
<meta name="CreateTime" content="1568827701" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the analog and mixed-signal aspects of the Cadence Verilog-AMS language. With Verilog-AMS, you can create and use modules that describe the high-level behavior and structure of analog, digital, and mixed-signal components and systems." />
<meta name="DocTitle" content="Cadence Verilog-AMS Language Reference" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Statements for the Analog Block" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-3.1" />
<meta name="Keyword" content="verilogamsref" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2019-09-18" />
<meta name="ModifiedTime" content="1568827701" />
<meta name="NextFile" content="chap6.html" />
<meta name="Group" content="Analog Mixed-Signal Simulation" />
<meta name="Platform" content="Functional Verification" />
<meta name="PrevFile" content="chap4.html" />
<meta name="Product" content="Xcelium" />
<meta name="ProductFamily" content="Xcelium" />
<meta name="ProductVersion" content="19.09" />
<meta name="RightsManagement" content="Copyright 2012-2019 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence Verilog-AMS Language Reference -- Statements for the Analog Block" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="product_feature" content="" />
<meta name="product_subfeature" content="" />
<meta name="Version" content="19.09" />
<meta name="SpaceKey" content="verilogamsref1909" />
<meta name="webflare-version" content="1.4" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" /></head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="verilogamsrefTOC.html">Contents</a></li><li><a class="prev" href="chap4.html" title="Data Types and Objects">Data Types and Objects</a></li><li style="float: right;"><a class="viewPrint" href="verilogamsref.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap6.html" title="Operators for Analog Blocks">Operators for Analog Blocks</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence Verilog-AMS Language Reference<br />Product Version 19.09, September 2019</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;">

<h1>5
<a id="pgfId-1031799"></a></h1>
<h1>
<a id="pgfId-1031801"></a><hr />
Statements for the Analog Block<hr />
</h1>

<p>
<a id="pgfId-1031802"></a>This chapter describes the assignment statements and the <a id="marker-1031803"></a><a id="marker-1031804"></a>procedural control constructs and statements that the Cadence<sup>&#174;</sup> Verilog<sup>&#174;</sup>-AMS language supports within the analog block. For information, see the indicated locations. The constructs and statements discussed include</p>
<ul><li>
<a id="pgfId-1031811"></a><a href="chap5.html#40527">Procedural Assignment Statements in the Analog Block</a></li><li>
<a id="pgfId-1031815"></a><a href="chap5.html#14367">Branch Contribution Statement</a></li><li>
<a id="pgfId-1031819"></a><a href="chap5.html#26164">Indirect Branch Assignment Statement</a></li><li>
<a id="pgfId-1031823"></a><a href="chap5.html#10229">Sequential Block Statement</a></li><li>
<a id="pgfId-1031827"></a><a href="chap5.html#16351">Conditional Statement</a></li><li>
<a id="pgfId-1031831"></a><a href="chap5.html#30936">Case Statement</a></li><li>
<a id="pgfId-1031833"></a>Loop statements, including <ul><li>
<a id="pgfId-1031836"></a><a href="chap5.html#14021">Repeat Statement</a></li><li>
<a id="pgfId-1031840"></a><a href="chap5.html#15808">While Statement</a></li><li>
<a id="pgfId-1031844"></a><a href="chap5.html#21292">For Statement</a></li></ul></li><li>
<a id="pgfId-1031848"></a><a href="chap5.html#38923">Generate Statement</a></li></ul>










<p>
<a id="pgfId-1047576"></a><a id="marker-1044169"></a>Verilog-AMS also supports statements for use in digital contexts. For more information, see the &#8220;Assignments&#8221; and &#8220;Behavioral Modeling&#8221; chapters, in the <em>Verilog-XL Reference</em>.</p>

<h2>
<a id="pgfId-1031856"></a>Assignment Statements</h2>

<p>
<a id="pgfId-1031857"></a>There are several kinds of assignment statements in Verilog-AMS: the procedural assignment statement, the branch contribution statement, and the indirect branch assignment statement are available for analog modeling. You use the procedural assignment statement to modify integer and real variables and you use the branch contribution and indirect branch assignment statements to modify branch values such as potential and flow.</p>
<p>
<a id="pgfId-1047613"></a><a id="marker-1044171"></a>In addition, Verilog-AMS supports the continuous assignment statement and the procedural assignment statement for digital modeling. Continuous assignment statements can be used only outside of the initial, always, and analog blocks. For more information on these statements, see the &#8220;Assignments&#8221; chapter, in the <em>Verilog-XL Reference</em>.</p>

<h3>
<a id="pgfId-1031859"></a><a id="40527"></a>Procedural Assignment Statements in the Analog Block</h3>

<p>
<a id="pgfId-1031862"></a>Use the <a id="marker-1031860"></a>procedural <a id="marker-1031861"></a>assignment statement to modify integer and real variables. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1032576"></a>procedural_assignment ::=
&#160;&#160;&#160;&#160;    lexpr <strong>=</strong> expression <strong>;</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034682"></a>lexpr ::=
&#160;&#160;&#160;&#160;    <code><em>integer_identifier<br /></em></code> |&#160;&#160; <code><em>real_identifier<br /></em></code> |&#160;&#160; array_element</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034684"></a>array_element ::=
&#160;&#160;&#160;&#160;    <code><em>integer_identifier</em></code> <strong>[</strong> <code><em>constant_expression</em></code> <strong>]<br /></strong> |&#160;&#160; <code><em>real_identifier</em></code> <strong>[</strong> <code><em>constant_expression</em></code> <strong>]</strong></pre>

<p>
<a id="pgfId-1031865"></a>The left-hand operand of the procedural assignment used in analog blocks must be a modifiable integer or real variable or an element of an integer or real array. The type of the left-hand operand determines the type of the assignment.</p>
<p>
<a id="pgfId-1032583"></a>The right-hand operand can be any arbitrary scalar expression constituted from legal operands and operators. </p>
<p>
<a id="pgfId-1031867"></a>In the following code fragment, the variable <code>phase</code> is assigned a real value. The value must be real because <code>phase</code> is defined as a real variable. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031868"></a>real phase ;
analog begin
&#160;&#160;&#160;&#160;phase = idt( gain*V(in) ) ;</pre>

<p>
<a id="pgfId-1031870"></a>You can also use procedural assignment statements to modify <a id="marker-1031869"></a>array values. For example, if <code>r</code> is declared as</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031871"></a>real r[0:3], sum ;</pre>

<p>
<a id="pgfId-1031872"></a>you can make assignments such as</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031873"></a>r[0] = 10.1 ;<br />r[1] = 11.1 ;<br />r[2] = 12.1 ;<br />r[3] = 13.1 ;<br />sum = r[0] + r[1] + r[2] + r[3] ;</pre>
<h3>
<a id="pgfId-1031875"></a><a id="14367"></a>Branch Contribution Statement</h3>

<p>
<a id="pgfId-1031880"></a>Use the <a id="marker-1031876"></a>branch <a id="marker-1031877"></a>contribution<a id="marker-1031878"></a> statement to modify <a id="marker-1031879"></a>signal values. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031881"></a>branch_contribution ::=
&#160;&#160;&#160;&#160;    bvalue <strong>&lt;+</strong> <code><em>expression</em></code> <strong>;</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034686"></a>bvalue ::=
&#160;&#160;&#160;&#160;    <code><em>access_identifier</em></code> <strong>(</strong> analog_signal_list <strong>)</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034688"></a>analog_signal_list ::=
&#160;&#160;&#160;&#160;    <code><em>branch_identifier<br /></em></code> |&#160;&#160; <code><em>node_or_port_identifier<br /></em></code> |&#160;&#160; <code><em>node_or_port_identifier</em></code> <strong>,</strong> <code><em>node_or_port_identifier</em></code></pre>

<p>
<a id="pgfId-1031883"></a><code>bvalue</code> specifies a source branch signal. <code>bvalue</code> must consist of an <a id="marker-1031882"></a>access function applied to a branch. <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> can be linear, nonlinear, or dynamic. </p>
<p>
<a id="pgfId-1031885"></a>Branch contribution statements must be placed within the analog block.</p>
<p>
<a id="pgfId-1032590"></a>As discussed in the following list, the <a id="marker-1031884"></a>branch contribution statement differs in important ways from the procedural assignment statement.</p>
<ul><li>
<a id="pgfId-1031886"></a>You can use the procedural assignment statement only for variables, whereas you can use the branch contribution statement only for access functions.</li><li>
<a id="pgfId-1031887"></a>Using the procedural assignment statement to assign a number to a variable overrides the number previously contained in that variable. Using the <a id="marker-1031888"></a>branch contribution statement, however, adds to any previous contribution. (Contributions to flow can be viewed as adding new flow sources in parallel with previous flow sources. Contributions to value can be viewed as adding new value sources in series with previous value sources.)</li></ul>


<h4>
<a id="pgfId-1031889"></a><a id="marker-1044175"></a>Evaluation of a Branch Contribution Statement</h4>

<p>
<a id="pgfId-1031890"></a>For source branch contributions, the simulator evaluates the branch contribution statement as follows:</p>
<ol><li>
<a id="pgfId-1031891"></a>The simulator evaluates the right-hand operand.</li><li>
<a id="pgfId-1031892"></a>The simulator adds the value of the right-hand operand to any previously retained value for the branch.</li><li>
<a id="pgfId-1031893"></a>At the end of the evaluation of the analog block, the simulator assigns the summed value to the source branch.</li></ol>


<p>
<a id="pgfId-1031894"></a>For example, given a pair of nodes declared with the <code>electrical</code> discipline, the code fragment</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031895"></a>V(n1, n2) &lt;+ expr1 ;<br />V(n1, n2) &lt;+ expr2 ;</pre>

<p>
<a id="pgfId-1031896"></a>is equivalent to</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031897"></a>V(n1, n2) &lt;+ expr1 + expr2 ;</pre>
<h4>
<a id="pgfId-1031898"></a><a id="marker-1044177"></a>Creating a Switch Branch</h4>
<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1031899"></a>
When you contribute a flow to a branch that already has a value retained for potential, the simulator discards the value for potential and converts the branch to a flow source. Conversely, when you contribute a potential to a branch that already has a value retained for flow, the simulator discards the value for flow and converts the branch to a potential source. Branches converted from flow sources to potential sources, and vice versa, are known as <em>switch branches</em><a id="marker-1031900"></a><a id="marker-1031901"></a>. For additional information, see <a href="appB.html#18248">&#8220;Switch Branches&#8221;</a>.</div>
<h3>
<a id="pgfId-1031906"></a><a id="marker-1044179"></a><a id="26164"></a>Indirect Branch Assignment Statement</h3>

<p>
<a id="pgfId-1031909"></a>Use the <a id="marker-1031907"></a>indirect branch <a id="marker-1031908"></a>assignment statement when it is difficult to separate the target from the equation.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1032163"></a>indirect_branch_assignment ::=
&#160;&#160;&#160;&#160;    target <strong>:</strong> equation <strong>;</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034690"></a>target ::=
&#160;&#160;&#160;&#160;    <code><em>bvalue</em></code></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034692"></a>equation ::=
&#160;&#160;&#160;&#160;    nexpr <strong>==</strong> <code><em>expression</em></code></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034694"></a>nexpr ::=
&#160;&#160;&#160;&#160;    <code><em>bvalue<br /></em></code> |&#160;&#160; <strong>ddt</strong> <strong>(</strong> <code><em>bvalue</em></code> <strong>)<br /></strong> |&#160;&#160; <strong>idt</strong> <strong>(</strong> <code><em>bvalue</em></code> <strong>)
&#160;&#160;&#160;&#160;</strong>|<strong>   idtmod ( </strong><code><em>bvalue</em></code><strong> )</strong></pre>

<p>
<a id="pgfId-1031911"></a>An indirect branch assignment has this format:</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031912"></a>V(out) : V(in) == 0 ;</pre>

<p>
<a id="pgfId-1031913"></a>Read this as &#8220;find <code>V(out)</code>such that <code>V(in)</code> is zero.&#8221; This example says that <code>out</code> should be driven with a voltage source and the voltage should be such that the given equation is satisfied. Any branches referenced in the equation are only probed and not driven, so in this example, <code>V(in)</code> acts as a voltage probe.</p>
<p>
<a id="pgfId-1031914"></a>Indirect branch assignments can be used only within the analog block.</p>
<p>
<a id="pgfId-1032591"></a>The next example models an ideal operational amplifier with infinite gain. The indirect assignment statement says &#8220;find <code>V(out)</code> such that <code>V(pin, nin)</code> is zero.&#8221;</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031915"></a>module opamp (out, pin, nin) ;
output out ;
input pin, nin ;
voltage out, pin, nin ;
analog
&#160;&#160;&#160;&#160;V(out) : V(pin, nin) == 0 ; // Indirect assignment<br />endmodule</pre>

<p>
<a id="pgfId-1031917"></a>Indirect assignments are incompatible with assignments made with the <a id="marker-1031916"></a>branch contribution statement. If you indirectly assign a value to a branch, you cannot then contribute to the branch by using the branch contribution statement.</p>

<h2>
<a id="pgfId-1031919"></a><a id="marker-1044181"></a>Sequential <a id="10229"></a>Block Statement</h2>

<p>
<a id="pgfId-1031922"></a>Use a sequential block when you want to group two or more statements together so that they act like a single statement. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031923"></a>seq_block ::=
&#160;&#160;&#160;&#160;    <strong>begin</strong> [ <strong>:</strong> block_identifier { block_item_declaration } ]
&#160;&#160;&#160;&#160;        { statement }
&#160;&#160;&#160;&#160;    <strong>end</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034696"></a>block_item_declaration ::=
&#160;&#160;&#160;&#160;    parameter_declaration
&#160;&#160;&#160;&#160;    integer_declaration
&#160;&#160;&#160;&#160;|&#160;&#160; real_declaration</pre>

<p>
<a id="pgfId-1031924"></a>For information on <code>statement</code>, see <a href="chap2.html#31616">&#8220;Defining Module Analog Behavior&#8221;</a>.</p>
<p>
<a id="pgfId-1032384"></a>The statements included in a sequential block run sequentially.</p>
<p>
<a id="pgfId-1031925"></a>If you add a block identifier, you can also declare local variables for use within the block. All the local variables you declare are static. In other words, a unique location exists for each local variable, and entering or leaving the block does not affect the value of a local variable.</p>
<p>
<a id="pgfId-1031926"></a>The following code fragment uses two named blocks, declaring a local variable in each of them. Although the variables have the same name, the simulator handles them separately because each variable is local to its own block. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031927"></a>integer j ;<br />...</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034698"></a> for ( j = 0 ; j &lt; 10 ; j=j+1 ) begin<br />     if ( j%2 ) begin : odd<br />         integer j ; // Declares a local variable<br />         j = j+1 ;<br />         $display (&quot;Odd numbers counted so far = %d&quot; , j ) ;<br />     end else begin : even<br />         integer j ; // Declares a local variable<br />         j = j+1 ;<br />         $display (&quot;Even numbers counted so far = %d&quot; , j ) ;<br />     end<br /> end</pre>

<p>
<a id="pgfId-1031931"></a>Each named block defines a new <a id="marker-1031928"></a>scope. For additional information, see <a href="chap3.html#22489">&#8220;Scope Rules&#8221;</a>.</p>

<h2>
<a id="pgfId-1031934"></a><a id="marker-1044183"></a><a id="16351"></a>Conditional Statement</h2>

<p>
<a id="pgfId-1031937"></a>Use the conditional statement to run a statement under the control of specified conditions.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031938"></a>conditional_statement ::=
&#160;&#160;&#160;&#160;    <strong>if</strong> <strong>(</strong> <code><em>expression</em></code> <strong>)</strong> <code><em>statement1<br /></em></code> &#160;&#160;  [ <strong>else</strong> <code><em>statement2</em></code> ]</pre>

<p>
<a id="pgfId-1031939"></a>If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> evaluates to a nonzero number (true), the simulator executes <span class="webflare-courier-new" style="white-space:pre"><em>statement1</em></span>. If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> evaluates to zero (false) and the <code>else</code> statement is present, the simulator skips <span class="webflare-courier-new" style="white-space:pre"><em>statement1</em></span> and executes <span class="webflare-courier-new" style="white-space:pre"><em>statement2</em></span>.</p>
<p>
<a id="pgfId-1032842"></a>If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> consists entirely of genvar expressions, literal numerical constants, parameters, or the analysis function, <span class="webflare-courier-new" style="white-space:pre"><em>statement1</em></span> and <span class="webflare-courier-new" style="white-space:pre"><em>statement2</em></span> can include analog operators.</p>
<p>
<a id="pgfId-1031941"></a>The simulator always matches an <code>else</code><a id="marker-1031940"></a> statement with the closest previous <code>if</code> that lacks an <code>else</code>. In the following code fragment, for example, the first <code>else</code> goes with the inner <code>if</code>, as shown by the indentation. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031942"></a>if (index &gt; 0)
&#160;&#160;&#160;&#160;if (i &gt; j) // The next else belongs to this if
&#160;&#160;&#160;&#160;    result = i ;
&#160;&#160;&#160;&#160;else // This else belongs to the previous if
&#160;&#160;&#160;&#160;    result = j ;<br />else $strobe (&quot;Index &lt; 0&quot;); // This else belongs to the first if</pre>

<p>
<a id="pgfId-1031943"></a>The following code fragment illustrates a particularly useful form of the <code>if-else</code> construct.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031944"></a>if ((value &gt; 0)&amp;&amp;(value &lt;= 1)) $strobe(&quot;Category A&quot;);<br />else if ((value &gt; 1)&amp;&amp;(value &lt;= 2)) $strobe(&quot;Category B&quot;);<br />else if ((value &gt; 2)&amp;&amp;(value &lt;= 3)) $strobe(&quot;Category C&quot;);<br />else if ((value &gt; 3)&amp;&amp;(value &lt;= 4)) $strobe(&quot;Category D&quot;); <br />else $strobe(&quot;Illegal value&quot;);</pre>

<p>
<a id="pgfId-1031945"></a>The simulator evaluates the expressions in order. If any one of them is true, the simulator runs the associated statement and ends the whole chain. The last <code>else</code> statement handles the default case, running if none of the other expressions is true.</p>

<h2>
<a id="pgfId-1031947"></a><a id="marker-1044185"></a><a id="30936"></a>Case Statement</h2>

<p>
<a id="pgfId-1031950"></a>Use the <code>case</code><a id="marker-1031948"></a><a id="marker-1031949"></a> construct to control which one of a series of statements runs.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031951"></a>case_statement ::=
&#160;&#160;&#160;&#160;    <strong>case</strong> <strong>(</strong> <code><em>expression</em></code> <strong>)</strong> case_item { case_item } <strong>endcase</strong></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034700"></a>case_item ::=
&#160;&#160;&#160;&#160;    <code><em>test_expression</em></code> { <strong>,</strong> <code><em>test_expression</em></code> } <strong>:</strong> <code><em>statement<br /></em></code> |&#160;&#160; <strong>default</strong> [ <strong>:</strong> ] <code><em>statement</em></code></pre>

<p>
<a id="pgfId-1031952"></a>The <code>default</code> statement is optional. Using more than one <code>default</code> statement in a case construct is illegal.</p>
<p>
<a id="pgfId-1031953"></a>The simulator evaluates each <span class="webflare-courier-new" style="white-space:pre"><em>test_expression</em></span> in turn and compares it with <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span>. If there is a match, the statement associated with the matching <span class="webflare-courier-new" style="white-space:pre"><em>test_expression</em></span> runs. If none of the expressions in <span class="webflare-courier-new" style="white-space:pre"><em>text_expression</em></span> matches <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> and if you coded a default <code>case_item</code>, the <code>default</code> statement runs. If all comparisons fail and you did not code a default <code>case_item</code>, none of the associated statements runs.</p>
<p>
<a id="pgfId-1032850"></a>If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> and <span class="webflare-courier-new" style="white-space:pre"><em>text_expression</em></span> are genvar expressions, parameters, or the analysis function, <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> can include analog operators; otherwise, <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> cannot include analog operators.</p>
<p>
<a id="pgfId-1031954"></a>The following code fragment determines what range <code>value</code> is in. For example, if <code>value</code> is 1.5 the first comparison fails. The second <span class="webflare-courier-new" style="white-space:pre"><em>test_expression</em></span> evaluates to 1 (true), which matches the case expression, so the <code>$strobe(&quot;Category B&quot;)</code> statement runs.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031955"></a>real value ;<br />...</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034732"></a> case (1)<br />     ((value &gt; 0)&amp;&amp;(value &lt;= 1)) : $strobe(&quot;Category A&quot;);<br />     ((value &gt; 1)&amp;&amp;(value &lt;= 2)) : $strobe(&quot;Category B&quot;);<br />     ((value &gt; 2)&amp;&amp;(value &lt;= 3)) : $strobe(&quot;Category C&quot;);<br />     ((value &gt; 3)&amp;&amp;(value &lt;= 4)) : $strobe(&quot;Category D&quot;);<br />     value &lt;= 0 , value &gt;= 4 : $strobe(&quot;Out of range&quot;);<br />     default $strobe(&quot;Error. Should never get here.&quot;);<br /> endcase </pre>
<h2>
<a id="pgfId-1031966"></a><a id="marker-1044187"></a><a id="14021"></a>Repeat Statement</h2>

<p>
<a id="pgfId-1031969"></a>Use the <code>repeat</code><a id="marker-1031967"></a> statement when you want a statement to run a fixed number of times.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031970"></a>repeat_statement ::=
&#160;&#160;&#160;&#160;    <strong>repeat (</strong> constant_expression <strong>)</strong> statement</pre>

<p>
<a id="pgfId-1031972"></a><span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> must not include any analog operators. For additional information, see <a href="chap9.html#42564">&#8220;Analog Operators&#8221;</a><a id="marker-1031971"></a>.</p>
<p>
<a id="pgfId-1031973"></a>The following example code repeats the loop exactly 10 times while summing the first 10 digits. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1031974"></a>integer i, total ;<br />...</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034753"></a> i = 0 ;<br /> total = 0 ;<br /> repeat (10) begin<br />     i = i + 1 ;<br />     total = total + i ;<br /> end</pre>
<h2>
<a id="pgfId-1031976"></a><a id="marker-1044189"></a><a id="15808"></a>While Statement</h2>

<p>
<a id="pgfId-1031979"></a>Use the <code>while</code><a id="marker-1031977"></a> statement when you want to be able to leave a loop when an expression is no longer valid.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031980"></a>while_statement ::=
&#160;&#160;&#160;&#160;    <strong>while</strong> <strong>(</strong> <code><em>expression</em></code> <strong>)</strong> <code><em>statement</em></code></pre>

<p>
<a id="pgfId-1031981"></a>The <code>while</code> loop evaluates <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> at each entry into the loop. If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> is nonzero (true), <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> runs. If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> starts out as zero (false), <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> never runs.</p>
<p>
<a id="pgfId-1031983"></a><span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> must not include any analog operators. For additional information, see <a href="chap9.html#42564">&#8220;Analog Operators&#8221;</a><a id="marker-1031982"></a>.</p>
<p>
<a id="pgfId-1031984"></a>The following code fragment counts the number of random numbers generated before <code>rand</code> becomes zero.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031985"></a>integer rand, count ;<br />...</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034762"></a> rand = abs($random % 10) ;<br /> count = 0 ;<br /> while (rand) begin<br />     count = count + 1 ;<br />     rand = abs($random % 10) ;<br /> end ;<br /> $strobe (&quot;Count is %d&quot;, count) ;</pre>
<h2>
<a id="pgfId-1031987"></a><a id="marker-1044191"></a><a id="21292"></a>For Statement</h2>

<p>
<a id="pgfId-1031990"></a>Use the <code>for</code><a id="marker-1031988"></a> statement when you want a statement to run a fixed number of times.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031991"></a>for_statement ::=
&#160;&#160;&#160;&#160;    <strong>for</strong> <strong>(</strong> <code><em>initial_assignment</em></code> <strong>;</strong> <code><em>expression</em></code> <strong>;</strong> 
             <code><em>step_assignment</em></code> <strong>)</strong> <code><em>statement</em></code></pre>

<p>
<a id="pgfId-1031993"></a>If <span class="webflare-courier-new" style="white-space:pre"><em>initial_assignment</em></span>, <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span>, and <span class="webflare-courier-new" style="white-space:pre"><em>step_assignment</em></span> are genvar expressions, the statement can include analog operators; otherwise, the <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> must not include any <a id="marker-1031992"></a>analog operators. For additional information, see <a href="chap9.html#42564">&#8220;Analog Operators&#8221;</a>.</p>
<p>
<a id="pgfId-1031997"></a>Use <span class="webflare-courier-new" style="white-space:pre"><em>initial_assignment</em></span> to initialize an integer loop control variable that controls the number of times the loop executes. The simulator evaluates <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> at each entry into the loop. If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> evaluates to zero, the loop terminates. If <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> evaluates to a nonzero value, the simulator first runs <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> and then runs <span class="webflare-courier-new" style="white-space:pre"><em>step_assignment</em></span>. <span class="webflare-courier-new" style="white-space:pre"><em>step_assignment</em></span> is usually defined so that it modifies the loop control variable before the simulator evaluates <span class="webflare-courier-new" style="white-space:pre"><em>expression</em></span> again.</p>
<p>
<a id="pgfId-1031998"></a>For example, to sum the first 10 even numbers, the <code>repeat</code> loop given earlier could be rewritten as a <code>for</code> loop.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1031999"></a>integer j, total ;<br />...</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034771"></a> total = 0 ;<br /> for ( j = 2; j &lt; 22; j = j + 2 ) <br /> &#160;&#160;  total = total + j ;</pre>
<h2>
<a id="pgfId-1032001"></a><a id="marker-1044193"></a><a id="38923"></a>Generate Statement</h2>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1046290"></a>The <code>generate</code> statement is obsolete. To comply with current practice, use the <code>genvar</code> statement instead.</div>
<p>
<a id="pgfId-1032004"></a>The <code>generate</code><a id="marker-1032002"></a> statement is a looping construct that is unrolled at compile time. Use the <code>generate</code><a id="marker-1032003"></a> statement to simplify your code or when you have a looping construct that contains <a id="marker-1032005"></a><a id="marker-1032006"></a>analog operators. The <code>generate</code> statement can be used only within the analog block. The generate statement is supported only for backward compatibility.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1032007"></a>generate_statement ::=
&#160;&#160;&#160;&#160;    <strong>generate</strong> <code><em>index_identifier</em></code> <strong>(</strong> start_expr <strong>,</strong> 
&#160;&#160;&#160;&#160;    end_expr [ <strong>,</strong> incr_expr ] <strong>)</strong> <code><em>statement</em></code></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034702"></a>start_expr ::=
&#160;&#160;&#160;&#160;    <code><em>constant_expression</em></code></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034704"></a>end_expr ::=
&#160;&#160;&#160;&#160;    <code><em>constant_expression</em></code></pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034706"></a>incr_expr ::=
&#160;&#160;&#160;&#160;    <code><em>constant_expression</em></code></pre>

<p>
<a id="pgfId-1032008"></a><span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> is an identifier used in <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span>. When <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> is unrolled, each occurrence of <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> found in <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> is replaced by a constant. You must be certain that nothing inside <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span> modifies the index.</p>
<p>
<a id="pgfId-1032010"></a>In the first unrolled instance of <span class="webflare-courier-new" style="white-space:pre"><em>statement</em></span>, the compiler replaces each occurrence of <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> by the value <code>start_expr</code>. In the second instance, the compiler replaces each <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> by the value <code>start_expr</code> plus <code>incr_expr</code>. In the third instance, the compiler replaces each <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> by the value <code>start_expr</code> plus twice the <code>incr_expr</code>. This process continues until the replacement value is greater than the value of <code>end_expr</code>.</p>
<p>
<a id="pgfId-1032011"></a>If you do not specify <code>incr_expr</code>, it takes the value +1 if <code>end_expr</code> is greater than <code>start_expr</code>. If <code>end_expr</code> is less than <code>start_expr</code>, <code>incr_expr</code> takes the value -1 by default. </p>
<p>
<a id="pgfId-1032012"></a>The values of the <code>start_expr</code>, <code>end_expr</code>, and <code>incr_expr</code> determine how the <code>generate</code> statement behaves.</p>

<p>
<a id="pgfId-1039165"></a></p>
<table class="webflareTable" id="#id1032013">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1032015">
<a id="pgfId-1032015"></a>If</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1032017">
<a id="pgfId-1032017"></a>And</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1032019">
<a id="pgfId-1032019"></a>Then the generate statement</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032021"></a><code>start_expr</code> &gt; <code>end_expr</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032023"></a><code>incr_expr</code> &gt; 0 </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032025"></a>does not execute</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032027"></a><code>start_expr</code> &lt; <code>end_expr</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032029"></a><code>incr_expr</code> &lt; 0</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032031"></a>does not execute</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032033"></a><code>start_expr</code> = <code>end_expr</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032035"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1032037"></a>executes once</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1032039"></a>As an <a id="marker-1032038"></a>example of using the <code>generate</code> statement, consider the following module, which implements an analog-to-digital converter.<a id="marker-1032040"></a></p>

<pre class="webflare-courier-new">
<a id="pgfId-1032041"></a>`define BITS 4</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034708"></a>module adc (in, out) ;<br />input in ;<br />output [0:<code>`</code>BITS - 1] out ;<br />electrical in ;<br />electrical [0:<code>`</code>BITS - 1] out ;<br />parameter fullscale = 1.0, tdelay = 0.0, trantime = 10n ;<br />real samp, half ;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034710"></a>analog begin
&#160;&#160;&#160;&#160;half = fullscale/2.0 ;
&#160;&#160;&#160;&#160;samp = V(in) ;
&#160;&#160;&#160;&#160;generate i (<code>`</code>BITS - 1,0) begin    // default increment = -1
&#160;&#160;&#160;&#160;    V(out[i]) &lt;+ transition(samp &gt; half, tdelay, trantime);
&#160;&#160;&#160;&#160;    if (samp &gt; half) samp = samp - half ;
&#160;&#160;&#160;&#160;    samp = 2.0 * samp ;
&#160;&#160;&#160;&#160;end<br />end<br />endmodule</pre>

<p>
<a id="pgfId-1032044"></a>Module <code>adc</code> is equivalent to the following <a id="marker-1032042"></a>module<a id="marker-1032043"></a> coded without using the <code>generate</code> statement. </p>

<pre class="webflare-courier-new">
<a id="pgfId-1032045"></a><code>`</code>define BITS 4</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034712"></a>module adc_unrolled (in, out) ;<br />input in ;<br />output [0:<code>`</code>BITS - 1] out ;<br />electrical in;<br />electrical [0:<code>`</code>BITS - 1] out ;<br />parameter fullscale = 1.0, tdelay = 0.0, trantime = 10n ;<br />real samp, half ;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1034714"></a>analog begin
&#160;&#160;&#160;&#160;half = fullscale/2.0 ;
&#160;&#160;&#160;&#160;samp = V(in) ;
&#160;&#160;&#160;&#160;V(out[3]) &lt;+ transition(samp &gt; half, tdelay, trantime);
&#160;&#160;&#160;&#160;if (samp &gt; half) samp = samp - half ;
&#160;&#160;&#160;&#160;samp = 2.0 * samp ;
&#160;&#160;&#160;&#160;V(out[2]) &lt;+ transition(samp &gt; half, tdelay, trantime);
&#160;&#160;&#160;&#160;if (samp &gt; half) samp = samp - half ;
&#160;&#160;&#160;&#160;samp = 2.0 * samp ;
&#160;&#160;&#160;&#160;V(out[1]) &lt;+ transition(samp &gt; half, tdelay, trantime);
&#160;&#160;&#160;&#160;if (samp &gt; half) samp = samp - half ;
&#160;&#160;&#160;&#160;samp = 2.0 * samp ;
&#160;&#160;&#160;&#160;V(out[0]) &lt;+ transition(samp &gt; half, tdelay, trantime);
&#160;&#160;&#160;&#160;if (samp &gt; half) samp = samp - half ;
&#160;&#160;&#160;&#160;samp = 2.0 * samp ;<br />end<br />endmodule</pre>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1032883"></a>Because the <code>generate</code> statement is unrolled at compile time, you cannot use the SimVision debugging tool to examine the value of <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> or to evaluate expressions that contain <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span>. For example, if <span class="webflare-courier-new" style="white-space:pre"><em>index_identifier</em></span> is <code>i</code>, you cannot use a debugging command like <code>print i</code> nor can you use a command like <code>print{a[i]}</code>.</div>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap4.html" id="prev" title="Data Types and Objects">Data Types and Objects</a></em></b><b><em><a href="chap6.html" id="nex" title="Operators for Analog Blocks">Operators for Analog Blocks</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2019, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
</body></html>