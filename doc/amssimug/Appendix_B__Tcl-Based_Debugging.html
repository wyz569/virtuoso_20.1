
<html><head><title>Appendix B: Tcl-Based Debugging</title>
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jaini" />
<meta name="CreateDate" content="2019-11-04" />
<meta name="CreateTime" content="1572864948" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the Virtuoso AMS Designer simulator, a mixed-signal simulator that supports the Verilog-AMS and VHDL-AMS language standards." />
<meta name="DocTitle" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Appendix B: Tcl-Based Debugging" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="reference" />
<meta name="reference_type" content="command reference" />
<meta name="prod_feature" content="Digital Mixed Signal,Digital Mixed Signal,Analog Mixed Signal,Explorer,AMS Designer," />
<meta name="prod_subfeature" content="Debugging,Documentation,Debugging,AMS Designer," />
<meta name="FileType" content="Chapter" />
<meta name="Keyword" content="amssimug" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2019-11-04" />
<meta name="ModifiedTime" content="1572864948" />
<meta name="NextFile" content="Appendix_C__Source_Protection.html" />
<meta name="Group" content="Analog Mixed-Signal Simulation" />
<meta name="Platform" content="Functional Verification" />
<meta name="PrevFile" content="Appendix_A__Updating_Legacy_Libraries_and_Netlists.html" />
<meta name="Product" content="Xcelium" />
<meta name="ProductFamily" content="Functional Verification" />
<meta name="ProductVersion" content="19.09" />
<meta name="RightsManagement" content="Copyright 2012-2019 Cadence Design Systems Inc." />
<meta name="Title" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide -- Appendix B: Tcl-Based Debugging" />
<meta name="Version" content="19.09" />
<meta name="Renderer" content="WIKI" />
<meta name="SpaceKey" content="amssimug2003" />
<meta name="confluence-version" content="6.13.3" />
<meta name="ecms-plugin-version" content="03.30.005" />

        
        <link href="styles/site.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    

    </head><body style="background-color: #FFFFFF;"><!-- Begin Buttons --><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="docHeadr">Product Documentation<img src="images/Cadence-Logo.jpg" /></div>
<nav class="blueHead"><ul><li><a class="content" href="amssimugTOC.html">Contents</a></li><li><a class="prev" href="Appendix_A__Updating_Legacy_Libraries_and_Netlists.html" title="Appendix_A__Updating_Legacy_Libraries_and_Netlists">Appendix_A__Updating_Legacy_Li ...</a></li><li style="float: right;"><a class="viewPrint" href="amssimug.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="Appendix_C__Source_Protection.html" title="Appendix_C__Source_Protection">Appendix_C__Source_Protection</a></li></ul></nav></header><!-- End Buttons --><div xmlns:html="http://www.w3.org/1999/xhtml" style="font-size:14px;line-height:1.42857142857;margin:20px 0 0 0;font-weight:bold;"><center>Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide<br />Product Version 19.09, September 2019</center></div>
<div xmlns:html="http://www.w3.org/1999/xhtml" style="margin-left:5%;">
<p></p>

<p></p>
<div id="main-header">
                    
                    
                                                <h1 style="margin: 4px 0 4px;"><span>Appendix B: Tcl-Based Debugging</span></h1>

                    
                </div>
<div class="wiki-content group" id="main-content">
                    
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1031356"></span></p>

<p>This appendix describes the Tcl-based simulator commands you can use to debug your design. Tcl is an object-oriented language, which means that you supply the action to be performed on the object as a modifier to the command.</p>

<p>The command format is</p>

<p><span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">xcelium&gt;<code> Tcl_command </code>[<code> -modifiers </code>] [<code>-options</code>] [<code>arguments</code>]</span></p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>See also important information in<a href="#AppendixB:Tcl-BasedDebugging-1047551">&#160;&quot;Specifying Unnamed Branch Objects&quot;</a>.</p>
</div>
</div>

<p>For information on the Tcl commands you can use with the Spectre<span style="color: rgb(0,0,0);"> <sup>&#174;</sup> </span>AMS Designer simulator, see the following table. Some commands are also links to more information. For commands that are not links, and for commands you can use only with purely digital designs, you can find more information in&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">&quot;Using the Tcl Command-Line Interface&quot;</a>&#160;</span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped relative-table confluenceTable" style="width: 97.3467%;"><colgroup> <col style="width: 26.0311%;" /> <col style="width: 73.9482%;" /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="144">
<p>Tcl Command</p>
</th><th class="confluenceTh" valign="middle" width="504">
<p>Description</p>
</th></tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>alias</code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032611"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_alias"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Defines aliases that you can use as command short-cuts.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
<a href="#AppendixB:Tcl-BasedDebugging-Tcl_analog">analog</a>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Controls the analog solver during mixed-signal simulation using AMS simulator with Spectre/APS solver.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>attribute </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_attribute"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Enables VHDL function-valued attributes for specified signals so that they can be accessed from the Tcl interface with the <code>value </code>command. The <code>attribute</code> command is enabled only for purely digital designs.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
<a href="#AppendixB:Tcl-BasedDebugging-Tcl_call">call</a>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you call a user-defined C-interface function or a Verilog user-defined<a href="Glossary.html#Glossary-1035591"> PLI </a>system task or function from the command line.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>coverage </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_coverage"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>For purely digital designs, controls the dumping of code coverage data.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_database"></span> <code>database </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you control an<a href="Glossary.html#Glossary-1034342"> SHM </a>or<a href="Glossary.html#Glossary-1032273"> VCD </a>database. An SHM database can hold both analog and digital databases. VCD databases do not support both analog and digital databases in a single database.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>deposit</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you set the value of an object.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>describe</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays information about the specified simulation object, including its declaration.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-Tcl_drivers">drivers</a>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays a list of all contributors to the value of the specified objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_exit"></span> <code>exit </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Terminates simulation and returns control to the operating system.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>finish</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Causes the simulator to exit and returns control to the operating system.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_fmibkpt"></span> <code> fmibkpt </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Performs operations on breakpoints that are coded into C models using the <code>fmiBreakpoint</code> call.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>force</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a specified object to a given value and forces it to retain that value until it is released with a release command or until another force is placed on it.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_help"></span> <code>help </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Displays information about simulator (<code>xmsim</code>) commands and options and predefined variable names and values.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>history</code> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_history"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032688"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you re-execute commands without having to retype them.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_input"></span> <code>input </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Queues the commands in a file so that the simulator executes them when it issues its first prompt. This command is enabled only for purely digital designs.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_memory"></span> <code>memory </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Loads VHDL memory from a memory file or dumps VHDL memory to a memory file. This command is disabled while the analog solver is active.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_omi"></span> <code>omi </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you display information about model managers and instances controlled by model managers. Also lets you pass<a href="Glossary.html#Glossary-1036112"> OMI </a>model manager run-time commands to model managers that support this capability.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>probe</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you control the values being saved to a database.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_process"></span> <code>process </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Displays information about the processes that are currently executing or that are scheduled to execute at the current time. This command is disabled while the analog solver is active.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>release</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Releases any force set on the specified objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>reset</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Resets the currently loaded model to its original state at time zero. This command is enabled only for purely digital designs.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>restart<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-restart"></span>
            </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Replaces the currently simulating snapshot with another snapshot of the same elaborated design. You cannot use <code>restart</code> after the current AMS simulation is started.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>run</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Starts simulation or resumes a previously halted simulation.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>save</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Creates a snapshot of the current simulation state.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>scope</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you set the current debug scope, describe items declared within a scope, display the drivers of objects declared within a scope, list instances of auto-inserted connect modules within a scope, list resolved disciplines of all nets within a scope, print the source code, or part of the source code, for a scope, and display scope information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>source</code> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032765"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_source"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you execute a file containing simulator commands.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_stack"></span> <code>stack </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you view or set the current stack frame. This command is enabled only for purely digital designs.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>status</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays memory and CPU usage statistics and shows the current simulation time.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-Tcl_stop">stop</a> <br />
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Creates or operates on a breakpoint.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_strobe"></span> <code>
              <a href="#AppendixB:Tcl-BasedDebugging-strobe_tcl">strobe</a> </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Writes out the values of objects under the control of specified conditions, changes in signal values, or at specified time intervals. This command can be used only for digital objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_task"></span> <code>task </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Lets you schedule Verilog-AMS tasks for execution. This command is disabled while the analog solver is active.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>time</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays the current simulation time scaled to the specified unit.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-Tcl_value">value</a>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Prints the current value of the specified objects using the last format specifier preceding the object name argument.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_version"></span> <code>version </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Displays the version number of <code>xmsim.</code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-Tcl_where">where</a>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays the current location of the simulation.</p>
</td>
</tr>
</tbody></table></div>
<h2 id="AppendixB:Tcl-BasedDebugging-analog1040981Tcl_analog">analog&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040981"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_analog"></span></h2>

<p>Controls the analog solver in a mixed-signal simulation.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax">Syntax</h3>

<p><code>
    <strong>Tcl&gt; analog</strong>[<strong>-stop</strong> time ] [<strong>-show</strong>] [<strong>-reltol</strong> r_val ] [<strong>-iabstol</strong> i_val ] [<strong>-vabstol</strong> v_val ]</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 700.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="101">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="159">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="388">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-stop </code> <code> time </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Changes the analog stop time to <code>time.</code> If <code>time</code> is not 1% larger than the current analog stop time, or if <code>time</code> is larger than 1000 times the original stop time in the analog control file, the simulator ignores the time with a warning.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-show </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Prints the present values of the analog solver options and indicates which options can be set using the <code>analog</code> command. This option also shows the values, if any, that will be set for the next analog time step.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-reltol </code> <code> r_val </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Changes the reltol of the analog solver. <code>r_val</code> must be less than 0.1 when the <code>errpreset</code> option is set to <code>liberal</code>, but must always be less than 1.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-iabstol </code> <code> i_val </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Changes the current abstol of the analog solver.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-vabstol </code> <code> v_val </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Changes the voltage abstol of the analog solver</p>
</td>
</tr>
</tbody></table></div>

<p>See also<a href="#AppendixB:Tcl-BasedDebugging-1047142"> &quot;How to Use save, restart, and analog&quot;</a>.</p>
<h2 id="AppendixB:Tcl-BasedDebugging-call1032842callTcl_call">call&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032842"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-call"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_call"></span></h2>

<p>Calls a user-defined or predefined<a href="Glossary.html#Glossary-1035631"> VPI </a>or system task or function from the command line.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>In this release, you cannot call an analog VPI or system task or function. In addition, you cannot use the&#160;<code>call</code>&#160;command for digital tasks or functions while the analog solver is active.</p>
</div>
</div>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.1">Syntax</h3>

<p><code>
    <strong>call[-systf|-predefined]</strong> task_or_function_name [ arg1 [ arg2...]]</code></p>

<p>If you use the <code>-systf</code>&#160;or <code>-predefined</code>&#160;command option, the option must appear before the task or function name or the simulator interprets it as an argument to the task or function. See<a href="#AppendixB:Tcl-BasedDebugging-1032920"> &quot;Modifiers and Options&quot; </a>for details on these options.</p>

<p>The <code>task_or_function_name</code>&#160;argument is the name of the system task or function with or without the beginning dollar sign. The dollar sign character has a special meaning in Tcl. If the name of the task or function contains any dollar signs, you must enclose the argument in curly braces or precede each dollar sign by a backslash. For example, you can start a system task or function called <code>$mytask</code>&#160;with</p>

<p><code> xcelium&gt; call mytask</code> <br /> <code>xcelium&gt; call \$mytask</code> <br /> <code>xcelium&gt; call {$mytask}</code> <br /> <code>xcelium&gt; call {mytask}</code></p>

<p>You can start a system task or function called <code>$my$task</code>&#160;with any of the following:</p>

<p><code> xcelium&gt; call my\$task</code> <br /> <code>xcelium&gt; call \$my\$task</code> <br /> <code>xcelium&gt; call {$my$task}</code> <br /> <code>xcelium&gt; call {my$task}</code></p>

<p>Arguments to the system task or function can be either literals or names.</p>

<p>Literals can be:</p>
<ul><li>Integers<br /> <code> xcelium&gt; call mytask 5<br /> </code> <code> xcelium&gt; call mytask 5 7 </code></li></ul><ul><li>Reals<br /> <code> xcelium&gt; call mytask 3.4<br /> </code> <code> xcelium&gt; call mytask 22.928E+10 </code></li></ul><ul><li>Strings<br />Strings must be enclosed in quotation marks. Enclose strings in curly braces or use the backslash character to escape quotation marks, spaces, and other characters that have special meaning to Tcl. For example:<br /> <code> xcelium&gt; call mytask {&quot;hello world&quot;}<br /> </code> <code> xcelium&gt; call mytask \&quot;hello\ world\&quot; </code></li></ul><ul><li>Verilog literals, such as <code>8&#39;h1f </code></li></ul>
<p>Names can be full or relative path names of instances or objects. Relative path names are relative to the current debug scope (set by the<code> scope </code>command). Object names can include a bit select or part select. For example:</p>

<p><code> xcelium&gt; call  mytask top.u1</code> <br /> <code>xcelium&gt; call  mytask top.u1.reg[3:5]</code></p>

<p>Expressions that include operators or function calls are not allowed. For example, the following two commands result in an error:</p>

<p><code> xcelium&gt; call \$mytask a+b</code> <br /> <code>xcelium&gt; call \$mytask {func a}</code></p>

<p>However, literals can be created using the Tcl <code>expr</code>&#160;command. For example, if the desired argument is the expression <code>(a+b)</code>, use the following:</p>

<p><code> xcelium&gt; call \$mytask [expr #a + #b] </code></p>

<p>The result of the expression <code>(a+b)</code>&#160;is substituted on the command line and then treated by the <code>call</code>&#160;command as a literal.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>The <code>expr</code> command cannot evaluate calls to Verilog functions.</p>
</div>
</div>

<p>If you are calling a user-defined system function, the result of the <code>call</code>&#160;command is the return value from the system function. Therefore, user-defined system functions can be used to generate literals for other commands. For example:</p>

<p><code>xcelium&gt; call task [call func arg1...]</code> <br /> <code>xcelium&gt; force a = [call func arg1...]</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-1032920ModifiersandOptions"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032920"></span>Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="101">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="159">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="388">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-systf </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Looks for the specified task or function name only in the table of user-defined<a href="Glossary.html#Glossary-1035591"> PLI </a>system tasks and functions.</p>

<p>This option is available because the <code>call</code> command is also used to start functions from the VHDL C-interface, and there may be a user-defined C-interface function with the same name as a PLI system task or function. The <code>-systf</code> option causes the lookup in the C-interface task list to be skipped.</p>

<p>This option must appear before the task or function name on the command line.</p>

<p>You cannot use this option with the <code>-predefined</code> option.</p>

<p>The command <code>call -systf</code> with no task or function name argument displays a list of all registered user-defined system tasks and functions.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-predefined </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Looks for the specified task or function name only in the table of predefined CFC library functions.</p>

<p>You cannot use the <code>-predefined</code> option when calling a user-defined system task or function.</p>

<p>This option must appear before the CFC function name on the command line.</p>

<p>You cannot use this option with the <code>-systf</code> option.</p>

<p>The command <code>call -predefined</code> with no function name argument displays a list of all predefined C function names.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples">Examples</h3>

<p>The following Verilog module contains a call to a user-defined system task and to a system function. The task and function can also be started from the command line.</p>

<p><code> module test(); </code></p>

<p><code> initial</code> <br /> <code>&#160;&#160;&#160;&#160;begin</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$hello_task();</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$hello_task($hello_func());</code> <br /> <code>&#160;&#160;&#160;&#160;end</code> <br /> <code>endmodule</code></p>

<p>The following command starts the <code>$hello_task</code>&#160;system task:</p>

<p><code> xcelium&gt; call \$hello_task </code></p>

<p>This task can also be started with any of the following:</p>

<p><code> xcelium&gt; call hello_task</code> <br /> <code>xcelium&gt; call {$hello_task}</code> <br /> <code>xcelium&gt; call {hello_task}</code></p>

<p>The <code>$hello_func</code>&#160;function can be started with any of the following commands:</p>

<p><code> xcelium&gt; call \$hello_func</code> <br /> <code>xcelium&gt; call hello_func</code> <br /> <code>xcelium&gt; call {$hello_func}</code> <br /> <code>xcelium&gt; call {hello_func}</code></p>

<p>In the following command, the <code>call</code>&#160;command calls the <code>$hello_task</code>&#160;system task with a call to the system function <code>$hello_func</code>&#160;as an argument.</p>

<p><code> xcelium&gt; call hello_task [call hello_func] </code></p>

<p>The following command displays a list of all registered user-defined system tasks and functions.</p>

<p><code> xcelium&gt; call -systf </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-deposit1032965Tcl_deposit">deposit&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1032965"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_deposit"></span></h2>

<p>Sets the value of an object. Behaviors that are sensitive to value changes on the object run when the simulation resumes, just as if the value change was caused by the Verilog or VHDL code.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>In this release, you cannot set the value of an analog object. In addition, you cannot use the <code>deposit</code> command to set the value of digital objects while the analog solver is active.</p>
</div>
</div>

<p>The <code>deposit</code>&#160;command without a delay is similar to a force in that the specified value takes effect and propagates immediately. However, it differs from a force in that future transactions on the signal are not blocked.</p>

<p>You can specify that the deposit is to take effect at a time in the future (<code>-after -absolute</code>) or after some amount of time has passed (<code>-after -relative</code>). In VHDL, a deposit with a delay is different from Verilog in that it creates a transaction on a driver, much the same as a VHDL signal assignment statement. Use the <code>-inertial</code>&#160;or <code>-transport</code>&#160;option to deposit the value after an inertial delay or after a transport delay, respectively.</p>

<p>For VHDL, you can deposit to ports, signals, and variables if no delay is specified. If a delay is specified, you cannot deposit to variables or to signals with multiple sources.</p>

<p>For Verilog, you can deposit to ports, signals (wires and registers), and variables.</p>

<p>If the object is a memory or a range of memory elements, the specified value is deposited into each element of the memory or into each element in the specified range.</p>

<p>If the object is currently forced, the specified value appears on the object after the force is released, unless the release value is overwritten by another assignment in the meantime.</p>

<p>If the object is a register that is currently forced or assigned, the <code>deposit</code>&#160;command has no effect.</p>

<p>The value assigned to the object must be a literal. The literal can be generated with Tcl value substitution or command substitution. (See the &quot;Verilog Value Substitution&quot; and &quot;Command Substitution&quot; sections, in the &quot;Basics of Tcl&quot; appendix of<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for details on Tcl substitution.)</p>

<p>For VHDL, the value specified with the<code> deposit </code>command must match the type and subtype constraints of the VHDL object. Integers, reals, physical types, enumeration types, and strings (including std_logic_vector and bit_vector) are supported. Records and non-character array values are not supported, but objects of these types can be assigned to by issuing commands for each subelement individually.</p>

<p>The object to which the value is to be deposited must have read/write access. An error is generated if the object does not have this access. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>

<p>For an SV-UDN net, you can deposit value to a scalar net, whole array, or bit-select and part-select of arrays. And, you can use order-based or name-based approach to deposit a value. For the name-based approach, the filed order can be different from that defined in the SV-UDT net. You can also assign <code>real&#39;z</code> or <code>real&#39;x</code> values to SV-UDN.</p>

<p>Additionally, you can use the <code>xm_deposit</code> system task to assign value on an SV-UDN net. The syntax is: <code>xm_desposit (&#8220;&lt;name&#8221;, &#8220;value&#8221;)</code>. The value string should not contain any space; and, for the scalar UDN or bit-selected UDN array, the <code>value</code> string should not contain <code>{}</code>. For example:</p>

<p><code>$xm_deposit(&quot;dut.ve[1:2]&quot;, &quot;{V:1.7,R:10,I:real&#39;z}{1.7,real&#39;x,20}&quot;);</code></p>

<p>The <code>deposit</code>&#160;command is supported on user-defined nettypes. For more information on user-defined nettypes, refer to<a href="Using_Real_Number_Modeling_in_SystemVerilog.html#UsingRealNumberModelinginSystemVerilog-1066573"> User-Defined Nettype and Resolution Function</a>.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.2">Syntax</h3>

<p><code>
    <span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">deposit object_name [=] value<br /> &#160;&#160;&#160;&#160;[-after time_spec {-relative | -absolute}]<br />&#160;&#160;&#160;&#160;[-inertial]<br />&#160;&#160;&#160;&#160;[-transport]<br />&#160;&#160;&#160;&#160;[-generic]</span>
  </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.1">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="116">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="144">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="388">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-after </code> <code>time_spec </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Causes the assignment to occur at a time in the future, rather than immediately. <code>time_spec</code> can be relative (the default) or absolute.</p>

<p>If you do not specify a time, the assignment happens immediately, before simulation resumes. If the specified time is the current simulation time, the assignment occurs after simulation resumes, but before time advances.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-absolute </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Causes the assignment to occur at the simulation time specified in <code>time_spec</code>.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-relative </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Causes the assignment to occur after the amount of time specified in <code>time_spec</code> has passed. This is the default.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-inertial </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Deposits the value after an inertial delay.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-transport </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Deposits the value after a transport delay.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-generic </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Deposits generic value. This operation might lead to violation of globally static bounds.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Example">Example</h3>
<h4 id="AppendixB:Tcl-BasedDebugging-DigitalVerilog-AMSexamples:">Digital Verilog-AMS examples:</h4>

<p>The following command assigns the value<code> 8&#39;h1F </code>to<code> r[0:7].</code> No time for this assignment is specified, so the assignment occurs immediately. The equal sign is optional.</p>

<p><code> xcelium&gt; deposit r[0:7] = 8&#39;h1F </code></p>

<p>The following command assigns <code>25</code>&#160;to <code>r[8:15]</code>&#160;after simulation resumes and 1 time unit has elapsed.</p>

<p><code> xcelium&gt; deposit r[8:15] = 25 -after 1 </code></p>

<p>The following command assigns <code>25</code>&#160;to <code>r[8:15]</code>&#160;at simulation time 1 ns.</p>

<p><code> xcelium&gt; deposit r[8:15] = 25 -after 1 ns -absolute </code></p>

<p>The following command sets the value of <code>x</code>&#160;to the current value of <code>w.</code> The assignment occurs at simulation time 10 ns.</p>

<p><code> xcelium&gt; deposit x = #w -after 10 ns -absolute </code></p>

<p>The following command uses both command and value substitution. The object <code>y</code>&#160;is set to the value returned by the Tcl <code>expr</code>&#160;command, which evaluates the expression<code> #r[0] &amp; ~#r[1] </code>using the current value of <code>r.</code></p>

<p><code> xcelium&gt; deposit y = [expr #r[0] &amp; ~#r[1]] </code></p>

<p>The following command shows the error message that is displayed if you run in regression mode and then try to deposit a value to an object that does not have read/write access.</p>

<p><code> xcelium&gt; deposit clrb 1<br />xmsim: *E,RWACRQ: Object does not have read/write access:<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hardrive.h1.clrb. </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-VHDLexamples:">VHDL examples:</h4>

<p>The following command deposits the value 1 to object<code>:t_nickel_out</code>&#160;(std_logic). The equal sign is optional.</p>

<p><code> xcelium&gt; deposit :t_nickel_out = &#39;1&#39; </code></p>

<p>The following command deposits the value 1 to object<code>:top:DISPENSE_tempsig</code>&#160;(std_logic).</p>

<p><code> xcelium&gt; deposit :top:DISPENSE_tempsig &#39;1&#39; </code></p>

<p>The following command deposits the value 0 to object<code>:t_dimes </code>(std_logic_vector) after 10 ns has elapsed.</p>

<p><code> xcelium&gt; deposit -after 10 ns -relative :t_DIMES {&quot;00000000&quot;} </code></p>

<p>The following command deposits the value TRUE to object<code> stoppit </code>(boolean).</p>

<p><code> xcelium&gt; deposit stoppit true </code></p>

<p>The following command deposits the value 10 to object<code>:count </code>(integer).</p>

<p><code> xcelium&gt; deposit :count 10</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-SV-UDNexamples:">SV-UDN examples:</h4>

<p>The following example illustrates the SV-UDN structure and how to apply the <code>deposit</code> command to a scalar net with name-based value:</p>

<p><code>typedef struct {</code> <br /> <code>&#160; &#160; real V;</code> <br /> <code>&#160; &#160; real I;</code> <br /> <code>&#160; &#160; real R;</code> <br /> <code>}&#160; EEstruct;</code></p>

<p><code>Time: 0 FS: tb.ve = (&#39;{V:0, I:0, R:1e+06},&#39;{V:0, I:0, R:1e+06},&#39;{V:0, I:0, R:1e+06})</code> <br /> <code>Time: 0 FS: tb.e = &#39;{V:0, I:0, R:1e+06}</code></p>

<p><code>xcelium&gt; deposit tb.e {V:1.2, I:real&#39;z, R:500};</code> <br /> <code>Time: 40 NS: tb.e = &#39;{V:1.2, I:`wrealZState, R:500}</code></p>

<p>The following example illustrates how the deposit command applies value on bit-select of an array with order-based value. Values 1.2, real&#8217;z, and 50 are applied on real variable V, I, and R, respectively in the order in which it is defined/declared in the structure:</p>

<p><code># Bit-Selected : Order-Based Value</code> <br /> <code>xcelium&gt; deposit tb.ve[1] {1.2, real&#39;z, 50}</code></p>

<p><code>Time: 40 NS: tb.ve = (&#39;{V:0, I:0, R:1e+06},&#39;{V:1.2, I:`wrealZState, R:50},&#39;{V:0, I:0, R:1e+06})</code></p>

<p>The following example applies the deposit command on part-select of an array with order-based value:</p>

<p><code>xcelium&gt; deposit tb.ve[2:1] {{V:1.0, R:10, I:real&#39;z} {1.5, real&#39;x, 20}}</code></p>

<p><code>Time: 60 NS: tb.ve = (&#39;{V:1, I:`wrealZState, R:10},&#39;{V:1.2, I:`wrealZState, R:50},&#39;{V:0, I:0, R:1e+06})</code> <br /> <code>Time: 60 NS: tb.ve = (&#39;{V:1, I:`wrealZState, R:10},&#39;{V:1.5, I:`wrealXState, R:20},&#39;{V:0, I:0, R:1e+06})</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-describeTcl_describe1033071">describe&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_describe"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033071"></span></h2>

<p>Displays information about the specified simulation object, including its declaration.</p>
<ul><li>For objects without read access, the output of the<code> describe </code>command does not include the object&#39;s value.</li></ul><ul><li>For objects that have read access but no write access, the string&#160;<code>(-W)</code>&#160;is included in the output.</li></ul><ul><li>For objects with neither read nor write access, the string <code>(-RW)</code>&#160;is included in the output.</li></ul>
<p>For information about using <code>describe</code>&#160;with unnamed branches, see<a href="#AppendixB:Tcl-BasedDebugging-1047551"> &quot;Specifying Unnamed Branch Objects&quot;</a>.</p>

<p>See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>

<p>The <code>describe</code>&#160;command is supported on user-defined nettypes. For more information on user-defined nettypes, refer to<a href="Using_Real_Number_Modeling_in_SystemVerilog.html#UsingRealNumberModelinginSystemVerilog-1066573"> User-Defined Nettype and Resolution Function</a>.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.3">Syntax</h3>

<p><code>
    <span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">describe simulation_object...</span>
  </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.2">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.1">Examples</h3>
<h4 id="AppendixB:Tcl-BasedDebugging-Verilog-AMSexamples:">Verilog-AMS examples:</h4>

<p>The following command displays information about the Verilog-AMS analog net <code>n1.</code> The resolved discipline is in parentheses. The value is the potential of the net.</p>

<p><code> xcelium&gt; describe n1<br />n1......wire (electrical) = 2.99227 </code></p>

<p>The following command displays information about the Verilog-AMS digital net <code>p1</code>, which is bound to an input port.</p>

<p><code> xcelium&gt; describe  top.I3.clkSig<br />top.I3.clkSig...input (wire/tri) = St0 </code></p>

<p>Both named and unnamed branches are described as <code>branch</code>, where the value is the potential of the branch. For example,</p>

<p><code> xcelium&gt; describe  top.I4.compSig_ground<br />top.I4.compSig_ground...branch(compSig) = 0 </code></p>

<p>The value is the potential of the branch. To see the flow through the branch, use the <code>value -flow</code>&#160;command instead.</p>

<p>The following command displays information about the Verilog object <code>data.</code></p>

<p><code> xcelium&gt; describe data<br />data......register [3:0] = 4&#39;h0 </code></p>

<p>The following command displays information about two Verilog objects: <code>data</code>&#160;and <code>q.</code></p>

<p><code> xcelium&gt; describe data q<br />data.......register [3:0] = 4&#39;h0<br />q..........wire [3:0]<br />&#160;&#160;&#160;&#160;q[3] (wire/tri) = StX<br />&#160;&#160;&#160;&#160;q[2] (wire/tri) = StX<br />&#160;&#160;&#160;&#160;q[1] (wire/tri) = StX<br />&#160;&#160;&#160;&#160;q[0] (wire/tri) = StX </code></p>

<p>The following command displays information about the object <code>alu_16.</code></p>

<p><code> xcelium&gt; describe alu_16<br />alu_16.....top-level module </code></p>

<p>The following command displays information about the object <code>u1.</code></p>

<p><code> xcelium&gt; describe u1<br />u1.......instance of module arith </code></p>

<p>The following commands display information about the mixed bus <code>w.</code></p>

<p><code> xcelium&gt; describe w<br />w..........wire (mixed bus) = Inf<br />xcelium&gt; describe w[0]<br />w..........wire (electrical)<br />xcelium&gt; describe w[1]<br />w..........wire [0:2]<br />w[1] (wire/tri) = StX<br />xcelium&gt; describe w[2]<br />w..........wire [0:2]<br />w[2] (wire/tri) = StX </code></p>

<p>The following command displays information about the connect module <code>mya2d.</code></p>

<p><code> xcelium&gt; describe<br /> mya2dmya2d........instance of connect module a2d </code></p>

<p>The following command shows the output of the <code>describe</code>&#160;command for an object that does not have read or write access. The output of the command does not include the object&#39;s value, but the string <code>(-RW).</code></p>

<p><code> xcelium&gt; describe d<br />d..........input [3:0]<br />&#160;&#160;&#160;&#160;d[3]  (-RW)<br />&#160;&#160;&#160;&#160;d[2]  (-RW)<br />&#160;&#160;&#160;&#160;d[1]  (-RW)<br />&#160;&#160;&#160;&#160;d[0]  (-RW) </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-VHDLexamples:.1">VHDL examples:</h4>

<p><code> xcelium&gt; describe t_NICKEL_IN</code> <br /> <code>t_NICKEL_IN...signal : std_logic = &#39;0&#39;</code> <br /> <code>xcelium&gt; describe t_NICKEL_IN t_CANS</code> <br /> <code>t_NICKEL_IN...signal : std_logic = &#39;0&#39;</code> <br /> <code>t_CANS........signal : std_logic_vector(7 downto 0) = &quot;11111111&quot;</code> <br /> <code>xcelium&gt; describe gen_dimes</code> <br /> <code>gen_dimes...process statement</code> <br /> <code>xcelium&gt; describe :top</code> <br /> <code>top........component instantiation</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-drivers1033155Tcl_drivers">drivers&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033155"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_drivers"></span></h2>

<p>Displays a list of all contributors to the value of the specified digital objects.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You cannot list drivers for analog nets, analog variables, or branches.</p>
</div>
</div>

<p>You can use the <code>scope -drivers </code> <code> [</code> <code>scope_name</code> <code>]</code>&#160;command to display the drivers of each digital object that is declared within a specified scope. See<a href="#AppendixB:Tcl-BasedDebugging-1042823"> &quot;scope&quot; </a>for details on the<code> scope </code>command.</p>

<p>For Verilog, the <code>drivers</code>&#160;command cannot find the drivers of a wire or register unless the object has read and connectivity access. However, even if you have specified access to an object, its drivers might have been collapsed, combined, or optimized away. In this case, the output of the command might indicate that the object has no drivers. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>

<p>See<a href="#AppendixB:Tcl-BasedDebugging-1033216"> &quot;drivers Command Report Format&quot; </a>for details on the output format of the <code style="letter-spacing: 0.0px;">drivers</code>&#160;command. See<a href="#AppendixB:Tcl-BasedDebugging-1033277"> &quot;Examples&quot; </a>for examples.</p>

<p>The <code>drivers</code>&#160;command is supported on user-defined nettypes. For more information on user-defined nettypes, refer to<a href="Using_Real_Number_Modeling_in_SystemVerilog.html#UsingRealNumberModelinginSystemVerilog-1066573"> User-Defined Nettype and Resolution Function</a>.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.4">Syntax</h3>

<p><code>drivers object_name...</code></p>

<p><code> &#160;&#160;&#160;&#160;[-effective]</code> <br /> <code>&#160;&#160;&#160;&#160;[-future]</code> <br /> <code>&#160;&#160;&#160;&#160;[-novalue]</code> <br /> <code>&#160;&#160;&#160;&#160;[-verbose] </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.3">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><tbody><tr><th class="confluenceTh" valign="middle" width="109">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="164">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="375">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-effective </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays contributions to the effective value of the signal. By default, the <code>drivers</code> command displays contributions to the driving value.</p>

<p>Only VHDL inout and linkage ports can have different driving and effective values.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-future </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays the transactions that are scheduled on each driver.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-novalue </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Suppresses the display of the current value of each driver.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-verbose </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>This option affects VHDL signals only.</p>

<p>Displays all of the processes (signal assignment statements), resolution functions, and type conversion functions that contribute to the value of the specified signal.</p>

<p>If you do not include the <code>-verbose</code> option, resolution and type conversion function information is omitted from the output.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-1033216driversCommandReportFormat"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033216"></span>drivers Command Report Format</h3>
<h4 id="AppendixB:Tcl-BasedDebugging-VerilogSignals">Verilog Signals</h4>

<p>The drivers report for digital Verilog-AMS signals is as follows:</p>

<p><span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;"> <code> value &lt;- </code>(<code> scope </code>)<code> verilog_source_line_of_the_driver </code> </span></p>

<p>For example:</p>

<p><code> af.........wire (wire/tri) = St1</code> <br /> <code>&#160;&#160;&#160;&#160;St1 &lt;- (board.counter) assign altFifteen = &amp;value </code></p>

<p>Instead of <code>verilog_source_line_of_the_driver</code>, the following is output when the actual driver is from a VHDL model:</p>

<p><code>port &#39;<em>port_name</em>&#39; in module_name [File:</code> <br /> <code> &#160;&#160;&#160;&#160;<em>path_to_file_containing_module</em>], driven by a VHDL model.</code></p>

<p>This report indicates that the signal is ultimately driven by a port (connected to <code>port_name</code>&#160;of the specified module) on a module whose body is an imported VHDL model. The <code>module_name</code>&#160;corresponds to the module name of the shell being used to import the VHDL model.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-VHDLSignals">VHDL Signals</h4>

<p>The drivers report for VHDL signals is as follows:</p>

<p><code> description_of_signal = value</code> <br /> <code> &#160;&#160;&#160;&#160; value_contributed_by_driver &lt;- ( scope_name ) source_description </code></p>

<p>The <code>source_description</code>&#160;for the various kinds of drivers are shown below:</p>
<h4 id="AppendixB:Tcl-BasedDebugging-AProcess">A Process</h4>

<p>Nothing is generated for the <code>source_description</code>. This implies that a sequential signal assignment statement within a process is the driver. The <code>scope_name</code>&#160;is the scope name of the process.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ConcurrentSignalAssignment/ConcurrentProcedurecall">Concurrent Signal Assignment/Concurrent Procedure call</h4>

<p>The <em> <code>source_description</code> </em>&#160;is the VHDL source text of the concurrent signal assignment statement or concurrent procedure call that results in a driving value. This concurrent statement is within the scope <code>
    <em>scope_name</em>.</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-Nodrivers">No drivers</h4>

<p>If the signal has no drivers, the text <code>No drivers</code>&#160;appears verbatim.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-AVerilogdriver">A Verilog driver</h4>

<p>If the driver is from a Verilog model, the report has the following form:</p>

<p><code>port &#39;port_name&#39; in entity ( arch ) [File:</code> <br /> <code> &#160;&#160;&#160;&#160;path_to_file_containing_entity ], driven by a Verilog model.</code></p>

<p>This report indicates that the signal is ultimately driven by a port (connected to&#160;<code>port_name</code>&#160;of the specified entity-architecture pair) on an entity whose body is an imported Verilog model.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-DriverfromaCmodel">Driver from a C model</h4>

<p>If the driver is from an imported C model, the report has the following form:</p>

<p><code>port &#39;port_name&#39; in entity ( arch ) [File:</code> <br /> <code> &#160;&#160;&#160;&#160;path_to_file_containing_entity ], driven by a C model.</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-DriverfromaLMCmodel">Driver from a LMC model</h4>

<p>If the driver is from an imported LMC model, the report has the following form:</p>

<p><code>port &#39;port_name&#39; in entity ( arch ) [File:</code> <br /> <code> &#160;&#160;&#160;&#160;path_to_file_containing_entity], driven by a LMC model.</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-DriverfromanOMImodel">Driver from an OMI model</h4>

<p>If the driver is from an imported<a href="Glossary.html#Glossary-1036112"> OMI </a>model, the report has the following form:</p>

<p><code>port &#39;port_name&#39; in entity ( arch ) [File:<br /> &#160;&#160;&#160;&#160;path_to_shell_file ], driven by a OMI model.</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-Resolution/TypeConversionFunctioninNon-Verbosemode">Resolution / Type Conversion Function in Non-Verbose mode</h4>

<p>If you do not use the <code>-verbose</code>&#160;option, the text<code> [verbose report available ....] </code>may appear. This indicates that the signal gets its value from a resolution function or a type conversion function. Use <code>-verbose </code>to display more information on the derivation of the signal&#39;s value.</p>

<p>On the next line of output (indented), a nonverbose driver report is displayed for each signal whose driver contributes to the value of the signal in question.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ResolutionFunction">Resolution Function</h4>

<p>The following text is generated only when the <code>-verbose</code>&#160;option is used:</p>

<p><code>[resolution function function_name ()]</code></p>

<p>This means that the signal is resolved with the named resolution function. A verbose drivers report is displayed (indented) for all inputs to the resolution function.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-TypeconversiononFormalofPortAssociation">Type conversion on Formal of Port Association</h4>

<p>The following text is generated only when the <code>-verbose</code>&#160;option is used:</p>

<p><code>[type conversion function function_name (formal)]</code></p>

<p>This means that the signal&#39;s driving value comes from a type conversion function on a formal in a port association. A verbose drivers report is displayed (indented) for the formal port that is the input to the function.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-TypeConversiononActualofPortAssociation">Type Conversion on Actual of Port Association</h4>

<p>The following text is generated only when the<code> -verbose </code>option is used:</p>

<p><code>[type conversion function function_name (actual)]</code></p>

<p>This means that the signal&#39;s effective value comes from a type conversion function on an actual in a port association. A verbose drivers report is displayed (indented) for the actual that is the input to the function.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ImplicitGuardSignal">Implicit Guard Signal</h4>

<p>The following text is displayed in response to a query on a signal whose value is computed from a<code> GUARD </code>expression:</p>

<p><code> [implicit guard signal] </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-SignalAttribute">Signal Attribute</h4>

<p>The following is displayed in response to a query on an IN port that ultimately is associated with a signal valued attribute:</p>

<p><code>[attribute of signal full_path_of_the_signal]</code></p>

<p><code> full_path_of_the_signal </code>corresponds to the complete hierarchical path name of the signal whose attribute is the driver.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ConstantExpressiononaPortAssociation">Constant Expression on a Port Association</h4>

<p>The following is displayed when the value of the signal in question is from a constant expression in a port map association:</p>

<p><code>[constant expression associated with port port_name]</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-CompositeSignals">Composite Signals</h4>

<p>For a composite signal, a separate report is displayed for each group of subelements that can be uniquely named and that have the same set of drivers.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-1033277Examples"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033277"></span>Examples</h3>

<p>This section includes examples of using the <code>drivers</code>&#160;command with digital Verilog-AMS and with VHDL signals.</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ExampleOutputforDigitalVerilog-AMSSignals">Example Output for Digital Verilog-AMS Signals</h4>

<p>The following command lists the drivers of a signal called<code> f.</code></p>

<p><code> xcelium&gt; drivers f</code> <br /> <code>f..........wire (wire/tri) = StX</code> <br /> <code>&#160;&#160;&#160;&#160;StX &lt;- (board.counter) assign fifteen = value[0] &amp; value[1] &amp;</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value[2] &amp; value[3] </code></p>

<p>The following command lists the drivers of two signals called<code> f </code>and<code> af.</code></p>

<p><code> xcelium&gt; drivers f af</code> <br /> <code>f..........wire (wire/tri) = StX</code> <br /> <code>&#160;&#160;&#160;&#160;StX &lt;- (board.counter) assign fifteen = value[0] &amp; value[1] &amp;</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value[2] &amp; value[3]</code> <br /> <code>af.........wire (wire/tri) = StX</code> <br /> <code>&#160;&#160;&#160;&#160;StX &lt;- (board.counter) assign altFifteen = &amp;value </code></p>

<p>The following command lists the drivers of a signal called <code>top.under_test.sum.</code></p>

<p><code> xcelium&gt; drivers  top.under_test.sum</code> <br /> <code>top.under_test.sum...output [1:0] (wire/tri) = 2&#39;h0 (-W)</code> <br /> <code>&#160;&#160;&#160;&#160;2&#39;h0 &lt;- (top.under_test) assign {c_out, sum} = a + b + c_in </code></p>

<p>The following command lists the drivers of a signal called<code> board.count.</code></p>

<p><code> xcelium&gt; drivers board.count </code></p>

<p><code> board.count......wire [3:0]<br />&#160;&#160;&#160;&#160;count[3] (wire/tri) = St1&#160;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St1 &lt;- (board.counter.d) output port 1, bit 0 (.counter.v:10)<br />&#160;&#160;&#160;&#160;count[2] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (board.counter.c) output port 1, bit 0 (./counter.v:9)<br />&#160;&#160;&#160;&#160;count[1] (wire/tri) = St1<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St1 &lt;- (board.counter.b) output port 1, bit 0 (./counter.v:8)<br />&#160;&#160;&#160;&#160;count[0] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (board.counter.a) output port 1, bit 0 (./counter.v:7) </code></p>

<p>The following commands list the drivers of a mixed bus<code> w.</code></p>

<p><code> xcelium&gt; drivers w<br />xmsim: *E,MIXBOFF: Mixed discipline bus &#39;w&#39; needs an index.<br />xcelium&gt; drivers w[0]<br />xmsim: *E,TNODIA: No drivers exist for analog object: top.w[0].<br />xcelium&gt; drivers w[1]<br />w..........wire [0:2]<br /> w[1] (wire/tri) = StX<br />No drivers<br />xcelium&gt; drivers w[2]<br />w..........wire [0:2]<br />w[2] (wire/tri) = StX<br />No drivers </code></p>

<p>The following command shows the error message that the simulator displays if you run the <code>xmsim</code>&#160;simulator in regression mode and then use the <code>drivers</code>&#160;command to find the drivers of an object that does not have read and connectivity access.</p>

<p><code> xcelium&gt; drivers count<br />xmsim: *E,OBJACC: Object must have read and connectivity access:<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board.count. </code></p>

<p>The following examples illustrates the output of the <code>drivers</code>&#160;command when the actual driver is from a VHDL model:</p>

<p><code> xcelium&gt; drivers :u1.a </code></p>

<p><code> u1.a.......input (wire/tri) = St1<br />&#160;&#160;&#160;&#160;St1 &lt;- (:u1) driven by a VHDL model </code></p>

<p><code> xcelium&gt; drivers :u1.v.d </code></p>

<p><code> u1.v.d.....input (wire/tri) = St1<br />&#160;&#160;&#160;&#160;St1 &lt;- (:u1) port &#39;a&#39; in module &#39;and2&#39; [File: ./verilog.v],<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;driven by a VHDL model </code></p>

<p><code> xcelium&gt; </code></p>

<p>This report indicates that the signal <code>:u1.v.d</code>&#160;is ultimately driven by a port (connected to port <code>a</code>&#160;of the module <code>and2</code>) on a module whose body is an imported VHDL model.</p>

<p>Drivers within the scope of automatically inserted connect modules are listed by giving the automatically inserted module name only. The <code>verilog_source_line_of_the_driver</code>&#160;does not list the source line. For example:</p>

<p><code> xcelium&gt; drivers result<br />result.....input (wire/tri) = StX<br />&#160;&#160;StX &lt;- (top.analogResultelect_to_logiclogic) module top </code></p>

<p>where <code>top.analogResultelect_to_logiclogic</code>&#160;is the auto-generated instance name for an auto-inserted connect module</p>
<h4 id="AppendixB:Tcl-BasedDebugging-ExampleOutputforVHDLSignals">Example Output for VHDL Signals</h4>

<p>The following examples use the VHDL model shown in the &quot;drivers.vhd&quot; section of the &quot;Code Examples&quot; appendix in<span style="color: rgb(0,0,0);"> <em> Cadence Verilog Simulation User Guide</em>.</span>&#160;A <code>run</code>&#160;command has been issued after invoking the simulator.</p>

<p>The following command shows the drivers of signal<code> s.</code> The string <code>[verbose report available .....] </code>indicates that type conversion functions or resolution functions are part of the hierarchy of drivers. Use the <code>-verbose</code>&#160;option to display this additional information.</p>

<p><code> xcelium&gt; drivers s<br />s..........signal : std_logic = &#39;0&#39;<br />&#160;&#160;&#160;&#160;[verbose report available.....]<br />&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE:p)<br />&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:) s &lt;= &#39;0&#39; after 1 ns </code></p>

<p>The following command includes the<code> -novalue </code>option, which suppresses the display of the current value of each driver.</p>

<p><code> xcelium&gt; drivers s -novalue </code></p>

<p><code> s..........signal : std_logic</code> <br /> <code>&#160; &#160; [verbose report available.....]</code> <br /> <code>&#160; &#160; (:GATE:p)</code> <br /> <code>&#160; &#160; (:) s &lt;= &#39;0&#39; after 1 ns</code></p>

<p>The following command includes the&#160;<code>-verbose</code>&#160;option, which causes the inclusion of resolution function and type conversion function information. This report shows that the port <code>:GATE:q </code>is one of the contributing drivers, and that there is a type conversion function <code>bit_to_std</code>&#160;through which the port&#39;s value is routed before being assigned to the signal <code>:s.</code> The report also shows that there is a concurrent signal assignment statement contributing as one of the sources to the resolution function.</p>

<p><code> xcelium&gt; drivers s -verbose<br />s..........signal : std_logic = &#39;0&#39;<br />&#160;&#160;&#160;&#160;&#39;0&#39; &lt;-[resolution function @ieee.std_logic_1164:resolved()]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;src 1&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE)  [type conversion function<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bit_to_std(&lt;formal&gt;)]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;formal&gt; connected to port q </code></p>

<p><code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;:GATE:q....port : inout BIT = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE:p)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;src 2&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:) s &lt;= &#39;0&#39; after 1 ns </code></p>

<p>The following command shows the drivers <code>:gate:q.</code></p>

<p><code> xcelium&gt; drivers :gate:q<br />GATE:q.....port : inout BIT = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE:p) </code></p>

<p>The following command includes the <code>-effective</code>&#160;option, which displays contributions to the effective value of the signal instead of to the driving value.</p>

<p><code> xcelium&gt; drivers :GATE:q -effective </code></p>

<p><code> GATE:q.....port : inout BIT = &#39;1&#39;</code> <br /> <code>&#160; &#160; [verbose report available.....]</code> <br /> <code>&#160; &#160; &#39;0&#39; &lt;- (:GATE:p)</code> <br /> <code>&#160; &#160; &#39;0&#39; &lt;- (:) s &lt;= &#39;0&#39; after 1 ns</code></p>

<p>The following command includes the <code>-verbose</code>&#160;option, which helps you to understand where the effective value of <code>1</code>&#160;in the previous example comes from.</p>

<p><code> xcelium&gt; drivers :GATE:q -effective -verbose </code></p>

<p><code> GATE:q.....port : inout BIT = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#39;1&#39; &lt;- (:GATE)  [type conversion function std_to_bit(&lt;actual&gt;)]<br />&#160;&#160;&#160;&#160;&lt;actual&gt; connected to signal s </code></p>

<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;:s.........signal : std_logic = &#39;0&#39;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;-[resolution function @ieee.std_logic_1164:resolved()]<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;src 1&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE)  [type conversion function&#160;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bit_to_std(&lt;formal&gt;)]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;formal&gt; connected to port q&#160;&#160;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;:GATE:q....port : inout BIT = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:GATE:p)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;src 2&gt;&#160;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#39;0&#39; &lt;- (:) s &lt;= &#39;0&#39; after 1 ns </code></p>

<p>The following command shows the output of the <code>drivers</code>&#160;command when the driver is from a Verilog model.</p>

<p><code> xcelium&gt; drivers -effective i1:a<br />i1:a.......port : in std_logic = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#39;1&#39; &lt;- (and2_top.i1) driven by a Verilog model </code></p>

<p><code> xcelium&gt; drivers -effective i1:i1:port1<br />i1:i1:port1...port : in std_logic = &#39;1&#39;<br />&#160;&#160;&#160;&#160;&#39;1&#39; &lt;- (and2_top.i1) port &#39;a&#39; in and2(and2_bot) [File:<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;./and2.vhd], driven by a Verilog model </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-finish1033404Tcl_finish">finish&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033404"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_finish"></span></h2>

<p>Closes the simulator and returns control to the operating system.</p>

<p>This command takes an optional argument that determines what type of information is displayed.</p>
<ul><li>0--Prints nothing (same as executing<code> finish </code>without an argument).</li></ul><ul><li>1--Prints the simulation time. If the analog solver is interactive when the finish command is issued, the analog solver&#39;s simulation time is printed; otherwise the digital solver&#39;s simulation time is printed.</li></ul><ul><li>2--Prints simulation time as for the argument above and also prints statistics on memory and CPU usage.</li></ul>
<p>See<a href="Simulating.html#Simulating-1050807"> &quot;Exiting the Simulation&quot; </a>for more information.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.5">Syntax</h3>

<p><code> finish [0 | 1 | 2] </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.4">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.2">Examples</h3>

<p>The following command ends the simulation session and prints the simulation time.</p>

<p><code>xcelium&gt; finish 1</code> <br /> <code>Simulation complete via $finish(1) at time 0 FS + 0</code> <br /> <code>%</code></p>

<p>The following command ends the simulation session, prints the simulation time, and displays memory and CPU usage statistics.</p>

<p><code> xcelium&gt; finish 2<br />Memory Usage - 7.6M program + 2.1M data = 9.8M total<br />CPU Usage - 0.9s system + 2.5s user = 3.4s total (28.5% cpu)<br />Simulation complete via $finish(2) at time 500 NS + 0<br />% </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-force1033448Tcl_force">force&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033448"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_force"></span></h2>

<p>Sets a specified object to a given value and forces it to retain that value until it is released with a <code>release</code>&#160;command or until another force is placed on it. (See<a href="#AppendixB:Tcl-BasedDebugging-1033952"> &quot;release&quot; </a>for details on the<code> release </code>command.)</p>

<p>The new value takes effect immediately, and, in the case of Verilog wires and VHDL signals and ports, the new value propagates throughout the hierarchy before the command returns. Releasing a force causes the value to immediately return to the value that would have been there if the force had not been blocking transactions.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You cannot use the <code>force</code> command on an analog object or use the <code>force</code> command on digital objects while the analog solver is active.</p>
</div>
</div>

<p>The object that is being forced must have write access. An error is printed if it does not. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>

<p>The object cannot be:</p>
<ul><li>A Verilog memory</li></ul><ul><li>A Verilog memory element</li></ul><ul><li>A bit-select or part-select of a Verilog register</li></ul><ul><li>A bit-select or part-select of an unexpanded Verilog wire</li></ul><ul><li>A VHDL variable</li></ul>
<p>For Verilog, a force created by the <code>force</code>&#160;command is identical in behavior to a force created by a Verilog <code>force</code>&#160;procedural statement. The force can be released by a Verilog <code>release</code>&#160;statement or replaced by a Verilog <code>force</code>&#160;statement during subsequent simulation.</p>

<p>The value must be a literal, and the literal is treated as a constant. Even if the literal is generated using value substitution or Tcl&#39;s <code>expr</code>&#160;command, the value is considered to be a constant. The forced value does not change if objects used to generate the literal change value during subsequent simulation.</p>

<p>For VHDL, the value specified with the <code>force</code>&#160;command must match the type and subtype constraints of the VHDL object. Integers, reals, physical types, enumeration types, and strings (including std_logic_vector and bit_vector) are supported. Records and non-character array values are not supported, but objects of these types can be assigned to by issuing commands for each subelement individually.</p>

<p>Forces created by the<code> force </code>command and those created by a Verilog<code> force </code>procedural statements are saved if the simulation is saved.</p>

<p>See the &quot;Forcing and Releasing Signal Values&quot; section in the &quot;Debugging Your Design&quot; chapter of <em> <span style="color: rgb(0,0,0);">Cadence Verilog Simulation User Guide </span> </em>for more information.</p>

<p>See the &quot;Basics of Tcl&quot; appendix in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for information on using Tcl with NC-Verilog.</p>

<p>The<code> force </code>command can also be used on wreals with the following limitations:</p>
<ul><li>The value being forced should be a literal value. The Tcl value substitution (<code>value x</code>) and <code>expr</code>&#160;command (<code>expr 2+3</code>) are supported.</li></ul><ul><li>Out of module references (OOMRs) to wreals that require support of Hierarchical IE optimization and IE insertion in VHDL scope are not supported.</li></ul>
<p>You can apply the <code>force</code>&#160;command on bit-select and part-select of wreal arrays, or on an entire wreal array. In case of part-select, the number of forced values should be equal to the width of part-select. In case of entire wreal arrays, the number of forced values should be equal to the width of the array.</p>

<p>The following net types are supported:</p>
<ul><li>wreal array, explicitly defined in Verilog-AMS<br /> <code> module foo();<br /> </code> <code>&#160; wreal ra[3:0];<br /> </code> <code> endmodule </code></li></ul><ul><li>wire vector defined in Verilog-AMS or SystemVerilog file, and coerced to wreal array<br /> <code> module top();<br /> </code> <code>&#160; wire [3:0]ra;<br /> </code> <code>&#160; foo inst(ra);<br /> </code> <code> endmodule <br />
      <br />
    </code> <code>module foo();<br /> </code> <code>&#160; wreal ra[3:0];<br /> </code> <code> endmodule </code></li></ul><ul><li>interconnect vector defined in a SystemVerilog file, and coerced to wreal array<br /> <code> module top();<br /> </code> <code>&#160; interconnect [3:0]ra;  &lt;&lt;&lt; applying TCL force/release on each bit will be supported<br />
    </code> <code>&#160; foo inst(ra);<br /> </code> <code> endmodule<br />
      <br />
    </code> <code>module foo();<br /> </code> <code>&#160; wreal ra[3:0];<br /> </code> <code> endmodule </code></li></ul>
<p>A wreal net can also be forced to <code>`wrealXState</code>&#160;and <code>`wrealZState.</code></p>

<p>For an SV-UDN net, the forced value overrides all previous forces on the entire SV-UDN structure. The forced value is frozen, and the resolution function result is overridden always, until another force or release command is applied. The forced value is the final value of net, and no resolution function is executed at that time.</p>

<p>You can apply the <code>force</code> command on scalar, whole array, bit-select, or part-select of arrays of SV-UDN. And, you can use order-based or name-based approach to force a value. For the name-based approach, the filed order can be different from that defined in the SV-UDT net. You can also assign <code>real&#39;z</code> or <code>real&#39;x</code> values to SV-UDN.</p>

<p>A limitation of applying the <code>force</code> command on an SV-UDN net is that you cannot force value on individual/specific fields of the SV-UDT net. You must specify all the fields of the SV-UDN structure in the <code>force</code> command.</p>

<p>Additionally, you can use the <code>xm_force</code> system task to assign value on an SV-UDN net. The syntax is: <code>xm_force (&#8220;&lt;name&#8221;, &#8220;value&#8221;)</code>. The &#8220;value&#8221; string should not contain any space; and, for the scalar UDN or bit-selected UDN array, the &#8220;value&#8221; string should not contain <code>{}</code>. For example:</p>

<p><code>$xm_force(&quot;dut.ve[0:1]&quot;, &quot;{V:1.0,R:10,I:real&#39;z}{1.5,real&#39;x,20}&quot;);</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.6">Syntax</h3>

<p><code>force <em>object_name</em> [=] <em>value </em>
  </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.5">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.3">Examples</h3>
<h4 id="AppendixB:Tcl-BasedDebugging-DigitalVerilog-AMSexamples:.1">Digital Verilog-AMS examples:</h4>

<p>The following command forces object <code>r</code>&#160;to the value <code>`bx.</code> The equal sign is optional.</p>

<p><code> xcelium&gt; force r = `bx </code></p>

<p>The following command uses value substitution. Object<code> x </code>is forced to the current value of w.</p>

<p><code> xcelium&gt; force x = #w </code></p>

<p>The following command uses command substitution and value substitution. Object <code>y</code>&#160;is forced to the result of the Tcl <code>expr</code>&#160;command, which evaluates the expression <code>#r[0] &amp; ~#r[1] </code>using the current value of<code> r.</code></p>

<p><code> xcelium&gt; force y [expr #r[0] &amp; ~#r[1]] </code></p>

<p>The following command shows the error message that is displayed if you run in regression mode and then use the <code>force</code>&#160;command on an object that does not have write access.</p>

<p><code> xcelium&gt; force clrb 1<br />xmsim: *E,RWACRQ: Object does not have read/write access:<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hardrive.h1.clrb. </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-VHDLexamples:.2"><span style="color: rgb(0,0,0);"> <strong>VHDL examples:</strong> </span></h4>

<p>The following command forces object<code> :t_nickel_out </code>(std_logic) to 1. The equal sign is optional.</p>

<p><code> xcelium&gt; force :t_nickel_out = &#39;1&#39; </code></p>

<p>The following command forces object<code> :top:DISPENSE_tempsig </code>(std_logic)<code> to 1. </code></p>

<p><code> xcelium&gt; force :top:DISPENSE_tempsig &#39;1&#39; </code></p>

<p>The following command forces object<code> :t_dimes </code>(std_logic_vector) to 0.</p>

<p><code> xcelium&gt; force :t_DIMES {&quot;00000000&quot;} </code></p>

<p>The following command forces object<code> is_ok </code>(boolean) to TRUE.</p>

<p><code> xcelium&gt; force :is_ok true </code></p>

<p>The following command forces object<code> :count </code>(integer) to 10.</p>

<p><code> xcelium&gt; force :count 10 </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-WrealExamples">Wreal Examples</h4>

<p>The following command applies the <code>force</code>&#160;command on bit-select of wreal arrays:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wv[3] 1.2</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (1.2,0,0,0)</code></p>

<p>The following command applies the <code>force</code>&#160;command on part-select of wreal arrays:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wrvInst.ra[2:1] {1.5 1.8}</code> <br /> <code>Time: 200 NS: top.wrvInst.ra = (0,1.5,0,0)</code> <br /> <code>Time: 200 NS: top.wrvInst.ra = (0,1.5,1.8,0)</code></p>

<p>The following command applies the force command on an entire wreal array:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wrvInst.ra {1.8 1.6 1.4 1.2}</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,0,0,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,0,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,1.4,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,1.4,1.2)</code></p>

<p>The following command forces the wreal net <code>top.wrvInst.r </code>to a value<code> real&#39;x.</code></p>

<p><code> xcelium&gt; force top.wrvInst.r=real&#39;x </code></p>

<p>The following command forces the wreal net <code>top.wrvInst.r </code>to a value<code> real&#39;z.</code></p>

<p><code> xcelium&gt; force top.wrvInst.r=real&#39;z </code></p>

<p>The following command forces wreal net <code>top.wrvInst.ra</code>&#160;to `<code> wrealXState</code>&#160;and <code>`wrealZState.</code></p>

<p><code> xcelium&gt; force top.wrvInst.ra {real&#39;x 1.6 1.4 real&#39;z}</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (`wrealXState,0,0,0)</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (`wrealXState,1.6,0,0)</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (`wrealXState,1.6,1.4,0)</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (`wrealXState,1.6,1.4,`wrealZState)</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-SV-UDNexamples:.1">SV-UDN examples:</h4>

<p>The following example illustrates the SV-UDN structure and how the force command applies a name-based value to a scalar net. Values 1.2, real&#8217;z, and 500 are forced on real variable V, I, and R, respectively.</p>

<p><code>typedef struct {</code> <br /> <code> real V;</code> <br /> <code> real I;</code> <br /> <code> real R;</code> <br /> <code>} EEstruct;</code> <br /> <br /> <code>Time: 0 FS: tb.ve = (&#39;{V:0, I:0, R:1e+06},&#39;{V:0, I:0, R:1e+06},&#39;{V:0, I:0, R:1e+06})</code> <br /> <code>Time: 0 FS: tb.e = &#39;{V:0, I:0, R:1e+06}</code></p>

<p><code>xcelium&gt; force tb.e {V:1.2, I:real&#39;z, R:500}; </code> <br /> <code>Time: 40 NS: tb.e = &#39;{V:1.2, I:`wrealZState, R:500}</code></p>

<p>The following example illustrates how the <code>force</code> command applies value on bit-select of an array with order-based value. Values 1.2, real&#8217;z, and 50 are forced on real variable V, I, and R, respectively in the order in which it is declared in the structure:</p>

<p><code>xcelium&gt; force tb.ve[1] {1.2, real&#39;z, 50}</code></p>

<p><code>Time: 40 NS: tb.ve = (&#39;{V:0, I:0, R:1e+06},&#39;{V:1.2, I:`wrealZState, R:50},&#39;{V:0, I:0, R:1e+06})</code></p>

<p>The following example applies the force command on part-select of an array:</p>

<p><code># Part-Selected</code> <br /> <code>xcelium&gt; force tb.ve[2:1] {{V:1.0, R:10, I:real&#39;z} {1.5, real&#39;x, 20}} //named-based and order-based approach</code></p>

<p><code>Time: 60 NS: tb.ve = (&#39;{V:1, I:`wrealZState, R:10},&#39;{V:1.2, I:`wrealZState, R:50},&#39;{V:0, I:0, R:1e+06})</code></p>

<p><code>Time: 60 NS: tb.ve = (&#39;{V:1, I:`wrealZState, R:10},&#39;{V:1.5, I:`wrealXState, R:20},&#39;{V:0, I:0, R:1e+06})</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-probetclprobecommand1033526Tcl_probe">probe&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-tclprobecommand"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033526"></span>&#160;<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe"></span></h2>

<p>Controls the values being saved to a database. You can</p>
<ul><li>Create probes (<code>
      <a href="#AppendixB:Tcl-BasedDebugging-1048515">-create</a>
    </code>)</li></ul><ul><li>Delete probes (<code>
      <a href="#AppendixB:Tcl-BasedDebugging-1050628">-delete</a>
    </code>)</li></ul><ul><li>Disable probes (<code>
      <a href="#AppendixB:Tcl-BasedDebugging-1050632">-disable</a>
    </code>)</li></ul><ul><li>Enable previously disabled probes (<a href="#AppendixB:Tcl-BasedDebugging-1050636"> <code>-enable</code> </a>)</li></ul><ul><li>Create a Tcl script that you can execute to recreate the current databases and probes (<a href="#AppendixB:Tcl-BasedDebugging-1050640"> <code>-save</code> </a>)</li></ul><ul><li>Display information about probes (<a href="#AppendixB:Tcl-BasedDebugging-1050644"> <code>-show</code> </a>)</li></ul><div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You cannot use the<code>&#160;probe&#160;</code>command to probe VHDL objects to a&#160;<a href="Glossary.html#Glossary-1032273">VCD</a>&#160;database. You can create a VCD database for VHDL objects by using the&#160;<code>call</code>&#160;command to call predefined CFC routines, which are part of the NC VHDL simulator C interface. See<a href="#AppendixB:Tcl-BasedDebugging-1032842">&#160;&quot;call&quot;&#160;</a>for details on the<code>&#160;call&#160;</code>command. See Appendix B, &quot;VCD Format Output,&quot; in<span style="color: rgb(0,0,0);">&#160;<em>NC VHDL Simulator Help</em>&#160;</span>for information on VCD files.</p>
</div>
</div>

<p>With an <a href="Glossary.html#Glossary-1034342">SHM</a>&#160;database, you can probe all VHDL signals, ports, and variables that are not declared inside subprograms unless their type falls into one of the following categories:</p>
<ul><li>Non-standard integer types whose bounds require more than 32 bits to represent</li></ul><ul><li>Physical types</li></ul><ul><li>Access and file types</li></ul><ul><li>Any composite type that contains one of the above types</li></ul>
<p>You can create probes for digital objects only if the objects have read access. (Analog objects have read access by default.) If you specify a digital object as an argument to the<code> probe </code>command, and that object does not have read access, the software reports an error. If you specify a scope as an argument to the<code> probe </code>command, the software excludes from the probe any digital objects within that scope that do not have read access and reports a warning. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-1033578Syntax"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033578"></span>Syntax</h3>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>For detailed syntax information for the<code>&#160;probe&#160;</code>Tcl command, see &quot;probe Command Syntax&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/The_Tcl_Command-Line_Interface.html">&quot;Using the Tcl Command-Line Interface&quot;</a> </span>in the<span style="color: rgb(0,0,0);">&#160;<em>Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</div>

<p>You can use the <code>probe</code>&#160;command with the following modifiers, options, and arguments with the AMS Designer simulator:</p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-ports_to_probe"></span> <code>probe_command ::=</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;probe probe_params</code></p>

<p><code>probe_params ::=</code> <br /> <code>&#160;&#160;&#160;&#160;[-create] ports_to_probe | object create_params ... db_format</code> <br /> <code>&#160;&#160;&#160;&#160;|-delete { probe_name | pattern } ...</code> <br /> <code>&#160;&#160;&#160;&#160;|-disable { probe_name | pattern } ...</code> <br /> <code>&#160;&#160;&#160;&#160;|-enable { probe_name | pattern } ...</code> <br /> <code>&#160;&#160;&#160;&#160;|-save [ filename ]</code> <br /> <code>&#160;&#160;&#160;&#160;|-show [{ probe_name | pattern } ...] [-database dbase_name ]</code> <br /> <code>&#160;&#160;&#160;&#160;|-emptyok</code></p>

<p><code>ports_to_probe ::=<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1049876"></span>
  </code> <br /> <code>&#160;&#160;&#160;&#160;&#160;-all [depth] [{-flow | domain}] [-variables] [-vspice_cell]</code> <br /> <code>&#160;&#160;&#160;&#160;|-inputs [depth] [{-flow | domain}]</code> <br /> <code>&#160;&#160;&#160;&#160;|-outputs [depth] [{-flow | domain}]</code> <br /> <code>&#160;&#160;&#160;&#160;|-ports [depth] [{-flow | domain}]</code></p>

<p><code>depth ::=</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;-depth { n | all | to_cells}</code></p>

<p><code>domain ::=</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;-domain {analog | digital}</code></p>

<p><code>object ::=</code> <br /> <code>&#160;&#160;&#160;&#160;&#160; instance_name [{-flow | domain}]</code> <br /> <code>&#160;&#160;&#160;&#160;| port_name [{-flow | domain}]</code></p>

<p><code>create_params ::=</code> <br /> <code>&#160;&#160;&#160;&#160;|-aicms</code> <br /> <code> &#160;&#160;&#160;&#160;|-noaicms</code> <br /> <code>&#160;&#160;&#160;&#160;|-inhconn_signal global_signal</code> <br /> <code> &#160;&#160;&#160;&#160;|-name probe_name</code> <br /> <code> &#160;&#160;&#160;&#160;|-screen [-format format_string ] [-redirect filename ] objects</code> <br /> <code> &#160;&#160;&#160;&#160;|-variables</code> <br /> <code>&#160;&#160;&#160;&#160;|-waveform</code></p>

<p><code>db_format::=</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;-shm</code> <br /> <code>&#160;&#160;&#160;&#160;|-vcd</code> <br /> <code>&#160;&#160;&#160;&#160;|-evcd</code> <br /> <code>&#160;&#160;&#160;&#160;|-database dbase_name </code></p>

<p>The argument to <code>-delete</code>,<code> -disable</code>,<code> -enable</code>, or <code>-show</code>&#160;can be:</p>
<ul><li>A probe name</li></ul><ul><li>A list of probe names</li></ul><ul><li>A pattern</li></ul><ul><ul><li>The asterisk (<code>*</code>) matches any number of characters</li></ul></ul><ul><ul><li>The question mark (<code>?</code>) matches any one character</li></ul></ul><ul><ul><li>[<code>characters</code>] matches any one of the characters</li></ul></ul><ul><li>Any combination of literal probe names and patterns</li></ul><h3 id="AppendixB:Tcl-BasedDebugging-Modifiers">Modifiers</h3>

<p>The <code>
    <a href="#AppendixB:Tcl-BasedDebugging-1033526">probe</a>
  </code> command has the following modifiers:</p>
<div class="table-wrap"><table border="0" cellpadding="4" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="192">
<p>Modifier</p>
</th><th class="confluenceTh" valign="middle" width="456">
<p>Cross-Reference</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
            <span>[-create][ { object | scope_name } ... ][options]</span>
          </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>See<a href="#AppendixB:Tcl-BasedDebugging-1048515"> &quot;-create&quot; </a></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-delete {</code> <code>probe_name</code> <code>|</code> <code>pattern</code> <code>} ... </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_delete"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050628"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p>See &quot;Deleting a Probe&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a> </span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-disable {</code> <code>probe_name</code> <code>|</code> <code>pattern</code> <code>} ... </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050632"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_disable"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p>See &quot;Disabling a Probe&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a> </span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-enable {</code> <code>probe_name</code> <code>|</code> <code>pattern</code> <code>} ... </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050636"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_enable"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p>See &quot;Enabling a Probe&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a> </span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-save [</code> <code>filename</code> <code>] </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050640"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_save"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p>See &quot;Saving a Script to Re-Create Probes&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a> </span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-show [{</code> <code>probe_name</code> <code>|</code> <code>pattern</code> <code>} ...][-database </code> <code> dbase_name</code> <code>] </code></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050644"></span></p>

<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_show"></span></p>
</div>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p>See &quot;Displaying Information about Probes&quot; in the <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a> </span>section of <span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a> </span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>
</div>
</td>
</tr>
</tbody></table></div>
<h4 id="AppendixB:Tcl-BasedDebugging-Tcl_probe_create1048515-create"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_probe_create"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1048515"></span> <code>-create</code></h4>

<p>The optional <code>-create</code>&#160;modifier for the <a href="#AppendixB:Tcl-BasedDebugging-1033526"> <code>probe</code> </a> command has the following general syntax:</p>

<p><code>
    <span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">[-create][ { object | scope_name } ... ][ options ]</span>
  </code></p>

<p>Use the<code> -create </code>modifier to place values of the specified simulation objects in a database.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You can only probe simulation objects that have read access. You can also probe signals inside the SPICE scope. For the list of probe options that are supported in SPICE, refer to the section<a href="#AppendixB:Tcl-BasedDebugging-1053348">&#160;Probe Options Supported in SPICE Scope</a>.</p>
</div>
</div>

<p>If you are probing an SHM or VCD database, you can add an argument to the <code>-create</code>&#160;modifier that specifies the following:</p>
<ul><li>The object or objects you want to traceIf you specify <code>-create</code>&#160;with the <a href="#AppendixB:Tcl-BasedDebugging-1050403"> <code>-inhconn_signal</code> </a> option, the object must be an instance (not a terminal) and must have a full hierarchical name.</li></ul><ul><li>The scope or scopes you want to trace</li></ul><ul><li>A combination of objects and scopes</li></ul>
<p>If you do not specify an argument, the software uses the current debug scope. However, you must include an option that specifies the objects to include in the trace. For more information, see <a href="#AppendixB:Tcl-BasedDebugging-1049876"> <code>ports_to_probe</code> </a> in the syntax description for the <a href="#AppendixB:Tcl-BasedDebugging-1033526"> <code>probe</code> </a> command.</p>

<p>If more than one database is open, you must use one of the following options to specify the database into which you want the software to dump the values:</p>
<ul><li><code> -database </code> <code> dbase_name </code></li></ul><ul><li><code> -shm </code></li></ul><ul><li><code> -vcd </code></li></ul><ul><li><code> -evcd </code></li></ul>
<p>You can specify the following options for the <code>-create</code>&#160;modifier when you use the AMS Designer simulator:</p>
<ul><li><code>
      <a href="#AppendixB:Tcl-BasedDebugging-1050968">-aicms</a> </code></li></ul><ul><li><code>
      <a href="#AppendixB:Tcl-BasedDebugging-1056098">-noaicms</a>
    </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_all"></span> <code>-all [-variables] </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_database"></span> <code>-database </code> <code> dbase_name </code></li></ul><ul><li>
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-depth"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_depth"></span> <code>-depth </code>{<code>n</code>|<code>all</code>|<code>to_cells</code>}</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>The software does not probe currents through inherited connections when processing the <code>all</code> argument.</p>
</div>
</div>
</li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_domain"></span> <code>-domain </code>{<code>analog</code>|<code>digital</code>}</li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_emptyok"></span> <code>-emptyok </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_evcd"></span> <code>-evcd </code></li></ul><ul><li><code>
      <a href="#AppendixB:Tcl-BasedDebugging-1051359">-flow</a> </code></li></ul><ul><li><a href="#AppendixB:Tcl-BasedDebugging-1050403"> <code>-inhconn_signal</code> </a> <code> global_signal </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_inputs"></span> <code>-inputs </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_name"></span> <code>-name </code> <code> probe_name </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_outputs"></span> <code>-outputs </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_ports"></span> <code>-ports </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_screen"></span> <code>-screen [-format </code> <code> format_string</code> <code>] [-redirect </code> <code> filename</code> <code>] </code> <code> objects </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_shm"></span> <code>-shm </code></li></ul><ul><li><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_vcd"></span> <code>-vcd </code></li></ul>
<p>For information about these and other options for the <code>-create</code>&#160;modifier, see &quot;Creating a Probe&quot; in the&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a>&#160;</span>section of&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a>&#160;</span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>

<p>You can use the <code>probe -create -screen</code>&#160;and <code>probe -create -shm </code>commands to probe objects with built-in and user-defined nettypes and resolution functions. For example, you can use these commands to probe the following:</p>
<ul><li>Scalar net of type real with built-in and user-defined resolution functions</li></ul><ul><li>Nettypes of type unpacked structure with real, logic, bit, integer and enum data types.</li></ul><ul><li>Unpacked array of nettypes with elements as scalar real with built-in and user-defined resolution functions</li></ul><ul><li>Unpacked array of unpacked structure nettype with built-in and user-defined resolution functions.</li></ul>
<p>Here nettype is defined on the type of the complete structure object and hence, following different scenarios will be supported:</p>
<ul><li>Probe on the complete object (Table B-1 and Table B-2).</li></ul><ul><li>Probe on the member select of complete object (Table B-1 and Table B-2).</li></ul><div class="pbi_avoid"><span class="content-title"><strong>Table B.1:</strong> Probe Creation Commands</span><div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><tbody><tr><th class="confluenceTh" valign="middle" width="260">
<p>Probe Commands</p>
</th><th class="confluenceTh" colspan="2" valign="middle" width="392">
<p>Description</p>
</th></tr>
<tr><td class="confluenceTd" valign="top" width="260">
<p><code>probe -create -screen &lt;</code> <code>complete_object</code> <span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span> <code>&gt; </code></p>
</td>
<td class="confluenceTd" rowspan="2" valign="top" width="109">
<p>Screen probe on object or object member</p>
</td>
<td class="confluenceTd" rowspan="4" valign="top" width="283">
<p><span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span> <span style="color: rgb(0,0,0);"> <strong>Object Probes</strong> </span>:</p>

<p>The probe will be attached on the complete unpacked structure net. If the value (that is, the value of any member) of the net changes during simulation, it will either display the value or dump it depending on the probe type.</p>

<p><span style="color: rgb(0,0,0);"> <strong> <sup>2</sup> </strong> </span> <span style="color: rgb(0,0,0);"> <strong>Member Select Probes:</strong> </span></p>

<p>Here, complete object implies the complete unpacked structure. The probe will be attached on the specific member of that structure. While printing the value, it will show the value of the probed member only.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>probe -create -screen &lt;c</code> <code>omplete_object.member_select</code> <span style="color: rgb(0,0,0);"> <strong> <sup>2</sup> </strong> </span> <code>&gt; </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>probe -create -shm &lt;</code> <code>complete_object</code> <span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span> <code>&gt; </code></p>
</td>
<td class="confluenceTd" rowspan="2" valign="top">
<p>Signal probe for shm on object or object member</p>

<p><br /></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>probe -create -shm &lt;</code> <code>complete_object.member_select</code> <span style="color: rgb(0,0,0);"> <strong> <sup>2</sup> </strong> </span> <code>&gt; </code></p>
</td>
</tr>
</tbody></table></div>
</div>
<div class="pbi_avoid"><span class="content-title"><strong>Table B.2:</strong> <span>Probe Manipulation Commands</span></span><div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="283">
<p>Probe Commands</p>
</th><th class="confluenceTh" valign="middle" width="363">
<p>Description</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
                <span style="color: rgb(0,0,0);">probe -delete &lt;</span>probe_name&gt;</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Only removes the respective probe on the specific complete object<span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span>or probed member.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
                <span style="color: rgb(0,0,0);">probe -disable &lt;</span>probe_name&gt;</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Only disables the respective probe on the specific complete object<span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span>or probed member.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
                <span style="color: rgb(0,0,0);">probe -enable &lt;</span>probe_name&gt;</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Only enables the respective probe on the specific complete object<span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span>or probed member.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>
                <span style="color: rgb(0,0,0);">probe -show [&lt;</span>probe_name&gt;]</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Only shows the respective probe on the specific complete object<span style="color: rgb(0,0,0);"> <strong> <sup>1</sup> </strong> </span>or probed member.</p>

<p>As the probe name is optional, it displays all available probes in case the probe name is not specified.</p>
</td>
</tr>
</tbody></table></div>
</div>

<p>For more information on user-defined net types, refer to<a href="Using_Real_Number_Modeling_in_SystemVerilog.html#UsingRealNumberModelinginSystemVerilog-1066573"> User-Defined Nettype and Resolution Function</a>.</p>
<h4 id="AppendixB:Tcl-BasedDebugging--aicmscreate_aicms1050968">-aicms<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_aicms"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050968"></span></h4>

<p>Use the <code>-aicms</code>&#160;option to probe automatically-inserted connect module (AICM) scopes exclusively. By default, <code>-aicms</code>&#160;uses <code>-depth all</code>&#160;for the AICM scope search. You must also specify -<code>all</code>,<code> -domain</code>,<code> -variables</code>,<code> -ports</code>,<code> -outputs</code>, or <code>-inputs.</code> (See&#160;<a href="#AppendixB:Tcl-BasedDebugging-1033578">&quot;Syntax&quot;</a>&#160;for more information about<code> probe </code>command syntax.)</p>

<p>You cannot use the following options when you specify <code>-aicms</code>:</p>
<ul><li><a href="#AppendixB:Tcl-BasedDebugging-1050403"> <code>-inhconn_signal</code> </a> <code> global_signal </code></li></ul><ul><li><code> -screen [-format </code> <code> format_string</code> <code>] [-redirect </code> <code> filename</code> <code>] </code> <code> objects </code></li></ul>
<p>For more information about these and other options for the <code>-create</code>&#160;modifier, see &quot;Creating a Probe&quot; in the&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/probe.html">&quot;probe&quot;</a>&#160;</span>section of&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../tclcmdref/Xcelium_Simulator_Tcl_Commands.html">Xcelium Simulator Tcl Commands</a>&#160;</span>in the<span style="color: rgb(0,0,0);"> <em> Xcelium Simulator Tcl Command Reference</em>.</span></p>

<p>Here are some examples:</p>

<p>The following command probes inputs of all AICM scopes relative to the current scope:</p>

<p><code> probe -create -aicms -depth all -inputs </code></p>

<p>Specifying<code> -depth all </code>is optional because the default behavior is<code> -depth all.</code> So, you could use the following command instead:</p>

<p><code> probe -create -aicms -inputs </code></p>

<p>The following command probes inputs of all AICM scopes relative to the scope<code> top.i1.i2.i3</code>:</p>

<p><code> probe -create -aicms -depth all -inputs top.i1.i2.i3 </code></p>

<p>Again, you could use the following command instead, because specifying<code> -depth all </code>is optional:</p>

<p><code> probe -create -aicms -inputs top.i1.i2.i3 </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging--noaicmsnoaicms1056098">-noaicms<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-noaicms"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1056098"></span></h4>

<p>Use the<code> -noaicms </code>option to exclude the AICM scopes from the probe set specified using the Tcl<code> probe </code>command. For example:</p>

<p><code>probe -create -all -noaicms</code></p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>Currently, the <code>-noaicms</code> option is applicable for AICMs in Verilog scope only.</p>
</div>
</div>
<h4 id="AppendixB:Tcl-BasedDebugging--flow1051359create_flow">-flow<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1051359"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_flow"></span></h4>

<p>The <code>-flow</code>&#160;option indicates a current probe. You can probe current in Verilog-A and Verilog-AMS modules that are behavioral or that instantiate Spectre subcircuits, Spectre primitives supporting calculated currents, or other Verilog-A or Verilog-AMS modules. You can also probe current in Spectre subcircuit and built-in primitive instances in Verilog-AMS modules. The probed object must be a port or an instance when you use the <code>-ports</code>&#160;or the <code>-all</code>&#160;option.</p>

<p>Use <code>-flow -all</code>&#160;to save port currents and all other values and quantities covered by the <code>-all</code>&#160;option. You cannot probe currents through inherited connections.</p>

<p>Use <code>-flow</code>&#160;with <code>-ports</code>,<code> -inputs</code>, or <code>-outputs</code>&#160;to probe currents in the specified objects of the scope.</p>
<ul><li>The software saves waveforms in Verilog modules as <code>signal </code> <code> _$flow</code>. Consequently, to plot the signal in SimVision, you need to add the <code>_$flow</code>&#160;extension to the signal name.</li></ul><ul><li>The software saves waveforms in SPICE or Spectre subcircuits or primitives as just <code>signal</code>, without the appended <code>_$flow.</code></li></ul>
<p>You cannot probe currents in</p>
<ul><li>Simulations using the partition-multirate capability</li></ul><ul><li>AC analysis</li></ul><ul><li>The following Spectre built-in devices:<code> port</code>,<code> delay</code>,<code> switch</code>,<code> hbt</code>,<code> transformer</code>,<code> core</code>,<code> winding</code>,<code> fourier</code>,<code> d2a</code>,<code> a2d</code>,<code> a2ao</code>,<code> a2ai</code>. Use the analog simulation control file to probe the currents in these primitives.</li></ul><div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>If you create a current probe after the simulation starts, the value of the current becomes available only after the next time period.</p>
</div>
</div>
<h4 id="AppendixB:Tcl-BasedDebugging--inhconn_signal1050403create_inhconn_signal">-inhconn_signal<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1050403"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-create_inhconn_signal"></span></h4>

<p>Specify the <code>-inhconn_signal</code>&#160;option in the following format with the&#160;<a href="#AppendixB:Tcl-BasedDebugging-1048515"> <code>-create</code> </a>&#160;modifier:</p>

<p><code> -inhconn_signal </code> <code> global_signal </code></p>

<p>You must use the&#160;<code>
    <a href="#AppendixB:Tcl-BasedDebugging-1051359">-flow</a>
  </code>&#160;option when you specify this option. These two options together specify that you want the probe to return the total current drawn from <code>global_signal </code>through inherited connections by the specified instance. The <code>global_signal</code>&#160;must have a full hierarchical name. The software generates a signal named either <code>global_signal </code> <code> _$flow</code>&#160;or just<code> global_signal</code>, depending on whether the instance is of a Verilog module or of a SPICE or Spectre subcircuit or primitive.</p>
<h4 id="AppendixB:Tcl-BasedDebugging--rnmnetsrnmnets">-rnmnets<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-rnmnets"></span></h4>

<p>Use the <code>-rnmnets</code> to probe only the set of RNM nets in the specified scope. For example:</p>

<p><code>probe -create -shm -rnmnets</code></p>

<p>When you specify the <code>-rnmnets</code> option along with <code>{object, scope_name}</code>, the tool probes only the RNM nets for the target scope. Similarly, when you use the option with <code>-aicms</code>, <code>-ports</code>, <code>-inputs</code>, <code>-outputs</code>, or <code>-depth {all, end, to_cell}</code>, the tool probes only the RNM nets among all the scope/ports.</p>
<div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>Using the <code>-all</code> option along with the <code>-rnmnets</code> option probe all the objects within the given scope; that is, all nets including RNM nets are probed.</p>
</div>
</div>

<p>You cannot use the following options when you specify <code style="letter-spacing: 0.0px;">-rnmnets</code>:</p>
<ul><li><code>-flow</code></li><li><code>-inhconn_signal global_signal</code></li></ul><h3 id="AppendixB:Tcl-BasedDebugging-Examples.4">Examples</h3>

<p>The following command creates a probe on all objects in the current debug scope. All objects have read access. Data is sent to the default<a href="Glossary.html#Glossary-1034342"> SHM </a>database. If no default SHM database exists, a default database called <code>xcelium.shm</code>&#160;in the file <code>xcelium.shm </code>is created. The <code>-create</code>&#160;modifier is not required. The <code>-all</code>&#160;option (or<code> -inputs</code>,<code> -outputs</code>, or <code>-ports</code>) is required because no <code>object</code>&#160;or <code>scope_name</code>&#160;argument is specified.</p>

<p><code> xcelium&gt; probe -create -shm -all </code></p>

<p>The following command creates a probe on all inputs in the current debug scope. Data is sent to the default VCD database. If no default VCD database exists, a default database called&#160;&#160;<code>xcelium.vcd</code>&#160;in the file<code> xcelium.vcd </code>is created. The <code>-inputs</code>&#160;option (or <code>-all</code>,<code> -outputs</code>, or <code>-ports</code>) is required because no <code>object</code>&#160;or <code>scope_name</code>&#160;argument is specified.</p>

<p>Probing analog objects to a VCD database is not supported, so the following command should not be used for such objects.</p>

<p><code> xcelium&gt; probe -vcd -inputs </code></p>

<p>The following command creates a probe on all ports in the current debug scope. Data is sent to the database<span style="color: rgb(0,0,0);"> waves.</span> This database must already exist. The <code>-ports</code>&#160;option (or <code>-all</code>,<code> -outputs</code>, or <code>-inputs</code>) is required because no <code>object</code>&#160;or <code>scope_name</code>&#160;argument is specified.</p>

<p><code> xcelium&gt; probe -database waves -ports </code></p>

<p>The following command creates a probe on the signal <code>sum</code>&#160;in the current debug scope and sends data to the default SHM database (creating one called <code>xcelium.shm</code>&#160;in the file&#160;<code>xcelium.shm</code>, if necessary).</p>

<p><code> xcelium&gt; probe -shm sum </code></p>

<p>The following command creates a probe on <code>sum</code>&#160;and <code>c_out</code>&#160;in the current debug scope and sends data to the default SHM database (creating one called<code> xcelium.shm </code>in the file<code> xcelium.shm </code>, if necessary).</p>

<p><code> xcelium&gt; probe -shm sum c_out </code></p>

<p>The following command creates a probe on <code>sum</code>&#160;in scope&#160;<code>u1</code>, sending data to the default SHM database (creating one called <code>xcelium.shm</code>&#160;in the file x<code>celium.shm</code>, if necessary).</p>

<p><code> xcelium&gt; probe -shm u1.sum </code></p>

<p>The following command creates a probe on all objects in scope <code>u1.</code></p>

<p><code> xcelium&gt; probe -shm u1 </code></p>

<p>The following command creates a probe on all objects in scopes <code>u1</code>&#160;and <code>u2.</code></p>

<p><code> xcelium&gt; probe -shm u1 u2 </code></p>

<p>The following command creates a probe on all ports in scope<code> u1.</code></p>

<p><code> xcelium&gt; probe -shm u1 -ports </code></p>

<p>The following command creates a probe on all ports in scope<code> u1 </code>and its subscopes.</p>

<p><code> xcelium&gt; probe -shm u1 -ports -depth 2 </code></p>

<p>The following command creates a probe on all ports in scope <code>u1</code>&#160;and all scopes below <code>u1.</code></p>

<p><code> xcelium&gt; probe -shm u1 -ports -depth all </code></p>

<p>The following command creates a probe on every signal inside spice instance <code>spice_A1.</code></p>

<p><code> xcelium&gt; probe -create -shm top.spice_A1.* -depth all </code></p>

<p>The following command creates a probe on all ports in scope<code> u1 </code>and all scopes below <code>u1</code>, stopping at modules with a <code>`celldefine</code>&#160;directive.</p>

<p><code> xcelium&gt; probe -shm u1 -ports -depth to_cells </code></p>

<p>The following command creates a probe called <code>peek.</code></p>

<p><code> xcelium&gt; probe -shm sum -name peek </code></p>

<p>The following command monitors value changes on the digital signals <code>clock</code>&#160;and <code>count</code>, and an analog signal, <code>analogsig</code>. When either of the digital signals changes value, output for all the signals displays on the screen.</p>

<p><code> xcelium&gt; probe -screen clock count analogsig<br />Created probe 1<br />xcelium&gt; run 10 ns<br />Time: 5 NS: board.clock = 1&#39;h1 : board.count = 4&#39;hx<br />Ran until 10 NS + 0 </code></p>

<p>The following command probes all the port currents of instance <code>top.A.</code></p>

<p><code> probe -create -flow -shm -ports top.A </code></p>

<p>The following command probes a single port current. The command specifies, as it must, the formal port name of the instance being probed.</p>

<p><code> probe -create -shm -flow top.A1.b1 </code></p>

<p>The following command probes the current drawn by the <code>top.A</code>&#160;instance from the <code>\vdd!</code>&#160;global net through inherited connections. Notice how full hierarchical names are specified for both the instance and the net. The original name of the net is <code>cds_globals.\vdd!</code>&#160;but preserving that name through the Tcl shell requires a second backslash, the space at the end of the name, and quotation marks.</p>

<p><code> probe -create -shm -flow top.A -inhconn_signal &quot;cds_globals.\\vdd! &quot; </code></p>

<p>In the following command, the<code> -format </code>option is included to format the output of <code>probe -screen.</code></p>

<p><code> xcelium&gt; probe -screen -format &quot;clock = %d \ncount = %b&quot; clock count<br />Created probe 1<br />xcelium&gt; run 10 ns<br />clock = 1&#39;d1count = 4&#39;bxxxx<br />Ran until 10 NS + 0 </code></p>

<p>The following example illustrates the simulator output when you use<code> probe -screen </code>to monitor signal value changes, and then disable the probe at some later time.</p>

<p><code> xcelium&gt; probe -screen clock count<br />Created probe 1<br />xcelium&gt; probe -disable 1<br />xcelium&gt; run 10 ns<br />Time: 5 NS: board.clock = &lt;disabled&gt; : board.count = &lt;disabled&gt;<br />Ran until 10 NS + 0 </code></p>

<p>The following command displays the state of all probes.</p>

<p><code> xcelium&gt; probe -show </code></p>

<p>The following command displays the state of the probe called<code> peek.</code></p>

<p><code> xcelium&gt; probe -show peek </code></p>

<p>The following command disables the probe called<code> peek.</code></p>

<p><code> xcelium&gt; probe -disable peek </code></p>

<p>The following command enables the probe called<code> peek </code>, which was disabled in the previous command.</p>

<p><code> xcelium&gt; probe -enable peek </code></p>

<p>The following command deletes all probes beginning with the characters<code> pe.</code></p>

<p><code> xcelium&gt; probe -delete pe* </code></p>

<p>The following command deletes all probes beginning with the characters<code> v </code>and<code> w.</code></p>

<p><code> xcelium&gt; probe -delete {[vw]} </code></p>

<p>The following command shows the error message that is displayed if you run in regression mode and then probe an object that does not have read access.</p>

<p><code> xcelium&gt; probe -shm d<br />xmsim: *E,RDACRQ: Object does not have read access: hardrive.h1.d. </code></p>

<p>The following command produces a warning message for attempting to probe an analog object to a <a href="Glossary.html#Glossary-1032273">VCD </a>database.</p>

<p><code> xcelium&gt; probe -create -vcd top.analogResult -waveform </code></p>

<p>The error message is</p>

<p><code> xmsim: *W,PRALOB: Cannot probe analog object:<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.analogResult. This object ignored.</code></p>

<p><code>xmsim: *E,PRWHAT: no items specified in probe -create command. </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-1053348ProbeOptionsSupportedinSPICEScope"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1053348"></span>Probe Options Supported in SPICE Scope</h4>

<p>The following table displays the probe options that can be used to probe signals inside the SPICE hierarchy.</p>
<div class="pbi_avoid"><span class="content-title"><strong>Table B.3:</strong> Probe Options Supported in SPICE Scope</span><div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> <col /> </colgroup><tbody><tr><td class="confluenceTd" valign="top" width="131">
<p><code>-create </code></p>
</td>
<td class="confluenceTd" valign="top" width="168">
<p><code>-shm </code></p>
</td>
<td class="confluenceTd" valign="top" width="191">
<p><code>-database </code> <code> dbase_name </code></p>
</td>
<td class="confluenceTd" valign="top" width="157">
<p><code>-all </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-depth </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-domain </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-emptyok </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-exclude </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-flow </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-name </code> <code> probe_name </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-ports </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-screen [-format] [-redirect] </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-waveform </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-delete </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-disable </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-enable </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-save </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-show </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-vspice_cell </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
</tr>
</tbody></table></div>
</div>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>Tcl probing inside the SPICE hierarchy is not supported in AMS-UltraSim. In addition, Tcl probing inside the SPICE hierarchy is not supported on the AIX platform.</p>
</div>
</div>
<h3 id="AppendixB:Tcl-BasedDebugging-vspice_cellProbingSPICEPortsinVerilog/SPICEBoundary"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-vspice_cell"></span>Probing SPICE Ports in Verilog/SPICE Boundary</h3>

<p>You can use the <code>-vspice_cell</code>&#160;option with the Tcl <code>probe</code>&#160;command to probe voltage, current, or both on SPICE ports on Verilog/SPICE or VHDL/SPICE boundary. Consider the following examples:</p>

<p><code> xcelium&gt;  probe -database ams_database -vspice_cell </code></p>

<p>The above command performs voltage probe on the SPICE ports on Verilog/SPICE boundary.</p>

<p>You can use the <code>-flow</code>&#160;and -<code>all</code>&#160;options with the -<code>vspice_cell</code>&#160;option, to probe both voltage and current, as follows:</p>

<p><code> xcelium&gt; probe -database ams_database -vspice_cell -flow </code></p>

<p>The above command performs current probe on the SPICE ports on Verilog/SPICE boundary.</p>

<p><code> xcelium&gt; probe -database ams_database -vspice_cell -flow -all </code></p>

<p>The above command performs both voltage and current probes on the SPICE ports on Verilog/SPICE boundary.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><ul><li>
<p>When you use the <code>save</code> or <code>.probe</code> commands, then internal SPICE nets as well as SPICE sub-hierarchies are also probed despite using the <code>-vspice_cell</code> option. Therefore, you need to either modify or disable all<code>&#160;save&#160;</code>and .<code>&#160;probe&#160;</code>commands in the design to effectively use the <code>-vspice_cell</code> option.</p>
</li><li>
<p><span>The </span> <code>-vspice_cell</code> <span> option takes precedence over other Tcl probes that refer to the same design hierarchy and are ignored.</span></p>
</li><li>
<p>Verilog ports are not probed on Verilog/SPICE boundary for SPICE-in-Middle and SPICE-on-Top cases.<span style="color: rgb(0,0,0);">&#160;</span></p>
</li></ul></div>
</div>
<h2 id="AppendixB:Tcl-BasedDebugging-releaseTcl_release1033952">release<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_release"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033952"></span></h2>

<p>Releases any force set on the specified objects. Releasing a force causes the value to immediately return to the value that would have been there if the force had not been blocking transactions.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You cannot use the <code>release</code> command on an analog object or while the analog solver is active.</p>
</div>
</div>

<p>This command releases any force, whether it was created by a <code>force</code>&#160;command or by a Verilog <code>force </code>procedural statement during simulation. The behavior is the same as that of a Verilog <code>release</code>&#160;statement.</p>

<p>Objects specified as arguments to the <code>release</code>&#160;command must have write access. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>

<p>The following objects cannot be forced to a value with the <code>force</code>&#160;command and, therefore, cannot be specified as the object in a <code>release</code>&#160;command.</p>
<ul><li>Memory</li></ul><ul><li>Memory element</li></ul><ul><li>Bit-select or part-select of a register</li></ul><ul><li>Bit-select or part-select of a unexpanded wire</li></ul><ul><li>VHDL variable</li></ul>
<p>See the &quot;Forcing and Releasing Signal Values&quot; section in the &quot;Debugging Your Design&quot; chapter of<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information</p>

<p>You can apply the <code>release</code>&#160;command on bit-select and part-select of wreal arrays, or on an entire wreal array.</p>

<p>For an SV-UDN net, the target net must be scalar, array, or bit-select and part-select of arrays. A limitation of applying the release command on an SV-UDN net is that you cannot release a forced value from individual/specific fields of the SV-UDT net.</p>

<p>Additionally, you can use the <code>xm_release</code> system task to release the forced value on an SV-UDN net. The syntax is: <code>xm_release (&#8220;&lt;name&#8221;)</code>. For example:</p>

<p><code>$xm_release(&quot;dut.ve[1:2]&quot;);</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.7">Syntax</h3>

<p><span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">release<code> object_name ... </code> </span></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.6">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="109">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="164">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="375">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code> -keepvalue </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Releases the forced object, but retains the forced value.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.5">Examples</h3>

<p>The following command removes a force set on object <code>x.</code></p>

<p><code> xcelium&gt; release x </code></p>

<p>The following command removes a force set on object<code> :top:DISPENSE_tempsig.</code></p>

<p><code> xcelium&gt; release :top:DISPENSE_tempsig </code></p>

<p>The following command releases two objects: <code>w[0]</code>&#160;and <code>r.</code></p>

<p><code> xcelium&gt; release w[0] r </code></p>

<p>The following command shows what happens if you try to release a force digital variable while the analog solver is active.</p>

<p><code> xcelium&gt; release b6</code> <br /> <code>*E,SETAIA: Analog engine is active. Cannot release digital object: top.sar.b6</code></p>

<p>The following command applies the release command on bit-select of wreal arrays and then releases the force set on the wreal object:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wv[3] 1.2</code> <br /> <code>Time: 100 NS: top.wrvInst.ra = (1.2,0,0,0)</code> <br /> <code>xcelium&gt; release top.wrvInst.ra[3]</code> <br /> <code>Time: 200 NS: top.wrvInst.ra = (0,0,0,0)</code></p>

<p>The following command applies the force command on part-select of wreal arrays and then releases the value:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wrvInst.ra[2:1] {1.5 1.8}</code> <br /> <code>Time: 200 NS: top.wrvInst.ra = (0,1.5,0,0)</code> <br /> <code>Time: 200 NS: top.wrvInst.ra = (0,1.5,1.8,0)</code> <br /> <code>xcelium&gt; release top.wrvInst.ra[1:0]</code> <br /> <code>Time: 300 NS: top.wrvInst.ra = (0,1.5,0,0)</code></p>

<p>The following command applies the force command on an entire wreal array and then releases the value:</p>

<p><code> Time: 100 NS: top.wrvInst.ra = (0,0,0,0)</code> <br /> <code>xcelium&gt; force top.wrvInst.ra {1.8 1.6 1.4 1.2}</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,0,0,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,0,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,1.4,0)</code> <br /> <code>Time: 100 FS: top.wrvInst.ra = (1.8,1.6,1.4,1.2)</code> <br /> <code>xcelium&gt; release top.wrvInst.ra</code> <br /> <code>Time: 200 NS: top.wrvInst.r = 0: top.wrvInst.ra = (1.8,1.6,1.4,0)</code> <br /> <code>Time: 200 NS: top.wrvInst.r = 0: top.wrvInst.ra = (1.8,1.6,0,0)</code> <br /> <code>Time: 200 NS: top.wrvInst.r = 0: top.wrvInst.ra = (1.8,0,0,0)</code> <br /> <code>Time: 200 NS: top.wrvInst.r = 0: top.wrvInst.ra = (0,0,0,0)</code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-SV-UDNexamples:.2">SV-UDN examples:</h4>

<p>The following example illustrates the SV-UDN structure and how the release command removes a forced value set on a part-select of an array <code>(tb.ve[2:1])</code>:</p>

<p><code>typedef struct {</code> <br /> <code>&#160; &#160; real V;</code> <br /> <code>&#160; &#160; real I;</code> <br /> <code>&#160; &#160; real R;</code> <br /> <code>}&#160; EEstruct;</code></p>

<p><code>xcelium&gt; release tb.ve[2:1]</code> <br /> <code>Time: 120 NS: tb.ve = (&#39;{V:1, I:`wrealZState, R:10},&#39;{V:1.8, I:0, R:200},&#39;{V:1.8, I:0, R:200})</code> <br /> <code>Time: 120 NS: tb.ve = (&#39;{V:1.8, I:0, R:200},&#39;{V:1.8, I:0, R:200},&#39;{V:1.8, I:0, R:200})</code></p>

<p>The following command removes a force set on a scalar udn, <code>tb.e</code>:&#160;</p>

<p><code>xcelium&gt; release tb.e</code> <br /> <code>Time: 140 NS: tb.dut.e = &#39;{V:1.8, I:0, R:200}</code></p>

<p><code>Time: 140 NS: tb.e = &#39;{V:1.8, I:0, R:200}</code></p>

<p>The following command removes a force set on a bit-select of an array, <code>tb.ve[0]</code>:&#160;</p>

<p><code>xcelium&gt; release tb.ve[0]</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-resetTcl_reset1034001">reset<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_reset"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1034001"></span></h2>

<p>Resets the currently loaded model to its original state at time zero. The time-zero snapshot, created by the elaborator, must still be available.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>The&#160;<code>reset</code>&#160;command is supported only for pure digital designs and cannot be used for mixed-signal designs.</p>
</div>
</div>

<p>The Tcl debug environment remains the same as much as possible after a reset.</p>
<ul><li>Tcl variables remain as they were before the reset.</li></ul><ul><li>
<p><a href="Glossary.html#Glossary-1034342"> SHM </a>and VCD databases remain open, and probes remain set.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>VCD databases created with the <code>$dumpvars</code> call in Verilog source code are closed when you reset.</p>
</div>
</div>
</li></ul><ul><li>Breakpoints remain set.</li></ul><ul><li>Watch Windows and the SimVision waveform viewer window remain the same.</li></ul>
<p>Forces and deposits in effect at the time you issue the <code>reset</code>&#160;command are removed.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.8">Syntax</h3>

<p><code> reset </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.7">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.1">Example</h3>

<p>The following command resets the currently loaded model to its original state at time zero. The snapshot created at time zero must still be available.</p>

<p><code> xcelium&gt; reset </code></p>

<p>This command does not work on mixed-signal designs. The following example shows what happens if you try to reset a mixed-signal design.</p>

<p><code> xcelium&gt; reset</code> <br /> <code>*E,RESTAG: Reset not supported for mixed-signal designs.</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-Tcl_restart1034026restart"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_restart"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1034026"></span>restart</h2>

<p>Replaces the currently simulating snapshot with another snapshot of a same design. The simulator then uses the analog control options associated with the new snapshot to continue the simulation.</p>

<p>The specified snapshot must be a snapshot created by the <a href="#AppendixB:Tcl-BasedDebugging-1034316"> <code>save</code> </a>&#160;command.</p>

<p>The software interprets the snapshot name the same way as the snapshot name on the <code>xmsim</code>&#160;command line, with the addition that, if you want, you can give only the view name preceded by a colon to load a snapshot that is a view of the currently loaded cell. For example:</p>
<div class="table-wrap"><table border="0" cellpadding="4" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><td class="confluenceTd" valign="top" width="240">
<p><code> restart top </code></p>
</td>
<td class="confluenceTd" valign="top" width="408">
<p>Restarts [<em> <code>lib</code> </em> <code>.</code>]<code> top </code>[<code>:</code> <em> <code>view</code> </em>]</p>

<p>If the view name is omitted, there must be only one snapshot of the given cell, otherwise the snapshot name is ambiguous. In this case, an error message is issued, and a list of available snapshots is printed.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> restart top:ckpt </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Restarts [<em> <code>lib</code> </em> <code>.</code>]<code> top:ckpt </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> restart :ckpt </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Restarts [<em> <code>lib</code> </em> <code>.</code>][<em> <code>cell</code> </em>]<code>:ckpt </code></p>
</td>
</tr>
</tbody></table></div>

<p>The following restrictions apply to using the <code>restart</code>&#160;command.</p>
<ul><li>You cannot restart a snapshot that is topologically different from the currently loaded snapshot. The simulator determines if snapshots are topologically different by comparing the analog control options saved in the restarted snapshot with the analog control options being used in the current session. Topological differences arise when the <code>useprobes</code>&#160;parameter of the immediate set <code>options</code>&#160;statement is set to <code>yes</code>&#160;and there is a change in the value of any of the following:</li></ul><ul><ul><li><code> options save </code></li></ul></ul><ul><ul><li><code> options currents </code></li></ul></ul><ul><ul><li><code> options subcktprobelvl </code>Topological differences can also arise if you attempt to restart a design that is different from the design that is running in the current session.When you do need to load a topologically different snapshot, exit <code>xmsim</code>&#160;and then start it with the new snapshot.</li></ul></ul><ul><li>To ensure accuracy, the analog simulation control options used to simulate a restarted snapshot must be the same as the options in use when the snapshot is saved.</li></ul><ul><li>You cannot use the<code> restart </code>command after the current simulation session has finished.</li></ul><ul><li>If your design is a mixed-signal design, you cannot simulate snapshots saved before the most recent elaboration of the design.</li></ul>
<p>When you restart with a saved snapshot in the same simulation session:</p>
<ul><li>SHM databases remain open and all probes remain set.</li></ul><ul><li>
<p>Breakpoints set in the current session at the time that you execute the restart remain set. Breakpoints are not saved in snapshots.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>After a restart, periodic breakpoints trigger at the same times they would trigger without a save and restart. This is true even when the save and restart takes place at a time in between the periodic breakpoints.</p>
</div>
</div>
</li></ul><ul><li>Probes set in the current session at the time you execute the restart remain set. Probes are not saved in snapshots.</li></ul><ul><li>Forces and deposits in effect at the time you issue a <code>save</code>&#160;command are still in effect when you restart.</li></ul>
<p>If you exit the simulation and then start the simulator with a saved snapshot, databases are closed. Any probes and breakpoints are deleted. If you want to restore the full Tcl debug environment when you restart, make sure that you save the environment with the <code>save -environment</code>&#160;command. This command creates a Tcl script that captures the current breakpoints, databases, probes, aliases, and predefined Tcl variable values. You can then use the Tcl <code>source</code>&#160;command after restarting or the <code>-input</code>&#160;option when you start the simulator to execute the script. For example,</p>

<p><code>
    <span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">xmsim top<br />&#160;&#160;&#160;&#160;&#160;&#160; (open a database, set probes, set breakpoints, deposits, forces, etc.)<br /> xcelium&gt; run 100 ns<br />xcelium&gt; save worklib.top:ckpt1<br />xcelium&gt; save -environment ckpt1.tcl<br />xcelium&gt; exit<br />xmsim -tcl worklib.top:ckpt1<br />xcelium&gt; source ckpt1.tcl</span>
  </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.9">Syntax</h3>

<p><code> restart snapshot_name </code></p>

<p><code> restart -show </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.8">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="136">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="182">
<p>Options andArguments</p>
</th><th class="confluenceTh" valign="middle" width="331">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code> -show </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lists the names of all snapshots that can currently be used as the argument to the<code> restart </code>command.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-restartCommandExamples">restart Command Examples</h3>

<p>In the following example, a <code>save</code>&#160;command is issued to save the simulation state as a view of the currently loaded cell, <code>top</code>. This snapshot can then be loaded using either of the next two&#160;<code>restart</code>&#160;commands.</p>

<p><code> xcelium&gt; save top:ckpt1</code> <br /> <code>xcelium&gt; restart top:ckpt1</code> <br /> <code>xcelium&gt; restart :ckpt1</code></p>

<p>In the following example, a <code>save</code>&#160;command is issued to save the simulation state as a view of the currently loaded cell, <code>top</code>. A second <code>save</code>&#160;command is issued to save the Tcl debug environment. If you exit the simulator, you can restart with the saved snapshot and then restore the debug settings by sourcing the script created with the <code>save -environment</code>&#160;command.</p>

<p><code> xcelium&gt; save top:ckpt1</code> <br /> <code>xcelium&gt; save -environment top_ckpt1.env</code> <br /> <code>xcelium&gt; exit</code> <br /> <code>xcelium -tcl :ckpt1</code> <br /> <code>xcelium&gt; source top_ckpt1.env</code></p>

<p>The following command reloads the snapshot of the given cell, <code>top</code>. Because the view name is not specified, the snapshot name is ambiguous if there is more than one view, and an error message is issued.</p>

<p><code> xcelium&gt; restart top </code></p>

<p>The following command lists all of the snapshots you can currently load with the <code>restart</code>&#160;command.</p>

<p><code> xcelium&gt; restart -show<br />otherlib.board:module<br />worklib.board:ckpt1<br />worklib.board:ckpt2 </code></p>

<p>For examples illustrating how the <code>save</code>,<code> restart</code>, and <code>analog</code>&#160;commands work together, see<a href="#AppendixB:Tcl-BasedDebugging-1047142"> &quot;How to Use save, restart, and analog&quot;</a>.</p>
<h2 id="AppendixB:Tcl-BasedDebugging-runTcl_run1033517">run<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_run"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1033517"></span></h2>

<p>Starts simulation or resumes a previously halted simulation.</p>

<p>Using the <code>run</code>&#160;command, you can perform the following tasks:</p>
<div class="table-wrap"><table bgcolor="#FFFFFF" cellpadding="4" cellspacing="0" class="wrapped relative-table confluenceTable" style="width: 43.9774%;"><colgroup> <col style="width: 68.1493%;" /> <col style="width: 31.8637%;" /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="456">
<p>Task</p>
</th><th class="confluenceTh" valign="middle" width="192">
<p>run Option</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p>Run until it is possible to create a snapshot with the <code>save&#160;-simulation</code> command.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040648">-clean</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run until an interrupt, such as a breakpoint or error, occurs or until simulation completes.</p>
</td>
<td class="confluenceTd" valign="top">
<p>(None)</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run one behavioral statement, stepping over subprogram calls.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040668">-next</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run one behavioral statement, stepping into subprogram calls.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040717">-step</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run until the current subprogram (task, function, procedure) returns.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040694">-return</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run to a specified timepoint or for a specified number of time units.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040702">-timepoint</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run to the beginning of the next delta cycle or to a specified delta cycle.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040660">-delta</a> </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run to the beginning of the next phase of the simulation cycle.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040676">-phase</a>
          </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run until the beginning of the next scheduled digital process or to the beginning of the next delta cycle, whichever comes first.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040684">-process</a>
          </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p>Run until the analog solver hands simulation control to the digital solver. This point is considered a synchronization point.</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>
            <a href="#AppendixB:Tcl-BasedDebugging-1040726">-sync</a>
          </code></p>
</td>
</tr>
</tbody></table></div>

<p>See also<a href="Simulating.html#Simulating-1041755"> &quot;Starting or Resuming a Simulation&quot;</a>.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.10">Syntax</h3>

<p><code> run<br />&#160;&#160;&#160;&#160;-clean<br />&#160;&#160;&#160;&#160;-delta [cycle_spec]<br />&#160;&#160;&#160;&#160;-next<br />&#160;&#160;&#160;&#160;-phase<br />&#160;&#160;&#160;&#160;-process<br />&#160;&#160;&#160;&#160;-return<br />&#160;&#160;&#160;&#160;-step<br />&#160;&#160;&#160;&#160;[-timepoint] [time_spec] [-absolute | -relative]<br />&#160;&#160;&#160;&#160;-sync </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.9">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="144">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="151">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="351">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-clean </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040648"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-clean"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs the simulation to the next point at which it is possible to create a checkpoint snapshot with the <code>
            <a href="#AppendixB:Tcl-BasedDebugging-1034316">save</a> -simulation</code> command.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-delta </code> <span>[</span> <code>cycle_spec</code> <span>]</span></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040660"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-delta"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs the simulation for the specified number of delta cycles. If <code>cycle_spec </code>is omitted, runs the simulation to the beginning of the next delta cycle.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-next</code> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-next"></span></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040668"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs one line of source code, stepping over any subprogram calls.</p>

<p>If the current execution point is a VHDL non-zero <code>wait</code> statement, <code>run -next</code> might behave the same as <code>run -step</code>. For example, if the current execution point is a <code>wait</code> statement, which suspends the current process, another process might be scheduled to run at the current simulation time. In this situation, <code>run -next</code> runs the next behavioral statement, and the simulation stops in the scheduled process. If you want to run to the next executable line in the source code after the <code>wait</code>, set a line breakpoint on the line and enter a <code>run </code>command.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-phase"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040676"></span> <code>-phase </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs to the beginning of the next phase of the digital simulation cycle. The two phases of a simulation cycle are signal evaluation and process execution.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-process"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040684"></span> <code>-process </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs until the beginning of the next scheduled digital process or to the beginning of the next delta cycle, whichever comes first.</p>

<p>In VHDL, a process is a<code> process </code>statement. In Verilog-AMS it is an<code> always </code>block, an<code> initial </code>block, or some other behavior that can be scheduled to run.</p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>For the purposes of<code> run -process</code>, the<code> analog </code>block is not considered a process.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-return"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040694"></span> <code>-return </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs until the current subprogram (task, function, procedure) returns.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-timepoint"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040702"></span> <span>[</span> <code>-timepoint</code> <span>] [</span> <code>time_spec</code> <span>] [</span> <code>-absolute</code> <span>|</span> <code>-relative</code> <span>]</span></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs until the specified time is reached. The time specification can be absolute or relative. Relative is the default.</p>

<p>In addition to time units such as fs, ps, ns, us, and so on, you can use<code> deltas </code>as the unit. For example,</p>

<p><code>xcelium&gt; run 10 deltas </code></p>

<p>This is the same as<code> run -delta 10.</code></p>

<p>If you include a time specification, the simulator stops at the specified time with the digital solver active.</p>

<p>If you include a time specification and a breakpoint or interrupt stops simulation before the specified time is reached, the time specification is thrown away. For example, in the following sequence of commands, the last<code> run </code>command does not stop the simulation at 500&#160;ns.</p>

<p><code>xcelium&gt; stop -object xCreated stop 1xcelium&gt; run 500 nsStop 1 {x = 0} at 10 nsxcelium&gt; run </code></p>

<p><code>run -timepoint</code> without <code>time_spec </code>runs the simulation until the next scheduled analog or digital event.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-step"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040717"></span> <code>-step </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs one behavioral statement, stepping into subprogram calls.</p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>The <code>-step</code> option does not step into function calls made by an<code> analog </code>statement. In this situation, the behavior of the <code>-step</code> option is identical to the behavior of the <code>-next</code> option.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-runOption-sync"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1040726"></span> <code>-sync </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Runs until the analog solver next hands control to the digital solver.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.6">Examples</h3>

<p>The following command runs the simulation until an interrupt occurs or until simulation completes.</p>

<p><code> xcelium&gt; run </code></p>

<p>The following command advances the simulation to 500 ns absolute time. The <code>-timepoint</code>&#160;option is not required.</p>

<p><code> xcelium&gt; run -timepoint 500 ns -absolute </code></p>

<p>The following command advances the simulation 500 ns relative time. With a time specification, <code>-relative</code>&#160;is the default.</p>

<p><code> xcelium&gt; run 500 ns </code></p>

<p>The following command runs one behavioral statement, stepping into any subprogram calls.</p>

<p><code> xcelium&gt; run -step </code></p>

<p>The following command runs one behavioral statement, stepping over any subprogram calls.</p>

<p><code> xcelium&gt; run -next </code></p>

<p>The following command runs until the current subprogram returns. The subprogram can be a task, function, or procedure.</p>

<p><code> xcelium&gt; run -return </code></p>

<p>The following two commands are equivalent. They both run the simulation for 5 delta cycles.</p>

<p><code> xcelium&gt; run -delta 5</code> <br /> <code>xcelium&gt; run 5 deltas</code></p>

<p>The following command runs the simulation until the digital solver next becomes active.</p>

<p><code> xcelium&gt; run -sync</code> <br /> <code>Ran until 2 NS + 0</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-save1034316Tcl_save">save<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1034316"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_save"></span></h2>

<p>Creates a snapshot of the current simulation state. You can then use the <a href="#AppendixB:Tcl-BasedDebugging-1034026"> <code>restart</code> </a> command to load the saved snapshot and resume simulation. (For information about using the save and restart feature in SimVision, see the &quot;Saving, Restarting, Resetting, and Reinvoking a Simulation&quot; section, in chapter 3 of<span style="color: rgb(0,0,0);"> <em> SimVision User Guide</em>.</span>)</p>
<div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p><span>If you are using the UltraSim solver, you can use the<code> save </code>command but not the</span> <span>&#160;</span> <code>
        <a href="#AppendixB:Tcl-BasedDebugging-1034026">restart</a>
      </code> <span> <a href="#1034026" rel="nofollow">command</a>.</span></p>
</div>
</div>

<p>You must specify a snapshot name with the<code> save </code>command. The snapshot name can be specified using <code>[lib.]</code>cell<code>[:view]</code> notation, or, if you want the snapshot to be a new view of the currently loaded cell, you can specify just the view name preceded by a colon. For example, if you are simulating<code> worklib.top:rtl</code>,</p>
<div class="table-wrap"><table border="0" cellpadding="4" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><tbody><tr><td class="confluenceTd" valign="top" width="240">
<p><code>save ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top" width="408">
<p>saves <code>worklib.ckpt1:rtl </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>save top:ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>saves <code>worklib.top:ckpt1 </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>save otherlib.top </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>saves <code>otherlib.top:rtl </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>save :ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>saves <code>worklib.top:ckpt1 </code></p>
</td>
</tr>
</tbody></table></div>

<p>The snapshot name must be a simple name containing only letters, numbers, and underscores.</p>

<p>You may only issue the <code>save</code>&#160;command when the simulator is at certain points in its execution cycle.</p>
<ul><li>The simulator cannot be in the middle of executing procedural statements. To run the simulation to the next point at which the <code>save</code>&#160;command will work, use the <code>run</code> <code>-clean</code>&#160;command.</li></ul><ul><li>For mixed-signal designs, the simulator must have accepted at least one transient time step.</li></ul><div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>If your files are very large, you might encounter a limit on the size of a file. If a library database exceeds this limit, you cannot add objects to the database. If you save many snapshot checkpoints to unique views in a single library, this file size limit could be exceeded. If you reach this limit, you can</p>
<ul><li>Use <code>save -overwrite</code> to overwrite an existing snapshot. For example,<br /> <code>xcelium&gt; save -simulation -overwrite snap1</code></li></ul><ul><li>Save snapshots to a separate library. For example,<br /> <code>mkdir xcelium.d/snaplib<br />xmsim -f xmsim.args<br />xcelium&gt; run 1000 ns<br />xcelium&gt; save -simulation snaplib.snap1<br />xcelium&gt; run 1000 ns<br />xcelium&gt; save -simulation snaplib.snap2</code></li></ul><ul><li>Remove snapshots using the<span style="color: rgb(0,0,0);">&#160;<code>xmrm</code>&#160;</span>utility. For example,<br /> <code>&#160;xmrm -snapshot worklib.snap1</code></li></ul></div>
</div>

<p>The state of the Tcl debug environment is not part of the simulation that is saved in a snapshot. To save the debug environment, you must issue a separate<code> save -environment </code>command. This command creates a Tcl script that captures the current breakpoints, databases, probes, aliases, and predefined Tcl variable values. You can then restore the environment by executing this script with the Tcl<code> source </code>command, or you can use the <code>-input</code>&#160;option when you start the simulator.</p>

<p>For example:</p>

<p><code> xcelium&gt; save :ckpt1</code> <br /> <code>xcelium&gt; save -environment ckpt1.tcl</code> <br /> <code>xcelium&gt; restart :ckpt1</code> <br /> <code>xcelium&gt; source ckpt1.tcl</code></p>

<p>or</p>

<p><code> xcelium&gt; -tcl cell:ckpt1 -input ckpt1.tcl) </code></p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>These scripts are meant to be sourced into an empty environment (that is, an environment with no breakpoints, no probes, no databases). If you start the simulator, set some breakpoints and probes, and then source a script that contains commands to set breakpoints and probes, the simulator will probably generate errors telling you that some commands in the script could not be executed. These errors are due to name conflicts. For example, you may have set a breakpoint that received the default name &quot;1&quot;, and the command in the script is trying to create a breakpoint with the same name. You can, of course, give your breakpoints unique names to avoid this problem. You can also edit the scripts to make them work the way you would like them to work.</p>
</div>
</div>

<p>See &quot;Saving, Restarting, Resetting, and Reinvoking a Simulation&quot; in the&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../Simulating/SimulatingTOC.html">&quot;Simulating Your Design With xmsim&quot;</a>&#160;</span>chapter of the<em> Simulating Your Design</em>&#160;book.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.11">Syntax</h3>

<p><code> save [-simulation] snapshot_name [-overwrite]</code> <br /> <code>
    <span style="color: rgb(0,0,0);">save -environment [</span>
    <code style="color: rgb(0,0,0);">filename</code>
    <span style="color: rgb(0,0,0);">]<br /> </span>
    <span style="color: rgb(0,0,0);">save -commands [</span>
    <code style="color: rgb(0,0,0);">filename</code>
    <span style="color: rgb(0,0,0);">]</span>
  </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-saveCommandModifiersandOptions">save Command Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><tbody><tr><th class="confluenceTh" valign="middle" width="146">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="155">
<p>Options andArguments</p>
</th><th class="confluenceTh" valign="middle" width="346">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-commands </code>[<code>filename</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p><code>save -commands</code> is the same as<code> save -environment.</code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-environment </code>[<code>filename</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Create a Tcl script that captures the current breakpoints, databases, probes, aliases, and predefined Tcl variable values. The <code>filename</code> argument is optional. If no file name is specified, the script is written to standard output.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>-simulation</code>]<code> snapshot_name </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Create a snapshot of the current simulation state. The snapshot also contains the analog control options in effect at the time of the save. This option is the default.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-overwrite </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Overwrites an existing snapshot.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.7">Examples</h3>
<ul><li><a href="#AppendixB:Tcl-BasedDebugging-1047172"> How to Save a Snapshot of the Current Simulation State </a></li></ul><ul><li><a href="#AppendixB:Tcl-BasedDebugging-1047092"> How to Use the save -environment Command </a></li></ul><ul><li><a href="#AppendixB:Tcl-BasedDebugging-1047142"> How to Use save, restart, and analog </a></li></ul><h4 id="AppendixB:Tcl-BasedDebugging-1047172HowtoSaveaSnapshotoftheCurrentSimulationState"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1047172"></span>How to Save a Snapshot of the Current Simulation State</h4>

<p>The following command saves the simulation state in <code>lib</code> <code>.</code> <code>cell</code> <code>:ckpt1</code>, where <code>lib</code>&#160;is the name of the current work library, and <code>cell</code>&#160;is the cell name of the currently loaded snapshot.</p>

<p><code> xcelium&gt; save -simulation :ckpt1 </code></p>

<p>The following command saves the simulation state in <code>lib </code> <code> .top:ckpt1.</code></p>

<p><code> xcelium&gt; save top:ckpt1 </code></p>

<p>The following command saves the simulation state in <code>lib</code> <code>.ckpt1:</code> <code>view_name</code>, where <code> view_name</code>&#160;is the view name that is currently being simulated.</p>

<p><code>
    <span style="color: rgb(0,0,0);"> xcelium&gt; save ckpt1 </span>
  </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-1047092HowtoUsethesave-environmentCommand"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1047092"></span>How to Use the save -environment Command</h4>

<p>The following example illustrates how to use the <code>save -environment</code>&#160;command.The right column annotates the behavior of each command.</p>
<div class="table-wrap"><table border="0" cellpadding="4" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="top" width="440">
<p>Commands&#160;</p>
</th><th class="confluenceTh" valign="top" width="207">
<p>Notes&#160;</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium -tcl hardrive<br />xmsim: v2.1.(p1): (c) Copyright 1995 - 2003 Cadence Design Systems </code></p>

<p><code>Loading snapshot worklib.hardrive:module .... Done </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Start the simulator.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; stop -create -line 32<br />Created stop 1<br />xcelium&gt; stop -create -object hardrive.clkCreated stop 2<br />xcelium&gt; probe -create -shm hardrive.data<br />Created default SHM database xcelium.shm<br />Created probe 1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Set a line breakpoint, an object breakpoint, and create a probe. The probe command creates a default<a href="Glossary.html#Glossary-1034342"> SHM </a>database.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br />0 FS + 0 (stop 2: hardrive.clk = 0)./hardrive.v:13    clk = 0; </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br />50 NS + 0 (stop 2: hardrive.clk = 1)./hardrive.v:16 always #50 clk = ~clk; </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; save -environment env1.env </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Save the debug settings in a file called <code>env1.env.</code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; more env1.env </code></p>

<p><code>set assert_report_level {note}<br />set assert_stop_level {error}<br />set autoscope {yes}<br />set display_unit {auto}<br />set tcl_prompt1 {puts -nonewline &quot;xmsim&gt; &quot;}<br />set tcl_prompt2 {puts -nonewline &quot;&gt; &quot;}<br />set time_unit {module}set vlog_format {%h}<br />set assert_1164_warnings {yes}<br />stop -create -name 1 -line 32 hardrive<br />stop -create -name 2 -object hardrive.clk<br />database -open -shm -into xcelium.shm xcelium.shm<br />-defaultprobe -create -name 1 -database xcelium.shm<br />hardrive.datascope -set hardrive </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Look at the file contents.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; exit </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Exit from the simulator.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>foghorn% xmsim -tcl hardrivexcelium: v1.2.(b9): (c) Copyright 1995 - 2000 Cadence Design Systems </code></p>

<p><code>Loading snapshot worklib.hardrive:module .................... Done </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Restart the simulator.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; stop -showNo stops set </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>The new session has no breakpoints.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; source env1.env </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Source the <code>env1.env</code> file.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; stop -show1 Enabled Line: ./hardrive.v:32 (scope: hardrive)2 Enabled Object hardrive.clkxcelium&gt; probe -show1 Enabled hardrive.data (database: xcelium.shm) -shmxcelium&gt; database -showxcelium.shm Enabled (file: xcelium.shm) (SHM) (default) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Show the status of breakpoints, probes, and databases.</p>
</td>
</tr>
</tbody></table></div>
<h4 id="AppendixB:Tcl-BasedDebugging-saverestartanalog1047142HowtoUsesave,restart,andanalog"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-saverestartanalog"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1047142"></span>How to Use save, restart, and analog</h4>

<p>You can use the <code>
    <a href="#AppendixB:Tcl-BasedDebugging-1034316">save</a>
  </code>, <a href="#AppendixB:Tcl-BasedDebugging-1034026"> <code>restart</code> </a>, and <code>
    <a href="#AppendixB:Tcl-BasedDebugging-1040981">analog</a>
  </code> commands during transient analysis of a mixed-signal simulation in interactive mode (under&#160;<code>-tcl</code>&#160;or <code>-gui</code>). In non-interactive mode or if there is other analysis after the transient analysis specified analog control file, these commands are ignored when the simulation has reached the analog stop time of the transient analysis.</p>

<p>The <code>analog -stop</code>&#160;option is ignored with a warning message when <code>.probe</code>&#160;is used in the analog control file.</p>

<p>The following example illustrates how to use the save, restart and analog commands in interactive mode. The right column annotates the behavior of each command.</p>
<div class="table-wrap"><table border="0" cellpadding="4" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="top" width="440">
<p>Commands&#160;</p>
</th><th class="confluenceTh" valign="top" width="207">
<p>Notes&#160;</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; database -open waves -into waves.shm -default<br />Created default SHM database waves </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Open a default SHM database called<code> waves.</code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; probe -create -all<br />Created probe 1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Probe all signals in the current scope.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; stop -create -time -absolute 200ns<br />Created stop 1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Create a breakpoint at absolute time 200ns.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br />200 NS + 0 (stop 1) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run until 200ns.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -show<br />vabstol = 1.000000e-06 (alterable)<br />iabstol = 1.000000e-12 (alterable)<br />reltol = 1.000000e-03 (alterable)<br />stop = 14 us (alterable) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Examine the tolerance values and stop time.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; save :ckpt1<br />Saved snapshot amslib.top:ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Save the first snapshot</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -stop 20 us </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lengthen the simulation.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -reltol 5e-03 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Change the <code>reltol</code> value.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -show<br />vabstol = 1.000000e-06 (alterable)<br />iabstol = 1.000000e-12 (alterable)<br />reltol = 5.000000e-03 (alterable)<br />stop = 20 us (alterable) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Examine the new values.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; stop -create -time -absolute 400ns<br />Created stop 2 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Create another breakpoint.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br />400 NS + 0 (stop 2) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run until 400ns.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; save :ckpt2<br />Saved snapshot amslib.top:ckpt2 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Save the second snapshot.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; restart :ckpt1<br />Loaded snapshot amslib.top:ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Reload the first snapshot.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -show<br />vabstol = 1.000000e-06 (alterable)<br />iabstol = 1.000000e-12 (alterable)<br />reltol = 1.000000e-03 (alterable)<br />stop = 14 us (alterable) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Check that tolerance values and stop time are the same values you had originally...</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; time<br />200 NS </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>...and that you are back at 200ns in the simulation.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; restart :ckpt2<br />Loaded snapshot amslib.top:ckpt2 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Now reload the second snapshot.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -show<br />vabstol = 1.000000e-06 (alterable)<br />iabstol = 1.000000e-12 (alterable)<br />reltol = 5.000000e-03 (alterable)<br />stop = 20 us (alterable) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Check for the changed<code> reltol </code>value and the lengthened simulation.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; time<br />400 NS </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run to 400ns, again!</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br /> 200 NSRan until 600 NS + 0 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run another 200ns.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; restart :ckpt1<br />Loaded snapshot amslib.top:ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Switch back to the first snapshot.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; time<br />200 NS </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Check where you are.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run<br />The analog simulator has reached stop time, please use analog -stop &lt;new stop time&gt; to extend the analog stop time. </code></p>

<p><code>Simulation complete via transient analysis stoptime at time 14 US Memory Usage - 19.4M program + 13.5M data = 32.9M total CPU Usage - 0.6s system + 3.6s user = 4.2s total (1.1% cpu) </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run until analog stop time.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; analog -stop 100us </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>At analog stop time, you can still lengthen the simulation.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; run </code></p>

<p><code>The analog simulator has reached stop time, please use analog -stop &lt;new stop time&gt;&#39; to extend the analog stop time. </code></p>

<p><code>Simulation complete via transient analysis stoptime at time 100 US </code></p>

<p><code>Memory Usage - 19.4M program + 13.5M data = 32.9M total CPU Usage - 0.6s system + 23.6s user = 24.2s total (1.1% cpu</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Run until analog stop time.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; restart :ckpt1<br />Loaded snapshot amslib.top:ckpt1 </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>At analog stop time, you can still restart a snapshot.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>xcelium&gt; exit </code> <br /> <code>Number of accepted tran steps = 3161. </code></p>

<p><code>Initial condition solution time = 200 ms.</code> <br /> <code>**** AMSD: Mixed-Signal Activity Statistics **** </code> <br /> <code>     Number of A-to-D events:                  24</code> <br /> <code>&#160;   &#160;Number of A-to-D events in IEs: &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0</code> <br /> <code> &#160;&#160;&#160;&#160;Number of D-to-A events: &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;16</code> <br /> <code> &#160;&#160;&#160;&#160;Number of D-to-A events in IEs:           &#160;0</code> <br /> <code> &#160;&#160;&#160;&#160;Number of VHDL-AMS Breaks:                &#160;0 </code></p>

<p><code>Intrinsic tran analysis time = 3.5 s. </code></p>

<p><code>Total time required for tran analysis tran1 was 23.7 s. </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Exit and complete the simulation.</p>
</td>
</tr>
</tbody></table></div>
<h2 id="AppendixB:Tcl-BasedDebugging-scope1042823Tcl_scope">scope<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1042823"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_scope"></span></h2>

<p>Lets you</p>
<ul><li>Set the current debug scope (<code>-set</code>)</li></ul><ul><li>List the automatically-inserted connect module instances within a scope or branch of the design hierarchy (<code>-aicms</code>)</li></ul><ul><li>Describe items declared within a scope (<code>-describe</code>)</li></ul><ul><li>Display the drivers of digital objects declared within a scope (<code>-drivers</code>)</li></ul><ul><li>List the resolved disciplines of all nets within a scope or branch of the design hierarchy (<code>-disciplines) </code></li></ul><ul><li>Print the source code, or part of the source code, for a scope (<code>-list</code>)</li></ul><ul><li>Display scope information (<code>-show</code>)</li></ul><div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>In this release, you cannot set scope into an auto-inserted connect module instance in a mixed-signal design. Nor can you describe such a scope, or list its drivers or source lines.</p>
</div>
</div>

<p>See the &quot;Traversing the Model Hierarchy&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-scopeCommandSyntax">scope Command Syntax</h3>

<p><code> scope [-set] [scope_name]<br />&#160;&#160;&#160;&#160;-up<br />&#160;&#160;&#160;&#160;-aicms [scope_spec]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-recurse<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-all<br />&#160;&#160;&#160;&#160;-describe [scope_name]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-names<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-sort {name|kind|declaration}<br />&#160;&#160;&#160;&#160;-drivers [scope_name]<br />&#160;&#160;&#160;&#160;-disciplines [scope_spec]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-recurse<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-all<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-sort {name|kind|declaration}<br />&#160;&#160;&#160;&#160;-list [line|start_line end_line] [scope_name]<br />&#160;&#160;&#160;&#160;-show </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.10">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="124">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="206">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="318">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-up </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets the debug scope to one level up the hierarchy from the current scope.</p>
</td>
</tr>
<tr><td class="confluenceTd" rowspan="3" valign="top">
<p><code>-aicms </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>scope_spec</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Lists automatically-inserted connect modules (AICMs) inserted within the specified scope, or within the current debug scope if no scope is specified.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-recurse </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Descends recursively through the design hierarchy, starting with the specified scope (or the current debug scope if no scope is specified), listing all the AICM instances.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-all </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lists the AICM instances in all top-level scopes. If used with <code>-recurse</code>, the <code>-all</code> option recursively lists all AICM instances in the entire design.</p>
</td>
</tr>
<tr><td class="confluenceTd" rowspan="3" valign="top">
<p><code>-describe </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>scope_name</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Describes all objects declared within the specified scope. If no scope is specified, objects in the current debug scope are described.</p>

<p>For objects without read access, the output of <code>scope -describe</code> does not include the object&#39;s value. For objects that have read access but no write access, the string <code>(-W) </code>is included in the output. For objects with neither read nor write access, the string <code>(-RW)</code> is included in the output. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-names </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Displays only the names of each declared item in the scope.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-sort </code>{<code>name</code>|<code>kind</code>|<code> declaration</code>}</p>
</td>
<td class="confluenceTd" valign="top">
<p>Specifies the sort order. There are three possible arguments to the <code>-sort</code> option:</p>

<p><code>name</code>: sort alphabetically by name</p>

<p><code>kind</code>: sort by declaration type (reg, wire, instance, branch, etc.)</p>

<p><code>declaration</code>: sort by the order in which objects are declared in the source code</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-drivers </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>scope_name</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Shows the drivers of each digital object declared within the specified scope. If no scope is specified, the drivers of digital objects in the current debug scope are displayed.</p>

<p>The output of <code>scope -drivers</code> includes only the digital objects that have read access. However, even if an object has read access, its drivers may have been collapsed, combined, or optimized away, and the output of the command might indicate that the object has no drivers. See<a href="Elaborating.html#Elaborating-1033476"> &quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot; </a>for details on specifying access to simulation objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" rowspan="4" valign="top">
<p><code>-disciplines </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>scope_name</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Lists all resolved net disciplines within the given scope, or within the current debug scope if no scope is given.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-recurse </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Descends recursively through the design hierarchy, starting with the specified scope (or the current debug scope if no scope is specified), listing all resolved net disciplines.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-all </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Lists all resolved net disciplines in all top-level scopes. If used with <code>-recurse</code>, recursively lists all resolved net disciplines in the entire design.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-sort<br /> </code>&#160;&#160;&#160;&#160;&#160;<code> name<br />   </code>&#160;&#160;&#160;|<code>kind<br />   </code>&#160;&#160;&#160;|<code>declaration </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sort the nets alphabetically by net name, by discipline (<code>electrical</code>, <code>logic</code>, and so on) or by the order they are declared in the source code. The default is to sort by discipline.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-list </code></p>

<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>line<br />
          </code>|<code>start_line </code> <code>end_line</code>][<code>scope_name</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Prints lines of source code for the specified scope, or for the current debug scope if no scope is specified.</p>

<p>You can follow the <code>-list</code> modifier with</p>
<ul><li>No range of lines to print all lines for the scope.</li></ul><ul><li>One line number to display that line of source text.</li></ul><ul><li>Two line numbers to display the text between those two line numbers. You can use a dash (-) for either <code>start_line</code> or <code>end_line.</code></li></ul></td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-set </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>[<code>scope_name</code>]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets the current debug scope to the specified scope. If no scope or other option is given, the name of the current scope is printed.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-show </code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>Shows scope information, including the current debug scope, instances within the debug scope, and top-level modules in the currently loaded model.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.2">Example</h3>

<p>The following example prints the name of the current scope. The&#160;<code>-set</code>&#160;modifier is not required.</p>

<p><code> xcelium&gt; scope -set </code></p>

<p>The following example sets the debug scope to scope<code> u1.</code> The <code>-set</code>&#160;modifier is not required.</p>

<p><code> xcelium&gt; scope -set u1 </code></p>

<p>The following example moves the debug scope up one level in the hierarchy.</p>

<p><code> xcelium&gt; scope -up </code></p>

<p>For the next example, you have a design that contains a top level module (top) in which three connect_module instances are instantiated with a merged connect mode attribute.</p>

<p>The command</p>

<p><code> xcelium&gt; scope -aicms -all -recurse </code></p>

<p>lists all automatically-inserted connect module (AICM) instances in the design as follows.</p>

<p><code> top.connect5a__elect_to_logic__logic&#160;(merged)&#160;is:<br />&#160;&#160;&#160;&#160;instance&#160;of&#160;connect_module:&#160;&#160;&#160;&#160;&#160;elect_to_logic,<br />&#160;&#160;&#160;&#160;inserted&#160;across&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect5a,<br />&#160;&#160;&#160;&#160;and&#160;ports&#160;of&#160;discipline:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;logic.<br />top.connect0a__elect_to_logic__logic&#160;(merged)&#160;is:<br />&#160;&#160;&#160;&#160;instance&#160;of&#160;connect_module:&#160;&#160;&#160;&#160;&#160;elect_to_logic,<br />&#160;&#160;&#160;&#160;inserted&#160;across&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect0a,<br />&#160;&#160;&#160;&#160;and&#160;ports&#160;of&#160;discipline:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;logic.<br />top.connect2a__elect_to_logic__logic&#160;(merged)&#160;is:<br />&#160;&#160;&#160;&#160;instance&#160;of&#160;connect_module:&#160;&#160;&#160;&#160;&#160;elect_to_logic,<br />&#160;&#160;&#160;&#160;inserted&#160;across&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect2a,<br />&#160;&#160;&#160;&#160;and ports of discipline:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;logic. </code></p>

<p>The following example shows the output of a similar design, in which the value of the connect mode attribute is split.</p>

<p><code> xcelium&gt; scope -aicms -all -recurse </code></p>

<p><code> top.connect5a__dig5__in&#160;(split)&#160;is&#160;instance&#160;of&#160;connect_module&#160;elect_to_logic:<br />&#160;&#160;&#160;&#160;connected&#160;where&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect5a,<br />&#160;&#160;&#160;&#160;joins&#160;port:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in,<br />&#160;&#160;&#160;&#160;of&#160;instance:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dig5.<br />top.connect5a__dig6__in&#160;(split)&#160;is&#160;instance&#160;of&#160;connect_module&#160;elect_to_logic:<br />&#160;&#160;&#160;&#160;connected&#160;where&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect5a,<br />&#160;&#160;&#160;&#160;joins&#160;port:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in,<br />&#160;&#160;&#160;&#160;of&#160;instance:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dig6.<br />top.connect0a__dig0__in&#160;(split)&#160;is&#160;instance&#160;of&#160;connect_module&#160;elect_to_logic:<br />&#160;&#160;&#160;&#160;connected&#160;where&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect0a,<br />&#160;&#160;&#160;&#160;joins&#160;port:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in,<br />&#160;&#160;&#160;&#160;of&#160;instance:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dig0.<br />top.connect0a__dig1__in&#160;(split)&#160;is&#160;instance&#160;of&#160;connect_module&#160;elect_to_logic:<br />&#160;&#160;&#160;&#160;connected&#160;where&#160;signal:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.connect0a,<br />&#160;&#160;&#160;&#160;joins&#160;port:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in,<br />&#160;&#160;&#160;&#160;of&#160;instance:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dig1. </code></p>

<p>The following example illustrates how to display a list of resolved disciplines.</p>

<p><code> xcelium&gt; scope -discipline -recurse<br />net disciplines for: top.I3 (sareg) </code></p>

<p><code> result.....input (logic)<br />clkSig.....input (unknown discipline)<br />trigger....input (unknown discipline) </code></p>

<p><code> net disciplines for: top.I4 (daconv) </code></p>

<p><code> compSig....output (electrical)<br />b0.........input (logic)<br />b1.........input (logic)<br />b2.........input (logic)<br />b3.........input (logic)<br />b4.........input (logic)<br />b5.........input (logic)<br />b6.........input (logic)<br />b7.........input (logic) </code></p>

<p><code> net disciplines for: top.I0 (signalSrc) </code></p>

<p><code> gnd........analog net (electrical)<br />sig........output (electrical) </code></p>

<p><code> net disciplines for: top.I2 (comparator) </code></p>

<p><code> inn........input (electrical)<br />inp........input (electrical)<br />net55......wire (electrical)<br />net79......wire (electrical)<br />net84......wire (electrical)<br />net92......wire (electrical)<br />net94......wire (electrical)<br />out........output (electrical)<br />vref1......wire (electrical) </code></p>

<p><code> net disciplines for: top.I1 (samplehold) </code></p>

<p><code> gnd........analog net (electrical)<br />holdSig....output (electrical)<br />inSig......input (electrical)<br />trigger....input (unknown discipline) </code></p>

<p><code> net disciplines for: top.compOut__elect_to_logic__logic (elect_to_logic) </code></p>

<p><code> aVal.......input (electrical)<br />dVal.......output (logic) </code></p>

<p>The following command displays the disciplines of nets and buses, one of which is a mixed bus.</p>

<p><code> xcelium&gt; scope -discipline<br />net disciplines for: top (top)<br />e..........wire (electrical)<br />d..........wire (unknown discipline)<br />w..........wire (mixed bus) </code></p>

<p>The following command displays a list and a description of all objects declared in the current debug scope (a Verilog-AMS module).</p>

<p><code> xcelium&gt; scope -describe<br />clr..............register = 1&#39;hx<br />clk..............register = 1&#39;hx<br />data.............register [3:0] = 4&#39;hx<br />q................wire [3:0] (wire/tri) = 4&#39;hx<br />end_first_pass...named event<br />h1...............instance of module hardreg<br />inSig............analog net (electrical) = 3.45<br />vplus5_ground....branch(vplus5) = 2.22<br />sig1.............inout (electrical) = 0.12<br />R1...............instance of &#39;resistor&#39; Spice primitive<br />vout_vspply_n....branch(vout,vspply_n) = 0 </code></p>

<p>The following command displays a list and a description of all objects declared in the current debug scope (a VHDL architecture).</p>

<p><code> xcelium&gt; scope -describe<br />top..............component instantiation<br />load_nickels.....process statement<br />load_dimes.......process statement<br />load_cans........process statement<br />load_action......process statement<br />gen_clk..........process statement<br />gen_reset........process statement<br />gen_nickels......process statement<br />gen_dimes........process statement<br />gen_quarters.....process statement<br />$PROCESS_000.....process statement<br />$PROCESS_001.....process statement<br />stoppit..........signal : BOOLEAN = TRUE<br />t_NICKEL_OUT.....signal : std_logic = &#39;0&#39;<br />t_EMPTY..........signal : std_logic = &#39;1&#39;<br />t_EXACT_CHANGE...signal : std_logic = &#39;0&#39;<br />t_TWO_DIME_OUT...signal : std_logic = &#39;Z&#39;<br />... </code></p>

<p><code> ... </code></p>

<p><code> t_NICKELS........signal : std_logic_vector(7 downto 0) = &quot;11111111&quot;<br />t_RESET..........signal : std_logic = &#39;0&#39; </code></p>

<p>The following command lists the names of all objects declared in the current debug scope. No description is included.</p>

<p><code> xcelium&gt; scope -describe -names<br />clr clk data q end_first_pass h1 </code></p>

<p>The following example displays a list and a description of all objects declared in the current debug scope. Objects are listed in alphabetical order.</p>

<p><code> xcelium&gt; scope -describe -sort name </code></p>

<p>The following command displays a list and a description of all objects declared in the current debug scope. Objects are sorted by type of declaration.</p>

<p><code> xcelium&gt; scope -describe -sort kind </code></p>

<p>The following example displays a list and a description of all objects declared in scope<code> h1.</code> Objects are listed in the order in which they were declared in the source code.</p>

<p><code> xcelium&gt; scope -describe -sort declaration h1<br />clk.............input (wire/tri) = StX<br />clrb............input (wire/tri) = StX<br />d...............input [3:0] (wire/tri) = 4&#39;hx<br />compSig.........output (electrical) = 0<br />q...............output [3:0] (wire/tri) = 4&#39;hx<br />f1..............instance of module flop<br />f2..............instance of module flop<br />f3..............instance of module flop<br />f4..............instance of module flop<br />compSig_ground..branch(compSig) = 0 </code></p>

<p>The following command shows the drivers for all objects declared in scope <code>h1.</code></p>

<p><code> xcelium&gt; scope -drivers h1 </code></p>

<p><code> clk........input (wire/tri) = St1<br />&#160;&#160;&#160;&#160;St1 &lt;- (hardrive.h1) input port 2, bit 0 (./hardrive.v:8)<br />clrb.......input (wire/tri) = St1<br />&#160;&#160;&#160;&#160;St1 &lt;- (hardrive.h1) input port 3, bit 0 (./hardrive.v:8)<br />d..........input [3:0] (wire/tri) = 4&#39;h2<br />&#160;&#160;&#160;&#160;[3] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1) input port 1, bit 3 (./hardrive.v:8)<br />&#160;&#160;&#160;&#160;[2] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1) input port 1, bit 2 (./hardrive.v:8)<br />&#160;&#160;&#160;&#160;[1] = St1<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St1 &lt;- (hardrive.h1) input port 1, bit 1 (./hardrive.v:8)<br />&#160;&#160;&#160;&#160;[0] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1) input port 1, bit 0 (./hardrive.v:8)<br />q..........output [3:0] (wire/tri) = 4&#39;h1<br />&#160;&#160;&#160;&#160;[3] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f4) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;[2] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f3) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;[1] = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f2) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;[0] = St1<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St1 &lt;- (hardrive.h1.f1) nd7 (q, e, qb) </code></p>

<p>In the following example, the design was elaborated using the default access level (no read or write access to simulation objects). Notice the difference in output between this example and the previous example, where the design was elaborated with full access (<code>xmelab -access +r+w</code>). In this example, only the drivers for wires and registers with read access are shown.</p>

<p><code> xcelium&gt; scope -drivers h1<br />q..........output [3:0]<br />&#160;&#160;&#160;&#160;q[3] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f4) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;q[2] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f3) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;q[1] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St0 &lt;- (hardrive.h1.f2) nd7 (q, e, qb)<br />&#160;&#160;&#160;&#160;q[0] (wire/tri) = St1<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;St1 &lt;- (hardrive.h1.f1) nd7 (q, e, qb) </code></p>

<p>The following example lists the drivers for a mixed bus.</p>

<p><code> xcelium&gt; scope -drivers<br />d..........wire (wire/tri) = StX<br />No drivers<br />e..........wire (electrical) = Inf<br />No drivers<br />w..........wire [0:2]<br /> w[1] (wire/tri) = StX<br />No drivers<br />w..........wire [0:2]<br /> w[2] (wire/tri) = StX<br />No drivers </code></p>

<p>The following example lists the source for the current debug scope.</p>

<p><code> xcelium&gt; scope -list </code></p>

<p>The following example lists the source for scope <code>u1.</code></p>

<p><code> xcelium&gt; scope -list u1 </code></p>

<p>The following example displays line 12 of the source for the current debug scope.</p>

<p><code> xcelium&gt; scope -list 12 </code></p>

<p>The following example lists lines 10 through 15 of the source for the current debug scope.</p>

<p><code> xcelium&gt; scope -list 10 15 </code></p>

<p>The following command lists lines from the top of the module through line 10 of the source for the current debug scope.</p>

<p><code> xcelium&gt; scope -list - 10 </code></p>

<p>The following command lists lines of source for the current debug scope, beginning with line 30.</p>

<p><code> xcelium&gt; scope -list 30 - </code></p>

<p>The following command shows the output of the<code> scope -describe </code>command when you run in regression mode and some objects do not have read or write access.</p>

<p><code> xcelium&gt; scope -describe h1<br />clk........input  (-RW)<br />clrb.......input  (-RW)<br />d..........input [3:0]<br />&#160;&#160;&#160;&#160;d[3]  (-RW)<br />&#160;&#160;&#160;&#160;d[2]  (-RW)<br />&#160;&#160;&#160;&#160;d[1]  (-RW)<br />&#160;&#160;&#160;&#160;d[0]  (-RW)<br />q..........output [3:0]<br />&#160;&#160;&#160;&#160;q[3] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;q[2] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;q[1] (wire/tri) = St0<br />&#160;&#160;&#160;&#160;q[0] (wire/tri) = St1<br />f1.........instance of module flop<br />f2.........instance of module flop<br />f3.........instance of module flop<br />f4.........instance of module flop </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-statusTcl_status1034597">status<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_status"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1034597"></span></h2>

<p>Displays memory and CPU usage statistics and shows the current simulation time. When the analog solver is active, the delta cycle count is not displayed.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.12">Syntax</h3>

<p><code> status </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.11">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.3">Example</h3>

<p>The following example shows the type of statistics displayed by the <code>status</code>&#160;command.</p>

<p><code> xcelium&gt; status<br />Memory Usage - 8.7M program + 10.8M data = 19.5M total<br />CPU Usage - 0.1s system + 0.3s user = 0.5s total (0.4% cpu)<br />Simulation Time - 856 NS + 0 </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-stopTcl_stop1034611">stop<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_stop"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1034611"></span></h2>

<p>Creates or operates on a breakpoint. You can</p>
<ul><li>Create various kinds of breakpoints (using the <code>-create</code>&#160;modifier followed by an option that specifies the breakpoint type)</li></ul><ul><li>Display information on breakpoints (<code>-show</code>)</li></ul><ul><li>Disable a breakpoint (<code>-disable</code>)</li></ul><ul><li>Enable a previously disabled breakpoint (<code>-enable</code>)</li></ul><ul><li>Delete a breakpoint (<code>-delete</code>)</li></ul>
<p>See the &quot;Setting Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information:</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.13">Syntax</h3>
<p style="margin-left: 60.0px;"><code>stop</code></p>
<p style="margin-left: 90.0px;"><code> -create</code> <br /> <code>&#160; &#160; &#160; &#160;-assert [{-all | -depth {levels | all | to_cells}}] [scope_name]</code> <br /> <code>&#160; &#160; &#160; &#160;-condition {tcl_expression}<br />
  </code> <code>&#160; &#160; &#160; &#160;-delta delta_cycle_number [-relative|-absolute]</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[-start delta_cycle_number]&#160;</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[-modulo delta_cycle_number]<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; [-timestep]<span>&#160;&#160;</span>
    <br />
  </code></p>
<p style="margin-left: 90.0px;"><code>-iso_rule rule_name [rule_name ...] [-iso_enable | -iso_disable]</code></p>
<p style="margin-left: 90.0px;"><code>-label &quot;stop_message&quot;</code> <br /> <code>-line line_number</code> <br /> <code>&#160; &#160; &#160; &#160; {-unit unit_name | [ scope_name ] [-all]}</code> <br /> <code>&#160; &#160; &#160; &#160; [-file filename]</code> <br /> <code>-object object_names</code> <br /> <code>-pdname power_domain_name [power_domain_name ...]</code> <br /> <code>[-isolation [-iso_disable | -iso_enable]]</code> <br /> <code>[-pd_off]</code> <br /> <code>[-pd_on]</code> <br /> <code>[-pd_standby]</code> <br /> <code>[-pd_trans]</code> <br /> <code>[-retention [-sr_restore | -sr_save]]</code></p>
<p style="margin-left: 60.0px;"><code>&#160; &#160; -process process_name</code></p>
<p style="margin-left: 90.0px;"><code>-pwr_mode_transition mode_transition_name [mode_transition_name ...]</code> <br /> <code>-randomize [-always] [object_name ]</code> <br /> <code>-sr_rule rule_name [rule_name ...] [-sr_save | -sr_restore]</code> <br /> <code>-subprogram subprogram_name</code></p>
<p style="margin-left: 90.0px;"><code>-time time_spec [-relative | -absolute]</code> <br /> <code>&#160; &#160; [-start time_spec]</code> <br /> <code>&#160; &#160; [-modulo time_spec]</code></p>
<p style="margin-left: 60.0px;"><code>&#160; &#160; [-continue]</code> <br /> <code>&#160; &#160; [-delbreak count]</code> <br /> <code>&#160; &#160; [-execute command]</code> <br /> <code>&#160; &#160; [-if { tcl_expression}]&#160;</code> <br /> <code>&#160; &#160; [-name break_name]</code> <br /> <code>&#160; &#160; [-silent]</code> <br /> <code>&#160; &#160; [-skip count]</code></p>
<p style="margin-left: 30.0px;"><code>&#160; &#160; -delete { break_name | pattern} ...</code> <br /> <code>&#160; &#160; -disable { break_name | pattern} ...</code> <br /> <code>&#160; &#160; -enable { break_name | pattern} ...</code> <br /> <code>&#160; &#160; -show [{ break_name | pattern} ...]</code></p>

<p>The argument to <code>-delete</code>,<code> -disable</code>,<code> -enable</code>, or <code>-show</code>&#160;can be</p>
<ul><li>A break name</li></ul><ul><li>A list of break names</li></ul><ul><li>A pattern</li></ul><ul><ul><li>The asterisk (*) matches any number of characters</li></ul></ul><ul><ul><li>The question mark (?) matches any one character</li></ul></ul><ul><ul><li>[<span style="color: rgb(0,0,0);"> characters </span>] matches any one of the characters</li></ul></ul><ul><li>Any combination of literal break names and patterns</li></ul><h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.12">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped relative-table confluenceTable" style="width: 97.6339%;"><colgroup> <col style="width: 19.4014%;" /> <col style="width: 25.3457%;" /> <col style="width: 53.0671%;" /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="96">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="225">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="327">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><code>-create</code></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>Creates a breakpoint. This modifier must be followed by an option that specifies the breakpoint type:</p>

<p><code> -condition </code></p>

<p><code> -delta </code>(VHDL only)</p>

<p><code> -line </code></p>

<p><code> -object </code></p>

<p><code> -process </code>(VHDL only)</p>

<p><code> -time </code></p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>-assert [{-all | -depth {levels | all | to_cells}}] [scope_name]</code></td>
<td class="confluenceTd" colspan="1">
<p>The <code>-assert</code> option lets you define a single breakpoint that is shared by multiple assertions in the design. Stop at failures for all assertions in the design hierarchy by using the -all option.<br /> <code>xcelium&gt; stop -assert -all</code> <br />Stop at failures for all assertions in a specified scope (or the current debug scope if no scope is specified).<br /> <code>xcelium&gt; stop -assert</code> <br /> <code>xcelium&gt; stop -assert top</code> <br /> <code>xcelium&gt; stop -assert top.u1</code></p>

<p>Specify how many scope levels to descend when searching for assertions to stop by using<br />the <code>-depth</code> option. The argument to <code>-depth</code> can be:</p>
<ul><li><code>Levels</code> - Descend the specified number of scopes. For example, <code>-depth 1</code> means include only the given scope, <code>-depth 2</code> means include the given scope and its sub-scopes, and so on. The default is 1.</li><li><code>all</code> - Include all scopes in the hierarchy below the given scope.</li><li><code>to_cells</code> - Include all scopes in the hierarchy below the specified scope(s), but stop at cells (Verilog modules with `celldefine or VITAL entities with VITAL Level0 attribute).</li></ul>
<p>By using the <code>-assert</code> option, you can avoid having to define a whole set of breakpoints on the<br />assertions using separate <code>stop -object</code> commands. The <code>-assert</code> option can also be used with other <code>stop</code> command options, such as <code>-execute</code> and <code>-continue</code>.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-condition </code>{<code>tcl_expression</code>}</p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers when any digital object referenced in <code> tcl_expression</code> changes value (wires, signals, registers, and variables) or is written to (memories) and the expression evaluates to true (non-zero, non-x, non-z). <code>tcl_expression</code> must contain at least one digital object.</p>

<p><span>For RNM nets, you can set condition for </span> <code>`wrealXState</code> <span> and </span> <code>`wrealZStates</code> <span> to trigger a breakpoint when the specified state is true.</span></p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>Although condition breakpoints are not triggered by changes in analog objects, you can include analog objects in the conditional expression, and their values are used when the condition is evaluated (due to a digital object changing value).</p>

<p>The simulator does not support stop points on individual bits of registers. If a bit-select of a register appears in the expression, the simulator stops and evaluates the expression when any bit of that register changes value. The same holds true for compressed wires.</p>

<p>See <a href="#AppendixB:Tcl-BasedDebugging-1035041">&quot;Tcl Expressions as Arguments&quot;</a> for details on the format of conditional expressions.</p>

<p>Objects included in a <code>-condition</code> expression must have read access. An error is printed if the object does not have read access. See <a href="Elaborating.html#Elaborating-1033476">&quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot;</a> for details.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-continue"></span> <code>-continue </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Resumes the simulation after executing the breakpoint. The simulator does not go into interactive mode.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-delbreak </code> <code> count </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Deletes the breakpoint after it has triggered <code>count</code> number of times.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-delta  delta_cycle_num </code></p>

<p><code>[-absolute] </code></p>

<p><code>[-relative]</code></p>

<p><code>[-start  delta_cycle_num]</code></p>

<p><code>[-modulo delta_cycle_num]</code></p>

<p><code>[-timestep]</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers when the simulation delta cycle count reaches the specified delta cycle.</p>

<p>The delta cycle specification can be absolute or relative (the default). If absolute, the breakpoint is automatically deleted after the delta cycle is reached and the breakpoint triggers. If relative, the delta cycle specification is an interval, and the breakpoint stops the simulation every<code> n </code>delta cycles.</p>

<p>Use <code>-start</code> to specify the absolute delta cycle at which a repetitive breakpoint is to begin firing. If this cycle is before the current cycle, the first stop occurs at the next cycle at which it would have occurred had the stop been set at the cycle specified with <code>-start.</code></p>

<p>The <code>-modulo</code> option is similar to <code>-start</code>. Use <code>-modulo</code> to specify the absolute delta cycle of the first stop cycle for a repeating delta cycle stop. This differs from <code>-start</code> only when the given cycle is more than one repeat interval in the future. In this case, the first stop occurs at a delta cycle less than or equal to one interval in the future such that a stop eventually occurs at the given cycle. For example, if you set a delta breakpoint to stop the simulation every 10 delta cycles, and specify <code>-modulo 15</code>, the simulation stops at delta cycle 5, 15, 25, and so on.</p>

<p><code>save -environment</code> writes this option to the script to restore your delta breakpoint pattern.</p>

<p>The <code>-timestep</code> option provides a way to detect infinite loops (due to infinite delta cycles) in the<br />design. This option halts the simulation if the specified number of delta cycles is created at any given simulation time. The simulation halts after the first timestep delta cycle is reached, and the simulation cannot be advanced.</p>

<p>See the &quot;Setting a Delta Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
          <span>-iso_rule</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>Stop when the specified isolation rule becomes enabled or disabled.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
<span>rule_name [rule_name ...] [-iso_enable | -iso_disable]</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You can specify multiple isolation rule names.<br />The <code>-iso_rule</code> option has two sub-options:</p>
<ul><li><code>-iso_disable</code>&#8211;Stop only when the isolation rule becomes disabled.</li><li><code>-iso_enable</code>&#8211;Stop only when the isolation rule becomes enabled.</li></ul></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p><code>
            <span>-label</span> &quot;stop_message&quot;</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Specify a label for the breakpoint message. The breakpoint will issue the stop_message.</p>

<p>For example:<br /> <code>xcelium&gt; stop -line 19 -file <span style="letter-spacing: 0.0px;">testbench.sv</span> -label &quot;setup phase&quot;</code></p>

<p><code>Created stop 1</code></p>

<p><code>xcelium&gt; run 0 FS + 0 setup phase</code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-execute"></span> <code>-execute </code> <code> command </code></p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Executes the specified Tcl command when the breakpoint is triggered.</p>

<p>If the command that you want to execute requires an argument, enclose the command and its argument in curly braces.</p>

<p>You also can specify that you want to execute a list of commands. Separate the commands with a semicolon. Tcl, however, displays only the output of the last command.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-if"></span> <code>-if</code>{<code>tcl_expression</code>}</p>
</div>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a condition on the breakpoint. The breakpoint triggers only if the given Tcl Boolean expression evaluates to true (non-zero, non-x, non-z). This option can be used with any breakpoint type. See <a href="#AppendixB:Tcl-BasedDebugging-1035041">&quot;Tcl Expressions as Arguments&quot;</a> for more information on the format of <code> tcl_expression.</code></p>

<p>For RNM nets, you can set condition for <code>`wrealXState</code> and <code>`wrealZStates</code> to trigger breakpoint when the specified state is true.</p>

<p>Objects included in an <code>-if</code> expression must have read access. An error is printed if the object does not have read access. See <a href="Elaborating.html#Elaborating-1033476">&quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot;</a> for details on specifying access to simulation objects.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-line line_number </code></p>

<p><code>{-unit unit_name| </code> <br /> <code>[scope_name] [-all] }</code></p>

<p><code>[-file <em>filename</em>]</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers when the specified line number is about to execute. You can set breakpoints on both analog and digital code statements. You cannot set a line breakpoint when you are using the simulation front end (SFE) parser. In addition, because structural code is not sequential, you cannot set line breakpoints in such code.</p>

<p>You must specify which design unit contains the line. There are two ways to do this:</p>

<p>Use <code>-unit.</code> The stop occurs whenever the line number in the specified design unit is about to execute, no matter where in the design hierarchy that unit appears.</p>

<p>Specify the name of a particular scope in the design hierarchy. This creates an instance-specific breakpoint. The breakpoint occurs only for that particular instance of the corresponding design unit, no matter where else it may appear in the design hierarchy. To create a breakpoint that is not instance-specific using the <code>scope_name</code> method, use the <code>-all</code> option. If the scope name is omitted, then the current debug scope is used.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p>The <code>-file</code> option specifies which of the source files that make up the specified design unit contains the specified line. This is necessary if the design unit has multiple source files.</p>

<p>You must compile with the <code>-linedebug</code> option to enable the setting of line breakpoints.</p>

<p>See the &quot;Setting a Source Code Line Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-name </code> <code>break_name </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Specifies a name for the breakpoint. This name can then be used to delete, disable, or enable the breakpoint. If you do not use <code>-name</code>, breakpoints are numbered sequentially.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-object </code> <code>object_name </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers when the specified object changes value (wires, signals, registers, and variables) or is written to (memories).</p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>You cannot create object breakpoints for analog objects.</p>

<p>The object specified as the argument must have read access for the breakpoint to be created. An error is printed if the object does not have read access. See <a href="Elaborating.html#Elaborating-1033476">&quot;Enabling Read, Write, or Connectivity Access to Digital Simulation Objects&quot;</a> for details on specifying access to simulation objects.</p>

<p>See the &quot;Setting an Object Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-pdname</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1">
<p><br /></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Set a breakpoint that triggers when the specified power domain changes status. If no options are<br />specified, simulation stops when the power domain is powered down or powered up. You can specify multiple power domain names.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>power_domain_name [power_domain_name ...]</code> <br /> <code>[-isolation [-iso_disable | -iso_enable]]</code> <br /> <code>[-pd_off]</code> <br /> <code>[-pd_on]</code> <br /> <code>[-pd_standby]</code> <br /> <code>[-pd_trans]</code> <br /> <code>[-retention [-sr_restore | -sr_save]]</code></td>
<td class="confluenceTd" colspan="1">
<p>The -pdname option has several sub-options that let you create power domain breakpoints that</p>

<p>trigger under specific conditions:</p>
<ul><li><code>-pd_off</code>&#8211;Stop when the power domain turns off.</li><li><code>-pd_on</code>&#8211;Stop when the power domain turns on.</li></ul>
<p>This option stops the simulation when the specified power domain has transitioned to the ON state or to the UNINITIALIZED state. The state of the power domain is UNINITIALIZED when the simulation is being controlled by active state conditions, and when the power domain is on but there are no active state conditions enabled to specify the nominal condition to which the domain should transition.</p>
<ul><li><code>-pd_standby</code>&#8211;Stop when the power domain enters standby mode.</li><li><code>-pd_trans</code>&#8211;Stop when the power domain transitions. The breakpoint triggers when the specified power domain starts transitioning from one nominal condition to a different nominal condition.</li><li><code>-isolation</code>&#8211;Stop when any isolation rule associated with the power domain is enabled or disabled.</li><li><code>-iso_disable</code>&#8211;Stop when any isolation rule associated with the power domain is disabled.</li><li><code>-iso_enable</code>&#8211;Stop when any isolation rule associated with the power domain is enabled.</li><li><code>-retention</code>&#8211;Stop when any state retention rule associated with the power domain saves or restores its variables.</li><li><code>-sr_restore</code>&#8211;Stop when any state retention rule associated with the power domain restores its variables.</li><li><code>-sr_save</code>&#8211;Stop when any state retention rule associated with the power domain saves its variables.</li></ul></td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-process </code> <code>process_name </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers when the specified VHDL named process starts executing or when it resumes executing after a wait statement.</p>

<p>You must compile with <code>-linedebug</code> to enable the setting of process breakpoints.</p>

<p>See the &quot;Setting a Process Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-silent </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Suppresses the display of the message that is printed when a breakpoint triggers.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-skip </code> <code>count </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Tells the simulator to ignore the breakpoint for the first <code>count</code> times that it triggers.</p>

<p>You can use <code>-skip</code> to set a breakpoint on the<code> n</code> <span style="color: rgb(0,0,0);"> <sup>th</sup> </span> occurrence of an event; in particular, you can use it to get inside <code>for</code> loops.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-pwr_mode_transition </span>
        </code></td>
<td class="confluenceTd" colspan="1"><code>
          <span>mode_transition_name mode_transition_name ...]</span>      </code></td>
<td class="confluenceTd" colspan="1">Stop when the specified power mode transition starts and ends.</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-randomize</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p>Sets a breakpoint in SystemVerilog randomize() method calls.</p>

<p>The SystemVerilog built-in randomize() function returns the value 1 for success or 0 for failure. A failure occurs because there are conflicts in the collection of constraints to solve or because a variable is over-constrained.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>-always] [object_name]</code></td>
<td class="confluenceTd" colspan="1">
<p>The <code>stop -create -randomize</code> command lets you set a breakpoint in randomize() method calls.<br />You can then use other Tcl commands, such as <code>deposit -constraint_mode</code>, <code>deposit -rand_mode</code>, <code>constraint</code>, and <code>run -rand_solve</code>, to debug the randomization failures. <br />By default, simulation stops at the end of randomize() calls when the call is about to return 0, or failure. If you include the <code>-always</code> option, simulation stops for all randomize() calls, regardless of the return status of the call.</p>

<p>You can include an <code>object_name</code> argument to stop the simulation in specific randomize() calls. The<br />argument can be a class name or a module name. The simulator stops on a failure in any call of<br />the randomize() method in the specified module or with the specified class name. If <code>-always</code> is<br />specified, the simulator stops in all calls to the randomize() method.<br />stop <code>-randomize</code> commands are supported for calls to class and scope randomize methods.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-sr_rule</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">Stop when the specified state retention rule saves or restores its variables.</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
<span>rule_name [rule_name ...] [-sr_save | -sr_restore]</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You can specify multiple state retention rule names.<br />The <code>-sr_rule</code> option has two sub-options:</p>
<ul><li><code>-sr_restore</code>&#8211;Stop only when the state retention rule restores its variables.</li><li><code>-sr_save</code>&#8211;Stop only when the state retention rule saves its variables.</li></ul></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><span> <code>-subprogram</code> </span></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p>Set a breakpoint that triggers when the specified VHDL subprogram or Verilog task or function is<br />called.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
          <span>subprogram_name</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You must compile with the <code>-linedebug</code> option to enable the setting of subprogram breakpoints.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-time time_spec </code> <br /> <code>[-absolute]</code> <br /> <code>[-relative]</code> <br /> <code>[-start  time_spec]</code> <br /> <code>[-modulo time_spec]</code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Sets a breakpoint that triggers at the specified time. The time can be absolute or relative (the default). Absolute time breakpoints are automatically deleted after they trigger. Relative time breakpoints are periodic, stopping, for example, every 10 ns.</p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>The digital solver is always active when the simulator stops for a time breakpoint.</p>

<p>Use <code>-start</code> to specify the absolute simulation time at which a relative time breakpoint is to begin firing. If this time is before the current simulation time, the first stop occurs at the next future time at which it would have occurred had the stop been set at the time specified with <code>-start.</code></p>

<p>The <code>-modulo</code> option is similar to -<code>start</code>. Use <code>-modulo</code> to specify the absolute simulation time of the first stop time for a repeating stop. This differs from <code>-start</code> only when the given time is more than one repeat interval in the future. In this case, the first stop occurs at a time less than or equal to one interval in the future such that a stop eventually occurs at the given time. For example, if you set a time breakpoint to stop the simulation every 100 ns, and specify <code>-modulo 250</code>, the simulation stops at time 50, 150, 250, and so on.</p>

<p>When you execute a <code>save -environment</code> command to save your debug environment, this option is written to the script to restore your time breakpoint pattern.</p>

<p>See the &quot;Setting a Time Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-disable </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-disable"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd" valign="top">
<p>Disables the breakpoints specified by the argument without deleting them. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-enable </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-enable"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd" valign="top">
<p>Enables the previously disabled breakpoints specified by the argument. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-delete </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-delete"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd" valign="top">
<p>Deletes the breakpoints specified by the argument. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top"><div class="content-wrapper">
<p><code>-show </code></p>
<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-show"></span></div>
</td>
<td class="confluenceTd" valign="top">
<p>[{<code>break_name</code>|<code>pattern</code>} ...]</p>
</td>
<td class="confluenceTd" valign="top">
<p>Shows the status of the breakpoints specified by the argument. If no breakpoint is specified, all breakpoints are shown. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.4">Example</h3>
<h4 id="AppendixB:Tcl-BasedDebugging-ObjectBreakpoints">Object Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation when<code> sum </code>changes value. The <code>-create</code>&#160;modifier is not required. Because the&#160;<code>-name</code>&#160;option is not included to specify a breakpoint name, <code>xmsim</code>&#160;assigns a sequential number as the name. This breakpoint is called <code>1.</code></p>

<p><code> xcelium&gt; stop -create -object sum</code> <br /> <code>Created stop 1 </code></p>

<p>The following command creates a breakpoint named <code>mybreak</code>&#160;that stops simulation when <code>sum</code>&#160;changes value.</p>

<p><code> xcelium&gt; stop -object sum -name mybreak</code> <br /> <code>Created stop mybreak</code></p>

<p>The following command creates a breakpoint that stops simulation when&#160;<code>EEnet_net1</code>&#160;changes value.</p>

<p><code>xcelium&gt; stop -object EEnet_net1&#160;</code> <br /> <code>Created stop 1</code> <br /> <code>xcelium&gt; run 5 ns</code> <br /> <code>0 FS + 1 (stop 1: top.EEnet_net1 = &#39;{V:4.9505, I:0, R:99.0099})</code></p>

<p>The following command creates a breakpoint that triggers when <code>sum</code>&#160;changes value. The breakpoint is ignored the first 3 times it triggers.</p>

<p><code> xcelium&gt; stop -object sum -skip 3 </code></p>

<p>The following command creates a breakpoint that stops simulation when <code>clr</code>&#160;changes value. The&#160;<code>value data</code>&#160;command is executed when the breakpoint triggers. Because the <code>value</code>&#160;command requires an argument, it must be enclosed in curly braces.</p>

<p><code> xcelium&gt; stop -object clr -execute {value data} </code></p>

<p>The following command creates a breakpoint that triggers when <code>clr</code>&#160;changes value. The <code>value data</code>&#160;command is executed when the breakpoint triggers. The <code>-continue</code>&#160;option prevents the simulator from entering interactive mode every time the stop triggers.</p>

<p><code> xcelium&gt; stop -object clr -execute {value data} -continue </code></p>

<p>The following command creates an object breakpoint that triggers when<code> data </code>changes value. The <code>-delbreak</code>&#160;option specifies that the breakpoint is deleted after it triggers three times.</p>

<p><code> xcelium&gt; stop -object data -continue -delbreak 3 </code></p>

<p>The following command creates a breakpoint that triggers when <code>clk</code>&#160;changes value, but only if <code>clk</code>&#160;is high. See<a href="#AppendixB:Tcl-BasedDebugging-1035041"> &quot;Tcl Expressions as Arguments&quot; </a>for details on the syntax of the argument to the <code>-if</code>&#160;option.</p>

<p><code> xcelium&gt; stop -object clk -if {#clk == 1} -continue </code></p>

<p>The following command creates a breakpoint that triggers when<code> data[1] </code>has the value<code> 1 </code>and the time becomes greater than 3 ns.</p>

<p><code> stop -object data -if {#data[1] == 1 &amp;&amp; [time ns -nounit] &gt; 3}</code></p>

<p>The following command shows the error message that is displayed if you run in regression mode and then try to set an object breakpoint on an object that does not have read access.</p>

<p><code> xcelium&gt; stop -object clk|</code> <br /> <code>xmsim: *E,RDACRQ: Object does not have read access: hardrive.clk. </code></p>

<p>The following shows an error caused by trying to create a breakpoint on an analog object.</p>

<p><code> xcelium&gt; stop -object compSig</code> <br /> <code>xcelium: *W,STALOB: Cannot set stop on analog object:</code> <br /> <code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.dac.compSig. This object ignored.</code> <br /> <code>xmsim: *E,STOBEX: Object expected after -OBJECT</code> <br /> <code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;option of stop command. </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-LineBreakpoints">Line Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation when line number 10 in the current debug scope is about to execute.</p>

<p><code> xcelium&gt; stop -line 10 </code></p>

<p>The following command creates a breakpoint that stops simulation when line number 13 in scope <code>counter</code>&#160;is about to execute.</p>

<p><code> xcelium&gt; stop -line 13 counter </code></p>

<p>In the following command, the <code>-all</code>&#160;option specifies that the stop is noninstance-specific. The breakpoint occurs on all scopes which are instances of the same module. For example if there are two instances of module <code>m16</code>, as follows:</p>

<p><code> module board;</code> <br /> <code>&lt;declarations&gt;m16 counter1 (...);</code> <br /> <code>m16 counter2 (...);</code> <br /> <code>&lt;code&gt;</code> <br /> <code>endmodule</code></p>

<p>the breakpoint triggers when line 13 in either <code>counter1</code>&#160;or <code>counter2 </code>is about to execute.</p>

<p><code> xcelium&gt; stop -line 13 counter1 -all </code></p>

<p>The following command is equivalent to the command shown in the previous example. Both commands create non-instance-specific breakpoints.</p>

<p><code> xcelium&gt; stop -line 13 -unit m16 </code></p>

<p>In the following example, the <code>-file</code>&#160;option specifies which of the source files that make up the given scope (or the debug scope if none is given) contains the specified line. This is necessary if the scope has multiple source files.</p>

<p><code> xcelium&gt; stop -line 13 counter -file foo.v </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-TimeBreakpoints">Time Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation at absolute time 200 ns. The breakpoint is automatically deleted after it triggers.</p>

<p><code> xcelium&gt; stop -time 200 ns -absolute </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 200 ns and then executes the <code>value</code>&#160;command. The&#160;<code>-relative</code>&#160;option is the default for time breakpoints.</p>

<p><code> xcelium&gt; stop -time 200 ns -relative -execute {value data} </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 200 ns. The&#160;<code>-start</code>&#160;option specifies the absolute time at which the breakpoint starts. For example, if the current simulation time is 300 ns, the breakpoint stops the simulation at time 600, 800, 1000, and so on.</p>

<p><code> xcelium&gt; stop -time 200 ns -start 600 ns </code></p>

<p>In the following example, the current simulation time is 300 ns. The absolute time specified with <code>-start</code>&#160;is before the current simulation time. The first stop occurs at the next future time at which it would have occurred had the stop been set at the time specified with&#160;<code>-start</code>. In this example, the first stop occurs at time 450 ns.</p>

<p><code> xcelium&gt; stop -time 200 ns -start 250 ns </code></p>

<p>The following example shows how the <code>-modulo</code>&#160;option is used to save a breakpoint pattern. Suppose that you simulate to time 300 ns and then set a repetitive breakpoint with the following command:</p>

<p><code> xcelium&gt; stop -time 200 ns -start 350 ns </code></p>

<p>This command stops the simulation at time 350, 550, 750, and so on. If you then execute a <code>save -environment</code>&#160;command to save your debug environment, the following line is written to the script:</p>

<p><code> stop -create -name 1 -time 200 NS -relative -modulo 950 NS </code></p>

<p>If you then exit and re-enter the simulation and source the script containing this command, the breakpoint pattern is re-established. In this example, if you restart the simulation and start at time 0, the breakpoint triggers the first time at time 150. It then triggers at 350, 550, 750, and so on.</p>

<p>The following command includes the <code>-if</code>&#160;option to set a breakpoint at time 100 ns (relative) if <code>data[1]</code>&#160;has the value <code>1.</code></p>

<p><code> xcelium&gt; stop -time 100 ns -if {#data[1] == 1} </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-DeltaBreakpoints">Delta Breakpoints</h4>

<p>The following command creates a breakpoint that stops the simulation when it reaches 20 delta cycles. The breakpoint is automatically deleted after it triggers.</p>

<p><code> xcelium&gt; stop -delta 20 -absolute </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 10 delta cycles. The <code>-start</code>&#160;option specifies the absolute delta cycle at which the breakpoint starts. For example, if the current delta cycle count is 0, the breakpoint stops the simulation when the delta cycle count is 30, 40, 50, and so on.</p>

<p><code> xcelium&gt; stop -delta 10 -start 30 </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-ConditionBreakpoints">Condition Breakpoints</h4>

<p>In a condition breakpoint, the argument to the <code>-condition</code>&#160;option is a Tcl expression. See<a href="#AppendixB:Tcl-BasedDebugging-1035041"> &quot;Tcl Expressions as Arguments&quot; </a>for more information on writing these expressions.</p>

<p>The following command sets a condition breakpoint that stops the simulation when <code>count</code>, the output of a 32-bit counter, has the value 100, decimal. The signal <code>count</code>&#160;is available from the top level of the hierarchy.</p>

<p><code> Verilog: xcelium&gt; stop -condition {[value %d top.count] = 100}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {[value %d :count] = 100}</code></p>

<p>If you are currently at the top level, you can omit the hierarchical path specification to<code> count </code>, and the two commands shown in the previous example could be written as follows:</p>

<p><code> xcelium&gt; stop -condition {[value %d count] = 100} </code></p>

<p>The<code> value </code>command uses the value of the <code>vlog_format </code>(or<code> vhdl_format</code>) variable. If you set the value of this variable to<code> %d</code>, the command shown in the previous example could be written as follows:</p>

<p><code> xcelium&gt; stop -condition {[value count] = 100} </code></p>

<p>Instead of using the<code> value </code>command to get the value of <code>count</code>&#160;into the expression evaluator, you can use <code>#count</code>. Include the format specifier after the # sign.</p>

<p><code> xcelium&gt; stop -condition {#%dcount = 100} </code></p>

<p>For Verilog, you can use the standard notation (for example<code> 4&#39;b0011</code>). For example, you can set the breakpoint on <code>count</code>&#160;as follows:</p>

<p><code> xcelium&gt; stop -condition {#count = 32&#39;d100}</code> <br /> <code>xcelium&gt; stop -condition {#count = 32&#39;b00000000000000000000000001100100}</code></p>

<p>VHDL does not have the same type of notation. Vectors must be enclosed in quotation marks, as shown in the next example.</p>

<p><code> xcelium&gt; stop -condition {#count = &quot;00000000000000000000000001100100&quot;} </code></p>

<p>The following command sets a condition breakpoint that stops the simulation when bit 0 of<code> count </code>is 1. The expression is evaluated when any bit of<code> count </code>changes value. For VHDL, single-bit entities must be enclosed in single quotation marks.</p>

<p><code> Verilog: xcelium&gt; stop -condition {#count[0] == 1}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {#count(0) == `1&#39;}</code></p>

<p>The following command is identical to the previous command. An explicit <code>value</code>&#160;command is used to get the value of <code>count</code>&#160;(bit 0) into the expression parser.</p>

<p><code> Verilog: xcelium&gt; stop -condition {[value %b count[0]] == 1&#39;b1}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {[value %b count(0)] == `1&#39;}</code></p>

<p>In the following command, the <code>-if</code>&#160;option is used to conditionalize the condition breakpoint. This breakpoint stops the simulation at the next positive edge of the clock if <code>en1</code>&#160;or <code>en2</code>&#160;is 1.</p>

<p><code> Verilog: xcelium&gt; stop -condition {#clock == 1} -if {#en1 || #en2}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {#clk_n == &#39;1&#39;}</code> <br /> <code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-if {#enable==&#39;1&#39;|| #reset_n==&#39;1&#39;}</code></p>

<p>The following command stops the simulation at 5 ns (absolute time). After that, <code>clock</code>&#160;changes depending on the condition in the <code>if</code>&#160;expression, and this happens repeatedly every 5 ns. The<code> -continue </code>option is used to prevent the simulation from stopping every time the breakpoint triggers. VHDL requires use of the single quotation marks.</p>

<p><code> xcelium&gt; stop -time 5 ns -start 5 ns<br />&#160;&#160;&#160;&#160;-execute {if {#clk == &#39;0&#39;} {force clk &#39;1&#39;}<br />&#160;&#160;&#160;&#160;else {force clk &#39;0&#39;}} -continue </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-ProcessBreakpoints">Process Breakpoints</h4>

<p>The following command sets a breakpoint that stops the simulation whenever the process called<code> :load_action </code>is executed.</p>

<p><code> xcelium&gt; stop -process :load_action </code></p>
<h4 id="AppendixB:Tcl-BasedDebugging-ExamplesofOtherstopCommandModifiers">Examples of Other stop Command Modifiers</h4>

<p>The following command sequence illustrates the<code> -show </code>modifier. The first command creates a source line breakpoint called <code>break1</code>; the second creates an object breakpoint called&#160;<code>break2</code>. The third command shows the status of the two breakpoints.</p>

<p><code> xcelium&gt; stop -line 12 -name break1<br />Created stop break1<br />xcelium&gt; stop -object data -name break2<br />Created stop break2<br />xcelium&gt; stop -show<br />break1  Enabled         Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; </code></p>

<p>In the following command sequence, breakpoint <code>break1</code>&#160;is first disabled with the <code>-disable</code>&#160;modifier and then enabled with the -<code>enable</code>&#160;modifier.</p>

<p><code> xcelium&gt; stop -show<br />break1  Enabled         Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; stop -disable break1<br />xcelium&gt; stop -show<br />break1  Disabled        Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; stop -enable break1<br />xcelium&gt; </code></p>

<p>The following command deletes breakpoint <code>break1.</code></p>

<p><code> xcelium&gt; stop -delete break1 </code></p>

<p>To disable, enable, or delete the two breakpoints <code>break1</code>&#160;and <code>break2</code>, any of the following commands could be used.</p>

<p><code> xcelium&gt; stop -delete *1 *2</code> <br /> <code>xcelium&gt; stop -delete break?</code> <br /> <code>xcelium&gt; stop -delete br*</code></p>

<p>The following command displays information on any breakpoint beginning with <code>v</code>&#160;or <code>b.</code></p>

<p><code> xcelium&gt; stop -show {[vb]*} </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-1035041TclExpressionsasArguments"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1035041"></span>Tcl Expressions as Arguments</h3>

<p>The<code> stop </code>command has two options that let you specify conditions. Both options require a Tcl expression argument.</p>
<ul><li><code> -condition<br /> </code>This option specifies that you are creating a condition breakpoint, as opposed to some other kind of breakpoint, such as a time or object breakpoint. A condition breakpoint triggers when any digital object named in the Tcl expression has an event that would trigger an object breakpoint and the expression evaluates to non-zero, non-x, or non-z. Although condition breakpoints are not triggered by changes in analog objects, you can include analog objects in the conditional expression and their values are used when the condition is evaluated (due to a digital object changing value).</li></ul><ul><li><code> -if<br /> </code>This option can be used with any breakpoint type, including condition breakpoints. The Tcl expression argument is evaluated, and the stop triggers if the expression evaluates to non-zero, non-x, or non-z.</li></ul>
<p>There are two general rules to keep in mind when writing the Tcl expression:</p>
<ul><li>
<p>Enclose the expression in braces to suppress immediate substitution of values.<br /> <span style="color: rgb(0,0,0);font-family: &quot;Courier New&quot;;font-size: small;">{<code>tcl_expression</code>}</span></p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>If you are using the SimVision environment, these braces are included on the Set Break form.</p>
</div>
</div>

<p>In the following example, the value of <code>w[1]</code>&#160;would be substituted with its current value (<code>1&#39;bx</code>, for example) if there were no braces. No object would be named in the expression by the time the<code> stop </code>command routine sees it, resulting in an error.<br /> <code>xcelium&gt; stop -condition #w[1] == 1</code> <br /> <code>  xcelium&gt; stop -condition {#w[1] == 1}</code></p>
</li></ul><ul><li>You must use either an explicit<code> value </code>command or the # character to get the object&#39;s value into the expression parser because the parser does not understand names. For example, the following command generates an error message.<br /> <code>xcelium&gt; stop -time 100 ns -if {r[1] == 1}</code> <br /> <code> Use the following commands:</code> <br /> <code> Verilog:</code> <br /> <code>  xcelium&gt; stop -time 100 ns -if {[value r[1]] == 1&#39;b1}</code> <br /> <code>  xcelium&gt; stop -time 100 ns -if {#r[1] == 1}</code> <br /> <code>  VHDL:</code> <br /> <code>  xcelium&gt; stop -time 100 ns -if {[value r(1)] == `1&#39;}</code> <br /> <code>  xcelium&gt; stop -time 100 ns -if {#r(1) == `1&#39;</code>}</li></ul>
<p>Format specifiers can be used with either the <code>value</code>&#160;command or the # sign. If you use the # sign, place the format specifier after the # sign. For example,</p>

<p>Verilog:</p>

<p><code> xcelium&gt; stop -condition {[value %d out] = 12}</code> <br /> <code>xcelium&gt; stop -condition {#%dout = 12}</code></p>

<p>VHDL:</p>

<p><code> xcelium&gt; stop -condition {[value %d out] = 12}</code> <br /> <code>xcelium&gt; stop -condition {#%dout = 1}</code></p>

<p>For VHDL, you must enclose vectors in quotation marks and single-bit entities in single quotation marks. For example,</p>

<p><code> Verilog: xcelium&gt; stop -condition {#clock == 1}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {#clock == `1&#39;}</code></p>

<p><code> Verilog: xcelium&gt; stop -condition {#count = 4&#39;b0101}</code> <br /> <code>VHDL: xcelium&gt; stop -condition {#clock = &quot;0101&quot;}</code></p>

<p>See the &quot;Basics of Tcl&quot; appendix in<em> <span style="color: rgb(0,0,0);"> Cadence Verilog Simulation User Guide </span> </em>for more details on basic Tcl syntax and on the extensions to Tcl that have been added to handle types and operators of the Verilog and VHDL hardware description languages.</p>

<p>For RNM nets, the following command creates a conditional on-change break when <code style="letter-spacing: 0.0px;">top.rnmnet</code> changes to <code style="letter-spacing: 0.0px;">`wrealXState</code>:</p>

<p><code>stop -create -object -if {#top.rnmnet = &quot;`wrealXState&quot;} top.rnmnet</code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-strobestrobe_tcl">strobe<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-strobe_tcl"></span></h2>

<p>The strobe command prints the values of specified VHDL, Verilog, or SystemC objects based on one of the following specifications:</p>
<ul><li>when a specified condition is true</li><li>When a specified signal changes value</li><li>At a specified time interval</li></ul>
<p>The strobe command is a Tcl procedure that uses the stop command to set a condition, object, or time breakpoint and then, when the breakpoint triggers, executes a value command to print out the values of the specified objects in tabular format.</p>

<p>You can apply the strobe command to objects in the SystemC portion of the design that are derived from <code>sc_signal</code>, <code>sc_port</code>, <code>sc_export</code>, <code>sc_in</code>, <code>sc_inout</code>, <code>sc_clock</code>, and&#160;<code>ncsc_viewable</code>.&#160;You can only set one strobe at a time. Setting a new strobe automatically deletes the previous strobe.</p>

<p>By default, the simulator prints the values of the specified objects using the default format of the value command. You can specify a format for individual objects by enclosing the object-format pair in curly braces. For example:</p>
<p style="margin-left: 30.0px;"><code>xcelium&gt; strobe -time 100 clk {data %b}</code></p>

<p>You can also set the <code>strobeFmt</code> variable to specify a global format. For example:</p>
<p style="margin-left: 30.0px;"><code>xcelium&gt; set strobeFmt %b</code></p>

<p>If you interrupt or stop the simulation (with <code>CTRL/C</code>, an <code>assert</code> statement, or by running the simulation for a specified period of time, for example), and then continue the simulation, the simulator does not print the header in the tabular output. This is done so that if you send the output to a file with the -redirect option, the header does not appear in the output file every time you continue the simulation. However, if you are sending output to the screen, you might want to redisplay the header. To display the header again, set the <code>strobeHeader</code> variable to <code>1</code>, as follows:</p>
<p style="margin-left: 30.0px;"><code>xcelium&gt; set strobeHeader 1</code></p>

<p>The variable <code>strobeTimeWidth</code> can be used to control how much space is used to print the simulation time in the strobe output. By default, the value is <code>15</code>. To change this, set the <code>strobeTimeWidth</code> variable before creating the strobe. For example:</p>
<p style="margin-left: 30.0px;"><code>xcelium&gt; set strobeTimeWidth 25</code></p>

<p>The <code>strobe</code> command defines other Tcl variables that are internal to the operation of the command.</p>

<p>The following variables should not be changed:</p>
<ul><li><code>strobeObjects</code></li><li><code>strobeObjectList</code></li><li><code>strobeStream</code></li><li><code>headerList</code></li><li><code>widthList</code></li></ul><div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>If a strobe is already set, you must reset the strobe to the change to take effect.</p>
</div>
</div>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.14">Syntax</h3>

<p><code>strobe strobe_specification object_list [output_file_specification]</code></p>

<p>where, <code>strobe_specification</code> can be:</p>
<ul><li><code>-condition condition_specification</code></li><li><code>-object object_specification</code></li><li><code>-time time_specification</code></li></ul>
<p><code>object_list</code> can be:<br /> <code>object | {object format} [object | {object format} ...]</code></p>

<p><code>output_file_specification</code> can be:<br /> <code>-redirect filename [-append]</code></p>

<p><code>strobe -delete</code> <br /> <code>strobe -help</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.13">Modifiers and Options</h3>
<div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 79.1816%;"><colgroup> <col style="width: 20.9991%;" /> <col style="width: 23.3243%;" /> <col style="width: 55.6585%;" /> </colgroup><tbody><tr><th class="confluenceTh">Modifiers<span> </span></th><th class="confluenceTh"><span>Options and Arguments</span> <span> </span></th><th class="confluenceTh" colspan="1"><span>Function</span></th></tr>
<tr><td class="confluenceTd"><code>strobe_specification</code></td>
<td class="confluenceTd"><br /></td>
<td class="confluenceTd" colspan="1">
<p>You must specify if you want to display signal values when a specified condition is true (-</p>
condition), when a specified signal changes value (-object), or at a specified time interval (-time).</td>
</tr>
<tr><td class="confluenceTd"><br /></td>
<td class="confluenceTd">
<p><code>-condition condition_specification object | {object format} [object | {object format} ...]</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Display the values of the specified object(s) when the condition_specification is true.</p>

<p>Set a breakpoint that triggers when any object referenced in the tcl_expression changes value (wires, signals, registers, and variables) or is written to (memories) and the expression evaluates to true (non-zero, non-x, non-z).</p>
</td>
</tr>
<tr><td class="confluenceTd"><br /></td>
<td class="confluenceTd">
<p><code>-object object_specification object | {object format} [object | {object format} ...]</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Display the values of the specified object(s) when the object specified by the <code>object_specification</code> argument changes value.</p>

<p>With <code>-object</code>, you can specify only one object to monitor for a change in value. For example, the following command displays the values of <code>y</code> and <code>z</code> when <code>x</code> changes value.</p>

<p><code>xcelium&gt; strobe -object x y z</code></p>
</td>
</tr>
<tr><td class="confluenceTd"><br /></td>
<td class="confluenceTd">
<p><code>-time time_specification object | {object format} [object | {object format} ...]</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Display the values of the object(s) at the time interval specified by the <code>time_specification</code> argument.</p>

<p><code>xcelium&gt; strobe -time 100ns x y z</code></p>

<p><code>xcelium&gt; strobe -time 100ns x {y %b} z</code></p>
</td>
</tr>
<tr><td class="confluenceTd"><code>object_list<span> </span>
        </code></td>
<td class="confluenceTd"><code>
          <span>object</span>
        </code></td>
<td class="confluenceTd" colspan="1">The <code>object_list</code> refers to the signals the strobe is being applied to and the format is basically how to display the object such as in hex format and binary format.</td>
</tr>
<tr><td class="confluenceTd">
<p><code>output_file_specification</code></p>
</td>
<td class="confluenceTd">
<p><code>-redirect filename [-append]</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Redirect output to the specified file. By default, the simulator prints the output of the <code>strobe</code> command to the screen.</p>

<p>Include the <code>-append</code> option to append output to the file specified with the <code>-redirect</code> option.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>-delete</code></p>
</td>
<td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Delete the strobe.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>-help</code></p>
</td>
<td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Display help on the <code>strobe</code> command. You can also get help on the strobe command by using the help command.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.8">Examples</h3>

<p>The following command prints the values of signals <code>clk</code>, <code>clr</code>, <code>data</code>, and <code>q</code> every <code>100 ns</code>.</p>

<p><code>xcelium&gt; <strong>strobe -time 100 clk clr data q</strong>
  </code> <br /> <code>Setting up strobe time - &#39;100&#39;</code> <br /> <code>xcelium&gt; <strong>run</strong>
  </code> <br /> <code>Time |clk |clr |data |q |</code> <br /> <code>-----------------------------------------</code> <br /> <code>100 NS |1&#39;h1 |1&#39;h1 |4&#39;h0 |4&#39;hx |</code> <br /> <code>200 NS |1&#39;h1 |1&#39;h1 |4&#39;h1 |4&#39;h0 |</code> <br /> <code>300 NS |1&#39;h1 |1&#39;h1 |4&#39;h2 |4&#39;h1 |</code> <br /> <code>400 NS |1&#39;h1 |1&#39;h1 |4&#39;h3 |4&#39;h2 |</code> <br /> <code>...</code></p>

<p>The following command prints the values of signals <code>clk</code>, <code>clr</code>, <code>data</code> (in binary), and <code>q</code> every 100 ns.</p>

<p><code>xcelium&gt; <strong>strobe -time 100ns clk clr {data %b} q<br /> </strong>Setting up strobe time - &#39;100ns&#39;</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300 ns<br /> </strong>Time |clk |clr |data |q |</code> <br /> <code>--------------------------------------------</code> <br /> <code>100 NS |1&#39;h1 |1&#39;h1 |4&#39;b0000 |4&#39;hx |</code> <br /> <code>200 NS |1&#39;h1 |1&#39;h1 |4&#39;b0001 |4&#39;h0 |</code> <br /> <code>300 NS |1&#39;h1 |1&#39;h1 |4&#39;b0010 |4&#39;h1 |</code> <br /> <code>Ran until 300 NS + 0</code>&#160;</p>

<p>In the following command sequence, the simulation is run for 300 ns. When the simulation is resumed, the strobe header is not displayed. The <code>strobeHeader</code> variable is then set to display the header when the simulation is resumed.</p>

<p><code>xcelium&gt; <strong style="letter-spacing: 0.0px;">strobe -time 100 clk clr data q<br /> </strong>Setting up strobe time - &#39;100&#39;</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300<br /> </strong>Time |clk |clr |data |q |</code> <br /> <code>-----------------------------------------</code> <br /> <code>100 NS |1&#39;h1 |1&#39;h1 |4&#39;h0 |4&#39;hx |</code> <br /> <code>200 NS |1&#39;h1 |1&#39;h1 |4&#39;h1 |4&#39;h0 |</code> <br /> <code>300 NS |1&#39;h1 |1&#39;h1 |4&#39;h2 |4&#39;h1 |</code> <br /> <code>Ran until 300 NS + 0</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300<br /> </strong>400 NS |1&#39;h1 |1&#39;h1 |4&#39;h3 |4&#39;h2 |</code> <br /> <code>500 NS |1&#39;h1 |1&#39;h1 |4&#39;h4 |4&#39;h3 |</code> <br /> <code>600 NS |1&#39;h1 |1&#39;h1 |4&#39;h5 |4&#39;h4 |</code> <br /> <code>Ran until 600 NS + 0</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">set strobeHeader 1<br /> </strong>1</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300<br /> </strong>Time |clk |clr |data |q |</code> <br /> <code>----------------------------------------</code> <br /> <code>700 NS |1&#39;h1 |1&#39;h1 |4&#39;h6 |4&#39;h5 |</code> <br /> <code>800 NS |1&#39;h1 |1&#39;h1 |4&#39;h7 |4&#39;h6 |</code> <br /> <code>900 NS |1&#39;h1 |1&#39;h1 |4&#39;h8 |4&#39;h7 |</code> <br /> <code>Ran until 900 NS + 0</code></p>

<p>To change the format globally, you can set the <code>strobeFmt</code> variable, as shown in the following&#160;example. You must reset the strobe after setting the <code style="letter-spacing: 0.0px;">strobeFmt</code> variable.</p>

<p><code>xcelium&gt; <strong>strobe -time 100 clk clr data q<br /> </strong>Setting up strobe time - &#39;100&#39;</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300<br /> </strong>Time |clk |clr |data |q |</code> <br /> <code>-----------------------------------------</code> <br /> <code>100 NS |1&#39;h1 |1&#39;h1 |4&#39;h0 |4&#39;hx |</code> <br /> <code>200 NS |1&#39;h1 |1&#39;h1 |4&#39;h1 |4&#39;h0 |</code> <br /> <code>300 NS |1&#39;h1 |1&#39;h1 |4&#39;h2 |4&#39;h1 |</code> <br /> <code>Ran until 300 NS + 0</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">set strobeFmt %b<br /> </strong>%b</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">strobe -time 100 clk clr data q<br /> </strong>Setting up strobe time - &#39;100&#39;</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300<br /> </strong>Time |clk |clr |data |q |</code> <br /> <code>-----------------------------------------------</code> <br /> <code>400 NS |1&#39;b1 |1&#39;b1 |4&#39;b0011 |4&#39;b0010 |</code> <br /> <code>500 NS |1&#39;b1 |1&#39;b1 |4&#39;b0100 |4&#39;b0011 |</code> <br /> <code>600 NS |1&#39;b1 |1&#39;b1 |4&#39;b0101 |4&#39;b0100 |</code> <br /> <code>Ran until 600 NS + 0</code></p>

<p>The following command displays the values of <code>clk</code>, <code>clr</code>, and <code>q</code> when data changes value.</p>

<p><code>xcelium&gt; <strong>strobe -object data clk clr q</strong>
  </code> <br /> <code>Setting up strobe object - &#39;data&#39;</code> <br /> <code>xcelium&gt; <strong>run 300 ns</strong>
  </code> <br /> <code>Time |clk |clr |q |</code> <br /> <code>-----------------------------------</code> <br /> <code>0 NS |1&#39;h0 |1&#39;h1 |4&#39;hx |</code> <br /> <code>100 NS |1&#39;h1 |1&#39;h1 |4&#39;hx |</code> <br /> <code>200 NS |1&#39;h1 |1&#39;h1 |4&#39;h0 |</code> <br /> <code>Ran until 300 NS + 0</code></p>

<p>The following command displays the values of <code>data</code>, <code>clk</code>, <code>clr</code>, and <code>q</code> when data changes value.</p>

<p><code>xcelium&gt; <strong>strobe -object data data clk clr q</strong>
  </code> <br /> <code>Setting up strobe object - &#39;data&#39;</code> <br /> <code>xcelium&gt; run <strong>300 ns</strong>
  </code> <br /> <code>Time |data |clk |clr |q |</code> <br /> <code>-----------------------------------------</code> <br /> <code>0 NS |4&#39;h0 |1&#39;h0 |1&#39;h1 |4&#39;hx |</code> <br /> <code>100 NS |4&#39;h1 |1&#39;h1 |1&#39;h1 |4&#39;hx |</code> <br /> <code>200 NS |4&#39;h2 |1&#39;h1 |1&#39;h1 |4&#39;h0 |</code> <br /> <code>Ran until 300 NS + 0</code></p>

<p>The following command displays value of <code>UDN EEnet_net1</code> when <code>EEnet_bus[0]</code> changes value.</p>

<p><code>xcelium&gt; <strong>strobe -object EEnet_bus[0]&#160; EEnet_net1</strong>&#160;</code> <br /> <code>Setting up strobe object - &#39;EEnet_bus[0]&#39;</code> <br /> <code>xcelium&gt; run <strong>500 ns</strong>
  </code> <br /> <code>Time&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |EEnet_net1&#160;&#160;&#160;&#160;&#160;&#160; |</code> <br /> <code>-----------------------------------</code> <br /> <code>0 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:4.9505, I:0, R:99.0099}&#160;&#160;&#160; |</code> <br /> <code>100 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; |</code> <br /> <code>150 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:3.33333, I:0, R:66.6667}&#160;&#160; |</code> <br /> <code>250 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; |</code> <br /> <code>300 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:3.33333, I:0, R:66.6667}&#160;&#160; |</code> <br /> <code>400 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:5, I:0, R:100}&#160;&#160; |</code> <br /> <code>450 NS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; |</code></p>

<p>The following command displays value of&#160; <code>EEnet_net1&#160; EEnet_bus[0]</code> when <code>EEnet_net1</code> changes value.</p>

<p><code>xcelium&gt; <strong>strobe -object EEnet_net1&#160; EEnet_net1&#160; EEnet_bus[0]</strong>
  </code> <br /> <code>Setting up strobe object - &#39;EEnet_net1&#39;</code> <br /> <code>xcelium&gt; run <strong>500 ns</strong>
  </code> <br /> <code>Time&#160;&#160;&#160; | EEnet_net1&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|{EEnet_bus[0]}&#160;&#160; |</code> <br /> <code>-----------------------------------------------------</code> <br /> <code>0 NS&#160;&#160;&#160; |&#39;{V:4.9505, I:0, R:99.0099} &#160;|&#39;{V:4.85437, I:0, R:97.0874} &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;</code> <br /> <code>100 NS&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;|&#39;{V:`wrealXState, I:0, R:`wrealZState} &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</code> <br /> <code>150 NS&#160; |&#39;{V:3.33333, I:0, R:66.6667} |&#39;{V:2, I:0, R:40}&#160; |</code> <br /> <code>250 NS&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;|&#39;{V:`wrealXState, I:0, R:`wrealZState}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; |</code> <br /> <code>300 NS&#160; |&#39;{V:3.33333, I:0, R:66.6667} |&#39;{V:2, I:0, R:40}&#160; |</code> <br /> <code>400 NS&#160; |&#39;{V:5, I:0, R:100}&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#39;{V:5, I:0, R:100&#160; |</code> <br /> <code>450 NS&#160; |&#39;{V:0, I:0.05, R:0}&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;|&#39;{V:`wrealXState, I:0, R:`wrealZState}&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</code></p>

<p>The following command displays the values of <code>data</code> (in binary), <code>clk</code>, <code>clr</code>, and <code>q</code> (in hex)&#160;when data changes value. Notice that the <code>object-format</code> pair is enclosed in curly braces.</p>

<p><code>xcelium&gt; <strong>strobe -object data {data %b} clk clr q<br /> </strong>Setting up strobe object - &#39;data&#39;</code> <br /> <code>xcelium&gt; <strong style="letter-spacing: 0.0px;">run 300 ns<br /> </strong>Time |data |clk |clr |q |</code> <br /> <code>--------------------------------------------</code> <br /> <code>0 NS |4&#39;b0000 |1&#39;h0 |1&#39;h1 |4&#39;hx |</code> <br /> <code>100 NS |4&#39;b0001 |1&#39;h1 |1&#39;h1 |4&#39;hx |</code> <br /> <code>200 NS |4&#39;b0010 |1&#39;h1 |1&#39;h1 |4&#39;h0 |</code> <br /> <code>Ran until 300 NS + 0</code></p>

<p>The following command displays the values of the specified signals when data has the value 3, decimal. The signal data is available from the top level of the hierarchy.</p>

<p>Verilog:</p>

<p><code>xcelium&gt; <strong>strobe -condition {[value %d top.data] = 3} clk clr data q</strong>
  </code></p>

<p>VHDL:</p>

<p><code>xcelium&gt; <strong>strobe -condition {[value %d :data] = 3} clk clr data q</strong>
  </code></p>

<p>If you are currently at the top level, you can omit the hierarchical path specification to data, and write the two commands shown in the previous example as follows:</p>

<p><code>xcelium&gt; <strong style="letter-spacing: 0.0px;">strobe -condition {[value %d data] = 3} clk clr data q</strong>
  </code></p>

<p>Instead of using the value command to get the value of data into the expression evaluator, you can use #data. Include the format specifier after the # sign.</p>

<p><code>xcelium&gt; <strong style="letter-spacing: 0.0px;">strobe -condition {#%ddata = 3} clk clr data q</strong>
  </code></p>

<p>The following command displays the values of the specified signals when data has the value 0010 (binary). For VHDL, you must enclose vectors in quotation marks.</p>

<p>Verilog:</p>

<p><code>xcelium&gt; <strong>strobe -condition {#data = 4&#39;b0010} clk clr data q</strong>
  </code></p>

<p>VHDL:</p>

<p><code>xcelium&gt; <strong>strobe -condition {#data =&quot;0010&quot;} clk clr data q</strong>
  </code></p>

<p>The following command displays the values of the specified signals when bit 0 of data is 1. The expression is evaluated when any bit of data changes value. For VHDL, you must enclose singlebit entities in single quotation marks.</p>

<p>Verilog:</p>

<p><code>xcelium&gt; <strong>strobe -condition {#data[0] == 1} clk clr data q</strong>
  </code></p>

<p>VHDL:</p>

<p><code>xcelium&gt; <strong>strobe -condition {#data(0) == `1&#39;} clk clr data q</strong>
  </code></p>

<p>The following command is identical to the previous command except that it uses an&#160;explicit value command to get the value of data (bit 0) into the expression parser.</p>

<p>Verilog:</p>

<p><code>xcelium&gt; <strong>strobe -condition {[value %b data[0]] == 1&#39;b1} clk clr data q</strong>
  </code></p>

<p>VHDL:</p>

<p><code>xcelium&gt; <strong>strobe -condition {[value %b data(0)] == `1&#39;} clk clr data q</strong>
  </code></p>

<p>The following command displays the values of the specified signals if the value of <code>top.load</code> has the value <code>x</code>. Notice that in the Tcl expression, the case-equality operator (===) is used.</p>

<p>For this operator, bits that are unknown are included in the comparison, and the result of the expression is always 1 (true) or 0 (false).</p>

<p><code>xcelium&gt; <strong style="letter-spacing: 0.0px;">strobe -condition {#top.load === 1&#39;bx} clk clr data q</strong>
  </code></p>

<p>In the following command, the logical comparison operator ( = or ==) is used. These operators return the unknown value (x) if either operand is unknown. In a conditional expression, an unknown result is treated as false. Therefore, the following command does not stop the simulation when the signal has the value <code>x</code>.</p>

<p><code>xcelium&gt; <strong>strobe -condition {#top.load == 1&#39;bx} clk clr data q</strong>
  </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-timeTcl_time1036081">time<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_time"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1036081"></span></h2>

<p>Displays the current simulation time scaled to the specified unit. The unit can be</p>
<ul><li>A time unit that you specify</li></ul><ul><li><code> auto</code>: use the largest base unit that makes the numeric part of the time an integer</li></ul><ul><li><code> module</code>: use the timescale of the current debug scope</li></ul>
<p>The simulation time can be displayed in the following time units:</p>
<ul><li><code> fs</code>: femtoseconds</li></ul><ul><li><code> ps</code>: picoseconds</li></ul><ul><li><code> ns</code>: nanoseconds</li></ul><ul><li><code> us</code>: microseconds</li></ul><ul><li><code> ms</code>: milliseconds</li></ul><ul><li><code> sec</code>: seconds</li></ul>
<p>If no unit is given, the value of the <code>$display_unit</code>&#160;variable is used. This variable is set to <code>auto</code>&#160;by default.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.15">Syntax</h3>

<p><code>time [[10 | 100] time_unit | auto | module]</code> <br /> <code>&#160; &#160; -delta</code> <br /> <code>&#160; &#160; -nounit</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.14">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="125">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="172">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="348">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-delta </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Includes the delta cycle count.</p>

<p><span style="color: rgb(0,0,0);"> <strong>Note:</strong>&#160;</span>The <code>-delta</code> option is ignored if the analog solver is active.</p>

<p>At any given simulation time, values of nets are first updated and then behaviors that are sensitive to those nets are executed. This two step process may be repeated any number of times because of zero-delays. The delta cycle count represents the number of times the process is repeated for the given simulation time.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-nounit </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Does not include the time unit.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="AppendixB:Tcl-BasedDebugging-Examples.9">Examples</h3>

<p><code> xmsim -tcl boardxmsim: v1.0.(p2): (c) Copyright 1995 - 2000 Cadence Design Systems </code></p>

<p><code> xcelium&gt; run 100 ns5  count= X, f=x, af=xRan until 100 NS + 0 </code></p>

<p>The following command displays the current simulation time in ns.</p>

<p><code> xcelium&gt; time ns100 NS </code></p>

<p>The following command displays the current simulation time in fs.</p>

<p><code> xcelium&gt; time fs100000000 FS </code></p>

<p>The following command displays the current simulation time in 100 times the base unit of fs.</p>

<p><code> xcelium&gt; time 100fs1000000 100FS </code></p>

<p>The following commands illustrate the<code> auto </code>keyword, which displays the time using the largest base unit that makes the numeric part of the time an integer.</p>

<p><code> xcelium&gt; time fs100000000 FSxcelium&gt; time auto100 NS </code></p>

<p>The following command displays the current simulation time using the timescale of the current debug scope.</p>

<p><code> xcelium&gt; time module100 NS </code></p>

<p>The following command displays the current simulation time using the timescale of the current debug scope and including the delta cycle count.</p>

<p><code> xcelium&gt; time module -delta100 NS + 0 </code></p>

<p>The following command displays the current simulation time with no time unit.</p>

<p><code> xcelium&gt; time -nounit100 </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-valueTcl_valuevalue_cmd1035187">value<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_value"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-value_cmd"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1035187"></span></h2>

<p>Prints the current value of the specified objects using the last format specifier preceding the object name argument. If no format is specified, a default format is used.</p>

<p>Objects specified as arguments to the <code>value</code>&#160;command must have read access. An error is printed if an object does not have read access.</p>

<p>For information about using <code style="letter-spacing: 0.0px;">value </code>with unnamed branches, see &quot;Specifying Unnamed Branch Objects&#160;<a href="Appendix_B__Tcl-Based_Debugging.html">Appendix B: Tcl-Based Debugging</a>&quot;.</p>

<p>The <code>value</code>&#160;command is supported on user-defined nettypes. For more information on user-defined nettypes, refer to<a href="Using_Real_Number_Modeling_in_SystemVerilog.html#UsingRealNumberModelinginSystemVerilog-1066573"> User-Defined Nettype and Resolution Function</a>.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.16">Syntax</h3>

<p><code>value [format ...] object_name...</code> <br /> <code>&#160; &#160; -potential</code> <br /> <code>&#160; &#160; -flow</code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.15">Modifiers and Options</h3>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> <col /> </colgroup><tbody><tr><th class="confluenceTh" valign="middle" width="125">
<p>Modifiers</p>
</th><th class="confluenceTh" valign="middle" width="172">
<p>Options and Arguments</p>
</th><th class="confluenceTh" valign="middle" width="348">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-potential </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Returns the potential of analog branches that follow on the command line. This option is ignored for any other kind of object.</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><br /></p>
</td>
<td class="confluenceTd" valign="top">
<p><code>-flow </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>Returns the flow value of analog branches that follow on the command line. Returns the flow value of analog objects that have existing Tcl current probes. This option is ignored for any other kind of object.</p>
</td>
</tr>
</tbody></table></div>

<p>For Verilog, the valid formats are:</p>
<div class="table-wrap"><table border="1" cellpadding="5" cellspacing="0" class="wrapped confluenceTable" style="width: 670.0px;"><colgroup> <col /> <col /> </colgroup><tbody><tr><td class="confluenceTd" valign="top" width="111">
<p><code> %c </code></p>
</td>
<td class="confluenceTd" valign="top" width="383">
<p>character</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %s </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>string</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %b </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>binary</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %d </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>decimal</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %o </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>octal</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %x </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>unsigned hexadecimal</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %h </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>same as<code> %x </code></p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %f </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>floating-point number</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %e </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>real number in mantissa-exponent form</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %g </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>use <code>%e</code> or <code>%f</code>, whichever is shorter</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %t </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>decimal time scaled from the timescale of the object&#39;s module to the simulation&#39;s timescale</p>
</td>
</tr>
<tr><td class="confluenceTd" valign="top">
<p><code> %v </code></p>
</td>
<td class="confluenceTd" valign="top">
<p>strength value--wires only</p>
</td>
</tr>
</tbody></table></div>

<p>To revert to the default format, use <code>%.</code></p>

<p>If no format is specified, the default format depends on the object type. The following defaults are used:</p>
<ul><li>analog:<code>&#160;%g </code></li></ul><ul><li>time: <code>%d </code></li></ul><ul><li>integer: <code>&#160;%d </code></li></ul><ul><li>real: <code>%g </code></li></ul><ul><li>reg: <code>$vlog_format </code></li></ul><ul><li>wire: <code>$vlog_format </code></li></ul>
<p>where <code>$vlog_format</code>&#160;is a predefined Tcl variable that defaults to<code> %h.</code> You can set this variable to <code>%b</code>,<code> %o</code>, or<code> %d</code>.</p>

<p>For VHDL, values are returned in a format that resembles the appropriate VHDL syntax for the object type. If one of the radix format specifiers (<code>%b</code>,<code> %o</code>,<code> %d</code>, or<code> %x</code>) is given, the format affects the format of integer values and of bit_vector and std_logic_vector values. Otherwise, the format specifier is ignored for VHDL values.</p>

<p>The value of a digital net that is associated with a mixed signal depends on whether the enclosing module is an ordinary module or a connect module. The value of a digital net within an ordinary module is the resolved value of the connect module drivers that drive the net. The value of a digital net within a connect module is the resolved value of the ordinary module drivers that drive the net. For more information, see the&#160;<span style="color: rgb(0,0,255);"> <a class="message-url" href="../verilogamsref/chap11.html#driverreceiversegregation">&quot;Driver-Receiver Segregation&quot;</a>&#160;</span>section of the &quot;Mixed-Signal Aspects of Verilog-AMS&quot; chapter, in the<span style="color: rgb(0,0,0);"> <em> Cadence Verilog-AMS Language Reference</em>.</span></p>

<p>You can also use the pound sign (<code>#</code>) as a shortcut to the <code>value</code>&#160;command. When used on an analog branch, the <code>#</code>&#160;shortcut accesses the potential across the branch, not the flow.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.5">Example</h3>

<p>You have an analog branch declared in Verilog-AMS source code like this:</p>

<p><code> branch (p,n) res; </code></p>

<p>You can return the potential of the branch like this:</p>

<p><code> xcelium&gt; value res<br />0.626 </code></p>

<p>Where the flow of the <code>res</code>&#160;and <code>bar</code>&#160;branches are 0.111mA and 2.3mA respectively, and the potential of the <code>p_n</code>&#160;branch is 4.666V, using the command</p>

<p><code> xcelium&gt; value -flow res bar -potential p_n </code></p>

<p>returns</p>

<p><code> 0.000111 0.00023 4.666 </code></p>

<p>The following sequence of <code>value</code>&#160;commands displays the current value of <code>data</code>&#160;in a variety of formats.</p>

<p><code> xcelium&gt; value data<br />4&#39;h2<br />xcelium&gt; value %o data<br />4&#39;o02<br />xcelium&gt; value %b data<br />4&#39;b0010<br />xcelium&gt; value %d data<br />4&#39;d2<br />xcelium&gt; value %g data<br />2<br />xcelium&gt; value %f data<br />2.000000<br />xcelium&gt; value %e data<br />2.000000e+00 </code></p>

<p><code> xcelium&gt; value %b data %d q<br />4&#39;b0010 4&#39;d1<br />xcelium&gt; value % data %d data %b data<br /> 4&#39;h2 4&#39;d2 4&#39;b0010 </code></p>

<p>The following command shows the error message that is displayed when you run in regression mode and use the <code>value</code>&#160;command on an object that does not have read access.</p>

<p><code> xcelium&gt; value clk</code> <br /> <code>xmsim: *E,RDACRQ: Object does not have read access: hardrive.clk. </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-Tcl_where1035281where"><span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-Tcl_where"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1035281"></span>where</h2>

<p>Displays the current location of the simulation. This includes the current simulation time and the current scope.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Syntax.17">Syntax</h3>

<p><code> where </code></p>
<h3 id="AppendixB:Tcl-BasedDebugging-ModifiersandOptions.16">Modifiers and Options</h3>

<p>None.</p>
<h3 id="AppendixB:Tcl-BasedDebugging-Example.6">Example</h3>

<p><code> xcelium&gt; where<br />TIME: 3400 NS + 0<br />Scope is (board.counter)<br />xcelium&gt; </code></p>
<h2 id="AppendixB:Tcl-BasedDebugging-SpecifyingUnnamedBranchObjectsunnamedBranchObjects1047551">Specifying Unnamed Branch Objects<span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-unnamedBranchObjects"></span> <span class="confluence-anchor-link" id="AppendixB:Tcl-BasedDebugging-1047551"></span></h2>

<p>Verilog<span style="color: rgb(0,0,0);"> <sup>&#174;</sup> </span>-AMS modules can contain unnamed branches. For example, you might have</p>

<p><code> electrical a, b;</code> <br /> <code>V(a,b) &lt;+ 7 * I(a,b) ;&#160;// Uses an unnamed branch across a and b </code></p>

<p>To refer to the unnamed branch when you use a Tcl command, you use an underscore between the two nets. So you might have a Tcl command and response like the following:</p>

<p><code> xcelium&gt; describe a_b</code> <br /> <code>a_b........analog net (electrical ) = 0 </code></p>

<p>Unfortunately, this approach is sometimes ambiguous. For example, consider the following code.</p>

<p><code> electrical a, b, a_b ; // Defines 3 nets, including a node named a_b</code> <br /> <code>V(a,b) &lt;+ 2 * I(a,b) ;&#160;// An unnamed branch across a and b </code></p>

<p>Now, using the command <code>describe a_b</code>&#160;is ambiguous, because <code>a_b</code>&#160;could refer to the node <code>a_b</code>&#160;or to the unnamed branch. To resolve this ambiguity, Tcl assumes that <code>a_b</code>&#160;refers to the node and requires you to use <code>a_b_1</code>&#160;to refer to the unnamed branch. So you might have commands and responses like the following:</p>

<p><code> xcelium&gt; describe a_b</code> <br /> <code>a_b........analog net (electrical ) = 0</code> <br /> <code>xcelium&gt; describe a_b_1</code> <br /> <code>a_b_1......branch(a,b) = 0 </code></p>

<p>It might sometimes be necessary to use additional generated names, such as <code>a_b_2</code>, if the names that would otherwise be used, such as <code>a_b_1</code>, are already in use. Generated names are used only for branches, never for nets.</p>

<p>To avoid the problem of ambiguous references, Cadence recommends that you declare and use named branches.</p>

                    </div>
<br /><br /></div>
<footer xmlns:html="http://www.w3.org/1999/xhtml"><nav class="navigation"><b><em><a href="Appendix_A__Updating_Legacy_Libraries_and_Netlists.html" id="prev" title="Appendix_A__Updating_Legacy_Libraries_and_Netlists">Appendix_A__Updating_Legacy_Li ...</a></em></b><b><em><a href="Appendix_C__Source_Protection.html" id="nex" title="Appendix_C__Source_Protection">Appendix_C__Source_Protection</a></em></b></nav><div>
          For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2019, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved.
        </div>
</footer><br xmlns:html="http://www.w3.org/1999/xhtml" /></body></html>