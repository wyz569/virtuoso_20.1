
<html><head><title>Technology Data Preparation</title>
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="leenap" />
<meta name="CreateDate" content="2020-02-20" />
<meta name="CreateTime" content="1582191945" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="" />
<meta name="DocTitle" content="Mixed Signal (MS) Interoperability Guide" />
<meta name="DocType" content="Methodology" />
<meta name="FileTitle" content="Technology Data Preparation" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="FileType" content="Chapter" />
<meta name="Keyword" content="dmsflow" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2020-02-20" />
<meta name="ModifiedTime" content="1582191945" />
<meta name="NextFile" content="Design_Data_Preparation.html" />
<meta name="Group" content="" />
<meta name="Platform" content="" />
<meta name="PrevFile" content="Overview_of_Mixed_Signal_Interoperability.html" />
<meta name="Product" content="Virtuoso Layout Suite,Innovus," />
<meta name="ProductFamily" content="Custom IC Design,Digital IC Design," />
<meta name="ProductVersion" content="20.10" />
<meta name="RightsManagement" content="Copyright 2012-2020 Cadence Design Systems Inc." />
<meta name="Title" content="Mixed Signal (MS) Interoperability Guide -- Technology Data Preparation" />
<meta name="Version" content="20.10" />
<meta name="Renderer" content="WIKI" />
<meta name="SpaceKey" content="dmsflow201" />
<meta name="confluence-version" content="6.13.3" />
<meta name="ecms-plugin-version" content="03.30.005" />

        
        <link href="styles/site.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    

    </head><body style="background-color: #FFFFFF;"><!-- Begin Buttons --><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="docHeadr">Product Documentation<img src="images/Cadence-Logo.jpg" /></div>
<nav class="blueHead"><ul><li><a class="content" href="dmsflowTOC.html">Contents</a></li><li><a class="prev" href="Overview_of_Mixed_Signal_Interoperability.html" title="Overview_of_Mixed_Signal_Interoperability">Overview_of_Mixed_Signal_Inter ...</a></li><li style="float: right;"><a class="viewPrint" href="dmsflow.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="Design_Data_Preparation.html" title="Design_Data_Preparation">Design_Data_Preparation</a></li></ul></nav></header><!-- End Buttons --><div xmlns:html="http://www.w3.org/1999/xhtml" style="font-size:14px;line-height:1.42857142857;margin:20px 0 0 0;font-weight:bold;"><center>Mixed Signal (MS) Interoperability Guide<br />Product Version 20.10, March 2020</center></div>
<div xmlns:html="http://www.w3.org/1999/xhtml" style="margin-left:5%;">
<p></p>

<p></p>
<div id="main-header">
                    
                    
                                                <div style="width: 100%; font-size: 32px; text-align: left;               font-weight: bold;">3</div>
<h1 style="margin: 4px 0 4px;"><span>Technology Data Preparation</span></h1>

                    
                </div>
<div class="wiki-content group" id="main-content">
                    
<p></p>
<div class="toc-macro rbtoc1582191928624">
<ul class="toc-indentation">
<li><a href="#TechnologyDataPreparation-SoftwareRequirements">Software Requirements</a></li>
<li><a href="#TechnologyDataPreparation-TechnologyDataPreparation">Technology Data Preparation</a>
<ul class="toc-indentation">
<li><a href="#TechnologyDataPreparation-LibraryandTechnologyRequirements">Library and Technology Requirements</a></li>
<li><a href="#TechnologyDataPreparation-PreparingtheTechnologyLibrary">Preparing the Technology Library</a></li>
<li><a href="#TechnologyDataPreparation-DeterminingWhetherYourMSOAPDKIsTraditionalorRapid">Determining Whether Your MSOA PDK Is Traditional or Rapid</a></li>
<li><a href="#TechnologyDataPreparation-PreparingtheIPLibrary">Preparing the IP Library</a></li>
<li><a href="#TechnologyDataPreparation-PreparingaTechnologyLibrarywithMultipleLDRSs">Preparing a Technology Library with Multiple LDRSs</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="TechnologyDataPreparation-SoftwareRequirements">Software Requirements</h2>

<p>The following installations &#160;are required to build the flow. There are older versions of Innovus and Virtuoso which have also been qualified for the mixed-signal flow.&#160;</p>
<ul><li>Innovus Implementation System 17.1 or later with IC 6.1.6 ISR6 &#160;or later</li></ul><h2 id="TechnologyDataPreparation-TechnologyDataPreparation">Technology Data Preparation</h2>

<p>This section contains the following:</p>
<ul><li><a href="#TechnologyDataPreparation-LibTechReq">Library and Technology Requirements</a></li><li><a href="#TechnologyDataPreparation-TechLibPrep">Preparing the Technology Library</a></li><li><a href="#TechnologyDataPreparation-commonPDK">Preparing the IP Library</a></li><li><a href="#TechnologyDataPreparation-MultipleLDRS">Preparing a Technology Library with Multiple LDRSs</a></li></ul>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-LibTechReq"></span></p>
<h3 id="TechnologyDataPreparation-LibraryandTechnologyRequirements">Library and Technology Requirements</h3>
<ul><li>Technology and IP data on OpenAccess 2.2 Data Model 4 format</li><li>A common (interoperable) Process Design Kit (PDK), which will have all the necessary technology information for Innovus and Virtuoso. For instruction on how to create a common PDK, please refer to the&#160;<a href="#TechnologyDataPreparation-TechLibPrep">Preparing the Technology Library</a>&#160;section. &#160;</li></ul><ul><li>Liberty timing library for standard cells and IP blocks and chip-level SDC file. If you do not have Liberty files and the chip-level SDC file, it will not be possible to perform static timing analysis of the top-level design.</li></ul><ul><li>Extended FE capacitance table and QRC technology file to support extraction in Innovus.</li></ul><ul><li>Power analysis libraries for enabling VoltageStorm analysis in Innovus.</li></ul>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-TechLibPrep"></span></p>
<h3 id="TechnologyDataPreparation-PreparingtheTechnologyLibrary">Preparing the Technology Library</h3>

<p>Historically, most digital designs have relied on the use of a LEF file to specify the required technology information for the complete implementation of the design. These LEF technology files typically contain a complete set of rules for the metal and cut layers, and a very small subset of rules on the masterslice layers:&#160;<code>poly</code>,&#160;<code>well</code>, and&#160;<code>diffusion</code>.</p>

<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/303237971/303237972.png" data-linked-resource-container-id="303237971" data-linked-resource-container-version="1" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib1.PNG" data-linked-resource-id="303237972" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/303237971/303237972.png" width="640" /></span></p>

<p>The use of the OpenAccess-based interoperable mixed-signal flow requires the implementation of a common OpenAccess Process Design Kit (MSOA PDK). The MSOA PDK&#160;contains the information typically found in a base PDK in addition to that found in the technology LEF. The base PDK, which is the PDK used for Virtuoso, is expected to have at least the foundry rules for the masterslice layers and will typically include the foundry rules for all the metal and cut layers. The LEF would have unique information not present in the PDK: Routing-specific information, such as default routing rules for most nets and non-default rules for selected nets. Default and non-default rules must include the list of valid routing layers and vias. The LEF language requires that routing pitch and width should be included. The LEF file also has antenna checking rules and current density limits, which could be defined in the PDK but is typically not found in a base PDK.</p>

<p>The following diagram shows the desired structure that must be built using the custom IC PDK and the digital implementation library shown above.&#160;</p>

<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/303237971/303237975.png" data-linked-resource-container-id="303237971" data-linked-resource-container-version="1" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib2.PNG" data-linked-resource-id="303237975" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/303237971/303237975.png" /></span></p>

<p>The base library contains all the rules and constraints required to run the Virtuoso implementation environment. The same DRC rules will be used by Innovus, when it uses this technology library. An incremental technology library is created, which contains only the information needed to run the place and route (P&amp;R) environment, such as any custom vias, the LefDefaultRouteSpec (LDRS) and the LefSpecialRouteSpec(LSRS), and the site definition for standard cells in the library. In order to run the P&amp;R environment, Innovus uses abstracts of the standard cells. The standard cell OpenAccess abstracts are the additional incremental technology layer in the library.</p>

<p>Given that Innovus and Virtuoso will obtain technology information from the &quot;Base tech&quot; in the above diagram, there might be a need to reconcile any difference between the tech LEF and the tech DB prior to building the library illustrated above. The resulting MSOA PDK is referred to as a &#8220;Traditional MSOA PDK&#8221;. The implementation of this type PDK is described in detail later in this document.</p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-commonPDK"></span></p>
<h4 id="TechnologyDataPreparation-ImplementinganInteroperable/MSOAPDK">Implementing an Interoperable/MSOA PDK</h4>

<p>As previously mentioned, interoperable PDKs are required to take advantage of OpenAccess-based interoperability for mixed signal designs. Starting from the 18.1 release of Innovus, you now have multiple options for creating an MSOA PDK:</p>
<ul><li>Innovus-only MSOA PDK (useful for experimenting with Innovus in OpenAccess mode)</li><li>Traditional MSOA PDK (available prior to 18.1 and described above)</li><li>Rapid MSOA PDK (available in 18.1 and later releases)</li></ul>
<p>As discussed earlier, the process of creating an MSOA PDK involves populating the tech file used by Virtuoso (base tech) with specific information that is typically only found in a tech LEF (used for the P&amp;R environment).&#160;</p>
<h5 id="TechnologyDataPreparation-CreatinganInnovus-onlyMSOAPDK">Creating an Innovus-only MSOA PDK</h5>
<p>Very often, users who have previously used Innovus in the LEF/DEF mode wish to try running the tool in the OpenAccess mode to better understand how the data is stored when Innovus is run in the OpenAccess mode. When Innovus is run in OpenAccess, the difference in the flow is basically in the initialization steps of the flow; the actual flow scripts that go through all the steps in the flow are identical to the LEF/DEF flow. In the OpenAccess mode, Innovus saves the data for the design into the same lib/cell/view structure that is used by Virtuoso to save the design data. This provides the end user with a unique interoperable environment, where a particular cell view could be opened in either Virtuoso or Innovus, edited, and the edits made available to the other tool.</p>

<p>If the end user is not interested in interoperating the design data between Innovus and Virtuoso and would only like to run Innovus in the OpenAccess mode, the MSOA interoperable PDK could be created using only the tech LEF data.&#160;</p>
<h6 id="TechnologyDataPreparation-DetailedprocessforimplementinganMSOAPDKforuseonlybyInnovus">Detailed process for implementing an MSOA PDK for use only by Innovus</h6>
<p>Steps:</p>
<ol><li>Invoke EDI or Innovus with any design that uses the LEF technology information in which you are interested. Then, invoke&#160;<code>write_oa_techfile</code>.&#160;This command writes out a DFII style ASCII technology file that can later be given to the&#160;<code>techLoadDump</code>&#160;executable to create an equivalent OpenAccess technology database.</li><li>
<p>In the same EDI/Innovus session, run the following command:&#160;<br /><code>write_lef_library -tech_only</code><br />This command creates a LEF file that contains only the LEF technology information. This file will be used in later tasks in this process.</p>
</li><li>In the same EDI/Innovus session, run the following command:&#160;<br /><code>write_lef_library -macro_only</code><br />This command will write out the LEF information for macros in the LEF library. This information will get used by later tasks in this process.</li><li>The next command is available in the Virtuoso and EDI/Innovus hierarchies. However, starting from the 16.1 release of Innovus, this command will only be made available in the Virtuoso hierarchy. Ensure that you have access to the installation you want to use for this step. Invoke the following command with the file created from Step 1:<br /><code>techLoadDump -l -createLib &lt;<em>library_name</em>&gt; &lt;<em>tech_file_from_Step1</em>&gt;</code>.&#160;<br />This command will create an OA library with LEF layers and foundry rules, from the ASCII technology file that was created by the&#160;<code>write_oa_techfile</code>&#160;command.&#160;<br /><strong>Note:</strong>&#160;For advanced node processes (14nm and below), the&#160;<code>techLoadDump</code>&#160;utility from a Virtuoso Advanced Node (ICADV*) Release must be used.</li><li>The next command is available in the EDI/Innovus installation hierarchy. You will be using the output of Step 2 as input for this command. Invoke:<br /><code>lef2oa -pnrLibDataOnly -lef&#160;<em>&lt;file_from_Step2&gt;&#160;</em>-techRefs&#160;<em>&lt;library_created_from_Step4&gt;</em>&#160;-lib&#160;<em>&lt;library_name&gt;</em></code>.&#160;<br />This command maps only library-specific place and route information to an&#160;incremental tech, ignoring foundry rules. The&#160;incremental technology database references a technology database that has complete&#160;foundry information. LEF constructs DIRECTION and PITCH, along with WIDTH, OFFSET, and WIREEXTENSION (if specified) are mapped to constraints in the&#160;<code>LEFDefaultRouteSpec</code>&#160;(LDRS) type constraint group. VIAS and VIARULES defined are&#160;added to the validRoutingVias constraint in the&#160;<code>LEFDefaultRouteSpec</code>. NONDEFAULTRULES are mapped to OpenAccess constraint groups, SITES&#160;are mapped to oaSiteDefs, and MACROS are mapped to abstract oaDesigns. For more information on this command, refer to the&#160;<em>Innovus Text Command Reference</em>&#160;manual.&#160;</li><li>Now that the library has all the rules, the abstracts need to be added to the library to complete the process. In EDI/Innovus, invoke the following command:&#160;<br /><code>lef2oa -lef&#160;<em>&lt;file_from_step3&gt;</em>&#160;-lib&#160;<em>&lt;library_created_in_Step5&gt;</em></code></li></ol><h5 id="TechnologyDataPreparation-CreatingaTraditionalMSOAPDK">Creating a Traditional MSOA PDK</h5>
<p>It is recommended that you seek assistance from Cadence when creating MSOA PDKs for use in the Mixed Signal flow. The PDK factory team at Cadence is available to provide assistance and answer any questions you might have in creating and testing such PDKs. The process for creating traditional MSOA PDKs differs slightly based on the technology node for which the MSOA PDK is being implemented.</p>
<h6 id="TechnologyDataPreparation-CreatingatraditionalMSOAPDKforprocessnodes40nmorolder">Creating a traditional MSOA PDK for process nodes 40nm or older</h6>
<p>The process of creating a traditional MSOA PDK involves transferring data from the tech LEF and the Virtuoso tech to the MSOA PDK by following the arrows in the diagram below:</p>

<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/303237971/303237974.png" data-linked-resource-container-id="303237971" data-linked-resource-container-version="1" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib3.PNG" data-linked-resource-id="303237974" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/303237971/303237974.png" width="640" /></span></p>

<p>The numbers in the above diagram represent the sequence of actions needed to implement the traditional MSOA PDK.</p>

<p>For the above process to work well, you might be required to make updates to the following items in the Virtuoso technology file to reconcile any differences between the tech LEF and the Virtuoso tech file: Layer name and purposes, LPPs, capacitance and resistance information, current density information (if existing in Virtuoso tech), and advanced routing constraints. This is denoted as Step 1 and Step 1a in the above diagram.</p>

<p>Note that many foundries have started delivering Virtuoso tech files that are ready to go through Steps 2 and 3. You should contact the particular foundry to ask for an Innovus-ready Virtuoso tech file.</p>

<p>This method uses the&#160;<code>lef2oa</code>&#160;command in the Innovus hierarchy, and is targeted only at process nodes 40nm or older. Following is an example of how this command can be used to create an MSOA PDK:</p>

<p><code>lef2oa -lef&#160; &lt;<em>name_of_the_LEF_technology_file</em>&gt; -lib &lt;<em>the_MSOA_PDK_to_be_created</em>&gt;&#160; -techRefs &lt;<em>the_base_PDK</em>&gt; -pnrLibDataOnly</code></p>

<p>The above step extracts routing information, such as metal pitch, site definition, NDRs, vias, and so on, from the tech LEF and populates the information in the resulting MSOA PDK. In the diagram above, it is represented as Step 2.</p>

<p>Now you need to create an Incremental Technology Database (ITDB) structure for the standard cells and any macro libraries to be used with the MSOA PDK. This is also done using the&#160;<code>lef2oa</code>&#160;command as shown below:</p>

<p><code>lef2oa -lib&#160; &lt;<em>the_OA_stdcell_lib_to_be_created</em>&gt; -lef&#160; stdcell.lef&#160; -techRefs&#160; &lt;<em>the_MSOA_PDK_created_from_the_previous_step</em>&gt;</code></p>

<p><code>lef2oa -lib &lt;<em>the_marco_library_to_be_created</em>&gt; -lef&#160; macro/lef -techRefs &lt;<em>the_MSOA_PDK_created_from_the_previous_step</em>&gt;</code></p>
<h6 id="TechnologyDataPreparation-CreatingatraditionalMSOAPDKforprocessnodes28nmandbelow">Creating a traditional MSOA PDK for process nodes 28nm and below</h6>
<p>The second method is to be used for 28nm and below. It involves the use of the&#160;<code><a href="../innovusTCR/write_oa_techfile.html">write_oa_techfile</a></code>&#160;command in Innovus to dump out an equivalent OpenAccess representation of the technology information found in the LEF technology file:</p>

<p><code>write_oa_techfile&#160; &lt;<em>filename</em>&gt;</code></p>

<p>After that is done, you can manually add the LEF information to the existing base PDK.</p>

<p>It is common to see a particular foundry update their existing 40nm or older LEF technology files to include rules that are typically found in newer processes. Pay special attention to warning and error messages when using the&#160;<code>lef2oa</code>&#160;command. If messages such as the one below are reported, you are advised to use the&#160;<code>write_oa_techfile</code>&#160;method to implement your interoperable MSOA PDK.</p>

<p><code>INFO: (OALEFDEF-XXXX): &lt;path to the LEF file&gt;(&lt;line numbers in the LEF file&gt;): A LEF58 property named &#39;XXXXXX&#39; with value &#39;yyyy ;&#39; was found in this line range. This property syntax is not supported by the LEF parser. This property string is kept, but is not converted into an OA rule constraint.</code></p>

<p>As can be seen from the above message, there will be a loss in the translation process to bring in the particular LEF information into the OpenAccess PDK.</p>
<h5 id="TechnologyDataPreparation-ImplementingaRapidMSOAPDK">Implementing a Rapid MSOA PDK</h5>
<p>This is the easiest method for creating an MSOA PDK that could be used by Innovus and Virtuoso to implement mixed signal designs. The Rapid MSOA infrastructure removes the necessity for all DRC rules to be consistent between tech LEF and Virtuoso tech for a certain process. In other words, there is no need to change the Virtuoso tech file to align the DRC rules in it with those found in the tech LEF. Virtuoso obtains all the DRC rules from the base tech (the same tech used by Virtuoso in the past), while Innovus gets DRC rules from an ITDB layer that contains all the rules found in the tech LEF.</p>

<p>The main difference between the traditional MSOA PDK and the rapid MSOA PDK is the presence of a new foundry group in the incremental tech file, which will be used exclusively by Innovus for DRC rules.</p>

<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/303237971/303237973.png" data-linked-resource-container-id="303237971" data-linked-resource-container-version="1" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib4.PNG" data-linked-resource-id="303237973" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/303237971/303237973.png" /></span></p>

<p>The table below provide guidelines on the use of rapid MSOA PDKs:</p>
<div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th class="confluenceTh"><br /></th><th class="confluenceTh">
<p><strong>Rapid</strong></p>
</th><th class="confluenceTh">
<p><strong>Traditional</strong></p>
</th></tr>
<tr><td class="confluenceTd">
<p>Same as LEF from an Innovus point of view?</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>Cellviews are interoperable with Virtuoso?</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>OpenAccess tech supports Design Rule Driven (DRD) design and <br />Virtuoso Space-based Router (VSR) with the same rules as LEF?</p>
</td>
<td class="confluenceTd">
<p>No</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>Target processes?</p>
</td>
<td class="confluenceTd">
<p>New process nodes that are often changing</p>
</td>
<td class="confluenceTd">
<p>Process nodes that are stable</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>User who is expected to create the PDK?</p>
</td>
<td class="confluenceTd">
<p>End users who receive frequent LEF updates<br />from their library vendor</p>
</td>
<td class="confluenceTd">
<p>Library vendors</p>
</td>
</tr>
</tbody></table></div>

<p>You can follow the steps outlined below to implement a rapid MSOA PDK:</p>

<p></p>
<ol><li>Read LEF into Innovus using&#160;<code>init_design</code>:<br /><ul><li>A dummy/empty Verilog netlist can be used for this step</li><li>Dump out canonical LEF files using&#160;<code>write_lef_library -tech_only</code>&#160;and&#160;<code>-macro_only</code></li><li>Files created:&#160;<code>TECH.lef</code>&#160;and&#160;<code>MACRO.lef</code></li></ul><code><span class="fontredcadence">set init_lef_file</span> { &lt;<em>list_of_lef_files</em>&gt; }</code><br /><code><code><span class="fontredcadence">set init_verilog</span> { &lt;<em>list_of_verilog_files_or_dummy</em>&gt; }<br /><span class="fontredcadence">set init_top_cell</span> &lt;<em><span class="fontredcadence">top_cell_name</span></em>&gt;</code></code><br /><code>init_design</code><br /><code>write_lef_library -tech_only TECH.lef</code><br /><code>write_lef_library -macro_only MACRO.lef</code></li><li>Determine if the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the LEF are consistent with those in the base PDK. If not, use&#160;<code>sed</code>&#160;to create temp LEF file(s) that align to the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the base PDK.&#160;<br /><strong>Note:</strong>&#160;Details and examples for this step are provided later in this document.</li><li>Use&#160;<code>lef2oa -useFoundryInnovus</code>&#160;to process the&#160;<code>TECH.lef</code>&#160;(or the version created through the optional&#160;<code>sed</code>&#160;step).<br />
<p>If Step 2 was not required, you can use the following command:<br /><code>lef2oa -useFoundryInnovus -lef TECH.lef -lib RapidPDK -techRefs BasePDK</code><br />If you had to use&#160;<code>sed</code>&#160;to rename certain items in Step 2, use the following command (here, the&#160;<code>TECH_OA_NAMES.lef</code>&#160;has been created using&#160;<code>sed</code>):<br /><code>lef2oa -useFoundryInnovus -lef TECH_OA_NAMES.lef -lib RapidPDK -techRefs BasePDK</code></p>
</li><li>
<p>Use&#160;<code>lef2oa</code>&#160;to process the&#160;<code>MACRO.lef</code>:<br /><code>lef2oa -lef MACRO.lef -lib RapidPDK</code>&#160;(If&#160;<code>sed</code>&#160;was not used)&#160;<br /><code>lef2oa -lef MACRO_OA_NAMES.lef -lib RapidPDK</code>&#160;(If&#160;<code>sed</code>&#160;was used)<br />While importing the standard cell LEFs, ensure that the standard cells library does not have any existing cells with the same names. <code>lef2oa</code> cannot override physical data in the standard cell abstract views by default, so you might see the following message:<br /><code>WARNING: (OALEFDEF-50057): stdcell.lef (107464-107522) : MACRO XXXXXX: The macro attempts to redefine obstructions, but updating physical data is not supported. The new obstructions were ignored. Use the -overwrite option to create the designs from scratch.</code><br /><span>If you want to recreate the abstracts for these cells, y</span>ou need use either the <code>-overwrite</code> option of <code>lef2oa</code> or delete the cellview for these cells. However, note that it is possible to import the antenna information for an existing cell from a different LEF file by using <code>lef2oa</code>.</p>
</li><li>Read the OpenAccess library data (from Steps 3 and 4) into Innovus by using&#160;<code>init_design</code>:<br /><ul><li>A dummy/empty Verilog netlist can be used for this step</li><li>Dump out canonical LEF files using&#160;<code>write_lef_library -tech_only</code>&#160;and&#160;<code>-macro_only</code></li><li>Files created:&#160;<code>TECH_RapidPDK.lef</code>&#160;and&#160;<code>MACRO_RapidPDK.lef</code></li></ul><code><span class="fontredcadence">set init_oa_ref_lib</span> { RapidPDK }</code><br /><code><code><span class="fontredcadence">set init_verilog</span> { &lt;<em>list_of_verilog_files_or_dummy</em>&gt; }<br /><span class="fontredcadence">set init_top_cell</span> &lt;<em><span class="fontredcadence">top_cell_name</span></em>&gt;<br /></code></code><code>init_design</code><br /><code>write_lef_library -tech_only TECH_RapidPDK.lef</code><br /><code>write_lef_library -macro_only MACRO_RapidPDK.lef</code></li><li>
<p>Compare the LEF files from Step 5 against the ones from Step 1 or 2. The only differences should be that additional layers from the base PDK that were not in the original LEF will be present:</p>
<ul><li>
<p>If Step 2 was required, compare to the files from that step instead of Step 1. Use:<br /><code>diff TECH.lef TECH_RapidPDK.lef &gt; TECH_RapidPDK.diff</code><br /><code>diff MACRO.lef MACRO_RapidPDK.lef &gt; MACRO_RapidPDK.diff</code></p>
</li><li>If Step 2 was required, use:<br /><code>diff TECH_OA_NAMES.lef TECH_RapidPDK.lef &gt; TECH_RapidPDK.diff</code><br /><code>diff MACRO_OA_NAMES.lef MACRO_RapidPDK.lef &gt; MACRO_RapidPDK.diff</code></li></ul>
<p>Except the additional layers from the base PDK, there should be no differences, which indicates that Innovus should be able to produce identical results as compared to the flows using the the original LEFs.</p>
</li></ol>
<p>As you can see, Steps 1-4 are for creating the rapid PDK, and Steps 5 and 6 are for checking the rapid PDK.</p>

<p><u>Details of Step 2 (using&#160;<code>sed</code>&#160;to create temp LEF file(s) that align to the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the base PDK)</u>:</p>

<p>Simple&#160;<code>sed</code>&#160;syntax is used to make sure that only complete names are mapped. For example,&#160;<code>M1</code>&#160;should be mapped to&#160;<code>METAL1</code>, but&#160;<code>CM1</code>&#160;should not be affected by that mapping. The&#160;<code>sed</code>&#160;approach relies on the white space separated style that is used by the LEF/DEF syntax. It maps any complete name, so it will affect the names inside the property string values as well.</p>

<p>There are some limitation to the use of&#160;<code>sed</code>:</p>
<ul><li>If the LEF file contains names that need to be mapped that are also keywords, then extra processing is required.&#160;<br />Example: Mapping a layer called&#160;<code>PWELL</code>&#160;to&#160;<code>PW</code>&#160;would affect the&#160;<code>TYPE PWELL</code>&#160;as well.</li><li>If the LEF and OpenAccess names are overlapping in some way:<br />Example 1: LEF has&#160;<code>M0</code>,&#160;<code>M1</code>,&#160;<code>M2</code>, ...,&#160;<code>M8</code>&#160;and OpenAccess has layers&#160;<code>M1</code>,&#160;<code>M2</code>,&#160;<code>M3</code>...,&#160;<code>M9<br /></code>To handle this case, the order of statements in the&#160;<code>sed</code>&#160;file is important to prevent the layer&#160;<code>M0</code>&#160;from becoming&#160;<code>M1</code>, then&#160;<code>M2</code>, then&#160;<code>M3</code>, and so on, as the&#160;<code>sed</code>&#160;file is processed (which happens sequentially). This is an unlikely perverse case, but is still easy to handle.<br /><br />Example 2: LEF has CUTCLASS names&#160;<code>SQ</code>&#160;and&#160;<code>RE</code>, while the respective names in OpenAccess are&#160;<code>VSINGLECUT</code>&#160;and&#160;<code>VDOUBLECUT</code>. In addition,&#160;LEF has layers&#160;<code>M1</code>&#160;and&#160;<code>VIA1</code>, while the respective OpenAccess layers are called&#160;<code>METAL1</code>&#160;and&#160;<code>VIA12</code>&#160;as shown in the example below.&#160;</li></ul>
<p>Example:</p>

<p><code>s/\&lt;M1\&gt;/METAL1/g</code><br /><code>s/\&lt;VIA1\&gt;/VIA12/g</code><br /><code>s/\&lt;RE\&gt;/VDOUBLECUT/g</code><br /><code>s/\&lt;SQ\&gt;/VSINGLECUT/g</code></p>

<p>In this case, the following syntax shoud be used:</p>

<p><code>s/\&lt;<em>lef_name</em>\&gt;/<em>oa_name</em>/g</code></p>

<p>The&#160;<code>\&lt;</code>&#160;and&#160;<code>\&gt;</code>&#160;are used to prevent partial matching.</p>

<p>To additionally handle the case where layer&#160;<code>PWELL</code>&#160;needs to be mapped to&#160;<code>PW</code>, the following syntax is required:</p>

<p>(<code><em>lef_names_to_oa_names</em>.sed</code>)</p>

<p><code>s/\&lt;TYPE PWELL\&gt;/TYPE PWELL_temp/g</code></p>

<p><code>s/\&lt;PWELL\&gt;/PW/g</code></p>

<p><code>s/\&lt;M1\&gt;/METAL1/g</code></p>

<p><code>s/\&lt;VIA1\&gt;/VIA12/g</code></p>

<p><code>s/\&lt;RE\&gt;/VDOUBLECUT/g</code></p>

<p><code>s/\&lt;SQ\&gt;/VSINGLECUT/g</code></p>

<p><code>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</code></p>

<p>Using&#160;<code>sed</code>&#160;to map OpenAccess names to LEF names:</p>

<p>To additionally handle the case where layer&#160;<code>PW OR</code>&#160;needs to be mapped to&#160;<code>PWELL</code>&#160;in LEF, the following syntax is required:</p>

<p>(oa_names_to_lef_names.sed)</p>

<p><code><em>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</em></code></p>

<p><code>s/\&lt;PW\&gt;/PWELL/g</code></p>

<p><code>s/\&lt;METAL1\&gt;/M1/g</code></p>

<p><code>s/\&lt;VIA12\&gt;/VIA1/g</code></p>

<p><code>s/\&lt;VDOUBLECUT\&gt;/RE/G</code></p>

<p><code>s/\&lt;VSINGLECUT\&gt;/SQ/g</code></p>

<p><code><em>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</em></code></p>

<p>The lines in Italic font are not actually required because the reverse mapping does not have the collision in this specific case.</p>

<p>The following are not covered by&#160;<code>sed</code>-based mapping:</p>
<ul><li>Special case mapping for LEF and OpenAccess semantic differences, such as:<ul><li>LEF&#160;<code>CM1 MASK1</code>&#160;becoming&#160;<code>CM1A</code>&#160;in OpenAccess</li><li><code>R1</code>&#160;(region layer) handling</li><li><code>*_P48</code>&#160;marker layer support</li></ul>Existing OpenAccess/OAX support is still required for these (OALAYERMAP techParam, and so on)</li><li>There is no scriptable workaround for the case where the same&#160;<code>CUTCLASS</code>&#160;name is used for different layers, but the OpenAccess side has different names for each layer. The names need to be manually synced up in this case.</li></ul><h4 id="TechnologyDataPreparation-RecommendedMethodforCheckingtheIntegrityoftheCommon/InteroperablePDKforInnovus">Recommended Method for Checking the Integrity of the Common/Interoperable PDK for Innovus</h4>

<p>After you have implemented an interoperable PDK, it is recommended that you perform the following steps to ensure that the LEF technology related information contained in the PDK is the same as the information contained in the initial LEF file that was used to create the interoperable PDK. The verification method involves writing the LEF related information out of the PDK and comparing it to the initial LEF. The steps are as follows:</p>
<ol><li>Start Innovus with the interoperable OA PDK, which contains the LEF technology information.</li><li>Use the Innovus command&#160;<code>write_lef_library</code>&#160;to output a LEF file from the interoperable OA PDK. Note that this command outputs a LEF directly from the Innovus DB, and is an exact representation of how the LEF technology data is seen by Innovus.</li><li>Start Innovus again with the original LEF that was used to make the interoperable PDK.</li><li>Use the Innovus command&#160;<code>write_lef_library</code>&#160;to output a LEF file.</li><li>As the output of&#160;<code>write_lef_library</code>&#160;is in a&#160;canonical&#160;format, you can now use the Unix command&#160;<code>tkdiff</code>&#160;to compare the two.</li></ol>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-iplib"></span></p>
<h3 id="TechnologyDataPreparation-DeterminingWhetherYourMSOAPDKIsTraditionalorRapid">Determining Whether Your MSOA PDK Is Traditional or Rapid</h3>

<p>The Innovus command <code>report_oa_lib</code> can be used to determine the type of MSOA PDK technology library being used in the Innovus session.</p>

<p><code>innovus&gt; report_oa_lib &lt;<em>libName</em>&gt;</code></p>

<p>The output of this command will be similar to the following:</p>

<p><code>Library Name        : FEOAreflib

cdsinto.tag exists     : No

Compression Level      : 0

<strong>Rapid PDK : Yes</strong>

Constraint Groups      : 6
 Library Name: FEOAreflib
  LEFDefaultRouteSpec (LEFDefaultRouteSpec, default)
   validLayers: M1 M2 M3 M4 M5 M6 AP 
   validVias: VIAGEN12 VIAGEN23 VIAGEN34 VIAGEN45 

  minSpacing
  minNumCut
  minProtrusionNumCut
  oaMinViaSpacing_FEOAreflib
  LEFSpecialRouteSpec

Technology Graph:
 FEOAreflib</code></p>

<p>If the MSOA PDK is a Rapid MSOA PDK, the report will contain the following line:</p>

<p><code>Rapid PDK&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160; : Yes</code></p>

<p>On the other hand, if the MSOA PDK you are using is traditional, the report will contain the following line:</p>

<p><code>Rapid PDK : No</code></p>
<h3 id="TechnologyDataPreparation-PreparingtheIPLibrary">Preparing the IP Library</h3>
<ol><li>
<p>For opening a design in Innovus, ensure that the IP library contains the abstract views of all IP blocks used at the top level in the design.&#160;</p>

<p>While opening an existing OpenAccess design database, Innovus uses the&#160;<code><span class="fontredcadence">init_oa_ref_lib</span></code>&#160;list and the&#160;<code><span class="fontredcadence">init_abstract_view</span></code>&#160;<span class="fontredcadence">variable</span> values given in the configuration file to read the existing abstract view.</p>
</li><li>If the&#160;<code>SYMMETRY</code>&#160;attribute is not set, you can set the symmetry of a cell using the following SKILL commands in the CIW window of Virtuoso XL:<ul><li><code>cv = geGetWindowCellView(hiGetCurrentWindow())</code></li><li><code>dbSetCellViewSymmetry(cv &quot;XYR90&quot;)</code></li><li><code>dbGetCellViewSymmetry(cv)</code><code><br /></code></li></ul></li><li>If you require the analog property, add the analog property&#160;<code>oacSigTypeAnalog</code>&#160;on analog nets so that Innovus maintains such nets as&#160;<code>dbIsAnalog&#160;true</code>. This is an optional step.&#160;<br />To add the analog property (signal type) in Virtuoso, follow these steps:<ol><li>Right-click the top-most toolbar to invoke the Navigator and the Property Editor.</li><li>Expand Navigator Nets to view all the nets.</li><li>Select the net for which you want to change the signal type.</li><li>Save the design.</li></ol></li><li>To generate abstracts for analog IPs that are finally used by Innovus, use Virtuoso Abstract Generator. Virtuoso Abstract Generator preserves the&#160;<code>oacSigTypeAnalog</code>&#160;on terminal nets in the OpenAccess database.&#160;</li><li>Save the OpenAccess database of IP abstracts to be used by the digital toolsets. Use verilogAnnotate, a stand-alone UNIX utility, to annotate the bus terminal list and order the distributed terms in the physical abstract. The verilogAnnotate utility can be found in the Virtuoso installation hierarchy.&#160;<br />Run the following command:<br /><code>verilogAnnotate -refLibs &lt;&gt; -verilog &lt;&gt;</code><br />If using Virtuoso Layout XL, use the following settings instead of the&#160;<code>verilogAnnotate</code>&#160;command:<br /><code>envSetVal(&quot;layoutXL&quot; &quot;createImplicitBusTerminals&quot; &#39;boolen t)&#160;</code><br />When you create abstracts in Virtuoso Abstract Generator, use:<br /><code>absSetOption( &quot;AnnotateBusInAbstract&quot; &quot;true&quot;)&#160;</code><br />Use&#160;<code>verilogAnnotate</code>&#160;only if you have some legacy IPs that cannot not be modified by any other way.&#160;</li><li>Unset the environment variable&#160;<code>OA_HOME</code>. Ensure that the&#160;<code>OA_HOME</code>&#160;environment variable is not set before running Virtuoso XL/GXL or Innovus. Source the Virtuoso path setting file so that you can get Virtuoso XL/GXL in your&#160;<code>PATH</code>&#160;environment variable.</li><li><span class="confluence-anchor-link" id="TechnologyDataPreparation-pcell"></span>Follow these steps to open the design with parameterized cell (PCell) in Virtuoso XL/GXL, and regenerate the PCell cache:<ol><li>Choose&#160;<em>Tools-Express Pcell Manager</em>.</li><li>Enter the details and enable caching of&#160;<em>Pcell</em>&#160;check box using the&#160;<em>Auto Save</em>&#160;option.</li><li>Click&#160;<em>Save Copy</em>&#160;to save the PCell layout cache.<br />This step enables inter-operation of data between Innovus and Virtuoso platforms. Close the layout window and purge your data from Virtuoso so that the Virtuoso file lock is released.&#160;For more information, see the&#160;<em>Virtuoso XL/GXL User Guide</em>.</li></ol></li></ol>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-MultipleLDRS"></span></p>
<h3 id="TechnologyDataPreparation-PreparingaTechnologyLibrarywithMultipleLDRSs">Preparing a Technology Library with Multiple LDRSs</h3>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>This process will work only for a traditional MSOA PDK. You should not follow these instructions if the MSOA PDK being created is a Rapid MSOA PDK.</p>
</div>
</div>

<p>As previously discussed in this document, a LEFDefaultRouteSpec (LDRS) is a constraint group that gets added to the Virtuoso tech file for use by Place and Route tools, such as the Virtuoso Space Based Router, the Innovus Placement Engine, and the Innovus Router NanoRoute. The LDRS contains the same information as that can be found in a tech LEF file. The LDRS can contain information on routing layers, default vias, pitch, routing direction and width, layer offset, and wire extension rule. The rest of the rules are read from the foundry constraint group in the tech.&#160;</p>

<p>In some cases, you may wish to have one tech file with multiple LDRSs. For example, you may want certain designs to use different widths or routing directions for optimal results while all other designs follow the regular LDRS. In this case, the original LDRS and the modified LDRS could both exist in the tech file. When the tech file is used with Innovus, you can instruct Innovus to pick the correct LDRS by using the following setting:&#160;&#160;</p>

<p><code>init_oa_default_rule&#160; &#160; <em>ruleName&#160;</em></code></p>

<p>Note that the second LDRS should be given a unique name because that is what tells Innovus which LDRS to choose for a particular Innovus session. The tech file needs to be edited to add the second LDRS. If the contents of the tech file is dumped to ASCII, the LDRS will look similar to this example:</p>

<p><code>;********************************</code><br /><code>; CONSTRAINT GROUPS</code><br /><code>;********************************</code><br /><code>constraintGroups(</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( &quot;LEFSpecialRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;nil&#160; &#160; &#160; &#160; &#160; &#160;&quot;LEFSpecialRouteSpec&quot;</code></p>

<p><code>interconnect(</code><br /><code> ( validVias (M2_M1 M3_M2 M4_M3 M5_M4 M6_M5 M7_M6 M8_M7 M9_M8 M10_M9 M11_M10 ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFSpecialRouteSpec</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;LEFDefaultRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160;nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFDefaultRouteSpec&quot;</strong></code></p>

<p><code>routingDirections(</code><br /><code> ( Poly &quot;none&quot; )</code><br /><code> ( Metal1 &quot;horizontal&quot; )</code><br /><code> ( Metal2 &quot;vertical&quot; )</code><br /><code> ( Metal3 &quot;horizontal&quot; )</code><br /><code> ( Metal4 &quot;vertical&quot; )</code><br /><code> ( Metal5 &quot;horizontal&quot; )</code><br /><code> ( Metal6 &quot;vertical&quot; )</code><br /><code> ( Metal7 &quot;horizontal&quot; )</code><br /><code> ( Metal8 &quot;vertical&quot; )</code><br /><code> ( Metal9 &quot;horizontal&quot; )</code><br /><code> ( Metal10 &quot;vertical&quot; )</code><br /><code> ( Metal11 &quot;horizontal&quot; )</code><br /><code> ) ;routingDirections</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Cont&quot; 0.06 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal1&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal1&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal1&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal1&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal1&quot; 0.06 )</code><br /><code> ( minWidth &quot;Via1&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal2&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal2&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal2&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal2&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal2&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via2&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal3&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal3&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal3&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal3&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal3&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via3&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal4&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal4&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal4&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal4&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal4&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via4&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal5&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal5&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal5&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal5&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal5&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via5&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal6&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal6&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal6&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal6&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal6&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via6&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal7&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal7&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal7&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal7&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal7&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via7&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal8&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal8&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal8&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal8&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal8&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via8&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal9&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal9&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal9&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal9&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal9&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via9&quot; 0.18 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal10&quot; 0.5 )</code><br /><code> ( verticalPitch &quot;Metal10&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal10&quot; 0.6 )</code><br /><code> ( verticalOffset &quot;Metal10&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal10&quot; 0.22 )</code><br /><code> ( minWidth &quot;Via10&quot; 0.18 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal11&quot; 0.5 )</code><br /><code> ( verticalPitch &quot;Metal11&quot; 0.475 )</code><br /><code> ( horizontalOffset &quot;Metal11&quot; 0.6 )</code><br /><code> ( verticalOffset &quot;Metal11&quot; 0.57 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal11&quot; 0.22 )</code><br /><code> ) ;spacings</code></p>

<p><code>interconnect(</code><br /><code> ( validLayers (Metal1 Metal2 Metal3 Metal4 Metal5 Metal6 Metal7 Metal8 Metal9 Metal10 Metal11 ) )</code><br /><code> ( validVias (M2_M1_HV M2_M1_VV M2_M1_VH M2_M1_HH M2_M1_2x1_HV_E M2_M1_2x1_HV_W M2_M1_1x2_HV_N M2_M1_1x2_HV_S M3_M2_VH M3_M2_HH M3_M2_HV M3_M2_VV M3_M2_M_NH M3_M2_M_SH M3_M2_2x1_VH_E M3_M2_2x1_VH_W M3_M2_1x2_VH_N M3_M2_1x2_VH_S M4_M3_HV&#160; ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFDefaultRouteSpec</code><br /><code>) ;constraintGroups</code></p>

<p>If the user wishes to add a second LDRS, the ASCII tech file needs to be edited to include the name of the additional LDRS and any specific data that is typically found in the LDRS. In the example below, <code>LEFDefaultRouteSpec_3H</code> is a new LDRS added to an existing tech that already contains a default LDRS.</p>

<p><code>;********************************</code><br /><code>; CONSTRAINT GROUPS</code><br /><code>;********************************</code><br /><code>constraintGroups(</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;</strong>LEFSpecialRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFSpecialRouteSpec&quot;</code></p>

<p><code>interconnect(</code><br /><code> ( validVias (M2_M1 M3_M2 M4_M3 M5_M4 M6_M5 M7_M6 M8_M7 M9_M8 M10_M9 M11_M10 ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFSpecialRouteSpec</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;LEFDefaultRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFDefaultRouteSpec&quot;</strong></code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>..</code></p>

<p><code>&#160; ) ;LEFDefaultRouteSpec</code></p>

<p><br /></p>

<p><code>( <strong>&quot;LEFDefaultRouteSpec_3H&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160;</strong> &#160; &#160; &#160; &#160; &#160;&#160;</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>&#160; ) ;LEFDefaultRouteSpec_3H</code></p>

<p>Note that the second LDRS (<code>LEFDefaultRouteSpec_3H</code>) did not need to be defined as a LEFDefaultRouteSpec, as Innovus will search the tech for the name specified using the following command:</p>

<p><code>init_oa_default_rule&#160; <strong>LEFDefaultRouteSpec_3H</strong></code></p>

                    </div>
<br /><br /></div>
<footer xmlns:html="http://www.w3.org/1999/xhtml"><nav class="navigation"><b><em><a href="Overview_of_Mixed_Signal_Interoperability.html" id="prev" title="Overview_of_Mixed_Signal_Interoperability">Overview_of_Mixed_Signal_Inter ...</a></em></b><b><em><a href="Design_Data_Preparation.html" id="nex" title="Design_Data_Preparation">Design_Data_Preparation</a></em></b></nav><div>
          For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2020, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved.
        </div>
</footer><br xmlns:html="http://www.w3.org/1999/xhtml" /></body></html>