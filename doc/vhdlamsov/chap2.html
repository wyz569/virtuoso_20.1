
<html><head><title>VHDL-AMS Modeling Styles</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jommy" />
<meta name="CreateDate" content="2019-09-18" />
<meta name="CreateTime" content="1568824580" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="This book contains overview information about VHDL-AMS for AMS Designer." />
<meta name="DocTitle" content="Cadence VHDL-AMS Overview" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="VHDL-AMS Modeling Styles" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-3.1" />
<meta name="Keyword" content="vhdlamsov" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2019-09-18" />
<meta name="ModifiedTime" content="1568824580" />
<meta name="NextFile" content="chap3.html" />
<meta name="Group" content="Analog Mixed-Signal Simulation" />
<meta name="Platform" content="Functional Verification" />
<meta name="PrevFile" content="chap1.html" />
<meta name="Product" content="Xcelium" />
<meta name="ProductFamily" content="Xcelium" />
<meta name="ProductVersion" content="19.09" />
<meta name="RightsManagement" content="Copyright 2012-2019 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence VHDL-AMS Overview -- VHDL-AMS Modeling Styles" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="product_feature" content="" />
<meta name="product_subfeature" content="" />
<meta name="Version" content="19.09" />
<meta name="SpaceKey" content="vhdlamsov1909" />
<meta name="webflare-version" content="1.4" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" /></head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="vhdlamsovTOC.html">Contents</a></li><li><a class="prev" href="chap1.html" title="Introduction">Introduction</a></li><li style="float: right;"><a class="viewPrint" href="vhdlamsov.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap3.html" title="Example: Design Entity">Example: Design Entity</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence VHDL-AMS Overview<br />Product Version 19.09, September 2019</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;">

<h1>2
<a id="pgfId-1032955"></a></h1>
<h1>
<a id="pgfId-1033821"></a><hr />
VHDL-AMS Modeling Styles<hr />
</h1>

<p>
<a id="pgfId-1039260"></a>You can read about the following topics in this chapter:</p>
<ul><li>
<a id="pgfId-1039268"></a><a href="chap2.html#98881">Levels of Abstraction</a></li><li>
<a id="pgfId-1039276"></a><a href="chap2.html#67672">Analog Abstraction Hierarchy</a></li><li>
<a id="pgfId-1039329"></a><a href="chap2.html#93961">Conservative Systems</a></li><li>
<a id="pgfId-1039281"></a><a href="chap2.html#99683">Analog Systems</a></li><li>
<a id="pgfId-1039286"></a><a href="chap2.html#95220">Design Hierarchy</a></li><li>
<a id="pgfId-1039301"></a><a href="chap2.html#21076">Digital Abstraction Hierarchy</a></li><li>
<a id="pgfId-1039291"></a><a href="chap2.html#42407">Mixed-Signal Systems</a></li></ul>







<h2>
<a id="pgfId-1038202"></a><a id="98881"></a>Levels of Abstraction</h2>

<p>
<a id="pgfId-1033850"></a>Design abstraction is a strategy for managing complexity and hiding and showing details. At lower levels of abstraction, more details are exposed and the behavior of the model is closer to the complexity of the physical implementation of a design. At higher levels of abstraction, less detail is exposed and the behavior of the model is further from the physical implementation of the design. Typically, designs using higher levels of abstraction simulate faster that designs using lower levels of abstraction.</p>
<p>
<a id="pgfId-1035008"></a>VHDL-AMS provides blocks that you can use to partition and organize designs into hierarchies. Multiple levels of nested blocks are allowed. The internal details of these relationships can be shown or hidden from view, as desired. The hierarchy consists of behavioral and structural elements. The structural elements define the parent/child relationships. As illustrated in the following diagram, these relationships can be represented as a tree structure</p>

<p>
<a id="pgfId-1038449"></a></p>
<div class="webflare-div-image">
<img width="668" height="302" src="images/chap2-2.gif" /></div>
<h2>
<a id="pgfId-1034271"></a><a id="67672"></a>Analog Abstraction Hierarchy</h2>

<p>
<a id="pgfId-1034523"></a>The tables below list the levels of abstraction most often associated with analog circuits.</p>

<p>
<a id="pgfId-1035678"></a>.</p>
<table class="webflareTable" id="#id1035619">
<caption style="text-align:left;"><p>
</p><h4>Table 2-1
<a id="pgfId-1037638"></a>Abstraction Hierarchy for the Analog Functional Domain</h4></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037642">
<a id="pgfId-1037642"></a>Level</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037644">
<a id="pgfId-1037644"></a>Description</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037646"></a>Functional or behavioral signal flow</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037648"></a>Describes signal flow input/output relations by mathematical functions. For example, you might model an op-amp as an output that is a function of its input.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037650"></a>Functional or behavioral conservative</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037652"></a>Uses equations to describe relations between terminals. You might use this level of abstraction to model a capacitor that takes second order effects into account.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037654"></a>Ideal equations</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037656"></a>Uses idealized device models</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037658"></a>Characteristic equations</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037660"></a>Uses device models that include second order effects</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1037270"></a></p>
<table class="webflareTable" id="#id1037271">
<caption style="text-align:left;"><p>
<ft-figtabl-title id="#id1037297">
<a id="pgfId-1037297"></a>Table 2-2 Abstraction Hierarchy for the Analog Structural Domain</ft-figtabl-title>
</p></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037273">
<a id="pgfId-1037273"></a>Level</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037275">
<a id="pgfId-1037275"></a>Description</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037277"></a>System transfer functions</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037279"></a>Models signal flow between system level blocks</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037281"></a>Macro Models</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037283"></a>Uses a parameterizable block of device models to model some complex function</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037285"></a>Ideal sources and devices</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037287"></a>Uses idealized device models</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037289"></a>Nets and devices</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037291"></a>Uses primitive devices and wire models that include second order effects</p>
</td>
</tr>
</tbody></table>
<h2>
<a id="pgfId-1037661"></a><a id="93961"></a>Conservative Systems</h2>

<p>
<a id="pgfId-1035722"></a>A <em>conservative</em><a id="marker-1035718"></a><a id="marker-1035719"></a> <em>system</em> is one that obeys the laws of conservation described by <a id="marker-1035720"></a>Kirchhoff&#8217;s Potential and<a id="marker-1035723"></a> Flow laws. Across quantities define the potential between two terminals. Through quantities define the flow through a terminal (to another terminal).</p>

<h3>
<a id="pgfId-1038525"></a>Terminals</h3>

<p>
<a id="pgfId-1038526"></a>A terminal is a point of physical connection between devices of continuous-time descriptions. Terminals obey conservation-law semantics.</p>

<h3>
<a id="pgfId-1035734"></a>Reference Terminal</h3>

<p>
<a id="pgfId-1035737"></a>The potential of a single terminal is defined with respect to a reference terminal. The reference terminal, often called <em>ground</em><a id="marker-1035738"></a> in electrical systems, has a potential of zero.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1037877"></a>NATURE electrical IS voltage ACROSS current THROUGH ground REFERENCE;</pre>

<p>
<a id="pgfId-1036953"></a>The reference terminal is declared as part of the nature declaration, can have any name, but is a unique terminal. A terminal (node in Verilog) cannot be arbitrarily declared to be the reference. See LRM 4.8.</p>

<h3>
<a id="pgfId-1035742"></a>Reference Directions</h3>

<p>
<a id="pgfId-1035745"></a>Each branch quantity has a <a id="marker-1035743"></a>reference direction<a id="marker-1035744"></a>. For example, consider the following schematic. With the reference direction shown, the potential in this schematic is positive whenever the potential of the terminal marked with a plus sign is larger than the potential of the terminal marked with a minus sign.</p>

<p>
<a id="pgfId-1035764"></a></p>
<div class="webflare-div-image">
<img width="503" height="67" src="images/chap2-3.gif" /></div>

<p>
<a id="pgfId-1036748"></a>The direction of a branch quantity is determined by the order of the terminals in the terminal_aspect of the branch quantity declaration. See LRM 4.3.1.6. So, for example:</p>

<pre class="webflare-courier-new">
<a id="pgfId-1036753"></a>QUANTITY vx ACROSS ix THROUGH t1 TO t2; </pre>

<p>
<a id="pgfId-1036972"></a>declares an across quantity <code>vx</code> from terminal <code>t1</code> to terminal <code>t2</code>. The value of <code>vx</code> is positive if terminal <code>t1</code> has a higher potential than terminal <code>t2</code> (it would be negative if <code>t2</code> had a higher potential than <code>t1</code>). It also declares a through quantity <code>ix</code> through <code>t1</code> to <code>t2</code>. If the flow is from <code>t1</code> to <code>t2</code> then the value of <code>ix</code> is positive (if the flow is from <code>t2</code> to <code>t1</code> then the value of <code>ix</code> is negative). If we change the declaration to:</p>

<pre class="webflare-courier-new">
<a id="pgfId-1036755"></a>QUANTITY vx ACROSS ix THROUGH t2 TO t1;</pre>

<p>
<a id="pgfId-1036976"></a>the value of <code>vx</code> and <code>ix</code> change signs.</p>

<h2>
<a id="pgfId-1035786"></a><a id="99683"></a>Analog Systems</h2>

<p>
<a id="pgfId-1035787"></a>For analog systems, the simulator uses Kirchhoff&#8217;s laws to develop equations that define the values and flows in the system. Because the equations can be differential and nonlinear, the simulator does not solve them directly. Instead, the simulator uses an approximation and solves the equations iteratively at individual time points (also called solution points). The simulator controls the interval between the time points to ensure the accuracy of the approximation. </p>
<p>
<a id="pgfId-1035980"></a>At each time point, iteration continues until two convergence criteria are satisfied. The first criterion requires that the approximate solution on this iteration be close to the accepted solution on the previous iteration. The second criterion requires that Kirchhoff&#8217;s Flow Law be adequately satisfied. To determine the required accuracy for these criteria, the simulator uses the tolerances specified in the design. </p>
<p>
<a id="pgfId-1037921"></a>An analog model contains three equation sets: the explicit set, the structural set, and the augmentation set. The explicit set is derived from the simultaneous statements that describe the signal flow behavior of free quantities and the branch behavior of branch quantities. The structural set, which is derived from Kirchoff&#8217;s Laws, constrains a network of branches to obey conservation of charge and potential. The augmentation set describes how <code>&#8217;DOT</code> and <code>&#8217;INTEG</code> are defined under various conditions such as computing initial state or solving a time integration step. At each solution point, the analog solver finds a simultaneous solution to the combined equations from all three sets.</p>

<h3>
<a id="pgfId-1035862"></a><a id="99089"></a>Simultaneous <a id="simultaneousStatements"></a>Statements</h3>

<p>
<a id="pgfId-1036582"></a>Simultaneous statements are algebraic and differential equations used to define the analog behavior of a system. For example: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1036585"></a>simple_expression <strong>==</strong> simple_expression<strong>;</strong></pre>

<p>
<a id="pgfId-1036019"></a><code>simple-expression</code> can contain linear, nonlinear, or differential equations involving operations on any value bearing construct (such as quantities, variables, constants, attributes, and arrays of constants, generics or signals). </p>
<p>
<a id="pgfId-1039142"></a>For example, the following signal flow description produces the sum and product of its inputs: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1038819"></a>entity am is <br />    port(quantity in1, in2: in real; quantity outsum, outmult: out real); <br />end am;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1038577"></a>architecture am_behav of am is <br />begin <br />    outsum == in1 + in2; <br />    outmult == in1 * in2; <br />end am_behav; </pre>

<p>
<a id="pgfId-1039080"></a>You can define dynamic relationships between the inputs and outputs of modules. For example, here is a conservative model behavioral description for a capacitor:</p>

<pre class="webflare-courier-new">
<a id="pgfId-1039081"></a>entity cap is <br />    generic(c : real := 1.0e-3); <br />    port (TERMINAL n, p: electrical); <br />end cap;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1038578"></a>architecture cap_behav of cap is <br />    quantity vcap across icap through n to p; <br />begin <br />    icap == vcap&#8217;dot * c; <br />end cap_behav; </pre>

<p>
<a id="pgfId-1035905"></a>The <code>&#8217;i</code>nteg attribute is used to relate quantities to time integrals of other quantities. For example, the following signal flow model sets the output to the integral of the input (with respect to time). The <code>break</code> statement specifies the initial conditions on <code>input&#8217;integ</code>, which are needed during DC analysis.</p>

<pre class="webflare-courier-new">
<a id="pgfId-1039119"></a>entity integrator is 
&#160;&#160;&#160;&#160;port (quantity input: in real; quantity output : out real); 
end integrator; 

architecture integrator_behav of integrator is 
begin 
&#160;&#160;&#160;&#160;break input&#8217;integ =&gt; 0.0; 
&#160;&#160;&#160;&#160;output == input&#8217;integ; <br />end integrator_behav; </pre>

<p>
<a id="pgfId-1039103"></a>You can perform index and slice operations on signal arrays in simultaneous equations. <br />For example: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1039399"></a>Signal s : real_vector(0 to 3) := (0.0, 0.0, 0.0, 0.0); <br />Quantity q1 : real_vector (0 to 3); <br />Quantity  q2 : real; <br />q1 == s; <br />q2 == s(2); </pre>

<p>
<a id="pgfId-1039383"></a>If you are using the Spectre or UltraSim solver with the simulation front end (SFE) parser, you can also perform index and slice operations on constant and generic arrays in simultaneous equations. For example: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1039175"></a>s == paramB( 1 downto 0 ); </pre>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1039176"></a>The array slice must have the same direction (such as <code>downto</code>) as the array declaration.</div>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1039148"></a>
You can perform index and slice operations on constant, generic, and signal arrays only in simultaneous statements. You must be using the SFE parser in order to use constant and generic arrays in this way. </div>

<p>
<a id="pgfId-1039226"></a>You can assign a whole quantity array to a whole constant, generic, or signal array. <br />For example: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1039149"></a>r == paramA; </pre>

<p>
<a id="pgfId-1039150"></a>You can access individual bits of a constant, generic, or signal array using another constant (such as <code>constIndex</code> here): </p>

<pre class="webflare-courier-new">
<a id="pgfId-1039152"></a>t == paramB( constIndex ); </pre>

<p>
<a id="pgfId-1039153"></a>In an analog context (and using the SFE parser), you can pass the result of a constant or generic indexed expression to a user-defined function. For example: </p>

<pre class="webflare-courier-new">
<a id="pgfId-1039155"></a>x == addParams( q(0) - paramB(0), q(1) + paramB(1) ); </pre>
<h3>
<a id="pgfId-1036695"></a>Conditional Behavior in Simultaneous Statements</h3>

<p>
<a id="pgfId-1037021"></a>You can use simultaneous conditional statements to define behavior in regions. The following architecture describes a voltage deadband amplifier <code>vdba</code>. For example, the conditional <code>if-else</code> structure describes the piecewise linear approximation of the characteristics of the amplifier. If the input voltage is greater than vin_high or less than vin_l<code>ow</code>, the amplifier is active. When the amplifier is active, the output is the gain times the differential voltage between the input voltage and the edge of the deadband. When the input is in the deadband between vin_low and <code>vin_high</code>, the amplifier is quiescent, and the output voltage is zero.</p>

<p>
<a id="pgfId-1038311"></a></p>
<div class="webflare-div-image">
<img width="667" height="180" src="images/chap2-5.gif" /></div>
<pre class="webflare-courier-new">
<a id="pgfId-1037385"></a>ENTITY vdba IS
&#160;&#160;&#160;&#160;GENERIC (vin_low : REAL := -2.0; vin_high : REAL := 2.0; gain : REAL := 1.0);
&#160;&#160;&#160;&#160;PORT (QUANTITY input : IN REAL; QUANTITY output : OUT REAL);<br />END vdba;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1038609"></a>ARCHITECTURE vdba_behav OF vdba IS
BEGIN
&#160;&#160;&#160;&#160;IF (input &gt;= vin_high) USE
&#160;&#160;&#160;&#160; output == gain * (input - vin_high);<br /> ELSIF (input &lt;= vin_low) USE<br />  output == gain * (input - vin_low);<br /> ELSE<br />  output == 0.0;<br /> END USE;<br />END vdba_behav;</pre>

<p>
<a id="pgfId-1037424"></a>The following graph shows the response of the amplifier to a sinusoidal source.</p>

<p>
<a id="pgfId-1038312"></a></p>
<div class="webflare-div-image">
<img width="668" height="178" src="images/chap2-6.gif" /></div>
<h2>
<a id="pgfId-1036124"></a><a id="95220"></a>Design Hierarchy</h2>

<p>
<a id="pgfId-1037483"></a>Hierarchy is supported by means of <em>instantiation</em>, which refers to the process of creating an instance of a design entity inside another design entity. Such instances are referred to as components.</p>
<p>
<a id="pgfId-1037506"></a>Here is an example of an architecture that contains component instantiation.</p>

<p>
<a id="pgfId-1039333"></a></p>
<div class="webflare-div-image">
<img width="379" height="145" src="images/chap2-7.gif" /></div>
<pre class="webflare-courier-new">
<a id="pgfId-1037510"></a>ENTITY rc IS
&#160;&#160;&#160;&#160;PORT (TERMINAL t1, t2: electrical);<br />END rc;</pre>
<pre class="webflare-courier-new">
<a id="pgfId-1038619"></a>ARCHITECTURE rc_behav OF rc IS
&#160;&#160;&#160;&#160;component cap IS
&#160;&#160;&#160;&#160; port (terminal t1, t2: electrical);<br />  generic (rval : real := 1.0e-3);<br /> end component;<br /> for all : cap_comp use entity work.cap(cap_behav);<br /> component resistor is<br />  port (terminal t1, t2: electrical);<br />  generic (cval := real := 1000.0);<br /> end component;<br /> for all : resistor_comp use entity work.resistor(resistor_behav);<br /> r1: resistor_comp<br />  generic map(2000.0)<br />  port map(t1, t2);<br /> c1 : capacitor_comp<br />  generic map (2.0e-3)<br />  port map(t2, gnd);<br />END rc_behav;</pre>
<h2>
<a id="pgfId-1037478"></a><a id="21076"></a>Digital Abstraction Hierarchy</h2>

<p>
<a id="pgfId-1035680"></a>Just as analog blocks have different levels of abstraction, digital models can also be categorized according to their level of abstraction. The following table shows the abstraction hierarchy associated with digital models and systems.</p>

<p>
<a id="pgfId-1036160"></a></p>
<table class="webflareTable" id="#id1036161">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037736">
<a id="pgfId-1037736"></a>Level</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037738">
<a id="pgfId-1037738"></a>Modeling Method</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037740">
<a id="pgfId-1037740"></a>Structural Primitive</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1037742">
<a id="pgfId-1037742"></a>Time Model</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037744"></a>System level</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037746"></a>Cooperating processing units</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037748"></a>CPU, memory, bus</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037750"></a>Causality</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037752"></a>Chip level</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037754"></a>Parallel algorithms</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037756"></a>Controller, RAM, ROM, UART</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037758"></a>Discrete (fine/coarse granularity)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037760"></a>Register transfer level</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037762"></a>Guarded commands</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037764"></a>Register, counter, ALU, multiplexor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037766"></a>Discrete (coarse granularity)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037768"></a>Logic gate level</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037770"></a>Boolean logic equations</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037772"></a>Gate, flip-flop</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037774"></a>Discrete (fine granularity)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037776"></a>Circuit level</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037778"></a>Differential equations</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037780"></a>Transistor, R, L, C</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1037782"></a>Continuous</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1033957"></a>A digital description can use several of these different styles simultaneously. </p>

<h3>
<a id="pgfId-1037796"></a><a id="12082"></a>System Level</h3>

<p>
<a id="pgfId-1037797"></a>As the name suggests, a system-level design can describe a complete system, comprising multiple PCBs connected to a backplane bus, although a system level description does not always contain a vast amount of structural information. In addition to the models of the hardware components making up a system, system-level designs often model the bus systems or networks used to interconnect the components. For example, a VHDL description of a computer interface card might be verified by using a VHDL model of the computer system bus and connecting the two of them together to form a testbench. </p>

<h3>
<a id="pgfId-1037808"></a><a id="90779"></a>Chip Level</h3>

<p>
<a id="pgfId-1037809"></a>Chip-level VHDL descriptions fall into two general categories: those intended for synthesis, and those intended for simulation. The first category consists of RTL descriptions forming a top-level structure without any detailed timing information other than basic clocking relationships. The chip being described is typically an FPGA or cell-based ASIC. </p>
<p>
<a id="pgfId-1037810"></a>The second category of chip-level descriptions are those intended for simulation. These descriptions are primarily behavioral models whose purpose is to accurately simulate the behavior of the chip at the pin level. The internal organization of the model is not important. To achieve this, the models generally include detailed timing behavior, extracted from the manufacturer&#39;s data sheets, concerning the behavior of the device interface pins under most conditions.</p>
<p>
<a id="pgfId-1037811"></a>Many IC manufacturers are producing accurate VHDL models for their standard devices. Models are available for a large range of devices covering simple gates to full-blown microprocessors. The primary purpose of these models is to enable a designer to perform a realistic simulation of a full system.</p>

<h3>
<a id="pgfId-1037820"></a><a id="68858"></a>Register Transfer Level</h3>

<p>
<a id="pgfId-1037821"></a>Register transfer level (RTL) descriptions are the most commonly used style of VHDL description. At this level, systems are described in terms of combinational and sequential functions at the behavioral level. The functions are often described using individual processes and interconnected using signals to form a dataflow. Typical functions included in an RTL description are registers, counters, and state machines along with combinational functions such as multiplexors, arithmetic units, and decoders. The RTL style can include some structural information via the dataflow. However, the individual functional blocks are described using behavioral constructs rather than instantiated gates and flip-flops. Many designs consist of registers interspersed with combinational functions and together these form the datapath. Transfers between registers and operations carried out by combinational functions are controlled by the controller or control path, which is usually a behavioral description of a finite state machine. </p>
<p>
<a id="pgfId-1037822"></a>The RTL level of description is particularly relevant to users of logic synthesis, because this is the accepted level for designs that are intended for synthesis.</p>

<h3>
<a id="pgfId-1037831"></a><a id="18377"></a>Logic Gate Level</h3>

<p>
<a id="pgfId-1037832"></a>VHDL-AMS provides many features for the support of gate-level simulation, the most useful being the Boolean operators (AND, OR, XOR, etc.), which correspond directly to the gate-level primitives. Boolean circuit algebra does not directly address the important delay time of the components so time values must be attributed by additional models. </p>
<p>
<a id="pgfId-1037833"></a>In addition to basic logic gates, this level includes other low-level primitives such as flip-flops and latches. VHDL-AMS descriptions written at this level are referred to as netlists or wirelists because they consist of a list of components and interconnections. VHDL netlists are often generated automatically from a schematic or as part of the output of a synthesis tool. </p>
<p>
<a id="pgfId-1037834"></a>Gate-level simulation is often performed during the latter stages of the design process after the design has been synthesized from a higher level description. Such synthesized designs can contain hundreds of thousands of gates so simulation performance is an important issue.</p>

<h3>
<a id="pgfId-1037793"></a><a id="83306"></a>Circuit Level</h3>

<p>
<a id="pgfId-1035673"></a>The circuit level consists of interconnected active and passive components. Circuit behavior within time domain is represented by means of nonlinear differential equations. This level acts as a link to physical representations of digital circuits.</p>

<h2>
<a id="pgfId-1037624"></a><a id="42407"></a><a id="54552"></a><a id="53667"></a>Mixed-Signal Systems</h2>

<p>
<a id="pgfId-1036716"></a>Mixed-signal systems and circuits generate and consume both continuous and discrete signals in the digital partition, while in the analog partition the values are continuous. Digital operates in the discrete time domain while analog operates with continuous time values so signal values must be converted as they move from one domain to the other. Each partition can be denoted at any abstraction level.</p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap1.html" id="prev" title="Introduction">Introduction</a></em></b><b><em><a href="chap3.html" id="nex" title="Example: Design Entity">Example: Design Entity</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2019, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
</body></html>