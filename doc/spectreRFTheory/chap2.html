
<html><head><title>The Spectre RF Analyses</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jommy" />
<meta name="CreateDate" content="2020-02-25" />
<meta name="CreateTime" content="1582698061" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the theory underpinning Virtuoso Spectre Circuit Simulator RF Analysis (Spectre RF)." />
<meta name="DocTitle" content="Spectre Circuit Simulator RF Analysis Theory" />
<meta name="DocType" content="Reference" />
<meta name="FileTitle" content="The Spectre RF Analyses" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-3.1" />
<meta name="Keyword" content="spectreRFTheory" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2020-02-25" />
<meta name="ModifiedTime" content="1582698061" />
<meta name="NextFile" content="chap3.html" />
<meta name="Group" content="SpectreRF" />
<meta name="Platform" content="Custom IC Design" />
<meta name="PrevFile" content="chap1.html" />
<meta name="Product" content="Spectre" />
<meta name="ProductFamily" content="Spectre" />
<meta name="ProductVersion" content="19.1" />
<meta name="RightsManagement" content="Copyright 2012-2020 Cadence Design Systems Inc." />
<meta name="Title" content="Spectre Circuit Simulator RF Analysis Theory -- The Spectre RF Analyses" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="product_feature" content="" />
<meta name="product_subfeature" content="" />
<meta name="Version" content="19.1" />
<meta name="SpaceKey" content="spectreRFTheory191" />
<meta name="webflare-version" content="1.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" /></head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="spectreRFTheoryTOC.html">Contents</a></li><li><a class="prev" href="chap1.html" title="Basic Reference Information">Basic Reference Information</a></li><li style="float: right;"><a class="viewPrint" href="spectreRFTheory.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap3.html" title="Oscillators and Autonomous PSS Analysis">Oscillators and Autonomous PSS ...</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Spectre Circuit Simulator RF Analysis Theory<br />Product Version 19.1, January 2020</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>2
<a id="pgfId-428099"></a><a id="marker-451721"></a></h1>
<h1>
<a id="pgfId-1020886"></a><hr />
The Spectre RF Analyses<hr />
</h1>

<p>
<a id="pgfId-1039262"></a><sup> </sup>Spectre<sup>&#174; </sup>circuit simulator RF analysis (Spectre RF) <a id="PSS_QPSSanalyses"></a>provides unique analyses that are useful on RF circuits. These analyses directly compute the steady-state response and the small-signal behavior of circuits that exhibit frequency translation.</p>
<p>
<a id="pgfId-1043931"></a>The individual Spectre RF analyses described in this section are</p>
<ul><li>
<a id="pgfId-1043935"></a>PSS (large-signal analysis). See <a href="chap2.html#92652">&#8220;Periodic Steady-State Analysis (PSS)&#8221;</a>.</li><li>
<a id="pgfId-1043937"></a>PAC (small-signal analysis). See <a href="chap2.html#29491">&#8220;Periodic AC Analysis (PAC)&#8221;</a>.</li><li>
<a id="pgfId-1043997"></a>PSP (small-signal analysis). See <a href="chap2.html#20945">&#8220;Periodic S-Parameter Analysis (PSP)&#8221;</a>.</li><li>
<a id="pgfId-1044007"></a>PXF (small-signal analysis). See <a href="chap2.html#11860">&#8220;Periodic Transfer Function Analysis (PXF)&#8221;</a>.</li><li>
<a id="pgfId-1044037"></a>Pnoise (small-signal analysis). See <a href="chap2.html#33596">&#8220;Periodic Noise Analysis (Pnoise)&#8221;</a>.</li><li>
<a id="pgfId-1027557"></a>PSTB (periodic stability analysis). See <a href="chap2.html#56366">&#8220;Periodic Stability Analysis (PSTB)&#8221;</a>.</li><li>
<a id="pgfId-1044093"></a>QPSS (large-signal analysis). See <a href="chap2.html#65248">&#8220;Quasi-Periodic Steady-State Analysis (QPSS)&#8221;</a>.</li><li>
<a id="pgfId-1044050"></a>QPnoise (small-signal analysis). See <a href="chap2.html#95696">&#8220;Quasi-Periodic Noise Analysis (QPnoise)&#8221;</a>.</li><li>
<a id="pgfId-1044059"></a>QPAC (small-signal analysis). See <a href="chap2.html#16587">&#8220;Quasi-Periodic AC Analysis (QPAC)&#8221;</a>.</li><li>
<a id="pgfId-1044015"></a>QPSP (small-signal analysis). See <a href="chap2.html#23623">&#8220;Quasi-Periodic S-Parameter Analysis (QPSP)&#8221;</a>.</li><li>
<a id="pgfId-1044019"></a>QPXF (small-signal analysis). See <a href="chap2.html#63409">&#8220;Quasi-Periodic Transfer Function Analysis (QPXF)&#8221;</a>.</li><li>
<a id="pgfId-1027561"></a>ENVLP (envelope analysis). See <a href="chap2.html#48507">&#8220;Envelope Analysis (ENVLP)&#8221;</a>.</li><li>
<a id="pgfId-1054652"></a>HB (large-signal analysis). See <a href="chap2.html#56537">&#8220;Harmonic Balance Steady State Analysis (HB)&#8221;</a>.</li><li>
<a id="pgfId-1054656"></a>HBAC (small-signal analysis). See <a href="chap2.html#94160">&#8220;Harmonic Balance AC Analysis (HBAC)&#8221;</a>.</li><li>
<a id="pgfId-1054660"></a>HBnoise (small-signal analysis). See <a href="chap2.html#24789">&#8220;Harmonic Balance Noise Analysis (HBnoise)&#8221;</a>.</li><li>
<a id="pgfId-1058469"></a>HB S-Parameter Analysis (hbsp). See <a href="chap2.html#71960">&#8220;HB S-Parameter Analysis (hbsp)&#8221;</a></li><li>
<a id="pgfId-1058492"></a>Envelope Analysis (ENVLP). See <a href="chap2.html#48507">&#8220;Envelope Analysis (ENVLP)&#8221;</a></li></ul>

















<h2>
<a id="pgfId-1027573"></a><a id="92652"></a>Periodic Steady-State Ana<a id="marker-1027572"></a>lysis (PSS)</h2>

<p>
<a id="pgfId-1027574"></a>The <a id="PSS"></a>PSS analysis computes the periodic steady-state response of a circuit at a specified fundamental frequency, with a simulation time independent of the time-constants of the circuit. The PSS analysis also determines the circuit&#8217;s periodic operating point which is the required starting point for the periodic time-varying small-signal analyses: PAC, PSP, PXF, and Pnoise.</p>

<h3>
<a id="pgfId-1035503"></a>The Shooting Method</h3>

<p>
<a id="pgfId-1035510"></a>Spectre RF simulation traditionally uses a technique called the sho<a id="shooting method"></a>oting method to implement PSS analysis. This method is an iterative, time-domain method which starts with a guess or estimate of the initial condition and ultimately finds an initial condition that directly results in a steady-state solution.</p>
<p>
<a id="pgfId-1027582"></a>The shooting method requires few iterations if the final state of the circuit after one period is a near-linear function of the initial state. This is usually true even for circuits that have strongly nonlinear reactions to large stimuli (such as the clock or the local oscillator). Typically, shooting methods need about five iterations on most circuits, and they easily simulate the nonlinear circuit behavior within the shooting interval.</p>
<p>
<a id="pgfId-1027584"></a>Cadence&#8217;s Fourier integral method, a new approach to Fouri<a id="marker-1027583"></a>er analysis, makes PSS analysis using the shooting engine more accurate with strongly nonlinear circuits than previous methods. Cadence&#8217;s Fourier integral method approaches the accuracy of harmonic balance simulators for near-linear circuits, and far exceeds it for strongly nonlinear circuits.</p>
<p>
<a id="pgfId-1027585"></a>In the case of a driven circuit, when you set <code>errpreset</code> to either <code>moderate</code> or <code>conservative</code>, Spectre RF automatically performs a high-order refinement after the shooting method. Spectre RF uses the Multi-Interval Chebyshev polynomial spectral algorithm (MIC) to refine the simulation results. When you set <code>highorder</code> to <code>no</code>, MIC is turned off. However, when you set <code>highorder</code> to <code>yes</code>, Spectre RF tries harder to converge. In a case where MIC fails to converge, Spectre RF falls back to the original PSS solution. For more information, see <h-hot><a href="chap2.html#94096"></a><xrefstd>&#8220;The High-Order and Finite Difference Refinement Parameters&#8221;</xrefstd></h-hot><h-hot /> and <a href="chap2.html#41517">&#8220;The errpreset Parameter in PSS Analysis&#8221;</a>.</p>
<p>
<a id="pgfId-1027592"></a>You can also use the finite difference (FD) refinement method after the shooting method to refine the simulation results. For more information, see <a href="chap2.html#94096">&#8220;The High-Order and Finite Difference Refinement Parameters&#8221;</a>.</p>

<h3>
<a id="pgfId-1027597"></a>Parameters for P<a id="ParamsPSS"></a>SS Analysis</h3>

<p>
<a id="pgfId-1060539"></a>For more information on PSS analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#pss" show="replace" xml:link="simple">Periodic Steady-State Analysis (pss)</a></em> section in the Spectre Circuit Simulation Reference manual.</p>

<h3>
<a id="pgfId-1035606"></a><a id="23967"></a>The PSS Algorithm for Driven and Autonomous Circuits</h3>

<p>
<a id="pgfId-1035607"></a>The PSS analysis works with both autonomous and driven circuits.</p>
<ul><li>
<a id="pgfId-1035608"></a>Driven circuits require some time-varying stimulus to generate a time-varying response.<br />
<a id="pgfId-1035609"></a>Some common driven circuits include amplifiers, filters, mixers, and so on.</li><li>
<a id="pgfId-1035610"></a>Autonomous circuits are time-invariant circuits with time-varying responses. Thus, autonomous circuits generate non-constant waveforms even though they are not driven by a time-varying stimulus.<br />
<a id="pgfId-1035611"></a>The most common autonomous circuit is an oscillator.</li></ul>







<p>
<a id="pgfId-1035619"></a>See <a href="chap2.html#73684">&#8220;Autonomous PSS Analysis&#8221;</a> for additional information on the algorithm for PSS analysis of autonomous circuits.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1035752"></a>
The <code>errpreset</code> parameter works differently for autonomous and driven circuits. For detailed information, see <a href="chap2.html#41517">&#8220;The errpreset Parameter in PSS Analysis&#8221;</a>.</div>
<h3>
<a id="pgfId-1035621"></a>Driven PSS Analysis</h3>

<p>
<a id="pgfId-1027843"></a>A PSS analysis using the shooting method consists of two phases</p>
<ul><li>
<a id="pgfId-1027844"></a>The initial transient phase, a standard transient analysis to initialize the circuit.</li><li>
<a id="pgfId-1027845"></a>The shooting phase, to compute the periodic steady-state solution for the circuit using the shooting method.</li></ul>


<h4>
<a id="pgfId-1035652"></a>The Initial T<a id="InitTransPSS"></a>ransient Phase of PSS Analysis</h4>

<p>
<a id="pgfId-1035649"></a>The initial transient analysis provides a flexible mechanism to direct the circuit to a particular steady-state solution you are interested in and to avoid undesired solutions. Another use of the initial transient simulation is to help convergence by eliminating large but fast decaying modes that are present in many circuits. For example, in the case of driven circuits, consider the reset signal in <a href="chap2.html#37645">Figure&#160;2-1</a>.</p>
<p>
<a id="pgfId-1027853"></a>PSS starts by performing a loose transient analysis for the interval from <em>
t</em>
<sub>start</sub> to <em>
t</em>
<sub><em>stop</em></sub> where <em>
t</em>
<sub><em>stop</em></sub> is <em>
t</em>
<sub>onset</sub><t-times />
+ <em>
t</em>
<sub>stab</sub><t-times>
 +</t-times>
<em>
 
<em>
period</em>
. This initial loose transient analysis disregards your <code>errpreset</code> setting and performs a transient analyses with <code>errpreset=liberal</code>. If the initial transient results are relevant, you can output them by setting <code>saveinit</code> to <code>yes</code>. The steady-state results are always computed for the specified period, from <em>
t</em>
<sub>init</sub> to <em>
t</em>
<sub>stop</sub>. By default, <em>
t</em>
<sub>start</sub> and <em>
t</em>
<sub>stab</sub> are set to zero, while <em>
t</em>
<sub>init</sub>, <em>
t</em>
<sub>onset</sub> and <em>
t</em>
<sub>stop</sub> are always automatically generated and your <code>errpreset</code> settings are used.</em></p>

<p><strong>Figure 2-1
<a id="pgfId-1027855"></a><a id="37645"></a>Initial Transient Analysis and Timing Relationships for PSS Analysis</strong></p>
<p>
<a id="pgfId-1027913"></a></p>
<div class="webflare-div-image">
<img width="531" height="379" src="images/chap2-3.gif" /></div>

<p>
<a id="pgfId-1027914"></a>The first interval begins at <code>tstart</code>, which is normally 0, and continues through the onset of periodicity <em>
t</em>
<sub><em>onset</em></sub> for the independent sources. The onset of periodicity, which is automatically generated, is the earliest time for which all sources are periodic. The second interval is an optional user specified stabilization interval whose length is <a id="tstabPSS"></a><code>tstab</code>. The final interval whose length is <code>period</code> for driven circuits, and estimated as 4x period for autonomous circuits, has a special use for the autonomous PSS analysis&#8212;the autonomous PSS analysis monitors the waveforms in the circuit and develops a better estimate of the oscillation period. As is true for transient analysis, the DC solution is the initial condition for the PSS analysis unless you specify otherwise.</p>

<h4>Table 2-1
<a id="pgfId-1027947"></a><helvbold>

Timing Intervals for PSS Analysis</helvbold></h4>
<table class="webflareTable" id="#id1027916">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027919"></a><helvbold>
t
<subscript>
start
<a id="marker-1027918"></a></subscript></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027921"></a>Start time, <code>tstart</code>, for the transient analysis that you specify. This value can be negative or positive and defaults to 0.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027924"></a><helvbold>
t
<subscript>
onset
<a id="marker-1027923"></a></subscript></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027926"></a>Time when the last stimulus waveform becomes periodic. This value is automatically determined by the simulator for built-in independent sources.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027929"></a><helvbold>
t
<subscript>
stab
<a id="marker-1027928"></a> </subscript></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027931"></a>Additional time that you specify to let the circuit settle. The <code>tstab</code> parameter is useful if you want a particular solution for a circuit that has multiple periodic solutions. A long<em>
 t</em>
<sub>stab</sub> might also improve convergence.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027934"></a><helvbold>
t
<subscript>
init
<a id="marker-1027933"></a> </subscript></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027936"></a>Time when the PSS analysis begins. tinit = t<em>
stab + max
(t<em>
start
, tonset).</em></em></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027939"></a><helvbold>
period
<a id="marker-1027938"></a></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027941"></a>Analysis interval for the PSS analysis determined from the fundamental frequency (<code>fund</code>) or the <code>period</code> that you specify.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027944"></a><helvbold>
t
<subscript>
stop
<a id="marker-1027943"></a></subscript></helvbold></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1027946"></a>Time when the PSS analysis ends. tstop = tinit + <em>
period
.</em></p>
</td>
</tr>
</tbody></table>
<h4>
<a id="pgfId-1027948"></a>The Shooting Phase</h4>

<p>
<a id="pgfId-1035554"></a>After the initial transient phase is complete, the shooting phase begins. During the shooting phase, the circuit is repeatedly simulated over one period while adjusting the initial condition (and the period for autonomous circuits) to find the periodic steady-state solution.</p>
<p>
<a id="pgfId-1027949"></a>PSS analysis estimates the initial condition for subsequent transient analyses with an interval <code>period</code><em>
.
 For an accurate estimate for this initial condition, the final state of the circuit must closely match its initial state. PSS then performs a transient analysis, prints the maximum mismatch, and, if the convergence criteria are not satisfied, generates an improved estimate of the necessary initial condition.</em></p>
<p>
<a id="pgfId-1035671"></a>This procedure repeats until the simulation converges. Typically, the simulation requires three to five such iterations to reach the steady-state circuit response. After completion, if you request it, PSS computes the frequency-domain response.</p>
<p>
<a id="pgfId-1035733"></a>In some circuits, the linearity of the relationship between the initial and final states depends on when the shooting interval begins. Theoretically, the starting time of the shooting interval does not matter, as long as it begins after the stimuli become periodic. Practically, it is better to start the shooting interval when signals are quiescent or changing slowly and to avoid starting times when the circuit displays strongly nonlinear behavior. Choosing a poor starting time slows the analysis.</p>
<p>
<a id="pgfId-1027951"></a>For driven circuits, you can use <code>writepss</code> and <code>readpss</code> to save or reuse the steady state solution from a previously converged PSS simulation.</p>
<p>
<a id="pgfId-1027952"></a>Within the Analog Circuit Design Environment, you</p>
<ul><li>
<a id="pgfId-1027954"></a>Define <code>tstart</code> in the <em>SImulation Interval Parameters</em> section of the PSS Options form.</li><li>
<a id="pgfId-1027956"></a>Define <code>tstab</code> in the <em>Additional </em><em>Time for Stabilization</em> section of the PSS Choosing Analyses form.</li></ul>

<p>
<a id="pgfId-1027957"></a>The PSS analysis determines the <code>period</code> value from the fundamental frequency (<code>fund</code>) you specify in the <em>Fundamental </em><em>Tones </em>(PSS and QPSS) section of the PSS Choosing Analyses form.</p>
<p>
<a id="pgfId-1035720"></a>You can save the initial transient results by setting <code>saveinit</code><a id="marker-1035719"></a> to <code>yes.</code> The steady-state results are always computed for the period from t<subscript>
init
 to t<subscript>
stop
. By default, <em>
t
<subscript>
start
 (<code>tstart</code>) and <em>
t
<subscript>
stab
 (<code>tstab</code>) are set to zero, while t<subscript>
init
, t<subscript>
onset
, and t<subscript>
stop
 are always automatically computed.</subscript></subscript></subscript></subscript></em></subscript></em></subscript></subscript></p>
<p>
<a id="pgfId-1027961"></a>Use the <code>skipdc</code> Initial-Condition Parameter to specify rampup before the transient (<code>tstab</code>) analysis. Use <code>skipdc</code> only for very special cases where there are several DC solutions in the system.</p>
<p>
<a id="pgfId-1027962"></a>Set <code>skipdc=no</code> to calculate the initial solution using the usual DC analysis. (This is the default.) Set <code>skipdc=yes</code> to use either the initial solution given in the <code>readic</code> parameter file or the values specified on the <code>ic</code> statements.</p>
<p>
<a id="pgfId-1027963"></a>When you set <code>skipdc=sigrampup</code>, independent source values start at 0 and ramp up to their initial values during the first phase of the simulation. After the rampup phase, waveform production is enabled in the time-varying independent source.The rampup simulation is from <em>
t</em>
<sub><em>start</em></sub> to <code>time=0</code> seconds. The main simulation is from <code>time=0</code> seconds to <em>
t</em>
<sub><em>stab</em></sub>. If you do not specify the<t-times />
<em>
t</em>
<sub><em>start</em></sub> parameter, the default start time is set to -0.1∗ <em>
t</em>
<sub><em>stab</em></sub>.</p>
<p>
<a id="pgfId-1035745"></a>For driven circuits, you specify either the period of the analysis, the <code>period</code> parameter, or its corresponding fundamental frequency, the <code>fund</code> parameter. The <code>period</code> parameter value must be an integer multiple of the period of the drive signals.</p>

<h3>
<a id="pgfId-1027977"></a><a id="73684"></a>Autonomous PSS Analysis</h3>

<p>
<a id="pgfId-1035836"></a>Because autonomous circuits do not have drive signals and you do not know the actual period of oscillation before you run a simulation, you estimate the oscillation period and the PSS analysis computes the precise period along with the periodic solution waveforms. Autonomous circuits, such as oscillators, however, have time-varying responses and generate non-constant waveforms even though the circuits themselves are time-invariant.</p>
<p>
<a id="pgfId-1035564"></a>PSS analysis of an autonomous circuit, requires you to specify a pair of nodes, <code>p</code> and <code>n</code>. In fact this is how PSS analysis determines whether it is being applied to an autonomous or a driven circuit. If the pair of nodes is supplied, the PSS analysis assumes the circuit is autonomous; if not, the circuit is assumed to be driven. See <em>Spectre Circuit Simulator and Accelerated Parallel Simulator RF Analysis in ADE Explorer User Guide</em> for an example.</p>

<h4>
<a id="pgfId-1035794"></a>Phases of Autonomous PSS Analysis</h4>

<p>
<a id="pgfId-1035795"></a>A PSS analysis has two phases,</p>
<ul><li>
<a id="pgfId-1035796"></a>A transient analysis phase to initialize the circuit.</li><li>
<a id="pgfId-1035797"></a>A shooting phase to compute the periodic steady state solution.</li></ul>

<p>
<a id="pgfId-1035798"></a>The transient analysis phase is divided into three intervals:</p>
<ul><li>
<a id="pgfId-1035800"></a>A beginning interval that starts at <code>tstart</code>, which is normally 0, and continues through the onset of periodicity for the independent sources.</li><li>
<a id="pgfId-1035802"></a>A second, optional stabilization interval of length <code>tstab</code>.</li><li>
<a id="pgfId-1035803"></a>A final interval that is four times the estimated oscillation period specified in the PSS Analysis form. During the final interval, the PSS analysis monitors the waveforms in the circuit and improves the estimate of the oscillation period.</li></ul>


<p>
<a id="pgfId-1035892"></a>During the first stage of the transient phase, PSS extracts the fundamental frequency from the set of nodes specified in the PSS statement. During the second stage, the PSS analysis examines all the nets in your design to verify the accuracy of the extracted PSS fundamental frequency. This enhancement improves PSS analysis of circuits with frequency dividers by re-evaluating the PSS fundamental to take into account the frequency division in your circuit.</p>

<h4><em>
<a id="pgfId-1035883"></a>Increasing the tstab Interval</em></h4>

<p>
<a id="pgfId-1036162"></a>In some cases when an autonomous PSS analysis does not converge after a few iterations, increasing the <code>tstab</code> interval makes convergence faster and easier.</p>
<p>
<a id="pgfId-1036046"></a>Adjusting the <code>tstab</code> interval might improve the shooting interval starting point by moving it such that signals are quiescent or changing slowly. This allows strongly nonlinear circuits to converge faster.</p>
<p>
<a id="pgfId-1035926"></a>For oscillator circuits, Spectre RF increases the <code>tstab</code> interval when:</p>
<ul><li>
<a id="pgfId-1036000"></a>The current Iteration is close to the maximum number of iterations, but the related Norm is still large.<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1036198">
<a id="pgfId-1036198"></a>(Iter &gt;= 0.8 * MaxIters &amp;&amp; Norm &gt; 1000.0
(Iter &gt;= 0.9 * MaxIters &amp;&amp; Norm &gt; 100.0)
(Iter &gt;= 0.95* MaxIters &amp;&amp; Norm &gt; 10.0)
(Iter &gt;= MaxIters    &amp;&amp; Norm &gt; 1.0)
</pre></li><li>
<a id="pgfId-1036214"></a>The PssPeriod has shrunk to zero<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1036219">
<a id="pgfId-1036219"></a>(PssPeriod &lt; UsrPssPeriod/1.0e3)</pre></li><li>
<a id="pgfId-1036005"></a>The initial transient analysis has failed.</li></ul>




<p>
<a id="pgfId-1036191"></a>When any of these conditions occur, Spectre RF increases the tstab interval as follows.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1036190"></a>4.0*PeriodEstimate + PeriodEstimate*DynamicTstabCounter/6.0</pre>

<p>
<a id="pgfId-1035941"></a>where <code>DynamicTstabCounter</code> is an integer from 1 to 6.</p>
<p>
<a id="pgfId-1035884"></a>During the shooting phase, the circuit is simulated repeatedly over one period. The length of the period and the initial conditions are modified to find the periodic steady state solution.</p>

<h3>
<a id="pgfId-1027987"></a><a id="12374"></a>Simulation Accuracy Parameters</h3>

<p>
<a id="pgfId-1027988"></a>The accuracy of your simulation results depends on your accuracy parameter settings, not on the number of harmonics you request. It is recommended that you adjust the accuracy parameters using the <code>errpreset</code> parameter settings as described in <a href="chap2.html#41517">&#8220;The errpreset Parameter in PSS Analysis&#8221;</a>.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1035770"></a>
The <code>errpreset</code> parameter works differently for autonomous and driven circuits. For detailed information, see <a href="chap2.html#41517">&#8220;The errpreset Parameter in PSS Analysis&#8221;</a>.</div>

<p>
<a id="pgfId-1027993"></a>Several parameters determine the accuracy of the PSS analysis.The <code>steadyratio</code><a id="marker-1027992"></a> parameter specifies the maximum allowed mismatch between node voltages or current branches from the beginning of the steady-state period to its end. The <code>steadyratio</code> value is multiplied by the <code>lteratio</code><a id="marker-1027994"></a> and <code>reltol</code><a id="marker-1027995"></a> parameter values to determine the convergence criterion. The<em> </em><code>reltol</code> and <code>abstol</code> parameters control the accuracy of the discretized equation solution. These parameters determine how well charge is conserved and how accurately steady-state or equilibrium points are computed. You can set the integration error, or the errors in the computation of the circuit dynamics (such as time constants), relative to the <code>reltol</code> and <code>abstol</code> parameters by setting the <code>lteratio</code> parameter.</p>
<p>
<a id="pgfId-1027996"></a>You can follow the progress of the steady-state iterations because the relative convergence norm is printed in the simulation log file along with the actual mismatch value at the end of each iteration. The iterations continue until the convergence norm value is below one.</p>

<h3>
<a id="pgfId-1027997"></a>Plotting the Current Spectrum</h3>

<p>
<a id="pgfId-1027998"></a>In order to plot the current or power spectrum for a PSS analysis, or for any of the periodic small signal analyses, you must set up the analysis to put the terminal currents into the rawfiles associated with the steady-state results. To do this, choose <em>Outputs - Save All</em> to display the Save Options form where you set <code>currents=selected</code> and <code>useprobes=yes. </code>You also need to use an <code>iprobe</code> component from the <code>analogLib</code> library.</p>

<h3>
<a id="pgfId-1028001"></a><a id="94096"></a>The <a id="HOandFDParams"></a>High-Order and Finite Difference Refinement Parameters</h3>

<p>
<a id="pgfId-1028002"></a>The <code>highorder</code> parameter specifies the use of the high-order Chebyshev refinement method (MIC) which is used after the shooting method to refine the shooting method&#8217;s steady-state solution. The <code>highorder</code> parameter applies only to the driven case and when <code>errpreset</code> is set to either <code>moderate</code> or <code>conservative</code>.</p>
<ul><li>
<a id="pgfId-1028003"></a>When <code>highorder=no</code>, the MIC method is turned off. This is the default.</li><li>
<a id="pgfId-1028004"></a>When <code>highorder=yes</code>, the MIC method tries harder to converge.</li><li>
<a id="pgfId-1028005"></a>When <code>errpreset</code> is set to either <code>moderate</code> or <code>conservative</code> and <code>highorder</code> is not set by the user, MIC is used but it does not aggressively try to converge unless <code>highorder</code> is explicitly set to <code>yes</code>.</li></ul>


<p>
<a id="pgfId-1028006"></a>The <code>finitediff</code> parameter specifies the use of the finite difference (FD) refinement method which is used after the shooting method to refine the simulation results. This flag is only meaningful when the <code>highorder</code> flag is set to <code>no</code>.</p>
<ul><li>
<a id="pgfId-1028007"></a>When <code>finitediff=no</code>, the FD method is turned off.</li><li>
<a id="pgfId-1028008"></a>When <code>finitediff=yes</code>, PSS applies the FD refinement method.</li><li>
<a id="pgfId-1028009"></a>When <code>finitediff=refine</code>, PSS applies the FD refinement method and tries to refine the time steps.</li></ul>


<p>
<a id="pgfId-1028010"></a>When the simulation uses the 2nd-order method, uniform 2nd order gear is used. When <code>readpss</code> and <code>writepss</code> are used to re-use PSS results, the <code>finitediff</code> parameter automatically changes from <code>no</code> to <code>yes</code>.</p>
<p>
<a id="pgfId-1028011"></a>Usually FD will eliminate the above mismatch in node voltages or current branches. It can also refine the grid of time steps. In some cases, the numerical error of the linear solver still introduces a mismatch. In this case, you can adjust the <code>steadyratio</code> parameter to a smaller value to activate a tighter tolerance for the iterative linear solver.</p>
<p>
<a id="pgfId-1028013"></a>The <code>maxacfreq</code><a id="marker-1028012"></a> parameter automatically adjusts <em>
maxstep
 to reduce errors due to aliasing in subsequent periodic small-signal analyses. By default, <code>maxacfreq</code> is four times the frequency of the largest harmonic you request, but it is never less than 40 times the fundamental.</em></p>
<p>
<a id="pgfId-1028017"></a>The <code>relref</code> parameter determines how the relative error is treated. Table <a href="chap2.html#99752">Table&#160;2-2</a> lists the <code>relref</code> parameter options.</p>

<h4>Table 2-2
<a id="pgfId-1028040"></a><a id="99752"></a>The relref Parameter Options</h4>
<table class="webflareTable" id="#id1028019">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028021">
<a id="pgfId-1028021"></a>Option</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028023">
<a id="pgfId-1028023"></a>Definition</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028025"></a><code>relref=pointlocal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028027"></a>Compares the relative errors in quantities at each node to that node alone.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028029"></a><code>relref=alllocal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028031"></a>Compares the relative errors at each node to the largest values found for that node alone for all past time.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028033"></a><code>relref=sigglobal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028035"></a>Compares relative errors in each of the circuit signals to the maximum for all signals at any previous point in time.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028037"></a><code>relref=allglobal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028039"></a>Same as <code>relref=sigglobal</code> except that it also compares the residues (KCL error) for each node to the maximum of that node&#8217;s past history.</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1028043"></a><a id="41517"></a>The errpreset Parameter in PSS Analysis</h3>
<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1028044"></a>
In most cases, <code>errpreset</code> should be the only accuracy parameter you need to adjust. The <code>errpreset</code> parameter quickly adjusts several simulator parameters to fit your needs.</div>

<p>
<a id="pgfId-1035858"></a>The<code> errpreset</code><a id="errpresetPSS"></a> parameter works differently for autonomous and driven circuits. For more information see,</p>
<ul><li>
<a id="pgfId-1035868"></a><a href="chap2.html#84847">&#8220;Using the errpreset Parameter With Driven Circuits&#8221;</a>.</li><li>
<a id="pgfId-1035873"></a><a href="chap2.html#93445">&#8220;Using the errpreset Parameter With Autonomous Circuits&#8221;</a>.</li></ul>


<h4>
<a id="pgfId-1028046"></a><a id="84847"></a>Using the errpreset Parameter With Driven Circuits</h4>

<p>
<a id="pgfId-1028048"></a>If your drive<a id="ErrpresetParamsDriven"></a>n (non-autonomous) circuit includes only one periodic tone and you are only interested in obtaining the periodic operating point, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>liberal</em></span>. The liberal setting produces reasonably accurate results with the fastest simulation speed. If your driven circuit contains more than one periodic tone and you are interested in intermodulation results, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>moderate</em></span>. The moderate setting produces very accurate results. If you want an extremely low noise floor in your simulation results and accuracy is your main interest, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>conservative</em></span>.</p>
<p>
<a id="pgfId-1028049"></a>For both <span class="webflare-courier-new" style="white-space:pre"><em>moderate</em></span> and <span class="webflare-courier-new" style="white-space:pre"><em>conservative</em></span> settings, the Multi-Interval Chebyshev (MIC) algorithm is activated automatically unless you explicitly set <code>highorder=no</code>. If MIC has difficulty converging, the simulator reverts back to the original method. If you set <code>highorder=yes</code>, MIC will continue to attempt to converge.</p>
<p>
<a id="pgfId-1028053"></a>Table <a href="chap2.html#61661">2-3</a> shows the effect of the <code>errpreset</code> settings (<code>liberal</code>, <code>moderate</code>, and <code>conservative</code>) on the values of the other parameters used with driven circuits.</p>

<h4>Table 2-3
<a id="pgfId-1028115"></a><a id="61661"></a>Default Values and Noise Floor for <code>errpreset</code> in Driven Circuits</h4>
<table class="webflareTable" id="#id1028055">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028057">
<a id="pgfId-1028057"></a>errpreset</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028059">
<a id="pgfId-1028059"></a>reltol</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028061">
<a id="pgfId-1028061"></a>relref</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028063">
<a id="pgfId-1028063"></a>method</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028065">
<a id="pgfId-1028065"></a>Iteratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028067">
<a id="pgfId-1028067"></a>steadyratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028069">
<a id="pgfId-1028069"></a>maxstep</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028071"></a><code>liberal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028073"></a>1e<sup>-3</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028075"></a>sigglobal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028077"></a>traponly</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028079"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028081"></a>0.001</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028083"></a>period/50</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028085"></a><code>moderate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028087"></a>1e<sup>-3</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028089"></a>alllocal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028091"></a>gear2only </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028093"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028095"></a>0.001</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028097"></a>period/200</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028099"></a><code>conservative</code><a href="#pgfId-1047736">1</a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028101"></a>1e<sup>-4</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028103"></a>alllocal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028105"></a>gear2only </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028110"></a>*</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028112"></a>0.01</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028114"></a>period/200</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1028116"></a>Several parameters determine the accuracy of the PSS analysis. <code>Reltol</code> and <code>abstol</code> control the accuracy of the discretized equation solution. These parameters determine how well charge is conserved and how accurately steady-state or equilibrium points are computed.The integration error, or the errors in the computation of the circuit dynamics (such as time constants) relative to <code>reltol</code> and <code>abstol</code> are set by the <code>lteratio</code> parameter.</p>
<p>
<a id="pgfId-1028117"></a>These <code>errpreset</code> settings include a default <code>reltol</code> value which is an enforced upper limit for <code>reltol</code>. The only way to decrease the <code>reltol</code> value is with the <code>options</code> statement. The only way to <em>relax</em> the <code>reltol</code> value is to change the <code>errpreset</code> setting.</p>
<p>
<a id="pgfId-1028118"></a>For a weakly nonlinear circuit, the estimated numerical noise floor is -70 dB for <code>liberal</code>, -90 dB for <code>moderate</code>, and -120 dB for <code>conservative</code> <code>errpreset</code> settings. For a linear circuit, the noise floor is even lower. Multi-interval Chebyshev (MIC) is activated when you explicitly set <code>highorder=yes</code>, which drops the numerical noise floor by at least 30 dB. MIC falls back to the original method if it encounters difficulty converging. You can tighten the <code>psaratio</code> to further drop the numerical noise floor. Spectre RF sets the value of <code>maxstep</code> so that it cannot be larger than the value given in Table <a href="chap2.html#61661">2-3</a>. Except for the <code>reltol</code> and <code>maxstep</code> parameters, <code>errpreset</code> does not change the value of any parameters you have explicitly set. The actual values used for the PSS analysis are given in the log file. If <code>errpreset</code> is not specified in the netlist, <code>liberal</code> settings are used.</p>

<h4>
<a id="pgfId-1028123"></a><a id="93445"></a>Using the errpreset Parameter With Autonomous Circuits</h4>

<p>
<a id="pgfId-1028125"></a>For an <a id="ErrpresetParamsAuto"></a>autonomous circuit, if you want a fast simulation with reasonable accuracy, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>liberal</em></span>. For greater accuracy, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>moderate</em></span>. For greatest accuracy, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>conservative</em></span>.</p>
<p>
<a id="pgfId-1028129"></a>Table <a href="chap2.html#12809">2-4</a> shows the effect of the <code>errpreset</code> settings (<code>liberal</code>, <code>moderate</code>, and <code>conservative</code>) on the values of parameters used with autonomous circuits.</p>

<h4>Table 2-4
<a id="pgfId-1028191"></a><a id="12809"></a>Default Values and maxstep for <code>errpreset</code> in Autonomous Circuits</h4>
<table class="webflareTable" id="#id1028131">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028133">
<a id="pgfId-1028133"></a>errpreset</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028135">
<a id="pgfId-1028135"></a>reltol</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028137">
<a id="pgfId-1028137"></a>relref</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028139">
<a id="pgfId-1028139"></a>method</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028141">
<a id="pgfId-1028141"></a>Iteratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028143">
<a id="pgfId-1028143"></a>steadyratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028145">
<a id="pgfId-1028145"></a>maxstep</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028147"></a><code>liberal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028149"></a>1e<sup>-3</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028151"></a>sigglobal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028153"></a>traponly</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028155"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028157"></a>0.001</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028159"></a>period/50</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028161"></a><code>moderate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028163"></a>1e<sup>-4</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028165"></a>alllocal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028167"></a>gear2only</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028169"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028171"></a>0.01</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028173"></a>period/200</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028175"></a><code>conservative</code><a href="#pgfId-1047791">2</a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028177"></a>1e<sup>-5</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028179"></a>alllocal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028181"></a>gear2only</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028186"></a>*</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028188"></a>0.1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028190"></a>period/400</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1028192"></a>These <code>errpreset</code> settings include a default <code>reltol</code> value which is an enforced upper limit for <code>reltol</code>. The only way to <em>decrease</em> the <code>reltol</code> value is in the <code>options</code> statement. The only way to <em>increase </em>the <code>reltol</code> value is to change the <code>errpreset</code> setting. Spectre RF sets the <code>maxstep</code> parameter value so that it is no larger than the value given in Table <a href="chap2.html#12809">2-4</a>. Except for the <code>reltol</code> and <code>maxstep</code> values, the <code>errpreset</code> setting does not change any parameter values you have explicitly set. The actual values used for the PSS analysis are given in the log file.</p>
<p>
<a id="pgfId-1028197"></a>The value of <code>reltol</code> can be decreased from the default value in the options statement. The only way to increase <code>reltol</code> is to relax <code>errpreset</code>. Spectre RF sets the value of <code>maxstep</code> so that it cannot be larger than the value given in Table <a href="chap2.html#12809">2-4</a>. Except for <code>reltol</code> and <code>maxstep</code>, <code>errpreset</code> does not change the value of any parameters you have explicitly set. The actual values used for the PSS analysis are given in the log file. If <code>errpreset</code> is not specified in the netlist, <code>liberal</code> settings will be used. Multi-interval Chebyshev (MIC) is activated when you explicitly set <code>highorder=yes</code>, which will drop the numerical noise floor by at least 30 dB. MIC falls back to the original method if it encounters difficulty converging. You can tighten <code>psaratio</code> to further drop the numerical noise floor.</p>

<h3>
<a id="pgfId-1036311"></a>Other Parameters</h3>

<p>
<a id="pgfId-1036315"></a>A long stabilization (by specifying a large tstab) can help with the PSS convergence. However it can slow down simulation. By default, in the stabilization stage, reltol=1e-3; maxstep=period/25; relref=sigglobal; and method=traponly. They are overwritten when maxstep, relref, or tstabmethod are specified explicitly in pss statement, or reltol is specified explicitly in options statement.</p>
<p>
<a id="pgfId-1036316"></a>If the circuit you are simulating can have infinitely fast transitions (for example, a circuit that contains nodes with no capacitance), Spectre RF might have convergence problems. To avoid this, you must prevent the circuit from responding instantaneously. You can accomplish this by setting <code>cmin</code>, the minimum capacitance to ground at each node, to a physically reasonable nonzero value. This often significantly improves convergence.</p>
<p>
<a id="pgfId-1036317"></a>You may specify the initial condition for the transient analysis by using the <code>ic</code> statement or the <code>ic</code> parameter on the capacitors and inductors. If you do not specify the initial condition, the DC solution is used as the initial condition. The <code>ic</code> parameter on the transient analysis controls the interaction of various methods of setting the initial conditions. The effects of individual settings are</p>

<p>
<a id="pgfId-1042008"></a></p>
<table class="webflareTable" id="#id1042009">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042011"></a><code>ic=dc</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042013"></a>Any initial condition specifiers are ignored, and the DC solution is used. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042015"></a><code>ic=node</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042017"></a>The <code>ic</code> statements are used, and the <code>ic</code> parameter on the capacitors and inductors are ignored.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042019"></a><code>ic=dev</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042021"></a>The <code>ic</code> parameters on the capacitors and inductors are used, and the <code>ic</code> statements are ignored. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042023"></a><code>ic=all</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042025"></a>Both the <code>ic</code> statements and the <code>ic</code> parameters are used, and the <code>ic</code> parameters override the <code>ic</code> statements.</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1036322"></a>If you specify an initial condition file with the <code>readic</code> parameter, initial conditions from the file are used, and any <code>ic</code> statements are ignored.</p>
<p>
<a id="pgfId-1036323"></a>After you specify the initial conditions, Spectre RF computes the actual initial state of the circuit by performing a DC analysis. During this analysis, Spectre RF forces the initial conditions on nodes by using a voltage source in series with a resistor whose resistance is <code>rforce</code> (see <code>options</code>).</p>
<p>
<a id="pgfId-1036324"></a>With the <code>ic</code> statement it is possible to specify an inconsistent initial condition (one that cannot be sustained by the reactive elements). Examples of inconsistent initial conditions include setting the voltage on a node with no path of capacitors to ground or setting the current through a branch that is not an inductor. If you initialize Spectre RF inconsistently, its solution jumps; that is, it changes instantly at the beginning of the simulation interval. You should avoid such changes if possible because Spectre RF can have convergence problems while trying to make the jump.</p>
<p>
<a id="pgfId-1036325"></a>You can skip the DC analysis entirely by using the parameter <code>skipdc</code>. If the DC analysis is skipped, the initial solution will be either trivial, or given in the file you specified by the <code>readic</code> parameter, or, if the <code>readic</code> parameter is not given, the values specified on the ic statements. Device-based initial conditions are not used for <code>skipdc</code>. Nodes that you do not specify with the <code>ic</code> file or <code>ic</code> statements will start at zero. You should not use this parameter unless you are generating a nodeset file for circuits that have trouble in the DC solution; it usually takes longer to follow the initial transient spikes that occur when the DC analysis is skipped than it takes to find the real DC solution. The <code>skipdc</code> parameter might also cause convergence problems in the transient analysis.</p>
<p>
<a id="pgfId-1036326"></a>The possible settings of parameter <code>skipdc</code> and their meanings are</p>

<p>
<a id="pgfId-1042097"></a></p>
<table class="webflareTable" id="#id1042098">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042100"></a><code>skipdc=no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042102"></a>Initial solution is calculated using the normal DC analysis (default). </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042104"></a><code>skipdc=yes</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042106"></a>Initial solution is given in the file specified by the <code>readic</code> parameter or the values specified on the ic statements. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042149"></a><code>skipdc=sigrampup</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042151"></a>Independent source values start at 0 and ramp up to their initial values in the first phase of the simulation. The waveform production in the time-varying independent source is enabled after the rampup phase.</p>

<ul><li>
<a id="pgfId-1042166"></a>The rampup simulation is from <code>tstart</code> to time=0 s, and the main simulation is from time=0 s to <code>tstab</code>.</li><li>
<a id="pgfId-1042167"></a>If the <code>tstart</code> parameter is not specified, the default <code>tstart</code> time is set to -0.1*<code>tstab</code>.</li></ul>


</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1036330"></a>Nodesets help find the DC or initial transient solution. You can supply them in the circuit description file with nodeset statements, or in a separate file using the <code>readns</code> parameter. When nodesets are given, Spectre RF computes an initial guess of the solution by performing a DC analysis while forcing the specified values onto nodes by using a voltage source in series with a resistor whose resistance is <code>rforce</code>. Spectre RF then removes these voltage sources and resistors and computes the true solution from this initial guess.</p>
<p>
<a id="pgfId-1036331"></a>Nodesets have two important uses. First, if a circuit has two or more solutions, nodesets can bias the simulator towards computing the desired one. Second, they are a convergence aid. By estimating the solution of the largest possible number of nodes, you might be able to eliminate a convergence problem or dramatically speed convergence.</p>
<p>
<a id="pgfId-1036332"></a>When you simulate the same circuit many times, we suggest that you use both the <code>write</code> and <code>readns</code> parameters and give the same file name to both parameters. The DC analysis then converges quickly even if the circuit has changed somewhat since the last simulation, and the nodeset file is automatically updated.</p>
<p>
<a id="pgfId-1036333"></a>Nodesets and initial conditions have similar implementation but produce different effects. Initial conditions actually define the solution, whereas nodesets only influence it. When you simulate a circuit with a transient analysis, Spectre RF forms and solves a set of differential equations. However, differential equations have an infinite number of solutions, and a complete set of initial conditions must be specified in order to identify the desired solution. Any initial conditions you do not specify are computed by the simulator to be consistent. The transient waveforms then start from initial conditions. Nodesets are usually used as a convergence aid and do not affect the final results. However, in a circuit with more than one solution, such as a latch, nodesets bias the simulator towards finding the solution closest to the nodeset values.</p>
<p>
<a id="pgfId-1036334"></a>The <code>method</code> parameter specifies the integration method. The possible settings and their meanings are</p>

<p>
<a id="pgfId-1042170"></a></p>
<table class="webflareTable" id="#id1042171">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042173"></a><code>method=euler</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042175"></a>Backward-Euler is used exclusively.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042177"></a><code>method=traponly</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042179"></a>Trapezoidal rule is used almost exclusively.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042181"></a><code>method=trap</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042183"></a>Backward-Euler and the trapezoidal rule are used.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042185"></a><code>method=gear2only</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042187"></a>Gears second-order backward-difference method is used almost exclusively.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042189"></a><code>method=gear2</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042191"></a>Backward-Euler and second-order Gear are used.</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1036340"></a>The trapezoidal rule is usually the most efficient when you want high accuracy. This method can exhibit point-to-point ringing, but you can control this by tightening the error tolerances. For this reason, though, if you choose very loose tolerances to get a quick answer, either backward-Euler or second-order Gear will probably give better results than the trapezoidal rule. Second-order Gear and backward-Euler can make systems appear more stable than they really are. This effect is less pronounced with second-order Gear or when you request high accuracy.</p>
<p>
<a id="pgfId-1036341"></a>Spectre RF provides two methods for reducing the number of output data points saved: <code>strobing</code>, based on the simulation time, and <code>skipping</code> time points, which saves only every Nth point.</p>
<p>
<a id="pgfId-1036342"></a>The parameters <code>strobeperiod</code> and <code>strobedelay</code> control the strobing method. <code>strobeperiod</code> sets the interval between points that you want to save, and <code>strobedelay</code> sets the offset within the period relative to <code>skipstart</code>. The simulator forces a time step on each point to be saved, so the data is computed, not interpolated.</p>
<p>
<a id="pgfId-1036343"></a>The skipping method is controlled by <code>skipcount</code>. If this is set to N, then only every Nth point is saved.</p>
<p>
<a id="pgfId-1036344"></a>The parameters <code>skipstart</code> and <code>skipstop</code> apply to both data reduction methods. Before <code>skipstart</code> and after <code>skipstop</code>, Spectre RF saves all computed data.</p>
<p>
<a id="pgfId-1036345"></a>The default value for <code>compression</code> is no. The output file stores data for every signal at every time point for which Spectre RF calculates a solution. Spectre RF saves the x axis data only once, because every signal has the same x value. If <code>compression=yes</code>, Spectre RF writes data to the output file only if the signal value changes by at least 2*the convergence criteria. In order to save data for each signal independently, x axis information corresponding to each signal must be saved. If the signals stay at constant values for large periods of the simulation time, setting <code>compression=yes</code> results in a smaller output data file. If the signals in your circuit move around a lot, setting <code>compression=yes</code> results in a larger output data file.</p>

<h2>
<a id="pgfId-1028203"></a><a id="29491"></a>Periodic AC A<a id="marker-1028202"></a>nalysis (PAC)</h2>

<p>
<a id="pgfId-1028204"></a>The Periodic AC (<a id="PAC"></a>PAC) small-signal analysis computes transfer functions for circuits that exhibit frequency translation. Such circuits include mixers, switched-capacitor filters, samplers, lower noise amplifier, sample-and-holds, and similar circuits. A PAC analysis cannot be used alone. It must follow a large signal PSS analysis. However, any number of periodic small-signal analyses, such as PAC, PSP, PXF, PNoise, can follow a PSS analysis.</p>
<p>
<a id="pgfId-1033384"></a>PAC analysis is a small-signal analysis like AC analysis, except the circuit is first linearized about a periodically varying operating point as opposed to a simple DC operating point. Linearizing about a periodically time-varying operating point allows transfer-functions that include frequency translation, whereas simply linearizing about a DC operating point could not because linear time-invariant circuits do not exhibit frequency translation. Also, the frequency of the sinusoidal stimulus is not constrained by the period of the large periodic solution.</p>
<p>
<a id="pgfId-1033399"></a>Computing the small-signal response of a periodically varying circuit is a two step process. First, the small stimulus is ignored and the periodic steady-state response of the circuit to possibly large periodic stimulus is computed using PSS analysis. As a normal part of the PSS analysis, the periodically time-varying representation of the circuit is computed and saved for later use. The second step is applying the small stimulus to the periodically varying linear representation to compute the small signal response. This is done using the PAC analysis.</p>
<p>
<a id="pgfId-1028205"></a>When you apply a small sinusoid to a linear time-invariant circuit, the steady-state response is a sinusoid at the same frequency. However, when you apply a small sinusoid to a linear circuit that is periodically time-varying, the circuit responds with sinusoids at many frequencies, as is shown in <a href="chap2.html#31262">Figure&#160;2-2</a>.</p>
<p>
<a id="pgfId-1028209"></a>Because PAC is a small-signal analysis, the magnitude and phase of each tone computed by PAC is linearly related to the magnitude and phase of the input signal. PAC computes a series of transfer functions, one for each frequency. These transfer functions are unique because the input and output frequencies are offset by the harmonics of the LO.</p>
<p>
<a id="pgfId-1042310"></a>The Spectre RF simulation labels the transfer functions with the offsets from the input signal in multiples of the LO fundamental frequency. These same labels identify the corresponding sidebands of the output signals. The labels are used as follows</p>

<p>
<a id="pgfId-1042311"></a></p>
<table class="webflareTable" id="#id1042335">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042337"></a>Label </p>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042339"></a>Definition</p>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042341"></a><code>0</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042343"></a>For circuits in which the input and output are at the same frequency, such as switched-capacitor filters, the transfer function or sideband is labeled 0. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042345"></a><code>-1</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042347"></a>For down-conversion mixers, the transfer function or sideband is labeled -1 because the output frequency is offset from the input frequency by -1 times the LO frequency. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042349"></a><code>+1 </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042351"></a>For up-conversion mixers, the transfer function or sideband is labeled +1. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042353"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1042355"></a>For samplers, sidebands far from zero might be used. </p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1028217"></a>In Figure <a href="chap2.html#31262">2-2</a>, all transfer functions from -3 to +3 are computed. As shown in the figure, the input signal is replicated and translated by each harmonic of the LO. In down-conversion mixers, the -1 sideband usually represents the IF output.</p>

<p><strong>Figure 2-2
<a id="pgfId-1028220"></a><a id="31262"></a>Th<a id="1-2"></a>e Small-Signal Response of a Mixer as Computed by PAC Analysis</strong></p>
<p>
<a id="pgfId-1028236"></a></p>
<div class="webflare-div-image">
<img width="487" height="521" src="images/chap2-4.gif" /></div>

<p>
<a id="pgfId-1028237"></a>PAC performance is not reduced if the input and LO frequencies are close or equal.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1028238"></a>
Unlike other analyses in Spectre RF, the PAC analysis can only sweep frequency.</div>
<h4>
<a id="pgfId-1028240"></a>PAC Syn<a id="marker-1028239"></a>opsis</h4>

<p>
<a id="pgfId-1028241"></a>You select the periodic small-signal output frequencies you want by specifying either the maximum sideband (the <code>maxsideband</code> parameter) or an array of sidebands (the <code>sidebands</code> parameter).</p>
<p>
<a id="pgfId-1028242"></a>For a set of <em>n</em> integer numbers representing the sidebands</p>

<p>
<a id="pgfId-1028246"></a><img width="115" height="42" src="images/chap2-5.gif" /></p>

<p>
<a id="pgfId-1028247"></a>the output signal frequency at each sideband is computed as</p>

<p>
<a id="pgfId-1028251"></a><img width="255" height="45" src="images/chap2-6.gif" /></p>

<p>
<a id="pgfId-1028252"></a>where</p>
<ul><li>
<a id="pgfId-1028253"></a><em>
f(in)</em>
 is the (possibly swept) input frequency</li><li>
<a id="pgfId-1028254"></a><em>
fund(pss)</em>
 is the fundamental frequency used in the corresponding PSS analysis</li></ul>

<p>
<a id="pgfId-1028255"></a>If you specify the maximum sideband value as k<sub>max</sub>, all 2 × k<sub>max</sub> + 1 sidebands from -k<sub>max</sub> to +k<sub>max</sub> are generated.</p>
<p>
<a id="pgfId-1036411"></a>The number of requested sidebands does not substantially change the simulation time. However, the <code>maxacfreq</code> of the corresponding PSS analysis should be set to guarantee that | <code>max{f(out)</code>} | is less than <code>maxacfreq</code>, otherwise the computed solution might be contaminated by aliasing effects. The PAC simulation is not executed for |<code>f(in)</code>| greater than <code>maxacfreq</code>. Diagnostic messages are printed for those extreme cases that indicate how to set <code>maxacfreq</code> in the PSS analysis. In the majority of simulations, however, this is not an issue because <code>maxacfreq</code> is never allowed to be smaller than 40x the PSS fundamental.</p>

<h4>
<a id="pgfId-1028258"></a>Intermodulation Distor<a id="marker-1028256"></a>tion Computatio<a id="IntermodDistortComputation"></a>n</h4>

<p>
<a id="pgfId-1028259"></a>A PSS analysis followed by a PAC analysis measures the intermodulation distortion of amplifiers and mixers. You can also measure intermodulation distortion with a QPSS analysis by applying two large, same-amplitude, closely spaced tones to the input and measuring the third-order intermodulation products. The PSS/PAC approach is slightly different. You apply only one large tone in the PSS analysis. The PSS analysis is therefore faster than the QPSS analysis. After the PSS analysis computes the circuit response to one large tone, then the PAC analysis applies the second tone close to the first. If you consider the small input signal to be one sideband of the large input signal, then the response at the other sideband is the third-order intermodulation distortion, as shown in Figure <a href="chap2.html#23587">2-3</a>.</p>
<p>
<a id="pgfId-1028266"></a>In Figure <a href="chap2.html#23587">2-3</a>, V<sub>L1</sub> is the fundamental of the response due to the large input tone. V<sub>S1</sub> is the fundamental of the response due to the small input tone and is the upper sideband of V<sub>L1</sub>. V<sub>S3</sub> is the lower sideband of V<sub>L1</sub> (in this case, it is the -2 sideband of the response due to the small tone). V<sub>S3</sub> represents the intermodulation distortion.</p>
<p>
<a id="pgfId-1028270"></a>In the lower part of Figure <a href="chap2.html#23587">2-3</a>, all of the signals are mapped into positive frequencies, which is the most common way of viewing such results.</p>

<p><strong>Figure 2-3
<a id="pgfId-1028272"></a><a id="23587"></a>Intermodulation Distortion Measured with PAC Analysis</strong></p>
<p>
<a id="pgfId-1028276"></a></p>
<div class="webflare-div-image">
<img src="images/PACinterModDistortion.gif" /></div>

<p>
<a id="pgfId-1028277"></a>Intermodulation distortion is efficiently measured by applying one large tone (L1), performing a PSS analysis, and then applying the second small tone (S1) with a PAC analysis. In this case, the first tone drives the circuit hard enough to cause distortion and the second tone is used to measure only the intermodulation distortion. After V<sub>L1</sub>, V<sub>S1</sub>, and V<sub>S3</sub> are measured in dB at the output, the output third-order intercept point is computed using the following equation.</p>

<p>
<a id="pgfId-1032690"></a><img width="198" height="63" src="images/chap2-8.gif" /></p>

<p>
<a id="pgfId-1028283"></a>In the equation, V<sub>L1</sub>, V<sub>S1</sub>, and V<sub>S3</sub> must be given in some form of decibels. Currently, dBV is used in the Analog Circuit Design Environment. In this example, V<sub>L1</sub>, V<sub>S1</sub>, and VS3 are given in dBV. Consequently, the intercept point is also computed in dBV. If V<sub>L1</sub>, V<sub>S1</sub>, and V<sub>S3</sub> are given in dBm, the resulting intercept point is computed in dBm.</p>
<p>
<a id="pgfId-1036391"></a>The intermodulation distortion of a mixer is measured in a similar manner, except that the PSS analysis must include both the LO and one large tone. For an example of measuring the intermodulation distortion of a mixer, see the <em>Spectre Circuit Simulator and Accelerated Parallel Simulator RF Analysis in ADE Explorer User Guide</em>.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1028286"></a>
If you must measure intermodulation distortion using two large tones to compare against bench measurements, you can run a PSS analysis with two large tones. However, a small commensurate frequency of the two tones can slow down simulation. At other times, use the quicker PSS/PAC approach.</div>

<p>
<a id="pgfId-1036406"></a>For the PAC analysis the frequencies of the stimulus and response are usually different. This is an important difference between the PAC analysis and the AC analysis. The <code>freqaxis</code> parameter specifies whether the results should be output versus the input frequency, <code>in</code>, the output frequency, <code>out</code>, or the absolute value of the output frequency, <code>absout</code>.</p>
<p>
<a id="pgfId-1028288"></a>You can make modulated small signal measurements using the Analog Circuit Design Environment (ADE). The <code>modulated</code> option for the PAC analysis and other modulated parameters are set in ADE. A PAC analyses with the <code>modulated</code> option produces results which might have limited use outside of ADE. The Direct Plot form is configured to analyze modulated small signal measurements and combine several waveforms to measure AM and PM response due to single sideband or modulated stimuli.</p>

<h3>
<a id="pgfId-1028290"></a>Frequency Swee<a id="FrequencySweepPAC"></a>p</h3>

<p>
<a id="pgfId-1028291"></a>You can specify sweep limits by providing either the end points or the center value and the span of the sweep.</p>
<p>
<a id="pgfId-1028292"></a>Steps can be linear or logarithmic and you can specify either the number of steps or the size of each step. You can specify a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10:1, and logarithmic when this ratio is equal to or greater than 10:1.</p>
<p>
<a id="pgfId-1028293"></a>Alternatively, you may specify particular values for the sweep parameter using the values parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hz.</p>

<h3>
<a id="pgfId-1033414"></a>Modulated Small-Signal Analyses</h3>

<p>
<a id="pgfId-1033419"></a>You can make modulated small signal measurements using the Analog Design Environment (ADE). The <code>modulated</code> option for PAC and other modulated parameters are set by ADE. PAC analyses with the <code>modulated</code> option produce results which might have limited use outside the ADE environment. The ADE Direct Plot form is configured to analyze these results and combine several wave forms to measure AM and PM response due to single sideband or modulated stimuli.</p>

<h3>
<a id="pgfId-1042529"></a>Sampled Small-Signal Analysis</h3>

<p>
<a id="pgfId-1042532"></a>Sampled small signal PXF and PAC analyses use the Analog Design Environment (ADE) environment. The sampled options are set by ADE. The Sampled option produces results which might have limited use outside ADE. Direct Plot is configured to analyze the results and make Sampled measurements due to single sideband or sampled stimuli. A sampled analysis is a small-signal analysis with a use model similar to the sampled (timedomain) PNoise analysis. Specifically, you first create a circuit (schematic or netlist description) and place port or source components to specify the key elements where the transfer function to the output is of interest.</p>
<p>
<a id="pgfId-1042533"></a>The ability to sample the noise, signal slope and transfer function at a particular time point is a valuable investigative tool for design and verification. For example it will be used in a design of switched-capacitor filters, logic circuits and in the evaluation of the power supply rejection. A Sampled analysis computes the transfer function from different parts of the circuit to the output at a particular time point. The output signal is sampled at the clock rate (large signal period which is used in PSS).</p>
<p>
<a id="pgfId-1042534"></a>A new choice in the <em>Specialized Analysis</em> cyclic menu, <em>Sampled</em>, opens the <em>Sampled</em> analysis fields in the Choosing Analyses form. Several fields are available to specify the sampling event. First, you select a control signal to observe in search for the triggering event(s). It could be a single or differential voltage signal or a probe, either voltage or current. The threshold value and the crossing direction are the parameters of a triggering timing event. In case of special need, you can specify a delayed measurement from the time of the crossing event.</p>
<p>
<a id="pgfId-1042535"></a>You can also specify actual time points for sampling the output. The same form will be used and either one or the combination of both approaches is used to do the sampled small signal analysis.</p>

<h3>
<a id="pgfId-1028295"></a>Parameters for PAC A<a id="ParamsPAC"></a>nalysis</h3>

<p>
<a id="pgfId-1060754"></a>For information on PAC analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#pac" show="replace" xml:link="simple">Periodic AC Analysis (pac)</a></em> section in the <em>Spectre Circuit Simulator Reference</em> manual</p>

<h2>
<a id="pgfId-1036383"></a><a id="20945"></a>Periodic S-Parameter Analysis (PSP)</h2>

<p>
<a id="pgfId-1028424"></a>The Periodic S-Parameter (<a id="PSP"></a>PSP) analysis is used to compute scattering and noise parameters for n-port circuits that exhibit frequency translation. Such circuits include mixers, switched-capacitor filters, samplers and other similar circuits.</p>
<p>
<a id="pgfId-1028425"></a>PSP is a small-signal analysis similar to the conventional SP analysis, except, the circuit is first linearized about a periodically time-varying operating point as opposed to a simple DC operating point. Linearizing about a periodically time-varying operating point allows the computation of S-parameters between circuit ports that convert signals from one frequency band to another.</p>
<p>
<a id="pgfId-1028426"></a>PSP analysis also calculates noise parameters in frequency-converting circuits. PSP computes noise figure (both single-sideband and double-sideband), input referred noise, equivalent noise parameters, and noise correlation matrices. The noise features of PSP analysis, as for Pnoise analysis but unlike SP analysis, include noise folding effects due to the periodically time-varying nature of the circuit.</p>
<p>
<a id="pgfId-1028427"></a>Computing the n-port S-parameters and noise parameters of a periodically varying circuit is a two step process.</p>
<ul><li>
<a id="pgfId-1028428"></a>First, the small stimulus is ignored and the periodic steady-state response of the circuit to possibly large periodic stimulus is computed using PSS analysis.<br />
<a id="pgfId-1028429"></a>As a normal part of the PSS analysis, the periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1028430"></a>Then, using the PSP analysis, small-signal excitations are applied to compute the n-port S-parameters and noise parameters.<br />
<a id="pgfId-1028431"></a>A PSP analysis cannot be used alone, it must follow a PSS analysis. However, any number of periodic small-signal analyses such as PAC, PSP, PXF, and Pnoise, can follow a single PSS analysis.</li></ul>







<p>
<a id="pgfId-1028432"></a>Like other Spectre RF small-signal analyses, the PSP analysis can sweep only frequency.</p>

<h4>
<a id="pgfId-1028433"></a>PSP Synopsis</h4>

<p>
<a id="pgfId-1028434"></a>For a PSP analysis, you need to specify the port and port harmonic relations. Select the ports of interest by setting the <em>port</em> parameter. Set the periodic small-signal output frequencies of interest by setting the <em>portharmsvec</em> or the <em>harmsvec</em> parameters.</p>
<p>
<a id="pgfId-1028435"></a>For a given set of <em>n</em> integer numbers representing the harmonics <em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>, ... <em>K</em><sub>n</sub>, the scattering parameters at each port are computed at the frequencies</p>
<p>
<a id="pgfId-1028436"></a><em>f(scattered)= f(rel) + K</em><sub>i</sub><em> x fund(pss)</em></p>
<p>
<a id="pgfId-1028437"></a>where <em>f(rel)</em> represents the relative frequency of a signal incident on a port, <em>f(scattered)</em> represents the frequency to which the relevant scattering parameter represents the conversion, and <em>fund(pss)</em> represents the fundamental frequency used in the corresponding PSS analysis.</p>
<p>
<a id="pgfId-1028438"></a>Thus, when analyzing a down-converting mixer, with signal in the upper sideband, and sweeping the RF input frequency, the most relevant harmonic for RF input is <em>Ki= 1</em> and for IF output <em>K</em>i= 0. Hence we can associate <em>K2=0</em> with the IF port and <em>K</em>1=1 with the RF port. <em>S21</em> will represent the transmission of signal from the RF to IF, and <em>S11</em> the reflection of signal back to the RF port. If the signal was in the lower sideband, then a choice of <em>K1=-1</em> would be more appropriate.</p>
<p>
<a id="pgfId-1028439"></a>You can use either the <em>portharmsvec</em> or the <em>harmsvec</em> parameters to specify the harmonics of interest. If you give <em>portharmsvec</em>, the harmonics must be in one-to-one correspondence with the ports, with each harmonic associated with a single port. If you specify harmonics with the optional <em>harmsvec</em> parameter, then all possible frequency-translating scattering parameters associated with the specified harmonics are computed.</p>
<p>
<a id="pgfId-1028440"></a>For PSP analysis, the frequencies of the input and of the response are usually different (this is an important way in which PSP differs from SP). Because the PSP computation involves inputs and outputs at frequencies that are relative to multiple harmonics, the <em>freqaxis</em> and <em>sweeptype</em> parameters behave somewhat differently in PSP than they do in PAC and PXF.</p>
<p>
<a id="pgfId-1028441"></a>The <em>sweeptype</em> parameter controls the way the frequencies are swept in PSP analysis. Specifying <em>relative </em>sweep, sweeps relative to the analysis harmonics (not the PSS fundamental). Specifying <em>absolute</em> sweep, sweeps the absolute input source frequency. For example, with a PSS fundamental of 100MHz, the <em>portharmsvec</em> set to [9 1] to examine a down-converting mixer, <em>sweeptype=relative</em>, and a sweep <em>range</em> of <em>f(rel)=0-&gt;50MHz</em>, then S21 would represent the strength of signal transmitted from the input port in the range 900-950MHz to the output port at frequencies 100-&gt;150MHz.</p>
<p>
<a id="pgfId-1028442"></a>Using <code>sweeptype=absolute</code> and sweeping the frequency from<em> 900-&gt;950MHz</em> would calculate the same quantities, since <em>f (abs)=900-&gt;950MHz</em>, and <em>f (rel) = f (abs) - K1 * fund(pss) = 0-&gt;50MHz</em>, because <em>K1=9</em> and <em>fund(pss) = 100MHz</em>.</p>
<p>
<a id="pgfId-1028443"></a>The <em>freqaxis</em> parameter is used to specify whether the results should be output versus the scattered frequency at the input <em>port(in)</em>, the scattered frequency at the output <em>port(out)</em> or the absolute value of the frequency swept at the input <em>port(absin)</em>.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1028444"></a>Unlike in PAC, PXF, and Pnoise analyses, increasing the number of requested ports and harmonics<em> increases</em> the simulation time substantially.</div>
<p>
<a id="pgfId-1028445"></a>To ensure accurate results in PSP analysis, you should set the <em>maxacfreq</em> parameter for the corresponding PSS analysis to guarantee that <em>|max{f(scattered)}|</em> is less than the <em>maxacfreq</em> parameter value, otherwise the computed solution might be contaminated by aliasing effects.</p>
<p>
<a id="pgfId-1028446"></a>PSP analysis also computes noise figures, equivalent noise sources, and noise parameters. The noise computation, which is skipped only when the <em>donoise</em> parameter is set to <code>no</code>, requires additional simulation time.</p>

<p>
<a id="pgfId-1028539"></a></p>
<table class="webflareTable" id="#id1028447">
<caption style="text-align:left;"><p>
<ft-figtabl-title id="#id1028450">
<a id="pgfId-1028450"></a>Noise C<a id="NoiseCalcsPSP"></a>alculations Performed by PSP</ft-figtabl-title>
</p></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028456">
<a id="pgfId-1028456"></a>Name</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028458">
<a id="pgfId-1028458"></a>Description</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028460">
<a id="pgfId-1028460"></a>Output Label</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028462"></a><strong>N</strong><sub><strong>o </strong></sub></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028464"></a>Total output noise at frequency f </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028466"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028468"></a><strong>Ns </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028470"></a>Noise at the output due to the input probe (the source)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028472"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028474"></a><strong>Nsi </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028476"></a>Noise at the output due to the image harmonic at the source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028478"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028480"></a><strong>Nso</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028482"></a>Noise at the output due to harmonics other than input at the<br />source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028484"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028486"></a><strong>Nl</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028488"></a>Noise at the output due to the output probe (the load) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028490"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028492"></a><strong>IRN </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028494"></a>Input referred noise </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028496"></a><strong>In</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028498"></a><strong>G</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028500"></a>Gain of the circuit (See <strong>Note:</strong>)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028502"></a><strong>Gain</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028504"></a><strong>F</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028506"></a>Single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028508"></a><strong>F</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028510"></a><strong>NF</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028512"></a>Single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028514"></a><strong>NF</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028516"></a><strong>Fdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028518"></a>Double sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028520"></a><strong>F</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028522"></a><strong>NFdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028524"></a>Double sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028526"></a><strong>NF</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028528"></a><strong>Fieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028530"></a>IEEE single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028532"></a><strong>F</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028534"></a><strong>NFieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028536"></a>IEEE single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028538"></a><strong>NF</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
</tbody></table>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1028540"></a>The gain computed by PSP is the voltage gain from the actual circuit input to the circuit output, not the gain from the internal port voltage source to the output.</div>
<p>
<a id="pgfId-1028541"></a>PSP analysis performs the following noise calculations.</p>
<p>
<a id="pgfId-1028542"></a>Input referred noise</p>

<p>
<a id="pgfId-1028546"></a></p>
<div class="webflare-div-image">
<img width="116" height="83" src="images/chap2-9.gif" /></div>

<p>
<a id="pgfId-1028547"></a>Single sideband noise factor</p>

<p>
<a id="pgfId-1028551"></a></p>
<div class="webflare-div-image">
<img width="136" height="82" src="images/chap2-10.gif" /></div>

<p>
<a id="pgfId-1028552"></a>Single sideband noise figure</p>

<p>
<a id="pgfId-1028556"></a></p>
<div class="webflare-div-image">
<img width="166" height="49" src="images/chap2-11.gif" /></div>

<p>
<a id="pgfId-1028557"></a>Double sideband noise factor</p>

<p>
<a id="pgfId-1028561"></a></p>
<div class="webflare-div-image">
<img width="150" height="107" src="images/chap2-12.gif" /></div>

<p>
<a id="pgfId-1028562"></a>Double sideband noise figure</p>

<p>
<a id="pgfId-1028566"></a></p>
<div class="webflare-div-image">
<img width="221" height="50" src="images/chap2-13.gif" /></div>

<p>
<a id="pgfId-1028567"></a>IEEE single sideband noise factor</p>

<p>
<a id="pgfId-1028571"></a></p>
<div class="webflare-div-image">
<img width="201" height="109" src="images/chap2-14.gif" /></div>

<p>
<a id="pgfId-1028572"></a>IEEE single sideband noise figure</p>

<p>
<a id="pgfId-1028576"></a></p>
<div class="webflare-div-image">
<img width="227" height="52" src="images/chap2-15.gif" /></div>

<p>
<a id="pgfId-1063054"></a>When the results are output, IRN is named <code>in</code>, G is named <code>gain</code>, F, NF, Fdsb, NFdsb, Fieee, and NFieee are named <code>F</code>, <code>NF</code>, <code>Fdsb</code>, <code>NFdsb</code>, <code>Fieee</code>, and <code>NFieee</code>, respectively.</p>
<p>
<a id="pgfId-1028577"></a>To ensure accurate noise calculations, you need to set the <em>maxsideband</em> or <em>sidebands</em> parameters to include the relevant noise folding effects. The <em>maxsideband</em> parameter is only relevant to the noise computation features of PSP.</p>

<h3>
<a id="pgfId-1028579"></a>Parameters for PSP A<a id="ParamsPSP"></a>nalysis</h3>

<p>
<a id="pgfId-1060905"></a>For information on PSP analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#psp" show="replace" xml:link="simple">Periodic S-Parameter Analysis (psp)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h2>
<a id="pgfId-1028689"></a><a id="11860"></a>Periodic Trans<a id="marker-1028687"></a>fer Function Analysis (PXF)</h2>

<p>
<a id="pgfId-1036447"></a>A conventional transfer function (XF) analysis computes the transfer function from every source in the circuit to a single output. An XF analysis differs from a conventional AC analysis in that the AC analysis computes the response from a single stimulus to every node in the circuit.</p>
<p>
<a id="pgfId-1028691"></a>The difference between the PXF and PAC analyses is similar. The <a id="PXF"></a>PXF analysis computes the transfer functions from any source at any frequency to a single output at a single frequency. Like PAC analysis, PXF analysis models frequency conversion effects. This is illustrated in Figure <a href="chap2.html#22523">2-4</a>.</p>
<p>
<a id="pgfId-1036461"></a>The PXF analysis directly computes such useful quantities as</p>
<ul><li>
<a id="pgfId-1036466"></a>Conversion efficiency (the transfer function from input to output at a desired frequency)</li><li>
<a id="pgfId-1036469"></a>Image and sideband rejection (input to output at an undesired frequency)</li><li>
<a id="pgfId-1036472"></a>LO feed-through and power supply rejection (undesired input to output at all frequencies)</li></ul>


<p>
<a id="pgfId-1036459"></a>PXF analysis measures conversion gains, especially those from the input source to the output. It also computes the conversion gain of the specified sideband as well as various unwanted images including the baseband feed through. PXF analysis also computes the coupling from other inputs such as the LO and the power supplies. These computations model frequency translation. PXF analysis determines the sensitivity of the output to either up-converted or down-converted noise from either the power supplies or the LO.</p>
<p>
<a id="pgfId-1028696"></a>The output is sensitive to signals at many frequencies at the input of the mixer. The input signals are replicated and translated by each harmonic of the LO. The signals shown in Figure <a href="chap2.html#22523">2-4</a> are those that end up at the output frequency.</p>
<p>
<a id="pgfId-1028700"></a>Computing transfer functions for a periodically varying circuit is a two step process.</p>
<ul><li>
<a id="pgfId-1028701"></a>First, the small stimulus is ignored and the periodic steady-state response of the circuit to possibly large periodic stimulus is computed using PSS analysis.<br />
<a id="pgfId-1028702"></a>As a normal part of the PSS analysis, the periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1028703"></a>Second, using the PXF analysis, small-signal excitations are applied to compute the transfer functions.<br /><strong class="webflare-fig-line-height">Figure 2-4
<a id="pgfId-1028705"></a><a id="22523"></a>Mixer Output Signals Shown by PXF Analysis</strong>
<a id="pgfId-1028735"></a><div class="webflare-div-image">
<img width="668" height="632" src="images/chap2-16.gif" /></div></li></ul>









<p>
<a id="pgfId-1028736"></a>A PXF analysis cannot be used alone, it must follow a PSS analysis. However, any number of periodic small-signal analyses such as PAC, PSP, and Pnoise, can follow a single PSS analysis.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1028737"></a>
Unlike other Spectre RF small-signal analyses, the PXF analysis can sweep only frequency.</div>
<h3>
<a id="pgfId-1028739"></a>Parameters for PXF A<a id="ParamsPXF"></a>nalysis</h3>

<p>
<a id="pgfId-1061057"></a>For information on PXF analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#pxf" show="replace" xml:link="simple">Periodic Transfer Function Analysis (pxf)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h3>
<a id="pgfId-1028870"></a>O<a id="marker-1028868"></a>utput P<a id="marker-1028869"></a>arameters</h3>

<p>
<a id="pgfId-1028871"></a>The output variable you measure can be voltage or current, and the variable frequency is not limited by the period of the large-periodic solution. When you sweep a selected output frequency, you can select the periodic small-signal input frequencies by specifying either one of the <code>maxsideband</code> or <code>sideband</code> parameters.</p>
<p>
<a id="pgfId-1028872"></a>For a set of <em>n</em> integer numbers representing the sidebands</p>

<p>
<a id="pgfId-1028876"></a><img width="119" height="52" src="images/chap2-17.gif" /></p>

<p>
<a id="pgfId-1028877"></a>the input signal frequency at each sideband is computed as</p>

<p>
<a id="pgfId-1028881"></a><img width="255" height="55" src="images/chap2-18.gif" /></p>

<p>
<a id="pgfId-1028882"></a>where</p>
<ul><li>
<a id="pgfId-1028883"></a><em>
f</em>
(<em>
out</em>
) represents the (possibly swept) output signal frequency</li><li>
<a id="pgfId-1028884"></a><em>
fund</em>
(<em>
pss</em>
) represents the fundamental frequency used in the corresponding PSS analysis</li></ul>

<p>
<a id="pgfId-1028885"></a>When you analyze a down-converting mixer and sweep the IF output frequency, <em>
k</em>
<sub>i </sub>= +1 for the RF input represents the first upper sideband, and <em>
k</em>
<sub>i </sub>= <code>-1</code> for the RF input represents the first lower sideband. If you specify the maximum sideband value by setting the <code>maxsideband</code> value to <em>
k</em>
<sub>max</sub>, you are selecting all 2 × <em>
k</em>
<sub>max</sub> <em>
+</em>
1 sidebands from -<em>
k</em>
<sub>max</sub> to +<em>
k</em>
<sub>max</sub>.</p>
<p>
<a id="pgfId-1028886"></a>For PXF analysis, the number of sidebands you select with <code>maxsideband</code> does not substantially increase the simulation time. However, to ensure accurate PXF analysis results, set the <code>maxacfreq</code> parameter for the corresponding PSS analysis to guarantee that</p>

<p>
<a id="pgfId-1028890"></a><img width="226" height="42" src="images/chap2-19.gif" /></p>

<p>
<a id="pgfId-1028891"></a>otherwise the computed solution might be contaminated by aliasing effects. The PXF simulation does not run when</p>

<p>
<a id="pgfId-1028895"></a><img width="172" height="41" src="images/chap2-20.gif" /></p>

<p>
<a id="pgfId-1028896"></a>For these extreme cases, diagnostic messages indicate how you should change the <code>maxacfreq</code> parameter value in the PSS analysis. In a majority of simulations, however, this is not an issue because the <code>maxacfreq</code> value is never allowed to be smaller than 40 times the PSS fundamental.</p>
<p>
<a id="pgfId-1028897"></a>With PXF analysis the frequency of the stimulus and response are usually different (this is an important way in which the PXF analysis differs from the XF analysis). Use the <code>freqaxis</code> parameter to specify whether the results should be output versus the input frequency, <code>in</code>, the output frequency, <code>out</code>, or the absolute value of the input frequency, <code>absin</code>.</p>

<h3>
<a id="pgfId-1028898"></a>Probe Parameters</h3>

<p>
<a id="pgfId-1028899"></a>You can specify the output with a pair of nodes or a probe component. Any component with two or more terminals can be a voltage probe. When there are more than two terminals, they are grouped in pairs. Use the <code>portv</code> parameter to select the appropriate pair of terminals. Alternatively, you can simply specify a voltage to be the output by giving a pair of nodes on the PXF analysis statement.</p>
<p>
<a id="pgfId-1028900"></a>Any component that naturally computes current as an internal variable, such as a voltage source, can be a current probe. If the probe component computes more than one current, you use the <code>porti</code> parameter to select the appropriate current. Do not specify both the <code>portv</code> and <code>porti</code> parameters. If you do not specify either parameter, the probe component provides a reasonable default.</p>
<p>
<a id="pgfId-1028901"></a>The Analog Circuit Design Environment (ADE) provides two ways to set probes on the Choosing Analyses form</p>
<ul><li>
<a id="pgfId-1028902"></a>When you specify input or output sources</li><li>
<a id="pgfId-1028903"></a>When you specify positive or negative output nodes</li></ul>


<h3>
<a id="pgfId-1028904"></a>Output Parameters</h3>

<p>
<a id="pgfId-1028905"></a>The <code>stimuli</code><em>
 
parameter (on the PXF Options form) specifies the transfer function inputs. You select one of two choices:</em></p>
<ul><li>
<a id="pgfId-1028906"></a>Use <code>stimuli</code> = <code>sources</code> to use the sources present in the circuit. To compensate for gains or losses in the test fixture, use the <code>xfmag</code> source component parameter to adjust the computed gain to compensate for gains or losses in a test fixture. In hierarchical netlists, limit the number of sources using the <code>save</code> and <code>nestlvl</code> parameters.</li><li>
<a id="pgfId-1028907"></a>Use <code>stimuli</code> = <code>nodes_and_terminals</code> to compute all possible transfer functions. Use this option when you cannot anticipate which transfer functions you might need to examine. This is useful when you do not know in advance which transfer functions are interesting.</li></ul>

<p>
<a id="pgfId-1028908"></a>Transfer functions for nodes are computed assuming that a unit magnitude flow (current) source is connected from the node to ground. Transfer functions for terminals are computed assuming that a unit magnitude value (voltage) source is connected in series with the terminal. By default, the PXF analysis computes the transfer functions from a small set of terminals.</p>
<p>
<a id="pgfId-1028909"></a>For transfer functions from specific terminals, specify the terminals in the <code>save</code> statement. Use the <code>:probe</code> modifier (for example, <code>Rout:1:probe</code>) or specify <code>useprobes=yes</code> on the options statement. For transfer functions from all terminals, specify <code>currents=all</code> and <code>useprobes=yes</code> on the <code>options</code> statement.</p>

<h3>
<a id="pgfId-1028910"></a>Modulation Parameters</h3>

<p>
<a id="pgfId-1063151"></a>You can make modulated small-signal measurements from the Analog Circuit Design Environment (ADE). The <code>modulated</code> option for PXF analysis and other modulated parameters are set by ADE. The PXF analysis with the <code>modulated</code> option produces results which might have limited use outside the ADE environment. The Direct Plot form is configured to analyze modulated small-signal measurement results. Direct Plot can combine several wave forms to measure AM and PM transfer functions from single sideband or modulated stimuli to the specified output. For details, refer to the <em>Spectre Circuit Simulator and Accelerated Parallel Simulator RF Analysis in ADE Explorer User Guide</em>.</p>

<h3>
<a id="pgfId-1042551"></a>Sampled Small-Signal Analysis</h3>

<p>
<a id="pgfId-1042552"></a>Sampled small signal PXF and PAC analyses use the Analog Design Environment (ADE) environment. The sampled options are set by ADE. The Sampled option produces results which might have limited use outside ADE. Direct Plot is configured to analyze the results and make Sampled measurements due to single sideband or sampled stimuli. A sampled analysis is a small-signal analysis with a use model similar to the sampled (timedomain) PNoise analysis. Specifically, you first create a circuit (schematic or netlist description) and place port or source components to specify the key elements where the transfer function to the output is of interest.</p>
<p>
<a id="pgfId-1042553"></a>The ability to sample the noise, signal slope and transfer function at a particular time point is a valuable investigative tool for design and verification. For example it will be used in a design of switched-capacitor filters, logic circuits and in the evaluation of the power supply rejection. A Sampled analysis computes the transfer function from different parts of the circuit to the output at a particular time point. The output signal is sampled at the clock rate (large signal period which is used in PSS).</p>
<p>
<a id="pgfId-1042554"></a>A new choice in the <em>Specialized Analysis</em> cyclic menu, <em>Sampled</em>, opens the <em>Sampled</em> analysis fields in the Choosing Analyses form. Several fields are available to specify the sampling event. First, you select a control signal to observe in search for the triggering event(s). It could be a single or differential voltage signal or a probe, either voltage or current. The threshold value and the crossing direction are the parameters of a triggering timing event. In case of special need, you can specify a delayed measurement from the time of the crossing event.</p>
<p>
<a id="pgfId-1042555"></a>You can also specify actual time points for sampling the output. The same form will be used and either one or the combination of both approaches is used to do the sampled small signal analysis.</p>

<h3>
<a id="pgfId-1028912"></a>Swept PXF Analysis</h3>

<p>
<a id="pgfId-1028913"></a>Specify sweep limits by providing either the end points (<code>start</code> and <code>stop</code>) or by providing the center value and the span (center and <code>span</code>) of the sweep.</p>
<p>
<a id="pgfId-1028914"></a>Specify sweep steps as <code>linear</code> or <code>logarithmic</code>. Either specify the number of steps or the size of each step. You can give a step-size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is <code>linear</code> or <code>logarithmic</code>. If you do not give a step-size parameter, the sweep is <code>linear</code> when the ratio of <code>stop</code> to <code>start</code> values is less than 10, and <code>logarithmic</code> when this ratio is 10 or greater.</p>
<p>
<a id="pgfId-1028915"></a>Alternatively, use the <code>values</code> parameter to specify the particular values that the sweep parameter should take. If you give both a specific set of values and a set of values specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hertz.</p>

<h2>
<a id="pgfId-1028918"></a><a id="33596"></a>Periodic Noise <a id="marker-1028917"></a>Analysis (Pnoise)</h2>

<p>
<a id="pgfId-1028919"></a>The Periodic Noise analysis (<a id="Pnoise"></a>Pnoise) is similar to the conventional noise analysis except that it models frequency conversion effects. Hence Pnoise analysis is useful for predicting the noise behavior of mixers, switched-capacitor filters and other periodically driven circuits. The Pnoise analysis is particularly useful for predicting the phase noise of autonomous circuits, such as oscillators.</p>
<p>
<a id="pgfId-1063176"></a>PNoise analysis linearizes the circuit about the periodic operating point computed in the prerequisite PSS analysis. It is the periodically time-varying nature of the linearized circuit that accounts for the frequency conversion. In addition, the affect of a periodically timevarying bias point on the noise generated by the various components in the circuit is also included.</p>
<p>
<a id="pgfId-1028921"></a>Initially, PSS computes the response to a large periodic signal such as a clock or a LO. These results are labeled LO and shown in Figure <a href="chap2.html#36996">2-5</a>. The subsequent Pnoise analysis computes the resulting noise performance.</p>
<p>
<a id="pgfId-1028925"></a>In periodic systems, there are two effects that act to translate noise in frequency.</p>
<ul><li>
<a id="pgfId-1036535"></a>First, for noise sources that are bias dependent, such as shot noise sources, the time-varying operating point modulates the noise sources.</li><li>
<a id="pgfId-1036536"></a>Second, the transfer function from the noise source to the output is also periodically time-varying and modulates the noise source contribution to the output.<br /><strong class="webflare-fig-line-height">Figure 2-5
<a id="pgfId-1028928"></a><a id="36996"></a>How no<a id="1-5"></a>ise is moved around by a mixer</strong>
<a id="pgfId-1028941"></a><div class="webflare-div-image">
<img width="668" height="653" src="images/chap2-21.gif" /></div></li></ul>






<p>
<a id="pgfId-1028942"></a>The time-average of the noise at the output is computed as a spectral density versus frequency. You identify the output by specifying a probe component or a pair of nodes. To specify the output with a probe, the preferred approach, use the <code>oprobe</code> parameter. If the output is voltage (or potential), choose a <code>resistor</code> or a <code>port</code> component for the output probe. If the output is current (or flow), choose a <code>vsource</code> or <code>iprobe</code> component for the output probe.</p>
<p>
<a id="pgfId-1036528"></a>To compute the input-referred noise or the noise figure, specify the input source using the <code>iprobe</code> parameter. For input-referred noise, use either a <code>vsource</code> or <code>isource</code> as the input probe; for noise figure, use a <code>port</code> as the probe. Currently, only a <code>vsource</code>, an <code>isource</code>, or a <code>port</code> can be used as an input probe. If the input source is noisy, as is a <code>port</code>, the noise analysis will compute the noise factor (F) and noise figure (NF). To match the IEEE definition of noise figure, the input probe must be a port with no excess noise and its <code>noisetemp</code> must be set to 16.85C (290K). In addition, the output load must be a <code>resistor</code> or <code>port</code> and must be identified as the <code>oprobe</code>.</p>
<p>
<a id="pgfId-1036542"></a>If <code>port</code> is specified as the input probe, then both input-referred noise and gain are referred back to the equivalent voltage source inside the <code>port</code>. S-parameter analysis calculates those values in the traditional sense.</p>
<p>
<a id="pgfId-1028943"></a>The reference sideband (<code>refsideband</code>) specifies which conversion gain is used to compute the input-referred noise, the noise factor, and the noise figure. The reference sideband specifies the input frequency relative to the output frequency with</p>

<p>
<a id="pgfId-1028947"></a></p>
<div class="webflare-div-image">
<img width="384" height="51" src="images/chap2-22.gif" /></div>

<p>
<a id="pgfId-1028949"></a>Use <code>refsideband=0</code><a id="marker-1028948"></a> when the input and output of the circuit are at the same frequency, such as with amplifiers and filters. When <code>refsideband</code> does not equal 0, the single sideband noise figure is computed.</p>
<p>
<a id="pgfId-1028950"></a>The Pnoise analysis computes the total noise at the output, which includes contributions from the input source, the circuit itself and the output load. The amount of the output noise that is attributable to each noise source in the circuit is also computed and output individually. If the input source is identified (using <code>iprobe</code>) and is a <code>vsource</code> or <code>isource</code>, the input-referred noise is computed, which includes the noise from the input source itself. Finally, if the input source is identified (using <code>iprobe</code>) and is also noisy, as is the case with ports, the noise factor and noise figure are computed.</p>

<p>
<a id="pgfId-1029042"></a></p>
<table class="webflareTable" id="#id1028951">
<caption style="text-align:left;"><p>
<ft-figtabl-title id="#id1028953">
<a id="pgfId-1028953"></a>Noise Calculations Performed by Pnoise</ft-figtabl-title>
</p></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028959">
<a id="pgfId-1028959"></a>Name</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028961">
<a id="pgfId-1028961"></a>Description</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1028963">
<a id="pgfId-1028963"></a>Output Label</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028965"></a><strong>N</strong><sub><strong>o </strong></sub></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028967"></a>Total output noise </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028969"></a><strong>Out</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028971"></a><strong>Ns </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028973"></a>Noise at the output due to the input probe (the source)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028975"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028977"></a><strong>Nsi </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028979"></a>Noise at the output due to the image harmonic at the source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028981"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028983"></a><strong>Nso</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028985"></a>Noise at the output due to harmonics other than input at the<br />source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028987"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028989"></a><strong>Nl</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028991"></a>Noise at the output due to the output probe (the load) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028993"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028995"></a><strong>IRN </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028997"></a>Input referred noise</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1028999"></a><strong>In</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029001"></a><strong>G</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029003"></a>Gain of the circuit</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029005"></a><strong>Gain</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029007"></a><strong>F</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029009"></a>Single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029011"></a><strong>F</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029013"></a><strong>NF</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029015"></a>Single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029017"></a><strong>NF</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029019"></a><strong>Fdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029021"></a>Double sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029023"></a><strong>F</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029025"></a><strong>NFdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029027"></a>Double sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029029"></a><strong>NF</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029031"></a><strong>Fieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029033"></a>IEEE single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029035"></a><strong>F</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029037"></a><strong>NFieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029039"></a>IEEE single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029041"></a><strong>NF</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1029043"></a>Spectre RF performs the following noise calculations.</p>
<p>
<a id="pgfId-1029044"></a>Input referred noise</p>

<p>
<a id="pgfId-1029048"></a></p>
<div class="webflare-div-image">
<img width="114" height="85" src="images/chap2-23.gif" /></div>

<p>
<a id="pgfId-1029049"></a>Single sideband noise factor</p>

<p>
<a id="pgfId-1029053"></a></p>
<div class="webflare-div-image">
<img width="132" height="87" src="images/chap2-24.gif" /></div>

<p>
<a id="pgfId-1029054"></a>Single sideband noise figure</p>

<p>
<a id="pgfId-1029058"></a></p>
<div class="webflare-div-image">
<img width="170" height="51" src="images/chap2-25.gif" /></div>

<p>
<a id="pgfId-1029059"></a>Double sideband noise factor</p>

<p>
<a id="pgfId-1029063"></a></p>
<div class="webflare-div-image">
<img width="154" height="108" src="images/chap2-26.gif" /></div>

<p>
<a id="pgfId-1029064"></a>Double sideband noise figure</p>

<p>
<a id="pgfId-1029068"></a></p>
<div class="webflare-div-image">
<img width="223" height="50" src="images/chap2-27.gif" /></div>

<p>
<a id="pgfId-1029069"></a>IEEE single sideband noise factor</p>

<p>
<a id="pgfId-1029073"></a></p>
<div class="webflare-div-image">
<img width="198" height="105" src="images/chap2-28.gif" /></div>

<p>
<a id="pgfId-1029074"></a>IEEE single sideband noise figure</p>

<p>
<a id="pgfId-1029078"></a></p>
<div class="webflare-div-image">
<img width="221" height="51" src="images/chap2-29.gif" /></div>
<h4>
<a id="pgfId-1029080"></a>Pnoise Syno<a id="marker-1029079"></a>psis</h4>

<p>
<a id="pgfId-1029081"></a>Noise can mix with each harmonic of the periodic drive signal from the PSS analysis and appear at the output frequency. However, Pnoise analysis models only noise that mixes with a set of harmonics that you normally specify with the <code>maxsideband</code><a id="marker-1029082"></a> parameter, but which you might specify with the <code>sidebands</code><a id="marker-1029083"></a> parameter in special circumstances. If Ki represents sideband i, then</p>

<p>
<a id="pgfId-1029087"></a></p>
<div class="webflare-div-image">
<img width="326" height="52" src="images/chap2-30.gif" /></div>

<p>
<a id="pgfId-1029088"></a>The <code>maxsideband</code> parameter specifies the maximum |Ki| included in the Pnoise calculation. Therefore, Pnoise ignores noise at frequencies less than <em>
f(out)
 &#8211; <em>
maxsideband
 <em>
fund
(pss) and greater than <em>
f(out)
 + <em>
maxsideband
 <em>
fund
(pss). If you specify sidebands with the <code>sidebands</code> parameter, then Pnoise includes only the specified sidebands in the calculation. When you specify <code>sidebands</code> parameter values, be careful not to omit any sidebands that might contribute significant output noise.</em></em></em></em></em></em></p>
<p>
<a id="pgfId-1036554"></a>In practice, noise can mix with each of the harmonics of the periodic drive signal applied in the PSS analysis and end up at the output frequency. However, the PNoise analysis only includes the noise that mixes with a finite set of harmonics that are typically specified using the <code>maxsideband</code> parameter, but in special circumstances may be specified with the <code>sidebands</code> parameter. If Ki represents sideband i, then</p>
<p>
<a id="pgfId-1036555"></a>    <em>f (noise_source) = f (out) + Ki * fund(pss)</em></p>
<p>
<a id="pgfId-1036552"></a>The <code>maxsideband</code> parameter specifies the maximum <em>|Ki|</em> included in the PNoise calculation. Thus, noise at frequencies less than <em>f(out)-maxsideband*fund(pss)</em> and greater than <em>f(out)+maxsideband*fund(pss)</em> are ignored. If selected sidebands are specified using the <code>sidebands</code> parameter, then only those are included in the calculation. You should take care when specifying the sidebands because the results will be in error if you do not include a sideband that contributes significant noise to the output.</p>
<p>
<a id="pgfId-1036565"></a>The number of requested sidebands does not change substantially the simulation time. However, the <code>maxacfreq</code> of the corresponding PSS analysis should be set to guarantee that <em>|max{f(noise_source)}|</em> is less than <code>maxacfreq</code>, otherwise the computed solution might be contaminated by aliasing effects. The PNoise simulation is not executed for |<em>f(out)|</em> greater than <code>maxacfreq</code>. Diagnostic messages are printed for those extreme cases, indicating which <code>maxacfreq</code> should be set in the PSS analysis. In the majority of the simulations, however, this is not an issue, because <code>maxacfreq</code> is never allowed to be smaller than 40 times the PSS fundamental.</p>
<p>
<a id="pgfId-1036566"></a>Phase Noise measurements are possible using the Analog Design Environment (ADE). Two Pnoise analyses are preconfigured for this simulation and most of the parameters are set by ADE.</p>
<ul><li>
<a id="pgfId-1037326"></a>The <code>mod1</code> Pnoise analysis is a regular noise analysis and can be used independently.</li><li>
<a id="pgfId-1037327"></a>The <code>mod2</code> Pnoise analysis is a correlation analysis and has limited use outside of the ADE environment.</li></ul>

<p>
<a id="pgfId-1037328"></a>The Direct Plot form in ADE is configured to analyze these results and combine several waveforms to measure AM and PM components of output noise.</p>
<p>
<a id="pgfId-1036567"></a>You can specify sweep limits by giving the end points or by providing the center value and the span of the sweep. Steps can be linear or logarithmic, and you can specify the number of steps or the size of each step. You can give a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10, and logarithmic when this ratio is 10 or greater. Alternatively, you may specify the particular values that the sweep parameter should take using the <code>values</code> parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hz.</p>

<h3>
<a id="pgfId-1029092"></a>Parameters for P<a id="ParamsPNOISE"></a>noise Analysis</h3>

<p>
<a id="pgfId-1061207"></a>For information on pnoise analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#pnoise" show="replace" xml:link="simple">Periodic Noise Analysis (pnoise) </a></em>section in the Spectre Circuit Simulator Reference manual.</p>

<h4>
<a id="pgfId-1029242"></a>Noise Figu<a id="marker-1029241"></a>re</h4>

<p>
<a id="pgfId-1029243"></a>When you use Pnoise analysis to compute the noise factor or noise figure of a circuit, and the load generates noise, specify the output with the <code>oprobe</code><a id="marker-1029244"></a> parameter rather than using a pair of nodes. Using the <code>oprobe</code> parameter explicitly specifies the load as the output probe. This is preferable because it excludes the noise of the load from the calculation of the noise figure.</p>
<p>
<a id="pgfId-1029245"></a>As an alternative, you can specify the output with a pair of nodes and make the load component a noiseless resistor. Results with this approach are similar to those computed if you specify a resistor or a port as the output probe (load). The only difference is that the noiseless resistor is considered noiseless for other noise calculations, such as total output noise and input-referred noise, and the resistor is noiseless at all frequencies. When you specify a conventional resistor or port for the load, its noise is subtracted from only the noise factor and noise figure calculations, and only at the output frequency. Consequently, noise from load frequencies other than the output frequency can appear at the output frequency if the circuit has a nonlinear output impedance.</p>
<p>
<a id="pgfId-1029246"></a>Pnoise computes the single-sideband noise figure. To match the IEEE definition of noise figure, you must use a <code>port</code> as the input probe and a <code>resistor</code> or a <code>port</code> as the output probe. In addition, the input port noise temperature must be 290 K (<code>noisetemp</code><em>
 
<a id="marker-1029247"></a>= 16.85) and have no excess noise. (You must not specify <code>noisevec</code><a id="marker-1029248"></a> and <code>noisefile</code><a id="marker-1029249"></a> on the input port.) The 290K temperature is the average noise temperature of an antenna used for terrestrial communication. However for your application, you can specify the input port noise temperature to be any appropriate value. For example, the noise temperature for antennas pointed at satellites is usually much lower.</em></p>

<h4>
<a id="pgfId-1047982"></a><a id="75980"></a>Frequency-Aware PPV Analysis for Oscillators with Large Time Constants</h4>

<p>
<a id="pgfId-1047983"></a>Phase noise, because it has an impact on overall system performance, is a major concern in oscillator circuit design. The perturbation projection vector (PPV) models often used to analyze oscillators overestimate the phase noise in oscillators with large time constants, such as oscillators that include switch capacitors, DC bias, or digital dividers. The overestimation error happens because the slow nodes in oscillators filter out the noise from nearby devices and the PPV does not consider these filtering effects.</p>
<p>
<a id="pgfId-1048004"></a>Setting the <code>augmented</code> parameter to <code>yes</code> turns on an analysis that considers the PPV as a frequency dependent quantity. This frequency-aware analysis takes into account the fact that different perturbation frequencies have different PPV waveforms. The analysis provides the same answers as ordinary PPV analysis for small, fast oscillators but provides a more accurate result for oscillators with large time constants.</p>

<h4>
<a id="pgfId-1029252"></a>Flicker Noi<a id="marker-1029250"></a>se<a id="FlickerNoise"></a></h4>

<p>
<a id="pgfId-1042526"></a>To avoid inaccurate results with Pnoise analysis on a circuit that mixes <em>flicker noise</em> or 1/f noise up to the carrier or its harmonics, place a cluster of frequencies near each harmonic to resolve the noise peaks accurately, but do not put frequency points precisely on the harmonics. In addition, choose Pnoise start and stop frequencies to avoid placing points precisely on the harmonics of the periodic drive signal. Then use the <code>values</code><a id="marker-1029254"></a> parameter to specify a vector of additional frequency points near the harmonics. In the Analog Circuit Design Environment, the <code>values</code> parameter is set in the <em>Add Specific Points</em> field in the Choosing Analyses form.</p>
<p>
<a id="pgfId-1029255"></a>The effect of specifying appropriate additional frequency points is shown in the following three diagrams. Figure <a href="chap2.html#57844">2-6</a> shows the true output noise of a mixer with flicker noise.</p>

<p><strong>Figure 2-6
<a id="pgfId-1029260"></a><a id="57844"></a>Actual Mixer Noise Output Including Flicker Noise</strong></p>
<p>
<a id="pgfId-1029274"></a></p>
<div class="webflare-div-image">
<img width="663" height="207" src="images/chap2-31.gif" /></div>

<p>
<a id="pgfId-1029278"></a>Figure <a href="chap2.html#59210">2-7</a> shows the output noise computed with a typical choice of points. In this case, total output noise is typically exaggerated by many orders of magnitude.</p>

<p><strong>Figure 2-7
<a id="pgfId-1029280"></a><a id="59210"></a>Noise Output Computed With Typical Points</strong></p>
<p>
<a id="pgfId-1029306"></a></p>
<div class="webflare-div-image">
<img width="667" height="239" src="images/chap2-32.gif" /></div>

<p>
<a id="pgfId-1029310"></a>Figure <a href="chap2.html#96766">2-8</a> shows noise output computed when the values parameter is used to cluster points near harmonics. By comparing Figures <a href="chap2.html#59210">2-7</a> and <a href="chap2.html#96766">2-8</a>, you can see that total output noise is computed accurately when points are carefully chosen.</p>

<p><strong>Figure 2-8
<a id="pgfId-1029318"></a><a id="96766"></a>Noise Output Computed With Clustered Points</strong></p>
<p>
<a id="pgfId-1029359"></a></p>
<div class="webflare-div-image">
<img width="668" height="256" src="images/chap2-33.gif" /></div>
<h4><em>
<a id="pgfId-1029360"></a>Flicker Noise Spectrum</em></h4>

<p>
<a id="pgfId-1029361"></a>Flicker noise depends on the current, <code>I</code>, of the channel. For all devices, flicker, or <code>1/f</code>, noise depends on the following equation</p>

<p>
<a id="pgfId-1029365"></a></p>
<div class="webflare-div-image">
<img width="368" height="62" src="images/chap2-34.gif" /></div>

<p>
<a id="pgfId-1029366"></a>This means that you see only odd harmonics. The power looks like a rectified sine wave because</p>

<p>
<a id="pgfId-1029370"></a></p>
<div class="webflare-div-image">
<img width="102" height="42" src="images/chap2-35.gif" /></div>
<h2>
<a id="pgfId-1042733"></a><a id="56366"></a>P<a id="PSTB"></a>eriodic Stability Analysis (PSTB)</h2>

<p>
<a id="pgfId-1042734"></a>The periodic stability (PSTB) analysis evaluates the local stability of a periodically time-varying feedback circuit. It is a small-signal analysis, like STB analysis, except that the circuit is first linearized about a periodically varying operating point as opposed to a simple DC operating point. Linearizing about a periodically time-varying operating point allows the stability evaluation to include the effect of the time-varying operating point.</p>
<p>
<a id="pgfId-1042735"></a>The stability evaluation of a periodically varying circuit is a two step process.</p>
<ul><li>
<a id="pgfId-1042736"></a>First, the small stimulus is ignored and the periodic steady-state response of the circuit to a possibly large periodic stimulus is computed using PSS analysis. As a normal part of the PSS analysis, the periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1042737"></a>Then, the small stimulus is applied to compute the loop gain of the zero sideband with a <code>probe</code> component. The local stability can be evaluated using gain margin, phase margin, or a Nyquist plot of the loop gain. To perform PSTB analysis, you must use a <code>probe</code> instance and specify it with the <code>probe</code> parameter.</li></ul>

<p>
<a id="pgfId-1042738"></a>The loop-based algorithm requires that you place the <code>probe</code> on the feedback loop to identify and characterize the particular loop of interest. The introduction of the <code>probe</code> component should not change any of the circuit characteristics. Because of the time-varying properties of the circuit, the loop gain at different places might be different but you can use the loop gain at any point to evaluate stability.</p>
<p>
<a id="pgfId-1042739"></a>The loop-based algorithm provides stability information for both single loop circuits and for multi-loop circuits in which you can place a <code>probe</code> component on a critical wire to break all loops. For a general multi-loop circuit, such a critical wire might not be available. The loop-based algorithm can only be performed on individual feedback loops to ensure they are stable.</p>
<p>
<a id="pgfId-1063242"></a>The device based algorithm requires the probe be a gain instant, such as a bjt transistor or a mos transistor. The device-based algorithm evaluates the loop gain around the probe, which can be involved in multi-loops.</p>
<p>
<a id="pgfId-1042740"></a>Unlike other analyses in Spectre RF, this analysis can only sweep frequency.</p>

<h3>
<a id="pgfId-1042742"></a>Parameters for P<a id="ParamsPSTB"></a>STB Analysis</h3>

<p>
<a id="pgfId-1061356"></a>For information on PSTB analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#pstb" show="replace" xml:link="simple">Periodic STB Analysis (pstb)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h3>
<a id="pgfId-1042834"></a>Swee<a id="FrequencySweepPSTB"></a>p</h3>

<p>
<a id="pgfId-1042835"></a>You can specify sweep limits by providing</p>
<ul><li>
<a id="pgfId-1042836"></a>The end points of the sweep</li><li>
<a id="pgfId-1042837"></a>The center value and the span of the sweep</li><li>
<a id="pgfId-1042838"></a>An array of specific values to sweep</li></ul>


<p>
<a id="pgfId-1042839"></a>Steps can be linear or logarithmic and you can specify either the number of steps or the size of each step. You can specify a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not provide a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10:1 and logarithmic when this ratio is equal to or greater than 10:1.</p>
<p>
<a id="pgfId-1042840"></a>Alternatively, you may specify particular values for the <code>sweep</code> parameter using the <code>values</code> parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hertz.</p>

<h3>
<a id="pgfId-1044179"></a>Understanding Loop-Based and Device-Based Algorithms</h3>

<p>
<a id="pgfId-1044180"></a>Both loop-based and device-based algorithms are available for periodic small-signal stability analysis. When the <code>probe</code> parameter points to a current probe or voltage source instance, the loop-based algorithm is used; when it points to a supported active device instance, the device-based algorithm is used.</p>

<h4>
<a id="pgfId-1042841"></a>About the PSTB Loop-Based Algorithm</h4>

<p>
<a id="pgfId-1042842"></a>The PSTB loop-based algorithm is based on a subset of Nyquist criteria. The analysis outputs the loop gain waveform.</p>
<p>
<a id="pgfId-1042843"></a>The PSTB loop-based algorithm calculates the true loop gain, which consists of both normal loop gain and reverse loop gain. The loop-based algorithm requires that you place a <code>probe</code> component in the feedback loop to identify and characterize the particular loop of interest. Introducing the <code>probe</code> component should not change circuit characteristics.</p>
<p>
<a id="pgfId-1042844"></a>The loop-based algorithm provides accurate stability information for single loop circuits. It also provides accurate stability information for multi-loop circuits in which you can place a <code>probe</code> component on a critical wire to break all loops. For general multi-loop circuits, such a critical wire may not be available. The loop-based algorithm can only be performed on individual feedback loops to ensure they are stable. Although the stability of all feedback loops is a necessary condition for the whole circuit to be stable, the multi-loop circuit tends to be stable if all individual loops are associated with reasonable stability margins.</p>

<h4>
<a id="pgfId-1044196"></a>Device-Based Algorithm</h4>

<p>
<a id="pgfId-1044197"></a>The device-based algorithm calculates the loop gain around a particular active device, which must be a gain instance such as a bjt or mos transistor. This algorithm is often applied to assess the stability of circuit designs in which local feedback loops cannot be neglected. The loop-based algorithm cannot be used for such designs because the local feedback loops are inside the devices where a <code>probe</code> component cannot be inserted.</p>
<p>
<a id="pgfId-1044275"></a>When the <code>probe</code> parameter points to a particular active device, the dominant controlled source in the device is nulled during the analysis. The device-based algorithm produces accurate stability information for a circuit in which a critical active device can be identified such that nulling the dominant gain source of this device renders the whole network to be passive.</p>

<h2>
<a id="pgfId-1042731"></a><a id="65248"></a>Quasi-Periodic Steady-State Analysis (QPSS)</h2>

<p>
<a id="pgfId-1029373"></a>The quasi-periodic steady-state (<a id="QPSS"></a>QPSS) analysis computes the quasi-periodic steady-state response of a circuit that operates on multiple time scales. A quasi-periodic signal has dynamics in multiple fundamental frequencies. Closely spaced or incommensurate fundamentals cannot be efficiently resolved by PSS analysis. (Incommensurate frequencies are those for which there is no period that is an integer multiple of the period of each frequency.) QPSS analysis allows you to compute circuit responses to several moderately large input signals in addition to a strongly nonlinear tone which represents the LO or clock signal. A typical example is the intermodulation distortion measurements of a mixer with two closely spaced moderate input signals. QPSS treats one particular input signal (usually the one that causes the most nonlinearity or the largest response) as the large signal, and the others as moderate signals.</p>
<p>
<a id="pgfId-1037172"></a>When you perform a QPSS analysis</p>
<ol><li>
<a id="pgfId-1029375"></a>An initial transient analysis runs with all moderate input signals suppressed.</li><li>
<a id="pgfId-1029376"></a>A number of stabilizing iterations run (always at least 2) with all signals activated.</li><li>
<a id="pgfId-1029377"></a>The shooting Newton method runs.</li></ol>


<p>
<a id="pgfId-1029378"></a>The QPSS analysis using the shooting engine employs the Mixed Frequency Time (MFT) algorithm extended to multiple fundamental frequencies. For details about the MFT algorithm, see <em>Steady-State Methods for Simulating Analog and Microwave Circuits</em>, by K. S. Kundert, J. K. White, and A. Sangiovanni-Vincentelli, Kluwer, Boston, 1990.</p>
<p>
<a id="pgfId-1029379"></a>Like PSS analysis, QPSS analysis uses the shooting Newton method as its backbone. However, unlike PSS analysis (where each Newton iteration performs a single transient integration), for each Newton iteration the QPSS analysis performs a number of transient integrations of one large signal period. Each integration differs by a phase-shift in each moderate input signal. When you set up a QPSS analysis, you determine the number of integrations performed by the number of harmonics of moderate fundamentals you select.</p>
<p>
<a id="pgfId-1029380"></a>You select the moderate signals to model with the <code>maxharms</code> parameter as follows</p>

<p>
<a id="pgfId-1046719"></a><img width="211" height="53" src="images/chap2-36.gif" /></p>

<p>
<a id="pgfId-1046720"></a>QPSS always treats k1 as the maximum harmonic of the large signal and the total number of integrations for the simulation is calculated as</p>

<p>
<a id="pgfId-1046724"></a><img width="285" height="50" src="images/chap2-37.gif" /></p>

<p>
<a id="pgfId-1029390"></a>One consequence is that the efficiency of the algorithm depends significantly on the number of harmonics required to model the responses of moderate fundamentals. Another consequence is that the number of harmonics of the large fundamental does not significantly affect the efficiency of the shooting algorithm. The boundary conditions of a shooting interval are such that the time domain integrations are consistent with a frequency domain transformation with a shift of one large signal period.</p>

<h3>
<a id="pgfId-1029391"></a>Comparing QPSS Analysis with PSS and PAC Analyses</h3>

<p>
<a id="pgfId-1029392"></a>A QPSS analysis is similar to a PSS analysis followed by a PAC analysis in that if you treat one of the input signals as a small signal, a signal whose harmonics do not contribute significantly to the output, you can use the PSS/PAC analyses to model intermodulation distortion effectively.</p>
<p>
<a id="pgfId-1029393"></a>The QPSS analysis has the following advantages that make it the analysis of choice in many situations. For example, with a QPSS analysis you can measure</p>
<ul><li>
<a id="pgfId-1029394"></a>Harmonic distortion and frequency translation effects created by multiple moderate-signal inputs, including all third order products. These measurements are impossible to obtain using PSS/PAC analysis because they do not model the effects of small-signal harmonics.</li><li>
<a id="pgfId-1029395"></a>The effects of multiple moderate signals. With PSS/PAC analysis, you are restricted to modeling the effects of a single small signal on the fundamental you compute with the PSS analysis. A QPSS analysis lets you model all moderate-signal inputs, including the sums of sinusoids that are not periodic.</li></ul>

<p>
<a id="pgfId-1029396"></a>To see the difference between the information available with QPSS and PSS/PAC analyses, compare how the two approaches determine the output signals produced by input signals at 900 MHz and 905 MHz. The discussion below assumes you are interested in data only for fundamentals and their first harmonics.</p>
<p>
<a id="pgfId-1029397"></a>If you perform a PSS analysis for the 900 MHz signal followed by a PAC analysis that applies 905 MHz as a small-signal with <code>maxsideband = k1</code>, you get</p>

<p>
<a id="pgfId-1029401"></a><img width="141" height="48" src="images/chap2-38.gif" /></p>

<p>
<a id="pgfId-1029402"></a>Where</p>

<p>
<a id="pgfId-1029406"></a><img width="148" height="51" src="images/chap2-39.gif" /></p>

<p>
<a id="pgfId-1029407"></a>If you perform a QPSS analysis with input signals at 900 MHz (for the large tone) and 905 MHz (for the moderate tone), you get information about the following additional frequency translation signals created by moderate tones.</p>
<p>
<a id="pgfId-1029408"></a>The output signals are centered at the following frequencies:</p>

<p>
<a id="pgfId-1029412"></a><img width="170" height="49" src="images/chap2-40.gif" /></p>

<p>
<a id="pgfId-1029413"></a>where</p>

<p>
<a id="pgfId-1029417"></a><img width="153" height="47" src="images/chap2-41.gif" /></p>

<p>
<a id="pgfId-1029418"></a>and</p>

<p>
<a id="pgfId-1029422"></a><img width="154" height="48" src="images/chap2-42.gif" /></p>

<p>
<a id="pgfId-1029423"></a>Again, the number of harmonics of the moderate tone (<em>
k</em>
<sub>2</sub>) effects the simulation time.</p>
<p>
<a id="pgfId-1029427"></a>Figure <a href="chap2.html#14851">2-9</a> shows that more information is available from a QPSS analysis than from a PSS analysis followed by a PAC analysis.</p>

<p><strong>Figure 2-9
<a id="pgfId-1029429"></a><a id="14851"></a>Comparison of Information From QPSS and PSS/PAC Analyses</strong></p>
<p>
<a id="pgfId-1029433"></a></p>
<div class="webflare-div-image">
<img src="images/QPSSvsPSSandPAC.gif" /></div>
<h3>
<a id="pgfId-1056584"></a><a id="95449"></a>QPSS P<a id="ParamsQPSS"></a>arameters</h3>

<p>
<a id="pgfId-1061507"></a>For information on QPSS analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#qpss" show="replace" xml:link="simple">Quasi-Periodic Steady State Analysis (qpss)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>
<p>
<a id="pgfId-1035373"></a>The QPSS analysis uses the same parameters as the PSS analysis with a couple of parameters added and a few parameters extended. The most important parameters for QPSS analysis are the <code>funds</code> and <code>maxharms</code> parameters, which replace and extend the <code>fund</code> (or <code>period</code>) and <code>harms</code> parameters that are used in PSS analysis.</p>
<p>
<a id="pgfId-1029639"></a>The <code>funds</code> parameter accepts a list of names of fundamentals that are present in the sources. (These fundamental names are specified by the source parameter <code>fundname</code>.) The simulator automatically figures out the frequencies associated with the fundamental names. An important feature of the <code>funds</code> parameter is that each input signal can be composed of more than one source, provided that all the sources have the same fundamental name. The fundamental frequency for each fundamental name is the greatest common factor of all the frequencies associated with the name. Simulation terminates if you do not list all the fundamental names on the <code>funds</code> parameter.</p>
<p>
<a id="pgfId-1048550"></a>If you do not specify <code>maxharms</code>, a warning message displays, and the number of harmonics defaults to 1 for each fundamental.</p>
<p>
<a id="pgfId-1029642"></a>The first fundamental is considered the large signal. You can use a few heuristics to pick the large fundamental.</p>
<ul><li>
<a id="pgfId-1029643"></a>Pick the fundamental that is not sinusoidal.</li><li>
<a id="pgfId-1029644"></a>Pick the fundamental that causes the most nonlinearity.</li><li>
<a id="pgfId-1029645"></a>Pick the fundamental that causes the largest response.</li></ul>


<p>
<a id="pgfId-1029646"></a>The <code>maxharms</code> parameter accepts a list of numbers of harmonics that are required to sufficiently model responses due to different fundamentals.</p>
<p>
<a id="pgfId-1029647"></a>The role of some PSS parameters is extended for QPSS analysis.</p>
<p>
<a id="pgfId-1029648"></a>The <code>maxperiods</code> parameter that controls the maximum number of shooting iterations for PSS analysis also controls the maximum number of shooting iterations for QPSS analysis. Its default value is 50. The <code>tstab</code> parameter controls both the length of the initial transient integration, with only the clock tone activated, and the number of stabilizing iterations, with the moderate tones activated. The stable iterations are run before Newton iterations begin.</p>

<h3>
<a id="pgfId-1029652"></a><a id="57661"></a>The errpreset Parameter in QPSS Analysis</h3>

<p>
<a id="pgfId-1029653"></a>The<code> errpreset</code><a id="errpresetQPSS"></a> parameter quickly adjusts several simulator accuracy parameters to fit your needs.</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1036607"></a>
In most cases, <code>errpreset</code> should be the only accuracy parameter you need to adjust.</div>

<ul><li>
<a id="pgfId-1029654"></a>For a fast simulation with reasonable accuracy, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>liberal</em></span>.</li><li>
<a id="pgfId-1029655"></a>For greater accuracy, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>moderate</em></span>.</li><li>
<a id="pgfId-1029656"></a>If accuracy is your primary concern, set <code>errpreset</code> to <span class="webflare-courier-new" style="white-space:pre"><em>conservative</em></span>.</li></ul>


<p>
<a id="pgfId-1029660"></a>If you do not specify a value for <code>steadyratio</code>, it is always 1.0, and it is not affected by <code>errpreset</code>.</p>
<p>
<a id="pgfId-1037269"></a>Table <a href="chap2.html#51757">2-5</a> shows the effect of <code>errpreset</code> settings (<code>liberal</code>, <code>moderate</code>, and <code>conservative</code>) on the default values of a set of accuracy parameters.</p>

<h4>Table 2-5
<a id="pgfId-1029714"></a><a id="51757"></a>Parameter Default Values for <code>errpreset</code> Settings</h4>
<table class="webflareTable" id="#id1029662">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029664">
<a id="pgfId-1029664"></a>errpreset</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029666">
<a id="pgfId-1029666"></a>reltol</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029668">
<a id="pgfId-1029668"></a>relref</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029670">
<a id="pgfId-1029670"></a>method</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029672">
<a id="pgfId-1029672"></a>Iteratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029674">
<a id="pgfId-1029674"></a>maxstep</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029676"></a><code>liberal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029678"></a>1e<sup>-3</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029680"></a>sigglobal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029682"></a>gear2only</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029684"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029686"></a>clock period/80</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029688"></a><code>moderate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029690"></a>1e<sup>-4</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029692"></a>sigglobal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029694"></a>gear2only</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029696"></a>3.5</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029698"></a>clock period/100</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029700"></a><code>conservative</code><a href="#pgfId-1063334">3</a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029702"></a>1e<sup>-5</sup></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029704"></a>sigglobal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029706"></a>gear2only</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029711"></a>*</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029713"></a>clock period/200</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1063347"></a>These <code>errpreset</code> settings include a default <code>reltol</code> value which is an enforced upper limit for <code>reltol</code>. An increase of <code>reltol</code> above the default is ignored by the simulator. The only way to <em>decrease</em> the <code>reltol</code> value is in the <code>options</code> statement. The only way to <em>increase </em>the <code>reltol</code> value is to relax the <code>errpreset</code> setting. Spectre RF sets the <code>maxstep</code> parameter value so that it is no larger than the value given in Table <a href="chap2.html#51757">2-5</a>.</p>
<p>
<a id="pgfId-1029719"></a>With the exception of the <code>reltol</code> and <code>maxstep</code> values, the <code>errpreset</code> setting does not change any parameter values you have explicitly set. The actual values used for the QPSS analysis are given in the log file. If <code>errpreset</code> is not specified in the netlist, <code>liberal</code> settings are used.</p>
<p>
<a id="pgfId-1063370"></a>For HB, only reltol is affected by errpreset, and the effect is the same as that in shooting. However, <code>lteratio</code> remains 3.5 and <code>steadyratio</code> remains 1 with all values of <code>errpreset</code>.</p>
<p>
<a id="pgfId-1063403"></a>With parameter <code>hbhomotopy</code>, you can specify harmonic balance homotopy selection methods. The possible values of parameter hbhomotopy and their meanings are as follows:</p>
<p>
<a id="pgfId-1063438"></a><code>hbhomotopy=tstab</code>: Simulator runs a transient analysis and generates an initial guess for harmonic balance analysis; it is recommended for nonlinear circuits or circuits with frequency dividers.</p>
<p>
<a id="pgfId-1063440"></a><code>hbhomotopy=source</code>: For driven circuit, simulator ignores tstab and accordingly increases the source power level; for oscillators, the simulator accordingly adjusts the probe magnitude until the probe has no effect on the oscillators. It is recommended for strongly nonlinear or high Q circuits.</p>
<p>
<a id="pgfId-1063442"></a><code>hbhomotopy=tone</code>: This method is valid only for multi-tone circuit. The simulator first solves a single-tone circuit by turning off all the tones except the first one, and then solves the multitone circuit by restoring all the tones and using the single-tone solution as its initial guess; it is recommended for multi-tone simulation with a strong first tone.</p>
<p>
<a id="pgfId-1063443"></a><code>hbhomotopy=inctone</code>: Simulator first solves a single tone, then turns on moderate tones incrementally till all tones are enabled. It is recommended for circuits with one strong large tone.</p>
<p>
<a id="pgfId-1063445"></a><code>hbhomotopy=gsweep</code>: A resistor, whose conductance is g, is connected with each node, and the sweep of g is controlled by gstart, gstop, and glog. It is recommended for circuits containing high-impedance or quasi-floating nodes.</p>

<h2>
<a id="pgfId-1029723"></a><a id="95696"></a>Quasi-Periodic Noise Analysis (QPnoise)</h2>

<p>
<a id="pgfId-1029724"></a>The Quasi-Periodic Noise (<a id="QPnoise"></a>QPnoise) analysis is a quasi-periodic small-signal analysis similar to the conventional noise analysis, except that with QPnoise the circuit is first linearized about a quasi-periodically time-varying operating point as opposed to a simple DC operating point. Linearizing about a quasi-periodically time-varying operating point includes frequency conversion and intermodulation effects. Simply linearizing about a DC operating point cannot include frequency translation because linear time-invariant circuits do not exhibit frequency translation. QPnoise also includes the effect of a quasi-periodically time-varying bias point on the noise generated by the various components in the circuit. Hence QPnoise is useful for predicting the noise behavior of mixers, switched-capacitor filters, and other periodically or quasi-periodically driven circuits. You cannot use a QPnoise analysis alone. It must follow a QPSS analysis. However, any number of quasi-periodic small signal analyses (QPAC, QPSP, QPXF, and QPnoise) can follow a single QPSS analysis.</p>
<p>
<a id="pgfId-1029725"></a>Computing the small-signal response of a quasi-periodically varying circuit is a two step process.</p>
<ol><li>
<a id="pgfId-1029726"></a>First, the small stimulus is ignored and the quasi-periodic steady-state response of the circuit to possibly large periodic stimuli is computed with a QPSS analysis. As a normal part of the QPSS analysis, the quasi-periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1029727"></a>Then, the small stimuli representing both individual noise sources in the circuit as well as the input noise are applied to the periodically-varying linear representation to compute the small signal response. This is done using the QPnoise analysis.</li></ol>


<h3>
<a id="pgfId-1029728"></a>QPnoise Output</h3>

<p>
<a id="pgfId-1029729"></a>The time-average of the noise at the output of the circuit is computed in the form of a spectral density versus frequency. The output of the circuit is specified with either a pair of nodes or a probe component. To specify the output of a circuit with a probe, specify it using the <code>oprobe</code> parameter. If the output is voltage (or potential), choose a <em>resistor</em> or a <em>port</em> as the output probe. If the output is current (or flow), choose a <code>vsource</code> or <code>iprobe</code> as the output probe.</p>
<p>
<a id="pgfId-1029730"></a>If you want the input-referred noise, specify the input source using the <code>iprobe</code> parameter. Currently, only a <code>vsource</code>, an <code>isource</code>, or a <code>port</code> can be used as an input probe. If the input source is noisy, as is a <code>port</code>, the noise analysis will compute the noise factor (F) and noise figure (NF). To match the IEEE definition of noise figure, the input probe must be a <code>port</code> with no excess noise and you must set its <code>noisetemp</code> parameter to 16.85 C (290 K). In addition, the output load must be a <code>resistor</code> or <code>port</code> and must be identified as the <code>oprobe</code>.</p>
<p>
<a id="pgfId-1036677"></a>If <code>port</code> is specified as the input probe, then both input-referred noise and gain are referred back to the equivalent voltage source inside the port. S-parameter analysis calculates those values in traditional sense.</p>
<p>
<a id="pgfId-1036675"></a>Use the <code>refsideband</code> parameter to specify which conversion gain to use when computing input-referred noise, noise factor, and noise figure. The reference sideband satisfies:</p>

<p>
<a id="pgfId-1029735"></a><img width="371" height="48" src="images/chap2-44.gif" /></p>

<p>
<a id="pgfId-1036690"></a>The reference sideband option (<code>refsidebandoption</code>) specifies whether to consider the input at the frequency or the input at the individual quasi-periodic sideband specified. Note that different sidebands can lead to the same frequency.</p>
<p>
<a id="pgfId-1036688"></a>Sidebands are vectors in QPnoise analysis. Assume you have one large tone and one moderate tone in a QPSS analysis. A sideband <em>Ki</em> will be a vector <em>[Ki_1 Ki_2]</em>. It gives the frequency at</p>
<p>
<a id="pgfId-1036701"></a><em>Ki_1 * fund(large tone of QPSS) + Ki_2 * fund(moderate tone of QPSS)</em></p>
<p>
<a id="pgfId-1029741"></a>Use <code>refsideband=[0 0...]</code> when the input and output of the circuit are at the same frequency (such as with amplifiers and filters). When the <code>refsideband</code> parameter value differs from the 0 vector, QPnoise computes the single side-band noise figure.</p>
<p>
<a id="pgfId-1029742"></a>The noise analysis always computes</p>
<ul><li>
<a id="pgfId-1029743"></a>Total noise at the output. This includes contributions from the input source and the output load.</li><li>
<a id="pgfId-1029744"></a>The amount of output noise that is attributable to each noise source in the circuit. These are computed and output individually.</li></ul>

<p>
<a id="pgfId-1029745"></a>If you identify the input source with <code>iprobe</code> and it is a <code>vsource</code> or an <code>isource</code>, the input-referred noise is computed. This includes the noise from the input source itself.</p>
<p>
<a id="pgfId-1029746"></a>If you identify the input source with <code>iprobe </code>and it is noisy, as is the case with ports, the noise factor and noise figure are computed.</p>

<p>
<a id="pgfId-1029838"></a></p>
<table class="webflareTable" id="#id1029747">
<caption style="text-align:left;"><p>
<ft-figtabl-title id="#id1029749">
<a id="pgfId-1029749"></a>Noise Calculations Performed by QPnoise</ft-figtabl-title>
</p></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029755">
<a id="pgfId-1029755"></a>Name</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029757">
<a id="pgfId-1029757"></a>Description</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1029759">
<a id="pgfId-1029759"></a>Output Label</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029761"></a><strong>N</strong><sub><strong>o </strong></sub></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029763"></a>Total output noise </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029765"></a><strong>Out</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029767"></a><strong>Ns </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029769"></a>Noise at the output due to the input probe (the source)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029771"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029773"></a><strong>Nsi </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029775"></a>Noise at the output due to the image harmonic at the source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029777"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029779"></a><strong>Nso</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029781"></a>Noise at the output due to harmonics other than input at the<br />source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029783"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029785"></a><strong>Nl</strong> </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029787"></a>Noise at the output due to the output probe (the load) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029789"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029791"></a><strong>IRN </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029793"></a>Input referred noise (See <strong>Note:</strong>) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029795"></a><strong>In</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029797"></a><strong>G</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029799"></a>Gain of the circuit (See <strong>Note:</strong>) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029801"></a><strong>Gain</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029803"></a><strong>F</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029805"></a>Single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029807"></a><strong>F</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029809"></a><strong>NF</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029811"></a>Single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029813"></a><strong>NF</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029815"></a><strong>Fdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029817"></a>Double sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029819"></a><strong>F</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029821"></a><strong>NFdsb </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029823"></a>Double sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029825"></a><strong>NF</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029827"></a><strong>Fieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029829"></a>IEEE single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029831"></a><strong>F</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029833"></a><strong>NFieee </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029835"></a>IEEE single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1029837"></a><strong>NF</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
</tbody></table>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1029839"></a>For the QPnoise analysis, the computation of <em>gain</em> and <em>IRN</em> assumes that the circuit under test is impedance-matched to the input source. This can introduce inaccuracy into the <em>gain</em> and <em>IRN</em> computation.</div>
<p>
<a id="pgfId-1029840"></a>Spectre RF performs the following noise calculations.</p>
<p>
<a id="pgfId-1029841"></a>Input referred noise</p>

<p>
<a id="pgfId-1029845"></a></p>
<div class="webflare-div-image">
<img width="114" height="86" src="images/chap2-45.gif" /></div>

<p>
<a id="pgfId-1029846"></a>Single sideband noise factor</p>

<p>
<a id="pgfId-1029850"></a></p>
<div class="webflare-div-image">
<img width="135" height="84" src="images/chap2-46.gif" /></div>

<p>
<a id="pgfId-1029851"></a>Single sideband noise figure</p>

<p>
<a id="pgfId-1029855"></a></p>
<div class="webflare-div-image">
<img width="162" height="49" src="images/chap2-47.gif" /></div>

<p>
<a id="pgfId-1029856"></a>Double sideband noise factor</p>

<p>
<a id="pgfId-1029860"></a></p>
<div class="webflare-div-image">
<img width="155" height="107" src="images/chap2-48.gif" /></div>

<p>
<a id="pgfId-1029861"></a>Double sideband noise figure</p>

<p>
<a id="pgfId-1029865"></a></p>
<div class="webflare-div-image">
<img width="226" height="51" src="images/chap2-49.gif" /></div>

<p>
<a id="pgfId-1029866"></a>IEEE single sideband noise factor</p>

<p>
<a id="pgfId-1029870"></a></p>
<div class="webflare-div-image">
<img width="205" height="107" src="images/chap2-50.gif" /></div>

<p>
<a id="pgfId-1029871"></a>IEEE single sideband noise figure</p>

<p>
<a id="pgfId-1029875"></a></p>
<div class="webflare-div-image">
<img width="231" height="54" src="images/chap2-51.gif" /></div>
<h4>
<a id="pgfId-1029876"></a>QPnoise Synopsis</h4>

<p>
<a id="pgfId-1029877"></a>At the UNIX command line use the optional terminals (<code>p</code> and <code>n</code>) to specify the output of the circuit. If you do not give the terminals, then you must specify the output with a <code>probe</code> component.</p>
<p>
<a id="pgfId-1029878"></a>In practice, noise can mix with each of the harmonics of the quasi-periodic drive signals applied in the QPSS analysis and end up at the output frequency. However, the QPnoise analysis includes only the noise that mixes with a finite set of harmonics that are specified using the <code>clockmaxharm</code> and <code>sidevec</code> parameters.</p>
<p>
<a id="pgfId-1063555"></a>The clockmaxharm parameter affects only clock frequency. It can be less or more than <code>maxharms[1]</code> in QPSS. Moderate tones are limited by <code>maxharms</code> specified in QPSS. Only the selected sidebands specified using the <code>sidevec</code> parameter are included in the calculation. Care should be taken when specifying sidevec or clockmaxharm in QPNOISE and maxharms in QPSS. Noise results are erroneous if you do not include the sidebands that contribute significant noise to the output.</p>
<p>
<a id="pgfId-1029881"></a>The number of requested sidebands will substantially change the simulation time.</p>
<p>
<a id="pgfId-1029882"></a>In quasi-periodic analyses sidebands are vectors, or, in other words, harmonic combinations. One way to specify them is using the <code>sidevec</code> parameter. When a QPSS analysis has one large tone and one moderate tone, the sideband is represented by a vector <code>K</code><sup>1</sup> as <code>[K</code><code><sup>1</sup></code><code><sub>1</sub></code><code> K</code><code><sup>1</sup></code><code><sub>2</sub></code><code>]</code>. The corresponding frequency translation is</p>

<p>
<a id="pgfId-1041862"></a><img width="515" height="55" src="images/chap2-52.gif" /></p>

<p>
<a id="pgfId-1029884"></a>When there are <code>L</code> tones total in the QPSS analysis (<code>1</code> large tone and <code>L-1</code> moderate tones), there is also a given set of <code>n</code> integer vectors representing the sidebands</p>
<p>
<a id="pgfId-1029885"></a><code>K</code><code><sup>1</sup></code><code> = { K</code><code><sup>1</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>1</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>1</sup></code><code><sub>L</sub></code><code>}<br />K</code><code><sup>2</sup></code><code> = { K</code><code><sup>2</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>2</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>2</sup></code><code><sub>L</sub></code><code>}<br />&#8230;<br />K</code><code><sup>n</sup></code><code> = { K</code><code><sup>n</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>n</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>n</sup></code><code><sub>L</sub></code><code>}</code></p>
<p>
<a id="pgfId-1029886"></a>The QPnoise analysis computes the output frequency corresponding to each sideband as follows.</p>

<p>
<a id="pgfId-1029890"></a><img width="264" height="81" src="images/chap2-53.gif" /></p>

<p>
<a id="pgfId-1029891"></a>where</p>
<ul><li>
<a id="pgfId-1029892"></a><em>
f(in)</em>
 represents the (possibly swept) input frequency</li><li>
<a id="pgfId-1029893"></a><em>
f</em>
<sub><em>j</em></sub> represents the<code> fundamental frequency</code> used in the corresponding QPSS analysis.</li></ul>

<p>
<a id="pgfId-1029894"></a>Enter the <code>sidevec</code> parameter as a sequence of integer numbers separated by spaces. For example, you would enter the set of vectors <code>{1 1 0} {1 -1 0} {1 1 1}</code> as follows</p>
<p>
<a id="pgfId-1029895"></a><code>sidevec=[ 1 1 0 1 -1 0 1 1 1]</code></p>
<p>
<a id="pgfId-1029896"></a>The other way to specify the sidebands is the <code>clockmaxharm</code> parameter and the <code>maxharms</code> parameter in the preceding QPSS analysis. Only the large tone, the first fundamental in QPSS, is affected by the QPnoise <code>clockmaxharm</code> parameter value. It limits the maximum harmonic order of the large tone that will be considered. All the remaining tones, the moderate tones, are limited by the QPSS <code>maxharms</code> parameter value.</p>
<p>
<a id="pgfId-1029897"></a>Given the following parameters</p>
<ul><li>
<a id="pgfId-1029898"></a>In the QPSS analysis input, <code>maxharms=[k</code><code><sup>0</sup></code><code><sub>max</sub></code><code> k</code><code><sup>2</sup></code><code><sub>max</sub></code><code>... k</code><code><sup>n</sup></code><code><sub>max</sub></code><code>]</code></li><li>
<a id="pgfId-1029899"></a>In the QPnoise analysis input, <code>clockmaxharm=K</code><code><sub>max</sub></code></li></ul>

<p>
<a id="pgfId-1029900"></a>The QPnoise analysis output generates the following number of sidebands</p>
<p>
<a id="pgfId-1029901"></a><code>(2*Kmax + 1)*(2*k</code><sup>2</sup><code>max+1)*(2*k<sup>3</sup><code>max</code>+1)*...*(2*k</code><sup>n</sup><code>max+1)</code></p>

<h4>
<a id="pgfId-1029902"></a>Swept QPnoise Analysis</h4>

<p>
<a id="pgfId-1029903"></a>Specify sweep limits by providing either the end points (<code>start</code> and <code>stop</code>) or by providing the center value and the span of the sweep (<code>center</code> and <code>span</code>).</p>
<p>
<a id="pgfId-1029904"></a>Specify sweep steps as linear or logarithmic as well as the number of steps or the size of each step. You can give a step-size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step-size parameter, the sweep is linear when the ratio of <code>stop</code> to <code>start</code> values is less than 10:1, and logarithmic when this ratio is equal to or greater than 10:1.</p>
<p>
<a id="pgfId-1029905"></a>Alternatively, you can specify the particular values for the sweep parameter using the <code>values</code> parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before simulation. All frequencies are in Hertz.</p>

<h3>
<a id="pgfId-1029907"></a>QPnoise P<a id="QPNoiseParameters"></a>arameters</h3>

<p>
<a id="pgfId-1061665"></a>For information on QPnoise analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#qpnoise" show="replace" xml:link="simple">Quasi-Periodic Noise Analysis (qpnoise)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h2>
<a id="pgfId-1030023"></a><a id="16587"></a>Quasi-Periodic AC Analysis (QPAC)</h2>

<p>
<a id="pgfId-1030024"></a>The quasi-periodic AC (<a id="QPAC"></a>QPAC) analysis computes transfer functions for circuits that exhibit multitone frequency translation. Such circuits include mixers, switched-capacitor filters, samplers, phase-locked loops, and similar circuits.</p>
<p>
<a id="pgfId-1030025"></a>QPAC is a quasi-periodic small-signal analysis like the conventional AC analysis, except that with QPAC the circuit is first linearized about a quasi-periodically time-varying operating point as opposed to a simple DC operating point. Linearizing about a quasi-periodically time-varying operating point produces transfer-functions that include frequency translation. Simply linearizing about a DC operating point cannot include frequency translation because linear time-invariant circuits do not exhibit frequency translation.</p>
<p>
<a id="pgfId-1030026"></a>Computing the small-signal response of a quasi-periodically varying circuit is a two step process.</p>
<ol><li>
<a id="pgfId-1030027"></a>First, the small stimulus is ignored and the quasi-periodic steady-state response of the circuit to possibly large periodic stimuli is computed with a QPSS analysis. As a normal part of the QPSS analysis, the quasi-periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1030028"></a>Second, the small stimuli are applied to the periodically-varying linear representation to compute the small signal response. This is done using the QPAC analysis.</li></ol>


<h3>
<a id="pgfId-1030029"></a>QPAC Output Frequency and Sideband Vectors</h3>

<p>
<a id="pgfId-1030030"></a>You select the set of quasi-periodic small-signal output frequencies you are interested in by setting either the <code>clockmaxharm</code> or the <code>sidevec</code> output parameters.</p>
<p>
<a id="pgfId-1030031"></a>In quasi-periodic analyses sidebands are vectors, or, in other words, harmonic combinations. One way to specify them is using the <code>sidevec</code> parameter. When a QPSS analysis has one large tone and one moderate tone, the sideband is represented by the vector <code>K</code><sup>1</sup> as <code>[K</code><code><sup>1</sup></code><code><sub>1</sub></code><code> K</code><code><sup>1</sup></code><code><sub>2</sub></code><code>]</code>. The corresponding frequency translation is</p>

<p>
<a id="pgfId-1041873"></a><img width="515" height="55" src="images/chap2-54.gif" /></p>

<p>
<a id="pgfId-1030033"></a>When there are <code>L</code> tones total in the QPSS analysis (<code>1</code> large tone and <code>L-1</code> moderate tones), there is also a given set of <code>n</code> integer vectors representing the sidebands</p>
<p>
<a id="pgfId-1030034"></a><code>K</code><code><sup>1</sup></code><code> = { K</code><code><sup>1</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>1</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>1</sup></code><code><sub>L</sub></code><code>}<br />K</code><code><sup>2</sup></code><code> = { K</code><code><sup>2</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>2</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>2</sup></code><code><sub>L</sub></code><code>}<br />&#8230;<br />K</code><code><sup>n</sup></code><code> = { K</code><code><sup>n</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>n</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>n</sup></code><code><sub>L</sub></code><code>}</code></p>
<p>
<a id="pgfId-1030035"></a>The QPAC analysis computes the output frequency corresponding to each sideband as follows.</p>

<p>
<a id="pgfId-1030039"></a><img width="264" height="81" src="images/chap2-55.gif" /></p>

<p>
<a id="pgfId-1030040"></a>Where</p>
<ul><li>
<a id="pgfId-1030041"></a><em>
f(in)</em>
 represents the (possibly swept) input frequency</li><li>
<a id="pgfId-1030042"></a><em>
f</em>
<sub><em>j</em></sub> represents the <code>fundamental frequency</code> used in the corresponding QPSS analysis.</li></ul>

<p>
<a id="pgfId-1030043"></a>In modeling a down-converting mixer with <em>low-side</em> LO and with swept RF input frequency, the most relevant sideband for the IF output is <code>{-1,0}</code>. For an up-converting mixer with swept IF input frequency, the most relevant sideband for the RF output is <code>{1,0}.</code> In a typical IP3 measurement, IM1 will correspond to the {-1, 0} sideband and IM3 to the {-1, 2} sideband.</p>
<p>
<a id="pgfId-1030044"></a>Enter the <code>sidevec</code> parameter as a sequence of integer numbers separated by spaces. For example, you would enter the set of vectors <code>{1 1 0} {1 -1 0} {1 1 1}</code> as follows</p>
<p>
<a id="pgfId-1030045"></a><code>sidevec=[ 1 1 0 1 -1 0 1 1 1]</code></p>
<p>
<a id="pgfId-1030046"></a>The other way to specify the sidebands is the <code>clockmaxharm</code> parameter and the <code>maxharms</code> parameter in the preceding QPSS analysis. Only the large tone, the first fundamental in QPSS, is affected by the <code>clockmaxharm</code> parameter value. It limits the maximum harmonic order of the large tone that will be considered. All the remaining tones, the moderate tones, are limited by the QPSS <code>maxharms</code> parameter value.</p>
<p>
<a id="pgfId-1030047"></a>Given the following parameters</p>
<ul><li>
<a id="pgfId-1030048"></a><code>maxharms=[k</code><code><sup>1</sup></code><code><sub>max</sub></code><code> k</code><code><sup>2</sup></code><code><sub>max</sub></code><code>... k</code><code><sup>n</sup></code><code><sub>max</sub></code><code>]</code></li><li>
<a id="pgfId-1030049"></a><code>clockmaxharm=K</code><code><sub>max</sub></code></li></ul>

<p>
<a id="pgfId-1030050"></a>The following sidebands are generated:</p>
<p>
<a id="pgfId-1030051"></a><code>(2*Kmax + 1)*(2*k</code><sup>2</sup><code>max+1)*(2*k<sup>3</sup><code>max</code>+1)*...*(2*k</code><sup>n</sup><code>max+1)</code></p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1030052"></a>The number of sidebands you request substantially increases the simulation time.</div>
<p>
<a id="pgfId-1030053"></a>For a QPAC analysis, the stimulus and response frequencies are usually different (this is an important way in which QPAC analysis differs from AC analysis).</p>
<p>
<a id="pgfId-1030054"></a>Use the QPAC <code>freqaxis</code> parameter to specify how to output the QPAC simulation results. For</p>
<ul><li>
<a id="pgfId-1030055"></a><code>freqaxis=</code><em>in</em> the results are output versus the input frequency</li><li>
<a id="pgfId-1030056"></a><code>freqaxis=</code><em>out </em>the results are output versus the output frequency</li><li>
<a id="pgfId-1030057"></a><code>freqaxis=</code><em>absout </em>the results are output versus the absolute value of the output frequency</li></ul>



<h4>
<a id="pgfId-1030058"></a>Swept QPAC Analysis</h4>

<p>
<a id="pgfId-1030059"></a>Specify sweep limits by providing either the end points (<code>start</code> and <code>stop</code>) or by providing the center value and the span of the sweep (<code>center</code> and <code>span</code>).</p>
<p>
<a id="pgfId-1030060"></a>Specify sweep steps as linear or logarithmic as well as the number of steps or the size of each step. You can give a step-size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step-size parameter, the sweep is linear when the ratio of <code>stop</code> to <code>start</code> values is less than 10, and logarithmic when this ratio is 10 or greater.</p>
<p>
<a id="pgfId-1030061"></a>Alternatively, you can specify the particular values that the sweep parameter should take using the <code>values</code> parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before simulation. All frequencies are in Hertz.</p>

<h3>
<a id="pgfId-1030063"></a>QPAC P<a id="ParamsQPAC"></a>arameters</h3>

<p>
<a id="pgfId-1061926"></a>For information on QPAC analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#qpac" show="replace" xml:link="simple">Quasi-Periodic AC Analysis (qpac)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h2>
<a id="pgfId-1030161"></a><a id="23623"></a>Quasi-Periodic S-Parameter Analysis (QPSP)</h2>

<p>
<a id="pgfId-1030162"></a>The quasi-periodic SP (<a id="QPSP"></a>QPSP) analysis computes scattering and noise parameters for n-port circuits that exhibit frequency translation. Such circuits include mixers, switched-capacitor filters, samplers, phase-locked loops, and the like.</p>
<p>
<a id="pgfId-1030163"></a>QPSP is a quasi-periodic small-signal analysis similar to the SP analysis except that with QPSP the circuit is first linearized about a quasi-periodically time-varying operating point as opposed to either a simple periodically time-varying operating point or a DC operating point. Linearizing about a quasi-periodically time-varying operating point allows the computation of S-parameters between circuit ports that convert signals from one frequency band to another.</p>
<p>
<a id="pgfId-1030164"></a>The QPSP analysis also calculates noise parameters in frequency-converting circuits. QPSP computes noise figure (single-sideband, double-sideband, and IEEE single-sideband), input referred noise, equivalent noise parameters, and noise correlation matrices. As is also true for QPnoise analysis, but unlike SP analysis, the noise features of the QPSP analysis include noise folding effects due to the quasi-periodically time-varying nature of the circuit.</p>
<p>
<a id="pgfId-1030165"></a>Computing the n-port S-parameters and noise parameters of a quasi-periodically varying circuit is a two step process.</p>
<ol><li>
<a id="pgfId-1030166"></a>First, the small stimuli are ignored and the quasi-periodic steady-state response of the circuit to possibly large periodic stimuli is computed with a QPSS analysis. As a normal part of the QPSS analysis, the quasi-periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1030167"></a>Second, using the QPSP analysis, the small-signal excitations are applied to compute the n-port S-parameters and noise parameters.</li></ol>


<h3>
<a id="pgfId-1030168"></a>QPSP Output Frequencies and Sideband Vectors</h3>

<p>
<a id="pgfId-1030169"></a>To specify the QPSP analysis, you must specify the physical ports and the port harmonics combinations that form the<tn-textnew />
<em>virtual ports</em> of interest. In QPSP as in PSP, port sidebands are used to assign the frequency translation between ports.</p>
<ul><li>
<a id="pgfId-1030170"></a>Set the <code>port</code> parameter for the physical ports of interest</li><li>
<a id="pgfId-1030171"></a>Set either the <code>portharmsvec</code> or the <code>harmsvec</code> parameter to select the quasi-periodic small-signal output frequencies, or harmonics, of interest<ul><li>
<a id="pgfId-1030172"></a>When you use the <code>portharmsvec</code> parameter, the harmonic vectors must be in one-to-one correspondence with the ports, with one harmonic combination associated with each physical port listed in the<tn-textnew />
<code>port</code> list. That is in the presence of two tones in QPSS, each physical port needs a combination of two harmonics assigned to it, so there are two integer numbers in <code>portharmsvec</code> for each entry in <code>po</code>rt.</li><li>
<a id="pgfId-1030173"></a>When you specify harmonic combinations with the optional <code>harmsvec</code> parameter, the QPSP analysis computes all possible frequency-translating scattering parameters associated with the specified harmonics.</li></ul></li></ul>



<p>
<a id="pgfId-1030174"></a>In quasi-periodic analyses sidebands are vectors, or, in other words, harmonic combinations. One way to specify them is using the <code>sidevec</code> parameter. When a QPSS analysis has one large tone and one moderate tone, the sideband is represented by a vector <code>K</code><sup>1</sup> as <code>[K</code><code><sup>1</sup></code><code><sub>1</sub></code><code> K</code><code><sup>1</sup></code><code><sub>2</sub></code><code>]</code>. The corresponding frequency translation is</p>

<p>
<a id="pgfId-1041894"></a><img width="535" height="127" src="images/chap2-56.gif" /></p>

<p>
<a id="pgfId-1030176"></a>When there are <code>L</code> tones total in the QPSS analysis (<code>1</code> large tone and <code>L-1</code> moderate tones), there is also a given set of <code>n</code> integer vectors representing the sidebands</p>
<p>
<a id="pgfId-1030177"></a><code>K</code><code><sup>1</sup></code><code> = { K</code><code><sup>1</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>1</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>1</sup></code><code><sub>L</sub></code><code>}<br />K</code><code><sup>2</sup></code><code> = { K</code><code><sup>2</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>2</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>2</sup></code><code><sub>L</sub></code><code>}<br />&#8230;<br />K</code><code><sup>n</sup></code><code> = { K</code><code><sup>n</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>n</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>n</sup></code><code><sub>L</sub></code><code>}</code></p>
<p>
<a id="pgfId-1030178"></a>QPSP computes the S-parameters from each virtual port to all the others. The frequency translation from one virtual port to the other is calculated using the following.</p>

<p>
<a id="pgfId-1030182"></a><img width="420" height="72" src="images/chap2-57.gif" /></p>

<p>
<a id="pgfId-1030183"></a>Where</p>
<ul><li>
<a id="pgfId-1030184"></a><em>
f(scattered)</em>
 is the frequency to which the relevant scattering parameter represents the conversion</li><li>
<a id="pgfId-1030185"></a><em>
f(incident)</em>
 represents the relative frequency of a signal incident on a port</li><li>
<a id="pgfId-1030186"></a><em>
f</em>
<code> </code>represents the <code>fundamental frequency</code> used in the corresponding QPSS analysis.</li></ul>



<h3>
<a id="pgfId-1030187"></a>Input and Output Frequencies in QPSP</h3>

<p>
<a id="pgfId-1030188"></a>For the QPSP analysis, the frequency of the input and the frequency of the response are usually different (this is an important way in which QPSP analysis differs from SP analysis).</p>
<p>
<a id="pgfId-1030189"></a><tn-textnew>
When you analyze a down-converting mixer with a signal in the upper sideband and you sweep the RF input frequency</tn-textnew>
</p>
<ul><li>
<a id="pgfId-1030190"></a><tn-textnew>
The most relevant harmonic for RF input is </tn-textnew>
<em>K</em><tn-textnew>
i={1,0}</tn-textnew>
</li><li>
<a id="pgfId-1030191"></a><tn-textnew>
The most relevant harmonic for IF output is Ki={0,0}</tn-textnew>
</li></ul>

<p>
<a id="pgfId-1030192"></a><tn-textnew>
Hence, you can associate</tn-textnew>
</p>
<ul><li>
<a id="pgfId-1030193"></a><tn-textnew>
K1={1,0} with the RF port</tn-textnew>
</li><li>
<a id="pgfId-1030194"></a><tn-textnew>
K2={0,0} with the IF port.</tn-textnew>
</li></ul>

<p>
<a id="pgfId-1030195"></a><tn-textnew>
The frequency translation will be the following</tn-textnew>
</p>

<p>
<a id="pgfId-1030199"></a><img width="595" height="53" src="images/chap2-58.gif" /></p>

<ul><li>
<a id="pgfId-1030200"></a><em>S</em><sub>21</sub> represents the transmission of the signal from the RF port with <em>
f</em>
(<em>
incident</em>
) = <em>
f</em>
(<em>
RF</em>
) to t<tn-textnew>
he IF port with </tn-textnew>
<em>
f</em>
(<em>
scattering</em>
) = <em>
f</em>
(<em>
IF</em>
) =  <em>
f</em>
(<em>
RF</em>
) + Δ<em>
f</em>
(<em>
RF to IF</em>
) = <em>
f</em>
(<em>
incident</em>
) − <em>
f</em>
(<em>
LO</em>
).</li><li>
<a id="pgfId-1030204"></a><tn-textnew>
S</tn-textnew>
<sub>11</sub><tn-textnew>
 represents the reflection of the signal back to the RF port.</tn-textnew>
</li><li>
<a id="pgfId-1030205"></a><tn-textnew>
S12 represents the transmission from the </tn-textnew>
IF port with <em>
f</em>
(<em>
incident</em>
) = <em>
f</em>
(<em>IF</em>) to the RF port with <em>
f</em>
(<em>
scattering</em>
) = <em>
f</em>
(<em>
RF</em>
) = <em>
f</em>
(<em>
IF</em>
) - Δ<em>
f</em>
(<em>
RF to IF</em>
) = <em>
f</em>
(<em>
incident</em>
) + <em>
f</em>
(<em>
LO</em>
)</li></ul>


<p>
<a id="pgfId-1030209"></a><tn-textnew>
If the signal is in the lower sideband, then a choice of </tn-textnew>
<em>
K</em>
<sub><em>1</em></sub><tn-textnew>
 = {-1,0} is more appropriate.</tn-textnew>
</p>

<div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1030210"></a>
Because the QPSP computation involves inputs and outputs at frequencies that are relative to multiple harmonics, the <code>freqaxis</code> and <code>sweeptype</code> parameters behave somewhat differently in QPSP analysis than they do in both QPAC and QPXF analyses.</div>

<p>
<a id="pgfId-1030211"></a>The <code>sweeptype</code> parameter controls the way the frequencies are swept.</p>
<ul><li>
<a id="pgfId-1030212"></a>A <span class="webflare-courier-new" style="white-space:pre"><em>relative</em></span> <code>sweeptype</code> indicates a sweep relative to the first virtual port harmonics vector</li><li>
<a id="pgfId-1030213"></a>An <span class="webflare-courier-new" style="white-space:pre"><em>absolute</em></span> <code>sweeptype</code> indicates a sweep of the absolute input source frequency</li></ul>

<p>
<a id="pgfId-1030214"></a><tn-textnew>
For the relative sweep with the frequenc</tn-textnew>
y <em>
f</em>
<sub><em>rel</em></sub> and th<tn-textnew>
e first virtual port with harmonic vector</tn-textnew>
</p>

<p>
<a id="pgfId-1041470"></a><img width="75" height="58" src="images/chap2-59.gif" /></p>

<p>
<a id="pgfId-1041469"></a>the i<tn-textnew>
ncident and scatter frequencies for S21 are</tn-textnew>
</p>

<p>
<a id="pgfId-1030219"></a><img width="637" height="108" src="images/chap2-60.gif" /></p>

<p>
<a id="pgfId-1030220"></a><tn-textnew>
while for S12 they are</tn-textnew>
</p>

<p>
<a id="pgfId-1030225"></a><img width="599" height="111" src="images/chap2-61.gif" /></p>

<p>
<a id="pgfId-1030226"></a>For the<em> absolute sweeptype </em>the sweep frequency will be used as an incident frequency on the first virtual port in <em>S</em><sub><em>21</em></sub></p>

<p>
<a id="pgfId-1030231"></a><img width="628" height="106" src="images/chap2-62.gif" /></p>

<p>
<a id="pgfId-1030232"></a>or scatter frequency for <em>S</em><sub><em>12</em></sub></p>

<p>
<a id="pgfId-1030237"></a><img width="627" height="96" src="images/chap2-63.gif" /></p>

<p>
<a id="pgfId-1030238"></a>For example, with the following parameter values including <code>relative sweeptype</code></p>
<ul><li>
<a id="pgfId-1030239"></a>QPSS fundamentals of 1000 MHz and 1010 MHz</li><li>
<a id="pgfId-1030240"></a><code>portharmsvec = [0 1 -1 1] </code>(to examine a down converting mixer)</li><li>
<a id="pgfId-1030241"></a><code>sweeptype=relative</code></li><li>
<a id="pgfId-1030242"></a>sweep range of<code> </code><em>f(rel)</em><code>=0 -&gt; 5</code> MHz</li></ul>



<p>
<a id="pgfId-1030243"></a>The frequency translation</p>

<p>
<a id="pgfId-1030247"></a><tn-textnew>
<img width="409" height="51" src="images/chap2-64.gif" /></tn-textnew>
</p>

<p>
<a id="pgfId-1030248"></a>The resulting <em>S</em><sub><em>21</em></sub> represents the strength of the signal transmitted from the input at the first virtual port in the range 1010-&gt;1015 MHz to the output at the second virtual port at frequencies of 10-&gt;15 MHz. Accordingly,<em> S</em><sub><em>12</em></sub> represents the signal transmitted from the second virtual port with <em>fi<sub><em>ncident</em></sub></em>=10-&gt;15 MHz to the first virtual port at<tn-textnew />
<em>f</em><sub><em>scatter</em></sub><tn-textnew />
= 1010-&gt;1015 MHz.</p>
<p>
<a id="pgfId-1030249"></a>Using the following changed parameter values including <code>absolute sweeptype </code>calculates the same quantities.</p>
<ul><li>
<a id="pgfId-1030250"></a><code>sweeptype=absolute</code></li><li>
<a id="pgfId-1030251"></a>sweep range of <em>f(abs)</em><code>=1010-&gt;1015</code> MHz</li></ul>

<p>
<a id="pgfId-1030252"></a>Both configuration calculate the same quantities</p>
<p>
<a id="pgfId-1030253"></a><em>f(abs)</em> = <code>1010-&gt;1015</code> MHz</p>
<p>
<a id="pgfId-1030254"></a><em>f(rel)</em> = <em>f(abs) - (K</em>11*f1 + K12*f2)= 0 -&gt; 5 MHz</p>
<p>
<a id="pgfId-1030255"></a>because</p>
<ul><li>
<a id="pgfId-1030256"></a><em>K</em><spti-sups-times-italic>
1</spti-sups-times-italic>
<sub><em>1</em></sub><code>=0</code></li><li>
<a id="pgfId-1030257"></a><em>K</em><spti-sups-times-italic>
1</spti-sups-times-italic>
<sub><em>2</em></sub><code>=1</code></li><li>
<a id="pgfId-1030258"></a><em>f</em><sub><em>1</em></sub><code>=1000</code> MHz</li><li>
<a id="pgfId-1030259"></a><em>f</em><sub><em>2</em></sub><code>=1010</code> MHz.</li></ul>



<p>
<a id="pgfId-1030260"></a>Use the <code>freqaxis</code> parameter to specify whether the results should be output versus the frequency at the first virtual port, the frequency at the second virtual port (out), or the absolute value of the frequency swept at the first virtual port (<code>absin</code>).</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1030261"></a>Requesting additional ports and harmonics increases the simulation time substantially.</div>

<h3>
<a id="pgfId-1030262"></a>Noise Analysis with QPSP</h3>

<p>
<a id="pgfId-1030263"></a>The QPSP analysis performs noise analysis which includes noise figures, equivalent noise sources, and noise parameters. The noise computation, which is performed by default and skipped only when you set <code>donoise=no</code>, requires additional simulation time beyond that required for S-parameter calculation.</p>

<p>
<a id="pgfId-1030355"></a></p>
<table class="webflareTable" id="#id1030264">
<caption style="text-align:left;"><p>
<ft-figtabl-title id="#id1030266">
<a id="pgfId-1030266"></a>Noise Calculations Performed by QPSP</ft-figtabl-title>
</p></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1030272">
<a id="pgfId-1030272"></a>Name</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1030274">
<a id="pgfId-1030274"></a>Description</span>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1030276">
<a id="pgfId-1030276"></a>Output Label</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030278"></a><strong>No</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030280"></a>Total output noise at frequency f </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030282"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030284"></a><strong>Ns</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030286"></a>Noise at the output due to the input probe (the source)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030288"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030290"></a><strong>Nsi</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030292"></a>Noise at the output due to the image harmonic at the source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030294"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030296"></a><strong>Nso </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030298"></a>Noise at the output due to harmonics other than input at the<br />source</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030300"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030302"></a><strong>Nl </strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030304"></a>Noise at the output due to the output probe (the load) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030306"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030308"></a><strong>IRN</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030310"></a>Input referred noise </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030312"></a><strong>In</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030314"></a><strong>G</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030316"></a>Gain of the circuit (See <strong>Note:</strong>) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030318"></a><strong>Gain</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030320"></a><strong>F</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030322"></a>Single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030324"></a><strong>F</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030326"></a><strong>NF</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030328"></a>Single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030330"></a><strong>NF</strong></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030332"></a><strong>Fdsb</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030334"></a>Double sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030336"></a><strong>F</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030338"></a><strong>NFdsb</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030340"></a>Double sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030342"></a><strong>NF</strong><sub><strong>dsb</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030344"></a><strong>Fieee</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030346"></a>IEEE single sideband noise factor</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030348"></a><strong>F</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030350"></a><strong>NFieee</strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030352"></a>IEEE single sideband noise figure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1030354"></a><strong>NF</strong><sub><strong>ieee</strong></sub></p>
</td>
</tr>
</tbody></table>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1030356"></a>For the QPSP analysis, the gain computed is the voltage gain from the actual circuit input to the circuit output, not the gain from the internal port voltage source to the output. For the noise characterization the first virtual port is dedicated as the input, the second virtual port serves as the output.</div>
<p>
<a id="pgfId-1030357"></a>Spectre RF performs the following noise calculations.</p>
<p>
<a id="pgfId-1030358"></a>Input referred noise</p>

<p>
<a id="pgfId-1030362"></a></p>
<div class="webflare-div-image">
<img width="111" height="85" src="images/chap2-65.gif" /></div>

<p>
<a id="pgfId-1030363"></a>Single sideband noise factor</p>

<p>
<a id="pgfId-1030367"></a></p>
<div class="webflare-div-image">
<img width="129" height="82" src="images/chap2-66.gif" /></div>

<p>
<a id="pgfId-1030368"></a>Single sideband noise figure</p>

<p>
<a id="pgfId-1030372"></a></p>
<div class="webflare-div-image">
<img width="162" height="51" src="images/chap2-67.gif" /></div>

<p>
<a id="pgfId-1030373"></a>Double sideband noise factor</p>

<p>
<a id="pgfId-1030377"></a></p>
<div class="webflare-div-image">
<img width="161" height="105" src="images/chap2-68.gif" /></div>

<p>
<a id="pgfId-1030378"></a>Double sideband noise figure</p>

<p>
<a id="pgfId-1030382"></a></p>
<div class="webflare-div-image">
<img width="219" height="54" src="images/chap2-69.gif" /></div>

<p>
<a id="pgfId-1030383"></a>IEEE single sideband noise factor</p>

<p>
<a id="pgfId-1030387"></a></p>
<div class="webflare-div-image">
<img width="202" height="105" src="images/chap2-70.gif" /></div>

<p>
<a id="pgfId-1030388"></a>IEEE single sideband noise figure</p>

<p>
<a id="pgfId-1030392"></a></p>
<div class="webflare-div-image">
<img width="231" height="54" src="images/chap2-71.gif" /></div>
<h4>
<a id="pgfId-1030393"></a>Noise Folding Effects</h4>

<p>
<a id="pgfId-1030394"></a>To ensure accurate noise calculations, set the <code>clockmaxharm</code> parameter to include the relevant noise folding effects.The <code>clockmaxharm</code> parameter is only relevant to the noise computation features of QPSP.</p>

<h3>
<a id="pgfId-1030395"></a>Swept QPSP Analysis</h3>

<p>
<a id="pgfId-1030396"></a>Specify sweep limits by providing either the end points (<code>start</code> and <code>stop</code>) or by providing the center value and the span of the sweep (<code>center</code> and <code>span</code>).</p>
<p>
<a id="pgfId-1030397"></a>Specify sweep steps as linear or logarithmic. Either specify the number of steps or the size of each step. You can give a step-size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step-size parameter, the sweep is linear when the ratio of <code>stop</code> to <code>start</code> values is less than 10, and logarithmic when this ratio is 10 or greater.</p>
<p>
<a id="pgfId-1030398"></a>Alternatively, you may specify the particular values that the sweep parameter should take using the <code>values</code> parameter. If you give both a specific set of values and a set of values specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hertz.</p>

<h3>
<a id="pgfId-1030400"></a>QPSP P<a id="ParamsQPSP"></a>arameters</h3>

<p>
<a id="pgfId-1062072"></a>For information on QPSP analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#qpsp" show="replace" xml:link="simple">Quasi-Periodic S-Parameter Analysis (qpsp)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h2>
<a id="pgfId-1030504"></a><a id="63409"></a>Quasi-Periodic Transfer Function Analysis (QPXF)</h2>

<p>
<a id="pgfId-1037307"></a>A conventional transfer function (<a id="QPXF"></a>QPXF) analysis computes the transfer function from every source in the circuit to a single output. It differs from a conventional AC analysis in that the AC analysis computes the response from a single stimulus to every node in the circuit. The differences between the QPAC and QPXF analyses are similar. The Quasi Periodic Transfer Function or QPXF analysis computes the transfer functions from any source at any frequency to a single output at a single frequency. Thus, like QPAC analysis, QPXF analysis includes frequency conversion effects.</p>
<p>
<a id="pgfId-1030506"></a>The QPXF analysis directly computes</p>
<ul><li>
<a id="pgfId-1030507"></a>Conversion Efficiency &#8211; The transfer function from the input to the output at a specified frequency.</li><li>
<a id="pgfId-1030508"></a>Image Rejection and Sideband Rejection &#8211; The transfer function from the input to output at an undesired frequency.</li><li>
<a id="pgfId-1030509"></a>LO Feed-Through and Power Supply Rejection &#8211; The transfer function from an undesired input to output at all frequencies.</li></ul>


<p>
<a id="pgfId-1030510"></a>Computing the small-signal response of a quasi-periodically varying circuit is a two step process.</p>
<ol><li>
<a id="pgfId-1030511"></a>First, the small stimulus is ignored and the quasi-periodic steady-state response of the circuit to possibly large periodic stimuli is computed with a QPSS analysis. As a normal part of the QPSS analysis, the quasi-periodically time-varying representation of the circuit is computed and saved for later use.</li><li>
<a id="pgfId-1030512"></a>Second, the small stimulus is applied to the quasi-periodically time-varying linear representation and the small signal response is computed. This is done using the QPXF analysis.</li></ol>


<h3>
<a id="pgfId-1030513"></a>QPXF Output Frequencies and Sideband Vectors</h3>

<p>
<a id="pgfId-1030514"></a>Either voltage or current can be the QPXF output variable of interest. The variable&#8217;s frequency is not constrained by the period of the large signal quasi-periodic solution. When you sweep a selected output frequency, you select the set of quasi-periodic small-signal input frequencies you are interested in by setting either the <code>clockmaxharm</code> or the <code>sidevec</code> output parameter.</p>
<p>
<a id="pgfId-1030515"></a>In quasi-periodic analyses sidebands are vectors, or, in other words, harmonic combinations. One way to specify them is using the <code>sidevec</code> parameter. When a QPSS analysis has one large tone and one moderate tone, the sideband is represented by a vector <code>K</code><sup>1</sup> as <code>[K</code><code><sup>1</sup></code><code><sub>1</sub></code><code> K</code><code><sup>1</sup></code><code><sub>2</sub></code><code>]</code>. The corresponding frequency translation is</p>

<p>
<a id="pgfId-1041911"></a><img width="515" height="55" src="images/chap2-72.gif" /></p>

<p>
<a id="pgfId-1030517"></a>When there are <code>L</code> tones total in the QPSS analysis (<code>1</code> large tone and <code>L-1</code> moderate tones), there is also a given set of <code>n</code> integer vectors representing the sidebands</p>
<p>
<a id="pgfId-1030518"></a><code>K</code><code><sup>1</sup></code><code> = { K</code><code><sup>1</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>1</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>1</sup></code><code><sub>L</sub></code><code>}<br />K</code><code><sup>2</sup></code><code> = { K</code><code><sup>2</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>2</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>2</sup></code><code><sub>L</sub></code><code>}<br />&#8230;<br />K</code><code><sup>n</sup></code><code> = { K</code><code><sup>n</sup></code><code><sub>1</sub></code><code>, ..., K</code><code><sup>n</sup></code><code><sub>j, </sub></code><code>..., K</code><code><sup>n</sup></code><code><sub>L</sub></code><code>}</code></p>
<p>
<a id="pgfId-1030519"></a>The QPXF analysis computes the output frequency corresponding to each sideband as follows.</p>

<p>
<a id="pgfId-1030523"></a><img width="264" height="81" src="images/chap2-73.gif" /></p>

<p>
<a id="pgfId-1030524"></a>where</p>
<ul><li>
<a id="pgfId-1030525"></a><em>
f(out)</em>
 represents the (possibly swept) output signal frequency</li><li>
<a id="pgfId-1030526"></a><em>
f</em>
<sub><em>j</em></sub> represents the <code>fundamental frequency</code> used in the corresponding QPSS analysis.</li></ul>

<p>
<a id="pgfId-1030527"></a>When you analyze a down-converting mixer, while sweeping the IF output frequency</p>
<ul><li>
<a id="pgfId-1030528"></a><t-times>
K</t-times>
<sub>i</sub><code>={1,0}</code> for the RF input represents the first upper-sideband</li><li>
<a id="pgfId-1030529"></a><t-times>
K</t-times>
<sub>i</sub><code>={-1,0}</code> for the RF input represents the first lower-sideband.</li></ul>

<p>
<a id="pgfId-1030530"></a>Enter the <code>sidevec</code> parameter as a sequence of integer numbers separated by spaces. For example, you would enter the set of vectors <code>{1 1 0} {1 -1 0} {1 1 1}</code> as follows</p>
<p>
<a id="pgfId-1030531"></a><code>sidevec=[ 1 1 0 1 -1 0 1 1 1]</code></p>
<p>
<a id="pgfId-1030532"></a>The other way to specify the sidebands is the <code>clockmaxharm</code> parameter and the <code>maxharms</code> parameter in preceding QPSS analysis. Only the large tone, the first fundamental in QPSS, is affected by the QPAC <code>clockmaxharm</code><tn-textnew />
parameter value. It limits the maximum harmonic order of the large tone that will be considered. All the remaining tones, the moderate tones, are limited by the QPSS <code>maxharms</code> parameter value.</p>
<p>
<a id="pgfId-1030533"></a>Given the following parameters</p>
<ul><li>
<a id="pgfId-1030534"></a>In the QPSS analysis, <code>maxharms=[</code><em>
k</em>
<sup>0</sup><sub><em>max</em></sub><code> </code><em>
k</em>
<sup>2</sup><sub><em>max</em></sub> ... <em>
k</em>
<sup>n</sup><sub><em>max</em></sub>]</li><li>
<a id="pgfId-1030535"></a>In the QPXF analysis, <code>clockmaxharm</code>=<em>
K</em>
<sub><em>max</em></sub></li></ul>

<p>
<a id="pgfId-1030536"></a>The QPXF analysis output generates the following number of sidebands</p>
<p>
<a id="pgfId-1030537"></a><code>(2*Kmax+1)*(2*k2max+1)*(2*k3max+1)*...*(2*knmax+1)</code></p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1030538"></a>The number of sidebands you request substantially increases the simulation time.</div>
<p>
<a id="pgfId-1030539"></a>For a QPXF analysis, the stimulus and response frequencies are usually different (this is an important way in which QPXF differs from XF analysis).</p>
<p>
<a id="pgfId-1030540"></a>Use the QPXF <code>freqaxis</code> parameter to specify how to output the QPXF simulation results. For</p>
<ul><li>
<a id="pgfId-1030541"></a><code>freqaxis=</code><em>in </em>the results are output versus the input frequency</li><li>
<a id="pgfId-1030542"></a><code>freqaxis=</code><em>out </em>the results are output versus the output frequency</li><li>
<a id="pgfId-1030543"></a><code>freqaxis=</code><em>absin </em>the results are output versus the absolute value of the input frequency</li></ul>


<p>
<a id="pgfId-1030544"></a>You can specify the output for the QPXF analysis with either a probe component or with a pair of nodes. Any component with two or more terminals can be a voltage probe. When there are more than two terminals, the terminals are grouped in pairs and you use the <code>portv</code> parameter to select the appropriate pair of terminals. Alternatively, you can simply give a pair of nodes to specify a voltage as the output.</p>
<p>
<a id="pgfId-1030545"></a>Any component that naturally computes current as an internal variable can be a current probe. If the probe component computes more than one current, use the <code>porti</code> parameter to select the appropriate current. Do not specify both <code>portv</code> and <code>porti</code> parameters for a simulation. If you specify neither a <code>portv</code> or <code>porti</code> parameter, the probe component provides a reasonable default.</p>

<h3>
<a id="pgfId-1030546"></a>Transfer Function Inputs</h3>

<p>
<a id="pgfId-1030547"></a>The QPXF <code>stimuli</code> parameter specifies the transfer function inputs. You have two choices.</p>
<ul><li>
<a id="pgfId-1030548"></a>The <code>stimuli=sources</code> parameter value uses the sources present in the circuit as inputs. You can adjust the computed gain to compensate for gains or losses in a test fixture with the <code>xfmag</code> parameters provided by the sources. You can use the <code>save</code> and <code>nestlvl</code> parameters to limit the number of sources in hierarchical netlists.</li><li>
<a id="pgfId-1030549"></a>The <code>stimuli=nodes_and_terminals</code> parameter value computes all possible transfer functions. This is useful when you do not know in advance which transfer functions might be interesting.</li></ul>

<p>
<a id="pgfId-1030550"></a>Transfer functions for nodes are computed assuming that a unit magnitude flow (current) source is connected from the node to ground. Transfer functions for terminals are computed assuming that a unit magnitude value (voltage) source is connected in series with the terminal.</p>
<p>
<a id="pgfId-1030551"></a>By default, the transfer functions are computed from a small set of terminals.</p>
<ul><li>
<a id="pgfId-1030552"></a>If you want transfer functions from specific terminals, specify the terminals in the <code>save</code> statement. Use the <code>:probe</code> modifier (ex. <code>Rout:1:probe</code>) or specify <code>useprobes=yes</code> on the <code>options</code> statement.</li><li>
<a id="pgfId-1030553"></a>If you want transfer functions from all terminals, specify <code>currents=all</code> and <code>useprobes=yes</code> on the <code>options</code> statement.</li></ul>


<h3>
<a id="pgfId-1030554"></a>Swept QPXF Analysis</h3>

<p>
<a id="pgfId-1030555"></a>Specify sweep limits by providing either the end points (<code>start</code> and <code>stop</code>) or by providing the center value and the span of the sweep (<code>center</code> and <code>span</code>).</p>
<p>
<a id="pgfId-1030556"></a>Specify sweep steps as linear or logarithmic as well as the number of steps or the size of each step. You can give a step-size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step-size parameter, the sweep is linear when the ratio of <code>stop</code> to <code>start</code> values is less than 10, and logarithmic when this ratio is 10 or greater.</p>
<p>
<a id="pgfId-1030557"></a>Alternatively, you may specify the particular values that the sweep parameter should take using the <code>values</code> parameter. If you give both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hertz.</p>

<h3>
<a id="pgfId-1030558"></a>QPXF Parameters</h3>

<p>
<a id="pgfId-1062121"></a>For information on QPXF analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#qpxf" show="replace" xml:link="simple">Quasi-Periodic Transfer Function Analysis (qpxf)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h2>
<a id="pgfId-1054671"></a><a id="56537"></a>Harmonic Balance Steady State Analysis (HB)</h2>

<p>
<a id="pgfId-1054672"></a>This analysis uses harmonic balance (in the frequency domain) to compute the response of circuits that have either one fundamental frequency (periodic steady-state, PSS) or that have multiple fundamental frequencies (quasi-periodic steady-state, QPSS). The simulation time required for an HB analysis is independent of the time-constants of the circuit. This analysis also determines the circuit&#8217;s periodic or quasi-periodic operating point, which can then be used during a periodic or quasi-periodic time-varying small-signal analysis, such as HBAC or HBnoise.</p>
<p>
<a id="pgfId-1057615"></a>Usually, harmonic balance (HB) analysis is a very efficient way to simulate weakly nonlinear circuits. Also, HB analysis works better than shooting analysis (in the time domain) for frequency dependent components, such as delay, transmission line, and S-parameter data.</p>
<p>
<a id="pgfId-1057616"></a>An HB analysis consists of two phases. The first phase calculates an initial solution, which the second phase then uses to compute the periodic or quasi-periodic steady-state solution, using the Newton method.</p>
<p>
<a id="pgfId-1057613"></a>The two most important parameters for HB analysis are <code>funds</code> and <code>maxharms</code>. The funds parameter accepts a list of names of fundamentals that are present in the sources. These names are specified in the sources by the <code>fundname</code> parameter. When only one name appears, the analysis is an HB PSS analysis. When more than one name appears, the analysis is an HB QPSS analysis. The <code>maxharms</code> parameter accepts a list of numbers of the harmonics that are required to adequately model the responses due to the different fundamentals.</p>
<p>
<a id="pgfId-1063687"></a>The annotate parameter has two values specific to HB analysis: <code>detailed_hb</code> and <code>internal_hb</code>. When annotate is set to <code>detailed_hb</code> or <code>internal_hb</code>, additional analysis debug information is printed to the log files. In the case of <code>internal_hb</code>, encrypted debug information is stored in the internal log file. Both options are valid for pss and qpss analyses with <code>flexbalance=yes</code>.</p>

<h3>
<a id="pgfId-1057568"></a>Using Multi-rate Harmonic Balance to Improve Performance</h3>

<p>
<a id="pgfId-1057569"></a>When the signals in different parts of an RF circuit have different fundamental frequencies and numbers of harmonics, it is often unnecessary and computationally costly to use a single harmonic set for all parts of the circuit. The multi-rate harmonic balance capability, by dividing the circuit into parts based on the signals contained in them, provides a way to avoid this problem.</p>
<p>
<a id="pgfId-1057570"></a>For example, consider an RF circuit with three parts (a divider, a mixer, and an output module) and three tones (<code>LO</code>, <code>RF1</code>, and <code>RF2</code>).</p>

<p>
<a id="pgfId-1057601"></a></p>
<div class="webflare-div-image">
<img width="668" height="202" src="images/chap2-74.gif" /></div>

<p>
<a id="pgfId-1057602"></a>The divider has no interaction with RF1 and RF2 so the harmonic set can be [10 0 0]; the mixer interacts with all the tones so that harmonic set can be [5 3 3]; and the output module harmonic set can be [3 3 3]. If the HB engine had to use a single harmonic set, it would be [10 3 3] for all the modules, but the multi-rate harmonic balance capability allows different harmonic sets to be used for different parts of the circuit.&#160;&#160;In this example, the design can be set up to use [10, 0, 0] for the divider; [5, 3, 3] for the mixer, and [3, 3, 3] for the output.</p>
<p>
<a id="pgfId-1057603"></a>In other words, HB multi-rate harmonic balance is a method of decomposing a circuit so that multi-rate behavior can be exploited to increase simulation performance. Of course, if every part of a circuit has the same spectrum structure (such as fundamental frequency and bandwidth), there is no need to use multi-rate harmonic balance.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1057604"></a>Multi-rate harmonic balance is only supported for driven circuits, but will be supported for autonomous circuits at a future time.</div>

<h3>
<a id="pgfId-1054676"></a>HB Synopsis</h3>
<a id="pgfId-1054677"></a><pre class="webflare-courier-new webflare-syx-syntax codeContent">
<code><em>Name</em></code> ( [<code><em>p</em></code>] [<code><em>n</em></code>] ) hb &lt;<code><em>parameter</em></code>=<code><em>value</em></code>&gt; ...</pre>
<h3>
<a id="pgfId-1054678"></a>HB Parameters</h3>

<p>
<a id="pgfId-1062162"></a>For information on harmonic balance parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#hb" show="replace" xml:link="simple">Harmonic Balance Steady State Analysis (hb)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h3>
<a id="pgfId-1054825"></a>Details about Using HB Analysis Parameters</h3>

<p>
<a id="pgfId-1055299"></a>The initial transient analysis provides a flexible mechanism to direct the circuit to a particular steady-state solution of interest and to avoid undesired solutions. The initial transient simulation also helps convergence by eliminating the large, but fast decaying, modes that are present in many circuits.</p>
<p>
<a id="pgfId-1055300"></a>In some circuits, the linearity of the relationship between the initial and final states depends on when HB analysis begins. In practice, starting analysis at a good point can improve convergence, and starting at a bad point can degrade convergence and slow the analysis.</p>

<h4>
<a id="pgfId-1055295"></a>oscic Parameter</h4>

<p>
<a id="pgfId-1055307"></a>When HB analysis is used for oscillators, initialization is performed to obtain an initial guess of the steady state solution and of the oscillating frequency. Two initialization methods are implemented, based on transient and linear analysis.</p>
<ul><li>
<a id="pgfId-1054826"></a>When <code>oscic=default</code> is specified, transient initialization is used and the length of the transient is specified by <code>tstab</code>. You must start the oscillator using initial conditions or using a brief impulsive stimulus, just as you would if you were simulating the turn-on transient of the oscillator using transient analysis. Initial conditions would be provided for the components of the oscillator&#8217;s resonator. If an impulsive stimulus is used, it should be applied so as to couple strongly into the oscillatory mode of the circuit and poorly into any other long-lasting modes, such as those associated with bias circuitry. The Designer&#8217;s Guide to Spice and Spectre [K. S. Kundert, Kluwer Academic Publishers, 1995] describes in depth some techniques for starting oscillators.</li><li>
<a id="pgfId-1054827"></a>When <code>oscic=lin</code> is specified, linear initialization is used. In this method, both oscillation frequency and amplitude are estimated based on linear analysis at the DC solution. No impulsive stimulus or initial conditions are needed. Linear initialization is suitable for linear oscillators such as LC and crystal oscillators. Note that <code>tstab</code> transient is still performed after linear initialization, though it can be significantly shortened or skipped. Either way, specifying a non-zero <code>tstab</code> parameter can improve convergence.</li></ul>


<h4>
<a id="pgfId-1055476"></a>funds Parameter</h4>

<p>
<a id="pgfId-1055477"></a>For the <code>funds</code> parameter, the frequencies associated with fundamentals are figured out automatically by the simulator. An important feature is that each input signal can be a composition of more than one source. However, these sources must have the same fundamental name. For each fundamental name, the fundamental frequency is the greatest common factor of all frequencies associated with the name. Omitting a fundamental name in the <code>funds</code> parameter is an error that stops the simulation. If <code>maxharms</code> is not given, a warning message is issued, and the number of harmonics defaults to 1 for each of the fundamentals in a multi-tone simulation and to 10 in a single-tone simulation.</p>

<h4>
<a id="pgfId-1063862"></a>hbpartition_defs Parameter</h4>

<p>
<a id="pgfId-1063901"></a>HB signal partition is a method of decomposing a circuit so that multi-rate behavior can be exploited to increase simulation performance. If every part of a circuit has the same spectrum structure, such as fundamental frequency and bandwidth, there is no need to apply signal partition. However, if the RF circuit has multiple tones, the signals in different parts can have various spectrum structures, such as different fundamental frequency and number of harmonics. With HB signal partition, you can divide the circuit into several parts based on the signals contained in them. The parameter hbpartition_defs defines the partitions. Each partition can be made up of one or more instances. For example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1063903"></a>hbpartition_defs = [&quot;I9 I10&quot; &quot;I11 I12&quot; &quot;I13 I14&quot;]</pre>

<p>
<a id="pgfId-1063904"></a>defines three partitions. The first partition consists of instance &quot;I9&quot; and &quot;I10&quot; while the second partition consists of instances &quot;I11&quot; and &quot;I12&quot;.The third one has &quot;I13&quot; and &quot;I14&quot;. The number of instances for each partition should not be less than 1 and there is no upper limit for the number.</p>
<p>
<a id="pgfId-1063933"></a>hbpartition_harms Parameter</p>
<p>
<a id="pgfId-1063958"></a>The principle for dividing a circuit is that the subcircuits or instances with the same spectrum properties should be put into one partition. The parameter <code>hbpartition_harms</code> specifies the maximum number of positive harmonics of each tone for every partition. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1063961"></a>hbpartition_harms=[&quot;10 0 0&quot; &quot;5 3 3&quot; &quot;3 3 3&quot;]</pre>

<p>
<a id="pgfId-1063962"></a>So, the maximum number of positive harmonics for the first partition is 10, 0 and 0, respectively. For the second partition, it is 5, 3 and 3. For the last one, it is 3, 3 and 3.</p>

<h4>
<a id="pgfId-1063989"></a>hbpartition_fundratios Parameter</h4>

<p>
<a id="pgfId-1064020"></a>The parameter <code>hbpartition_fundratios</code> indicates the fundamental frequency ratio of each tone for each partition. With these ratios, it is easy to know the fundamental frequencies of each tone of the partitions. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1064023"></a>hbpartition_fundratios=[&quot;2 1 1&quot; &quot;1 1 1&quot; &quot;1 1 1&quot;]</pre>

<p>
<a id="pgfId-1064024"></a>If three global fundamental frequencies are defined as: LO=1GHz, RF1=1.1GHz and RF2=1.13GHz, it indicates the fundamental frequencies of each tone of the first partition is 2*LO, 1*RF1, and 1*RF2, respectively. The second and third partition has the same frequencies for their each tone: 1*LO, 1*RF1 and 1*RF2. However, you have to make sure that the global fundamental frequencies for each tone are the smallest among all the partitions and the ratios are integers.</p>

<h4>
<a id="pgfId-1055458"></a>cmin Parameter</h4>

<p>
<a id="pgfId-1055459"></a>If the circuit you are simulating can have infinitely fast transitions (for example, a circuit that contains nodes with no capacitance), the simulator might not converge well. To avoid this, you must prevent the circuit from responding instantaneously. You can accomplish this by setting <code>cmin</code>, the minimum capacitance to ground at each node, to a physically reasonable nonzero value. This often significantly improves convergence.</p>

<h4>
<a id="pgfId-1055483"></a>hbhomotopy Parameter</h4>

<p>
<a id="pgfId-1055484"></a>The convergence rate of large signal analyses is mainly determined by two factors: the initial condition and the nonlinearity of the circuit. When the initial condition is close to the true solution and the nonlinearity is small, convergence is typically fast. One way to calculate the initial condition is by running a transient analysis but with this method it is hard to determine how long the transient analysis needs to run.</p>
<p>
<a id="pgfId-1055485"></a>The homotopy method uses a different approach. Given a circuit with strong nonlinearity, the homotopy method obtains a solution by starting from the same circuit but with an altered, much lower nonlinearity. Then the method increases the nonlinearity, using the solution from the lower nonlinearity as the initial condition. When the nonlinearity of the circuit reaches the original nonlinearity, a good initial condition is available from the previous solution so convergence is fast. Source stepping is used to change the nonlinearity of the circuit.</p>
<p>
<a id="pgfId-1055896"></a>In another method, a resistor and a parallel capacitor are added between each circuit node and the ground. These components reduce the dynamic range of the circuit and help with convergence. Initially, this method obtains a solution by assuming a small resistor value. Then the method increases the resistance and obtains a new solution, using as the initial value the solution obtained on the previous iteration. When the resistance becomes large enough, the inserted components become negligible and the iteratively derived solution provides a good guess of the true solution.</p>
<p>
<a id="pgfId-1055486"></a>The parameter used to control HB homotopy is called <code>hbhomotopy</code>. The parameter has the possible values <code>source</code>, <code>tone</code>, <code>tstab</code> (which is the default), and <code>gsweep</code>.</p>
<ul><li>
<a id="pgfId-1056331"></a>For the <code>source</code> value, the initial condition is generated by stepping the RF source level. This value is appropriate when the power level of the large tone or of the RF tones is high. Because there is no source available in autonomous circuits, this value is not applicable to oscillators.</li><li>
<a id="pgfId-1056332"></a>For the <code>tone</code> value, a single tone solution is generated by turning off all the tones except the first one. The multi-tone circuit is then solved by restoring all the tones and using the single-tone solution as the initial guess. This value is appropriate for multitone designs with a strong first tone.</li><li>
<a id="pgfId-1056364"></a>For the <code>tstab</code> value, the initial condition is generated by the usual transient analysis described above. This value is appropriate when the circuit contains devices, such as digital frequency dividers, that display strong non-linear behavior.</li><li>
<a id="pgfId-1055865"></a>For the <code>gsweep</code> value, a resistor of conductance <span class="webflare-courier-new" style="white-space:pre"><em>g</em></span> is connected with each node. The conductance <span class="webflare-courier-new" style="white-space:pre"><em>g</em></span> is swept under the control of the <code>gstart</code>, <code>gstop</code>, and <code>glog</code> parameters. This value is appropriate for circuits containing high-impedance or quasi-floating nodes.</li></ul>




<h4>
<a id="pgfId-1055492"></a>ic Parameter</h4>

<p>
<a id="pgfId-1055493"></a>You can specify the initial condition for the transient analysis by using the <code>ic</code> statement or the <code>ic</code> parameter on the capacitors and inductors. If you do not specify the initial condition, the DC solution is used as the initial condition. </p>
<p>
<a id="pgfId-1055494"></a>If you specify an initial condition file with the <code>readic</code> parameter, initial conditions from the file are used, and any <code>ic</code> statements are ignored.</p>
<p>
<a id="pgfId-1055495"></a>When you specify initial conditions, the simulator computes the actual initial state of the circuit by performing a DC analysis. During this analysis, the simulator forces the initial conditions on nodes by using a voltage source in series with a resistor whose resistance is <code>rforce</code> (see options).</p>
<p>
<a id="pgfId-1055496"></a>With the <code>ic</code> statement, it is possible to specify an inconsistent initial condition (one that cannot be sustained by the reactive elements). Examples of inconsistent initial conditions include setting the voltage on a node with no path of capacitors to ground or setting the current through a branch that is not an inductor. If you initialize the simulator inconsistently, its solution jumps; that is, it changes instantly at the beginning of the simulation interval. You should avoid such changes because the simulator can have convergence problems while trying to make the jump.</p>
<p>
<a id="pgfId-1055497"></a>Initial conditions and nodesets have similar implementations but produce different effects. Initial conditions actually define the solution, whereas nodesets only influence it. When you simulate a circuit with a transient analysis, Spectre forms and solves a set of differential equations. However, differential equations have an infinite number of solutions, and a complete set of initial conditions must be specified to identify the desired solution. Any initial conditions you do not specify are computed by the simulator to be consistent. The transient waveforms then start from initial conditions. Nodesets are usually used as a convergence aid and do not affect the final results. However, in a circuit with more than one solution, such as a latch, nodesets bias the simulator toward finding the solution closest to the nodeset values.</p>

<h4>
<a id="pgfId-1055503"></a>readns Parameter</h4>

<p>
<a id="pgfId-1055504"></a>Nodesets help the simulator find the DC or initial transient solution. You can supply nodesets in the circuit description file with <code>nodeset</code> statements, or in a separate file using the <code>readns</code> parameter. When nodesets are given, Spectre computes an initial guess of the solution by performing a DC analysis while forcing the specified values onto nodes by using a voltage source in series with a resistor whose resistance is <code>rforce</code>. Spectre then removes these voltage sources and resistors and computes the true solution from this initial guess.</p>
<p>
<a id="pgfId-1055505"></a>Nodesets have two important uses. First, if a circuit has two or more solutions, nodesets can bias the simulator toward computing the desired one. Second, they are a convergence aid. By estimating the solution of the largest possible number of nodes, you might be able to eliminate a convergence problem or dramatically speed convergence.</p>
<p>
<a id="pgfId-1055506"></a>Nodesets and initial conditions have similar implementations but produce different effects. Initial conditions actually define the solution, whereas nodesets only influence it. When you simulate a circuit with a transient analysis, Spectre forms and solves a set of differential equations. However, differential equations have an infinite number of solutions, and a complete set of initial conditions must be specified to identify the desired solution. Any initial conditions you do not specify are computed by the simulator to be consistent. The transient waveforms then start from initial conditions. Nodesets are usually used as a convergence aid and do not affect the final results. However, in a circuit with more than one solution, such as a latch, nodesets bias the simulator toward finding the solution closest to the nodeset values.</p>

<h4>
<a id="pgfId-1054840"></a>skipdc Parameter</h4>

<p>
<a id="pgfId-1055329"></a>You can skip the DC analysis entirely by using the <code>skipdc</code> parameter. If the DC analysis is skipped, the initial solution will be either trivial or given in the file you specified by the <code>readic</code> parameter, or, if the <code>readic</code> parameter is not given, the values specified on the <code>ic</code> statements. Device-based initial conditions are not used for <code>skipdc</code>. Nodes that you do not specify with the <code>ic</code> file or <code>ic</code> statements start at zero. You should not use this parameter unless you are generating a nodeset file for circuits that have trouble in the DC solution; it usually takes longer to follow the initial transient spikes that occur when the DC analysis is skipped than it takes to find the real DC solution. The <code>skipdc</code> parameter might also cause convergence problems in the transient analysis.</p>

<h2>
<a id="pgfId-1054850"></a><a id="94160"></a>Harmonic Balance AC Analysis (HBAC)</h2>

<p>
<a id="pgfId-1054851"></a>The harmonic balance AC (HBAC) analysis computes transfer functions for circuits that exhibit single or multi-tone frequency translation. Such circuits include mixers, switched-capacitor filters, samplers, phase-locked loops, and the like. HBAC is a small-signal analysis like AC analysis, except the circuit is first linearized about a periodically or quasi-periodically varying operating point rather than about a simple DC operating point. Linearizing about a periodically or quasi-periodically time-varying operating point allows transfer-functions that include frequency translation, whereas simply linearizing about a DC operating point cannot because linear time-invariant circuits do not exhibit frequency translation. Also, the frequency of the sinusoidal stimulus is not constrained by the period of the large periodic solution.</p>
<p>
<a id="pgfId-1054852"></a>Computing the small-signal response of a periodically or quasi-periodically varying circuit is a two step process. First, the small stimulus is ignored and the periodic or quasi-periodic steady-state response of the circuit to possibly large periodic stimuli is computed using HB analysis. As a normal part of the HB analysis, the periodically or quasi-periodically time-varying representation of the circuit is computed and saved for later use. Second, the small stimulus is applied to the periodically varying linear representation to compute the small signal response. This is done using the HBAC analysis. A HBAC analysis cannot be used alone, it must follow a HB analysis. However, any number of periodic or quasi-periodic small-signal analyses, such as HBAC or HBnoise, can follow a HB analysis.</p>
<p>
<a id="pgfId-1054853"></a>Modulated small signal measurements are possible using the Analog Design Environment (ADE). The <code>modulated</code> option for HBAC and other modulated parameters are set by ADE. HBAC analyses with this option produce results that can have limited use outside of ADE. Direct Plot is configured to analyze these results and combine several wave forms to measure AM and PM response due to single sideband or modulated stimuli. For details, see the <em>Spectre Circuit Simulator and Accelerated Parallel Simulator RF Analysis in ADE Explorer User Guide</em>.</p>
<p>
<a id="pgfId-1054854"></a>Unlike other analyses in Spectre, the HBAC analysis can sweep only frequency.</p>

<h3>
<a id="pgfId-1054855"></a>HBAC Synopsis</h3>
<a id="pgfId-1054856"></a><pre class="webflare-courier-new webflare-syx-syntax codeContent">
<code><em>Name </em></code>hbac &lt;<code><em>parameter</em></code>=<code><em>value</em></code>&gt; ...</pre>
<h3>
<a id="pgfId-1054857"></a>HBAC Parameters</h3>

<p>
<a id="pgfId-1062313"></a>For information on hbac analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#hbac" show="replace" xml:link="simple">HB AC Analysis (hbac)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>

<h3>
<a id="pgfId-1055514"></a>Details about Using HBAC Analysis Parameters</h3>
<h4>
<a id="pgfId-1055707"></a>freqaxis Parameter</h4>

<p>
<a id="pgfId-1055708"></a>With HBAC, the frequency of the stimulus and of the response are usually different&#8212;this is one important way that HBAC differs from AC. The <code>freqaxis</code> parameter is used to specify whether the results should be output versus the input frequency (<code>in</code>), the output frequency (<code>out</code>), or the absolute value of the output frequency (<code>absout</code>).</p>

<h4>
<a id="pgfId-1055521"></a>maxsideband and sidevec Parameters</h4>

<p>
<a id="pgfId-1055529"></a>You can select the set of periodic small-signal output frequencies of interest by setting either the <code>maxsideband</code> or the <code>sidevec</code> parameters. </p>
<p>
<a id="pgfId-1055534"></a>When there is only <strong>one tone in HB analysis</strong>, sidebands are n integer numbers, K1, K2, ..., Kn, and the output frequency at each sideband is computed as</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055021"></a>f(out)= f(in) + Ki * fund(hb) </pre>

<p>
<a id="pgfId-1055022"></a>where <code>f(in)</code> represents the (possibly swept) input frequency, and <code>fund(hb)</code> represents the fundamental frequency used in the corresponding HB analysis. Thus, when analyzing a down-converting mixer, while sweeping the RF input frequency, the most relevant sideband for IF output is Ki= -1. When simulating an up-converting mixer, while sweeping IF input frequency, the most relevant sideband for RF output is Ki= 1. By setting the <code>maxsideband</code> value to Kmax, all 2 * Kmax + 1 sidebands from -Kmax to +Kmax are generated.</p>
<p>
<a id="pgfId-1055535"></a>When there are <strong>multiple tones in HB analysis</strong>, sidebands are vectors. Assume we have one large tone and one moderate tone in HB. A sideband, K1, is represented as [K1_1 K1_2]. The corresponding frequency is</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055024"></a>K1_1 * fund(large tone of HB) + K1_2 * fund(moderate tone of HB) </pre>

<p>
<a id="pgfId-1055025"></a>We assume that there are L large and moderate tones in HB analysis and a given set of n integer vectors representing the sidebands, K1 = { K1_1, ..., K1_j, ..., K1_L}, K2, ..., Kn. The output frequency at each sideband is computed as </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055026"></a>f(out)= f(in) + SUM_j=1_to_L{Ki_j * fund_j(hb)}</pre>

<p>
<a id="pgfId-1055027"></a>where <code>f(in)</code> represents the (possibly swept) input frequency, and <code>fund_j(hb)</code> represents the fundamental frequency used in the corresponding HB analysis. Thus, when analyzing a down-converting mixer, while sweeping the RF input frequency, the most relevant sideband for IF output is {-1, 0}. When simulating an up-converting mixer, while sweeping IF input frequency, the most relevant sideband for RF output is {1, 0}. You enter <code>sidevec</code> as a sequence of integer numbers, separated by spaces. The set of vectors {1 1 0} {1 -1 0} {1 1 1} becomes <code>sidevec=[1 1 0 1 -1 0 1 1 1]</code>. For <code>maxsideband</code>, only the large tone, the first fundamental, is affected by this entry. All the other tones, the moderate tones, are limited by <code>maxharms</code>, specified for a HB analysis. Given maxharms=[k1max k2max ... knmax] in HB and maxsideband=Kmax, all </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055028"></a>(2*Kmax + 1)*(2*k2max+1)*(2*k3max+1) *...*(2*knmax+1)</pre>

<p>
<a id="pgfId-1055029"></a>sidebands are generated.</p>
<p>
<a id="pgfId-1055030"></a>The number of requested sidebands has a significant impact on the simulation time.</p>

<h4>
<a id="pgfId-1055032"></a>Sweep Interval Parameters</h4>

<p>
<a id="pgfId-1055533"></a>You can specify sweep limits by giving the end points or by providing the center value and the span of the sweep. Steps can be linear or logarithmic, and you can specify the number of steps or the size of each step. You can give a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10 and logarithmic when this ratio is 10 or greater. All frequencies are in Hertz.</p>

<h2>
<a id="pgfId-1055034"></a><a id="24789"></a>Harmonic Balance Noise Analysis (HBnoise)</h2>

<p>
<a id="pgfId-1055035"></a>The harmonic balance periodic or quasi-periodic noise (HBnoise) analysis is similar to conventional noise analysis, except that HBnoise analysis includes frequency conversion effects. As a consequence, it is useful for predicting the noise behavior of mixers, switched-capacitor filters, and other periodically driven circuits. It is particularly useful for predicting the phase noise of autonomous circuits, such as oscillators.</p>
<p>
<a id="pgfId-1055036"></a>HBnoise analysis linearizes the circuit about the periodic or quasi-periodic operating point computed in the prerequisite HB analysis. It is the periodically or quasi-periodically time-varying nature of the linearized circuit that accounts for the frequency conversion. In addition, the effect of a periodically or quasi-periodically time-varying bias point on the noise generated by the various components in the circuit is also included.</p>
<p>
<a id="pgfId-1055037"></a>The time-average of the noise at the output of the circuit is computed in the form of a spectral density versus frequency. The output of the circuit is specified with either a pair of nodes or a probe component. To specify the output of a circuit with a probe, specify it using the <code>oprobe</code> parameter. If the output is voltage (or potential), choose a resistor or a port as the output probe. If the output is current (or flow), choose a vsource or iprobe as the output probe.</p>
<p>
<a id="pgfId-1055047"></a>The noise analysis always computes the total noise at the output, including contributions from the input source and the output load. The amount of the output noise that is attributable to each noise source in the circuit is also computed and output individually. If the input source is identified (using <code>iprobe</code>) and is a vsource or isource, the input-referred noise, which includes the noise from the input source itself, is computed. Finally, if the input source is identified (using <code>iprobe</code>) and is noisy, as is the case with ports, the noise factor and noise figure are computed. Thus if</p>
<p>
<a id="pgfId-1055048"></a><code>No</code> = total output noise<br /><code>Ns</code> = noise at the output due to the input probe (the source)<br /><code>Nsi</code> = noise at the output due to the image harmonic at the source<br /><code>Nso</code> = noise at the output due to harmonics other than input at the source<br /><code>Nl</code> = noise at the output due to the output probe (the load)<br /><code>IRN</code> = input referred noise<br /><code>G</code> = gain of the circuit<br /><code>F</code> = noise factor<br /><code>NF</code> = noise figure<br /><code>Fdsb</code> = double sideband noise factor<br /><code>NFdsb</code> = double sideband noise figure<br /><code>Fieee</code> = IEEE single sideband noise factor<br /><code>NFieee</code> = IEEE single sideband noise figure</p>
<p>
<a id="pgfId-1055049"></a>then,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055050"></a>IRN = sqrt(No^2/G^2)<br />F = (No^2 - Nl^2)/Ns^2<br />NF = 10*log10(F)<br />Fdsb = (No^2 - Nl^2)/(Ns^2+Nsi^2)<br />NFdsb = 10*log10(Fdsb)<br />Fieee = (No^2 - Nl^2 - Nso^2)/Ns^2<br />NFieee = 10*log10(Fieee)</pre>

<p>
<a id="pgfId-1055634"></a>When the results are output, <code>No</code> is named <code>out</code>, <code>IRN</code> is named <code>in</code>, <code>G</code> is named <code>gain</code>, <code>F</code>, <code>NF</code>, <code>Fdsb</code>, <code>NFdsb</code>, <code>Fieee</code>, and <code>NFieee</code> are named <code>F</code>, <code>NF</code>, <code>Fdsb</code>, <code>NFdsb</code>, <code>Fieee</code>, and <code>NFieee</code> respectively.</p>
<p>
<a id="pgfId-1055635"></a>The computation of gain and IRN for quasi-periodic noise in HBnoise assumes that the circuit under test is impedance-matched to the input source. This can introduce inaccuracy into the gain and IRN computation.</p>
<p>
<a id="pgfId-1055054"></a>An HBnoise analysis must follow an HB analysis.</p>
<p>
<a id="pgfId-1055055"></a>Unlike other analyses in Spectre, this analysis can only sweep frequency.</p>

<h3>
<a id="pgfId-1055056"></a>HBnoise Synopsis</h3>
<a id="pgfId-1055057"></a><pre class="webflare-courier-new webflare-syx-syntax codeContent">
<code><em>Name</em></code> ( [<code><em>p</em></code>] [<code><em>n</em></code>] ... ) hbnoise &lt;<code><em>parameter</em></code>=<code><em>value</em></code>&gt; ...</pre>

<p>
<a id="pgfId-1055058"></a>The optional terminals (<span class="webflare-courier-new" style="white-space:pre"><em>p</em></span> and <span class="webflare-courier-new" style="white-space:pre"><em>n</em></span>) specify the output of the circuit. If you do not give the terminals, then you must specify the output with a probe component.</p>

<h3>
<a id="pgfId-1055059"></a>HBnoise Parameters</h3>

<p>
<a id="pgfId-1062456"></a>For information on hbnoise parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#hbnoise" show="replace" xml:link="simple">HB Noise Analysis (hbnoise</a></em>) section in the <em>Spectre Circuit Simulator Reference</em> manual.</p>

<h3>
<a id="pgfId-1057375"></a>Details about Using HBnoise Analysis Parameters</h3>
<h4>
<a id="pgfId-1055198"></a>iprobe Parameter</h4>

<p>
<a id="pgfId-1055688"></a>If you want the input-referred noise or noise figure, specify the input source using the <code>iprobe</code> parameter. For input-referred noise, use either a vsource or isource as the input probe; for noise figure, use a port as the probe. Currently, only a vsource, an isource, or a port can be used as an input probe. If the input source is noisy, as is a port, the noise analysis computes the noise factor (F) and noise figure (NF). To match the IEEE definition of noise figure, the input probe must be a port with no excess noise and its noisetemp must be set to 16.85C (290K). In addition, the output load must be a resistor or port and must be identified as the oprobe.</p>
<p>
<a id="pgfId-1055689"></a>If port is specified as the input probe, then both input-referred noise and gain are referred back to the equivalent voltage source inside the port. S-parameter analysis calculates those values.</p>

<h4>
<a id="pgfId-1055685"></a>maxsideband Parameter</h4>

<p>
<a id="pgfId-1055596"></a>In practice, noise can mix with each of the harmonics of the periodic drive signal applied in the HB analysis and end up at the output frequency. However, the HBnoise analysis only includes the noise that mixes with a finite set of harmonics that are typically specified using the <code>maxsideband</code> parameter.</p>
<p>
<a id="pgfId-1055199"></a>If Ki represents sideband i, then for periodic noise,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055200"></a>f(noise_source) = f(out) + Ki * fund(hb)</pre>

<p>
<a id="pgfId-1055201"></a>For quasi-periodic noise with multiple tones in HB analysis, assuming there are one large tone and one moderate tone, Ki is represented as [Ki_1 Ki_2]. The corresponding frequency shift is</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055202"></a>Ki_1 * fund(large tone of HB) + Ki_2 * fund(moderate tone of HB)</pre>

<p>
<a id="pgfId-1055203"></a>Assuming that there are L large and moderate tones in HB analysis and a set of n integer vectors representing the sidebands</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055204"></a>K1 = { K1_1,...K1_j..., K1_L}, K2, ..., Kn.</pre>

<p>
<a id="pgfId-1055205"></a>Then</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055206"></a>f(noise_source) = f(out) +&#160;&#160;SUM_j=1_to_L{ Ki_j * fund_j(hb) }</pre>

<p>
<a id="pgfId-1055207"></a>The <code>maxsideband</code> parameter specifies the maximum |Ki| included in the HBnoise calculation. For quasi-periodic noise, only the large tone, the first fundamental, is affected by this entry. All the other tones, the moderate tones, are limited by <code>maxharms</code>, specified for a HB analysis.</p>
<p>
<a id="pgfId-1055208"></a>The number of requested sidebands changes the simulation time substantially.</p>
<p>
<a id="pgfId-1055649"></a>When HBnoise analysis does only an xf analysis (<code>xfonly=yes</code>), the variable of interest at the output can be voltage or current, and its frequency is not constrained by the period of the large periodic solution. While sweeping the selected output frequency, you can select the periodic small-signal input frequencies of interest by setting the <code>maxsideband</code> parameter. With this analysis, the frequency of the stimulus and of the response are usually different (this is an important way that this analysis differs from XF).</p>

<h4>
<a id="pgfId-1055656"></a>refsideband Parameter</h4>

<p>
<a id="pgfId-1055664"></a>The reference sideband (<code>refsideband</code>) specifies which conversion gain is used when computing input-referred noise, noise factor, and noise figure. The reference sideband specifies the input frequency relative to the output frequency with:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055657"></a>|f(input)| = |f(out) + refsideband frequency shift|</pre>

<p>
<a id="pgfId-1055658"></a>For periodic noise (only <strong>one tone in HB analysis</strong>), the <code>refsideband</code> is a number. Use <code>refsideband=0</code> when the input and output of the circuit are at the same frequency (such as with amplifiers and filters). When <code>refsideband</code> differs from 0, the single side-band noise figure is computed.</p>
<p>
<a id="pgfId-1055659"></a>While for quasi-periodic noise (<strong>multiple tones in HB analysis</strong>), reference sidebands are vectors. Assume we have one large tone and one moderate tone in HB. A sideband Ki will be a vector [Ki_1 Ki_2]. It gives the frequency at&#160;&#160;   </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1055660"></a>Ki_1 * fund(large tone of HB) + Ki_2 * fund(moderate tone of HB) </pre>

<p>
<a id="pgfId-1055661"></a>Use <code>refsideband=[0 0 ...]</code> when the input and output of the circuit are at the same frequency (such as with amplifiers and filters).</p>

<h4>
<a id="pgfId-1055722"></a>stimuli Parameter</h4>

<p>
<a id="pgfId-1055723"></a>You can use the <code>stimuli</code> parameter to specify what serves as the inputs for the transfer functions.</p>
<ul><li>
<a id="pgfId-1055724"></a><code>stimuli=sources</code> indicates that the sources present in the circuit are to be used. You can use the <code>xfmag</code> parameters provided by the sources to adjust the computed gain to compensate for gains or losses in a test fixture. You can limit the number of sources in hierarchical netlists by using the <code>save</code> and <code>nestlvl</code> parameters.</li><li>
<a id="pgfId-1055725"></a><code>stimuli=nodes_and_terminals</code> indicates that all possible transfer functions are to be computed. This is useful when you do not know in advance which transfer functions are interesting. Transfer functions for nodes are computed assuming that a unit magnitude flow (current) source is connected from the node to ground. Transfer functions for terminals are computed assuming that a unit magnitude value (voltage) source is connected in series with the terminal. By default, the transfer functions from a small set of terminals are computed. If you want transfer functions from specific terminals, specify the terminals in the <code>save</code> statement. You must use the <code>:probe</code> modifier (for example, <code>Rout:1:probe</code>) or specify <code>useprobes=yes</code> on the <code>options</code> statement. If you want transfer functions from all terminals, specify <code>currents=all</code> and <code>useprobes=yes</code> on the <code>options</code> statement.</li></ul>

<p>
<a id="pgfId-1055726"></a>With HBnoise analysis, transfer function outputs are always available.</p>

<h4>
<a id="pgfId-1055650"></a>Sweep Interval Parameters</h4>

<p>
<a id="pgfId-1055651"></a>You can specify sweep limits by giving the end points or by providing the center value and the span of the sweep. Steps can be linear or logarithmic, and you can specify the number of steps or the size of each step. You can give a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10, and logarithmic when this ratio is 10 or greater. All frequencies are in Hertz.</p>

<h4>
<a id="pgfId-1055696"></a>xfonly Parameter</h4>

<p>
<a id="pgfId-1055699"></a>When option <code>xfonly</code> is set to <code>yes</code>, HBnoise analysis does only a conventional transfer function (xf) analysis, which computes the transfer function from every source in the circuit to a single output. This analysis differs from a conventional AC analysis in that the AC analysis computes the response from a single stimulus to every node in the circuit. HBnoise computes the transfer functions from any source at any frequency to a single output at a single frequency. Thus, like HBAC analysis, it includes frequency conversion effects. It directly computes such useful quantities as conversion efficiency (transfer function from input to output at desired frequency), image and sideband rejection (input to output at undesired frequency), and LO feed-through and power supply rejection (undesired input to output at all frequencies).</p>

<h2>
<a id="pgfId-1058320"></a><a id="71960"></a>HB S-Parameter Analysis (hbsp)</h2>

<p>
<a id="pgfId-1058338"></a>The periodic or quasi-periodic SP (HBSP) analysis is used to compute scattering and noise parameters for n-port circuits such as mixers that exhibit frequency translation. It is a small-signal analysis similar to SP analysis, except that in HBAC and HBNOISE, the circuit is first linearized about a periodically varying operating point as opposed to a simple DC operating point. Linearizing about a periodically or quasi-periodically time-varying operating point allows the computation of S-parameters between circuit ports that convert signals from one frequency band to another. HBSP can also calculate noise parameters in frequency-converting circuits. In addition, HBSP computes noise figure (both single-sideband and double-sideband), input referred noise, equivalent noise parameters, and noise correlation matrices. Similar to HBNOISE, but unlike SP, the noise features of the HBSP analysis include noise folding effects due to the periodic time-varying nature of the circuit.</p>
<p>
<a id="pgfId-1058339"></a>Computing the n-port S-parameters and noise parameters of a periodically varying circuit is a two-step process. First, the small stimulus is ignored and the periodic or quasi-periodic steady-state response of the circuit to possibly large periodic stimulus is computed using HB analysis. As a part of the HB analysis, the periodically time-varying representation of the circuit is computed and saved for later use. The second step is applying small-signal excitations to compute the n-port S-parameters and noise parameters. This is done using the HBSP analysis. HBSP analysis cannot be used independently; it must follow HB analysis. However, any number of periodic small-signal analyses such as HBAC, HBSP, HBNOISE, can follow an HB analysis.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1058340"></a>Unlike other analyses in Spectre, this analysis can only sweep frequency.</div>

<h3>
<a id="pgfId-1062604"></a>HBSP Parameters</h3>

<p>
<a id="pgfId-1062623"></a>For information on hbsp analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#hbsp" show="replace" xml:link="simple">HB S-Parameter Analysis (hbsp)</a></em> section in the <em>Spectre Circuit Simulator Reference</em> manual.</p>
<p>
<a id="pgfId-1058375"></a>To specify the HBSP analysis, the port and port harmonic relations must be specified. You can select the ports of interest by setting the <code>port</code> parameter, and select the set of periodic small-signal output frequencies of interest by setting <code>portharmsvec</code> or<code> harmsvec</code> parameters. For a given set of n integer numbers representing the harmonics K1, K2, ... Kn, the scattering parameters at each port are computed at the following frequencies:</p>
<p>
<a id="pgfId-1058376"></a>For periodic SP in one-tone HB analysis, frequency is:</p>
<p>
<a id="pgfId-1058377"></a><code>f(scattered)= f(rel) + Ki * fund(HB) </code></p>
<p>
<a id="pgfId-1058378"></a>For quasi-periodic noise with multi-tone in HB analysis, sidebands are vectors. Consider that you have one large tone and one moderate tone in HB. Then, the above sideband K1 will be represented as [K1_1 K1_2]. In this case, the corresponding frequency is:</p>
<p>
<a id="pgfId-1058379"></a><code>K1_1 * fund(large tone of HB) + K1_2 * fund(moderate tone of HB)= SUM_j=1_to_L{Ki_j * fund_j(HB)} </code></p>
<p>
<a id="pgfId-1058380"></a>If there are L (1 large and L-1 moderate) tones in HB analysis and a given set of n integer vectors representing the sidebands:</p>
<p>
<a id="pgfId-1058381"></a><code>K1 = { K1_1,...K1_j..., K1_L } , K2, ... Kn</code></p>
<p>
<a id="pgfId-1058382"></a>If you specify the relative frequency, the scattering parameters at each port are computed at the frequencies:</p>
<p>
<a id="pgfId-1058383"></a><code>f(scattered)= f(rel) + SUM_j=1_to_L{Ki_j * fund_j(hb)}, </code></p>
<p>
<a id="pgfId-1058384"></a>where <code>f(rel)</code> represents the relative frequency of a signal incident on a port, <code>f(scattered)</code> represents the frequency to which the relevant scattering parameter represents the conversion, and <code>fund</code>(one-tone HB) or <code>fund_j</code>(multi-tone HB) represents the fundamental frequency used in the corresponding HB analysis. </p>
<p>
<a id="pgfId-1058385"></a>During analysis of a down-converting mixer with a blocker and the signal in the upper sideband, we sweep the input frequency of the signal coming into RF port. In case of periodic SP with one-tone HB, the most relevant harmonic for RF input is Ki= 1 and for IF output Ki= 0. Therefore, we can associate K2=0 with the IF port and K1=1 with the RF port. S21 represents the transmission of signal from the RF to IF, and S11 represents the reflection of signal back to the RF port. If the signal was in the lower sideband, a choice of K1=-1 is more appropriate. For quasi-periodic SP with multi-tone HB, the most relevant sideband for this input is Ki= {1 , 0} and for IF output Ki= {0 , 0}. Therefore, we can associate K1={1 , 0} with the RF port and K2={0 , 0} with the IF port. If the signal was in the lower sideband, then a choice of K1={-1 , 0} is more appropriate. </p>
<p>
<a id="pgfId-1058386"></a><code>portharmsvec</code> or <code>harmsvec</code> parameters can be used to specify the harmonics of interest. If <code>portharmsvec</code> is specified, the harmonics must be in one-to-one correspondence with the ports, with each harmonic associated with a single port. If harmonics are specified in the optional <code>harmsvec</code> parameter, all possible frequency-translating scattering parameters associated with the specified harmonics are computed.</p>
<p>
<a id="pgfId-1058387"></a>With HBSP the frequency of the input and of the response are usually different (this is an important area in which HBSP differs from SP). Because the HBSP computation involves inputs and outputs at frequencies that are relative to multiple harmonics or sidebands, the <code>freqaxis</code> and <code>sweeptype</code> parameters behave differently in HPSP than in HBAC and HBNOISE.</p>
<p>
<a id="pgfId-1058388"></a>The <code>sweeptype</code> parameter controls the way the frequencies in the HBSP analysis are swept. Specifying a <code>relative</code> sweep indicates the sweep to be relative to the analysis harmonics or port sideband (not the HB fundamental) and specifying an <code>absolute</code> sweep indicates the sweep of the absolute input source frequency. </p>
<p>
<a id="pgfId-1058389"></a>For example, in case of periodic SP with one-tone HB and HB fundamental of 100MHz, <code>portharmsvec</code> set to [9 1] to examine a downconverting mixer, <code>sweeptype=relative</code>, and a sweep range of f(rel)=0-&gt;50MHz, S21 represents the strength of signal transmitted from the input port in the range 900-&gt;950MHz to the output port at frequencies 100-&gt;150MHz. Using <code>sweeptype=absolute</code> and sweeping the frequency from 900-&gt;950MHz would calculate the same quantities, because f(abs)=900-&gt;950MHz, f(rel) = f(abs) - K1 * fund(hb) = 0-&gt;50MHz, and K1=9 and fund(hb) = 100MHz. </p>
<p>
<a id="pgfId-1058390"></a>For quasi-periodic noise with multi-tone HB, and HB fundamentals of 1000MHz (LO) and 966MHz (blocker in RF channel), <code>portharmsvec</code> could be set to [0 1 -1 1] to examine a downconverting mixer. Consider setting <code>sweeptype=relative</code> and a sweep range of f(rel)=-10MHz&lt;-&gt;10MHz. Then, S21 will represent the strength of the signal transmitted from the input port in the range 956-&gt;976MHz to the output port at frequencies 24&lt;-&gt;44MHz. Using <code>sweeptype=absolute</code> and sweeping the frequency from 966&lt;-&gt;976MHz will calculate the same quantities, because f(abs)=956&lt;-&gt;976MHz, f(rel) = f(abs) - ( K1_1 * fund_1(hb) + K1_2 * fund_2(hb) = -10MHz&lt;-&gt;10MHz, andK1_1=0, K1_2=1 and fund_1(hb) = 1000MHz, fund_2(hb) = 966MHz. </p>
<p>
<a id="pgfId-1058391"></a>The <code>freqaxis</code> parameter is used to specify whether the results should be output versus the scattered frequency at the input port (<code>in</code>), the scattered frequency at the output port (<code>out</code>), or the absolute value of the frequency swept at the input port (<code>absin</code>). </p>
<p>
<a id="pgfId-1058392"></a>HBSP analysis also computes noise figures, equivalent noise sources, and noise parameters. The noise computation, which is skipped only when <code>donoise=no</code>, requires additional simulation time. If:</p>
<p>
<a id="pgfId-1058393"></a>No = total output noise at frequency f</p>
<p>
<a id="pgfId-1058394"></a>Ns = noise at the output due to the input probe (the source)</p>
<p>
<a id="pgfId-1058395"></a>Nsi = noise at the output due to the image harmonic at the source</p>
<p>
<a id="pgfId-1058396"></a>Nso = noise at the output due to harmonics other than input at the source</p>
<p>
<a id="pgfId-1058397"></a>Nl = noise at the output due to the output probe (the load)</p>
<p>
<a id="pgfId-1058398"></a>IRN = input referred noise</p>
<p>
<a id="pgfId-1058399"></a>G = gain of the circuit</p>
<p>
<a id="pgfId-1058400"></a>F = noise factor (single side band)</p>
<p>
<a id="pgfId-1058401"></a>NF = noise figure (single side band)</p>
<p>
<a id="pgfId-1058402"></a>Fdsb = double sideband noise factor</p>
<p>
<a id="pgfId-1058403"></a>NFdsb = double sideband noise figure</p>
<p>
<a id="pgfId-1058404"></a>Fieee = IEEE single sideband noise factor</p>
<p>
<a id="pgfId-1058405"></a>NFieee = IEEE single sideband noise figure</p>
<p>
<a id="pgfId-1058406"></a>Then:</p>
<p>
<a id="pgfId-1058407"></a>IRN = sqrt(No^2/G^2)</p>
<p>
<a id="pgfId-1058408"></a>F = (No^2 - Nl^2)/Ns^2</p>
<p>
<a id="pgfId-1058409"></a>NF = 10*log10(F)</p>
<p>
<a id="pgfId-1058410"></a>Fdsb = (No^2 - Nl^2)/(Ns^2+Nsi^2)</p>
<p>
<a id="pgfId-1058411"></a>NFdsb = 10*log10(Fdsb)</p>
<p>
<a id="pgfId-1058412"></a>Fieee = (No^2 - Nl^2 - Nso^2)/Ns^2</p>
<p>
<a id="pgfId-1058413"></a>NFieee = 10*log10(Fieee).</p>
<p>
<a id="pgfId-1058414"></a>When the results are output, IRN is named <code>in</code>, G is named <code>gain</code>, F, NF, Fdsb, NFdsb, Fieee, and NFieee are named <code>F</code>, <code>NF</code>, <code>Fdsb</code>, <code>NFdsb</code>, <code>Fieee</code>, and <code>NFieee</code>, respectively. Note that the gain computed by HBSP is the voltage gain from the actual circuit input to the circuit output, not the gain from the internal port voltage source to the output. </p>
<p>
<a id="pgfId-1058415"></a>To ensure accurate noise calculations, the <code>maxsideband</code> or <code>sidebands</code> parameters must be set to include the relevant noise folding effects.<code>maxsideband</code> is only relevant to the noise computation features of HBSP.</p>
<p>
<a id="pgfId-1058330"></a>You can specify sweep limits by giving the end points or by providing the center value and span of the sweep. Steps can be linear or logarithmic, and you can specify the number of steps or the size of each step. In addition, you can specify a step size parameter (<code>step</code>, <code>lin</code>, <code>log</code>, <code>dec</code>) to determine whether the sweep is linear or logarithmic. If you do not give a step size parameter, the sweep is linear when the ratio of stop to start values is less than 10, and logarithmic when this ratio is 10 or greater. Alternatively, you use the <code>values</code> parameter to specify the values that the sweep parameter should take. If you use both a specific set of values and a set specified using a sweep range, the two sets are merged and collated before being used. All frequencies are in Hertz.</p>

<h2>
<a id="pgfId-1048943"></a><a id="48507"></a>Envelope Analysis (ENVLP)</h2>

<p>
<a id="pgfId-1039717"></a>Efficient and accurate prediction of the envelope transient response of RF circuits is important for RF circuit designers who are simulating communications systems. You can apply <a id="ENVLP"></a>ENVLP analysis to efficiently and accurately analyze modulation signals in large communication circuits. Important applications include</p>
<ul><li>
<a id="pgfId-1039718"></a>Predicting the spectral regrowth of amplifiers and mixers</li><li>
<a id="pgfId-1039719"></a>Designing feedback loops such as Automatic Gain Control (AGC) loops</li><li>
<a id="pgfId-1039720"></a>Predicting the transient behavior of switched capacitor filters</li><li>
<a id="pgfId-1039721"></a>Simulating large transients in phase lock loops</li><li>
<a id="pgfId-1039722"></a>Helping the oscillator designer identify the load pull effect for the communication systems with VCO and power amplifier.</li></ul>




<p>
<a id="pgfId-1039723"></a>It is important to know that ENVLP Analysis is <em>not</em> designed to simulate circuits having a filter with nodes that have higher frequencies than clock. A transient analysis is faster for these circuits.</p>

<h4>
<a id="pgfId-1039727"></a>Modulation Signals</h4>

<p>
<a id="pgfId-1039728"></a>Many RF circuits process narrowband signals in the form of modulated carriers. Modulated carriers are characterized as having both a periodic high-frequency carrier signal and a low-frequency modulation signal. The modulation signal acts on either the amplitude, phase, or frequency of the carrier. In general, the modulation is arbitrary. The ratio between the lowest frequency in the modulation and the frequency of the carrier is a measure of the relative frequency resolution required of the simulation. Traditional transient analysis is inefficient for the resolution of low modulation frequencies in the presence of a high carrier frequency because the high-frequency carrier forces a small time step while the low-frequency modulation forces a long simulation interval.</p>

<h3>
<a id="pgfId-1039730"></a><a id="59616"></a>A Mixer Example</h3>

<p>
<a id="pgfId-1039731"></a>As a typical example, a designer might be interested in simulating a receiver transmit path involving a modulator, in particular, to predict the spectral regrowth of the modulator. As shown in Figure <a href="chap2.html#23060">2-10</a>, the inputs to a modulator can be one complete digital low-frequency (not necessarily periodic) modulation and one high frequency LO. The result is a modulated high-frequency signal as shown in Figure <a href="chap2.html#23060">2-10</a>. However, due to the nonlinearity of the modulator, unwanted harmonics might be generated and, to validate the design, it is important to predict the signal level at these unwanted harmonics.</p>

<p><strong>Figure 2-10
<a id="pgfId-1039739"></a><a id="23060"></a>Time-Domain Modulation</strong></p>
<p>
<a id="pgfId-1039743"></a></p>
<div class="webflare-div-image">
<img width="655" height="162" src="images/chap2-75.gif" /></div>

<p>
<a id="pgfId-1039747"></a>Figure <a href="chap2.html#20565">2-11</a> shows a typical scenario in the receiver signal path. Due to the nonlinearity of the mixer, it is important to predict the resulting spectral regrowth. Spectral regrowth is expensive to simulate using traditional transient analysis because spectral regrowth requires a very long time interval to resolve the required frequency resolution.</p>

<p><strong>Figure 2-11
<a id="pgfId-1039749"></a><a id="20565"></a>Spectrum-Domain Modulation</strong></p>
<p>
<a id="pgfId-1039753"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig2.gif" /></div>

<p>
<a id="pgfId-1039754"></a>ENVLP analysis overcomes this difficulty with traditional transient analysis. ENVLP analysis reduces simulation time without compromising accuracy by exploiting the property that the behavior of a circuit in a given high frequency clock cycle is similar, but not identical, to its behavior in the preceding and following cycles. In particular, the envelope of the high-frequency clock can be followed by accurately computing the circuit behavior over occasional cycles, which accurately capture the fast transient behavior. The slow varying modulation is accurately followed by a smooth curve. As a result, the spectrum of the circuit response can be obtained by combining the spectrum of the smooth curve and the spectrum of occasional clock cycles.</p>
<p>
<a id="pgfId-1039755"></a>RF analyses such as PSS (periodic steady-state analysis) [1] or QPSS (quasi-periodic steady-state analysis) [2] might not work directly because the modulation signal might be neither periodic nor quasi-periodic.</p>
<p>
<a id="pgfId-1039756"></a>The clock is referred to differently in different applications.</p>
<ul><li>
<a id="pgfId-1039757"></a>For mixers, the clock is called the LO</li><li>
<a id="pgfId-1039758"></a>For detectors, the clock is called the carrier</li><li>
<a id="pgfId-1039759"></a>For switched-capacitor filters, the clock is called the clock</li></ul>


<p>
<a id="pgfId-1039760"></a>The clock is normally the most rapidly changing signal in the circuit and thus causes the most nonlinearity.</p>

<h3>
<a id="pgfId-1039762"></a><a id="31878"></a>The Time Domain and Harmonic Balance ENVLP Algorithms</h3>

<p>
<a id="pgfId-1039763"></a>The Spectre RF ENVLP analysis uses a multi-stage multi-past-point integration algorithm that is an extension to a method introduced by Petzold [3] and further explored by Kundert, White and Sangiovanni-Vincentelli [4]. The method approximates the sample envelope as a piecewise polynomial in a manner that is analogous to conventional transient analysis. The ENVLP algorithm is based on two schemes:</p>
<ul><li>
<a id="pgfId-1039764"></a>Time domain shooting</li><li>
<a id="pgfId-1039765"></a>Harmonic balance</li></ul>

<p>
<a id="pgfId-1039766"></a>In time domain shooting, the clock nonlinearity is resolved by time-domain integration. In harmonic balance, the clock nonlinearity is expressed as harmonics of fundamental frequencies.</p>
<p>
<a id="pgfId-1039767"></a>Most RF circuits used in communication systems are clocked at a high frequency. The clock (such as LO) usually causes the most nonlinearity in the circuit response. Time-domain integration is a more efficient and accurate method of resolving strong nonlinear circuits with sharp transitions and transient details, while harmonic balance is more efficient for linear and nearly linear circuits. ENVLP analysis samples the circuit waveforms at the clock frequency, and assumes the resulting envelope can be accurately represented by a piecewise polynomial. The nonlinearity caused by the clock signal is resolved by occasional integrations of a period of circuit responses.</p>

<h4>
<a id="pgfId-1039768"></a>Time Domain Envelope (TD ENVLP) Analysis</h4>

<p>
<a id="pgfId-1039769"></a>Most circuits can be described by a system of differential equations of the form shown in Equation <a href="chap2.html#65074">2-1</a>.</p>

<p>
<a id="pgfId-1039779"></a></p>
<table class="webflareTable" id="#id1039770">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-1)
<a id="pgfId-1039773"></a><a id="65074"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039778"></a><img width="204" height="53" src="images/chap2-77.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039780"></a>where</p>
<ul><li>
<a id="pgfId-1039781"></a><em>
u</em>
(<em>
t</em>
)∈ ℜ<spti-sups-times-italic>
M</spti-sups-times-italic>
 is the vector of input sources</li><li>
<a id="pgfId-1039782"></a><em>
v</em>
(<em>
t</em>
)∈ ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 (the state) is the node voltages</li><li>
<a id="pgfId-1039783"></a><em>
q(v</em>
(<em>
t</em>
))∈ ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 is the vector of node charges and fluxes</li><li>
<a id="pgfId-1039784"></a><em>
i(v</em>
(<em>
t</em>
))∈ ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 is the vector of resistive node currents</li></ul>



<p>
<a id="pgfId-1039788"></a>If the state <em>
v</em>
 is known at some time <em>
t</em>
<sub>0</sub>, it is possible to solve Equation <a href="chap2.html#65074">2-1</a> and compute the state at some later time <em>
t</em>
<sub>1</sub>. In general, you can write Equation <a href="chap2.html#35908">2-2</a>.</p>

<p>
<a id="pgfId-1043035"></a></p>
<table class="webflareTable" id="#id1039789">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-2)
<a id="pgfId-1039791"></a><a id="35908"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039796"></a><img width="182" height="40" src="images/chap2-78.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039798"></a>where φ&#160;&#160;:&#160;&#160;ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
<sptib-sups-times-italic-bold />
 X&#160;&#160;ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 X ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 →&#160;&#160;ℜ<spti-sups-times-italic>
N</spti-sups-times-italic>
 is a state transition function for the differential equation.</p>
<p>
<a id="pgfId-1039799"></a>Consider that the circuit to be simulated has an input clock with a known period <em>
T</em>
 that is much smaller than the simulation interval. Assume the sequence formed by sampling the state at the beginning of each clock cycle, <em>
v</em>
(0), <em>
v</em>
(<em>
T</em>
), <em>
v</em>
(<em>
2T</em>
), ..., <em>
v</em>
(<em>
mT</em>
), ..., changes slowly as a function of <em>m</em>, the clock cycle number. A smooth continuous function can be defined to interpolate the sequence formed by sampling the state at every time interval <em>
T</em>
.</p>
<p>
<a id="pgfId-1039803"></a>The waveform shown in Figure <a href="chap2.html#12523">2-12</a>, is sampled at the clock period, resulting in a circuit envelope that reveals the slow varying modulation.</p>

<p><strong>Figure 2-12
<a id="pgfId-1039805"></a><a id="12523"></a>A Sample Envelope</strong></p>
<p>
<a id="pgfId-1039809"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig3.gif" /></div>

<p>
<a id="pgfId-1039813"></a>Figure <a href="chap2.html#55436">2-13</a> illustrates how the TD ENVLP (time domain envelope) algorithm works.</p>

<p><strong>Figure 2-13
<a id="pgfId-1039815"></a><a id="55436"></a>TD ENVLP Integration</strong></p>
<p>
<a id="pgfId-1039819"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig4.gif" /></div>

<p>
<a id="pgfId-1039820"></a>TD ENVLP integration is similar to transient integration. In this example, two past stages are used to compute a new stage. Assume the state values are known at <em>
t</em>
<sub>(</sub><sbtib-subs-times-italic-bold>
n</sbtib-subs-times-italic-bold>
<sub>-1</sub><sub>)</sub> and <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub>)</sub>, which are a number of clock cycles apart from each other, and are at the beginning of the clock cycle. The state values at <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub>-1</sub><sub>)</sub> and <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub>-1</sub><sub>)</sub>+<em>
T</em>
 are related by integration of one clock cycle, that is,</p>

<p>
<a id="pgfId-1039829"></a></p>
<table class="webflareTable" id="#id1039821">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-3)
<a id="pgfId-1039823"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039828"></a><img width="391" height="56" src="images/chap2-81.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039830"></a>where φ is the state transition function.</p>
<p>
<a id="pgfId-1039831"></a>Likewise, the states at <em>
t</em>
<sub><em>n</em></sub> and <em>
t</em>
<sub><em>n </em></sub>+ <em>
T</em>
 are related by <em>
v</em>
(<em>
t</em>
<sub><em>n </em></sub>+ <em>
T)</em>
 = φ(<em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub>), <em>
t</em>
<sub><em>n</em></sub>, <em>
t</em>
<sub><em>n </em></sub>+ <em>
T</em>
). The job of the algorithm is to find the state value at a new time point <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub>+1</sub><sub>)</sub> many cycles from <em>
t</em>
<sub><em>n</em></sub>, such that the pair <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub><sub> + 1</sub>), <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub> + 1</sub><sub>)</sub> interpolates a quadratic polynomial defined by the three state values<br /><em>
v</em>
(<em>
t</em>
<sub><strong>(</strong></sub><sub><em>n</em></sub><sub> - 1</sub><sub><strong>)</strong></sub>), <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub>) and <em>
v</em>
(<em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub> + 1</sub><sub><strong>) </strong></sub>+ <em>
T</em>
) at <em>
t</em>
<sub><strong>(</strong></sub><sub><em>n</em></sub><sub> - 1</sub><sub><strong>), </strong></sub><em>
t</em>
<sub><em>n</em></sub> and <em>
t</em>
<sub><strong>(</strong></sub><sub><em>n</em></sub><sub> + 1</sub><sub><strong>) </strong></sub>+ <em>
T, </em>
respectively.</p>
<p>
<a id="pgfId-1039832"></a>On one hand, the state value <em>
v</em>
(<em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub> + 1</sub><sub><strong>) </strong></sub>+ <em>
T</em>
) is given by</p>

<p>
<a id="pgfId-1039841"></a></p>
<table class="webflareTable" id="#id1039833">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-4)
<a id="pgfId-1039835"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039840"></a><img width="343" height="51" src="images/chap2-82.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039842"></a>On the other hand, from the interpolation condition, <em>
v</em>
(<em>
t</em>
<sub>(</sub><sub><em>n + 1</em></sub><sub><strong>) </strong></sub>+ <em>
T</em>
) can be written as a linear combination of <em>
v</em>
(<em>
t</em>
<sub><strong>(</strong></sub><sub><em>n</em></sub><sub> - 1</sub><sub><strong>)</strong></sub>), <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub>) and <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub><sub> + 1</sub>), i.e., there exist scalars α<sub>1</sub>, α<sub>2</sub> and α<sub>3</sub> such that</p>

<p>
<a id="pgfId-1039851"></a></p>
<table class="webflareTable" id="#id1039843">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-5)
<a id="pgfId-1039845"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039850"></a><img width="388" height="37" src="images/chap2-83.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039852"></a>The scalars α<sub>1</sub>, α<sub>2</sub> and α<sub>3</sub> can be obtained by standard techniques such as by first defining a quadratic function using three state values and then asking the fourth value to be interpolated by the quadratic function. Combining the two equations gives</p>

<p>
<a id="pgfId-1039861"></a></p>
<table class="webflareTable" id="#id1039853">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-6)
<a id="pgfId-1039855"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1039860"></a><img width="541" height="35" src="images/chap2-84.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1039862"></a>which can be used to solve for <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub><sub>+1</sub>) by shooting Newton method.</p>
<p>
<a id="pgfId-1039863"></a>After <em>
v</em>
(<em>
t</em>
<sub>n+1</sub>) is obtained, we use <em>
t</em>
<sub>n</sub> and <em>
t</em>
<sub>(</sub><sub><em>n</em></sub><sub>+1</sub><sub>)</sub> as past points and solve for a new stage <em>
v</em>
(<em>
t</em>
<sub><em>n</em></sub><sub>+2</sub>). The two-past-point one-new-stage process is repeated until the desired stop time is reached.</p>

<h4>
<a id="pgfId-1039864"></a>Harmonic Balance Envelope (HB ENVLP) Analysis</h4>

<p>
<a id="pgfId-1043213"></a>A general signal in a modulation system has the form</p>

<p>
<a id="pgfId-1043306"></a></p>
<table class="webflareTable" id="#id1043307">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-7)
<a id="pgfId-1043309"></a><a id="90452"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043311"></a><img width="237" height="44" src="images/chap2-85.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1043404"></a>when the Fourier coefficients</p>

<p>
<a id="pgfId-1043405"></a><img width="46" height="23" src="images/chap2-86.gif" /></p>

<p>
<a id="pgfId-1043412"></a>are taken to be slowly varying transient waveforms.</p>

<p>
<a id="pgfId-1043440"></a><img width="46" height="23" src="images/chap2-87.gif" /></p>

<p>
<a id="pgfId-1043438"></a>must vary slowly relative to <em>
f</em>
<sbtib-subs-times-italic-bold>
k</sbtib-subs-times-italic-bold>
, because when the bandwidth of</p>

<p>
<a id="pgfId-1043450"></a><img width="23" height="22" src="images/chap2-88.gif" /></p>

<p>
<a id="pgfId-1043448"></a>is greater than <em>
f</em>
<sbtib-subs-times-italic-bold>
k</sbtib-subs-times-italic-bold>
/2, the sidebands of adjacent harmonics begin to overlap and the representation is not unique. If there is an <em>
f</em>
<sbtib-subs-times-italic-bold>
0</sbtib-subs-times-italic-bold>
 that satisfies</p>

<p>
<a id="pgfId-1043321"></a></p>
<table class="webflareTable" id="#id1043322">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-8)
<a id="pgfId-1043324"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043326"></a><img width="93" height="20" src="images/chap2-89.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1043244"></a>then <em>
x(t)</em>
 is a one tone signal and the corresponding analysis is a single carrier HB envelope. Otherwise, <em>
x(t)</em>
 is a multi-tone signal and the corresponding analysis is a multi-carrier HB envelope.</p>
<p>
<a id="pgfId-1043340"></a>Rewriting <a href="chap1.html#83741">Equation&#160;1-1</a> in the form of <a href="chap2.html#90452">Equation&#160;2-7</a> results in the following.</p>

<p>
<a id="pgfId-1043341"></a></p>
<table class="webflareTable" id="#id1043348">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-9)
<a id="pgfId-1043350"></a><a id="38685"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043352"></a><img width="357" height="42" src="images/chap2-90.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1043253"></a>In vector form, this can be written as</p>

<p>
<a id="pgfId-1043362"></a></p>
<table class="webflareTable" id="#id1043363">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-10)
<a id="pgfId-1043365"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043367"></a><img width="317" height="42" src="images/chap2-91.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1043267"></a>where &#x2126; is a diagonal matrix with <em>
j</em>
<t-times>
2</t-times>
<em>
πf<sub><em>k</em></sub></em>
 on the <em>
k</em>
<spti-sups-times-italic>
th</spti-sups-times-italic>
 diagonal. As the transient analysis does, an HB ENVLP analysis discretizes</p>

<p>
<a id="pgfId-1043476"></a><img width="27" height="33" src="images/chap2-92.gif" /></p>

<p>
<a id="pgfId-1043474"></a>with a finite-difference approximation such as the backward-Euler, trapezoidal, or Gear method. For example, applying backward-Euler, <a href="chap2.html#38685">Equation&#160;2-9</a> becomes</p>

<p>
<a id="pgfId-1043377"></a></p>
<table class="webflareTable" id="#id1043378">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p><strong>(2-11)
<a id="pgfId-1043380"></a><a id="50867"></a></strong></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043382"></a><img width="507" height="49" src="images/chap2-93.gif" /></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1043278"></a><a href="chap2.html#50867">Equation&#160;2-11</a> is a system of nonlinear algebraic equations.</p>

<p>
<a id="pgfId-1043486"></a><img width="48" height="23" src="images/chap2-94.gif" /></p>

<p>
<a id="pgfId-1043484"></a>can be solved by Newton&#39;s method. After that value is obtained, it is used to get</p>

<p>
<a id="pgfId-1043516"></a><img width="48" height="23" src="images/chap2-95.gif" /></p>

<p>
<a id="pgfId-1043514"></a>until the desired stop time is reached.</p>
<p>
<a id="pgfId-1043288"></a>HB ENVLP analysis samples the modulation envelope in time and outputs a time-varying spectrum for time point <em>
t</em>
<sub><em>1</em></sub>, <em>
t</em>
<sub><em>2</em></sub>, ..., <em>
t</em>
<sub><em>n</em></sub>, .... The spectrum is converted to time domain waveforms in each clock cycle.</p>
<p>
<a id="pgfId-1044589"></a>In the first several clock cycles, a transient analysis is used in single carrier HB Envelope, as it is in TD Envelope. For multi-carrier HB Envelope, HB QPSS is adopted to get the steady state at the beginning.Then the time domain data is converted to frequency domain and <a href="chap2.html#50867">Equation&#160;2-11</a> works. HB Envelope is like a special Transient for frequency data.</p>

<p><strong>Figure 2-14
<a id="pgfId-1044590"></a>HB Envelope Analysis outputs a time-varying spectrum</strong></p>
<p>
<a id="pgfId-1044594"></a></p>
<div class="webflare-div-image">
<img width="667" height="319" src="images/chap2-96.gif" /></div>

<p>
<a id="pgfId-1044595"></a>For linear and nearly linear circuits, HB Envelope is more efficient than TD Envelope analysis.</p>
<p>
<a id="pgfId-1044596"></a>Both TD and HB Envelope analysis use Newton&#8217;s method. In a manner similar to that used for Periodic Steady-State (PSS) analysis (for details see [1]), the Newton equation is solved efficiently by a matrix-implicit iterative method. Compared to harmonic balance-based envelope following algorithms, the Spectre RF Envelope Following algorithm has advantages and weaknesses similar to Spectre RF PSS analysis versus analogous harmonic balance-based steady-state computation approaches.</p>
<p>
<a id="pgfId-1044597"></a>In TD and single carrier HB Envelope analysis, the clock is pointed directly. In multi-carrier HB Envelope analysis, the first one of the fundamentals is regarded as the clock. The period of the clock is the time unit of the envelope analyses.</p>
<p>
<a id="pgfId-1044598"></a>Both TD and HB Envelope analysis attempt to skip as many clock cycles as possible to achieve a faster speed than Transient analysis. Similar to Transient analysis, after a sample point is computed, it is necessary to check that the trajectory is following the low-order polynomial as assumed. If it is not, the point is discarded and the time step is reduced. If rapid changes in the envelope are encountered, Envelope analysis reduces its step size down to the point where no cycles are skipped. In this case, both TD Envelope analysis and single carrier HB Envelope analysis degenerate to a simple Transient analysis. The frequency domain data are converted to time domain. After the simple Transient, the data are converted back to frequency domain.</p>
<p>
<a id="pgfId-1044599"></a>Generally, HB Envelope is faster than TD Envelope for linear or weakly non-linear circuits. However, HB Envelope suffers from accuracy problems when dealing with strongly non-linear circuits.</p>

<h4>
<a id="pgfId-1041656"></a>HB Parameters</h4>

<p>
<a id="pgfId-1041657"></a>Parameters required by the HB ENVLP analysis are:</p>

<h4>
<a id="pgfId-1041669"></a>Basic Parameters for HB ENVLP Analysis</h4>
<table class="webflareTable" id="#id1041658">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1041660"></a><code>flexbalance=yes</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1041662"></a>The HB engine shares this analysis form with the TD engine. Use the HB engine by setting <code>flexbalance=yes</code> in the analysis statement. The default is <code>no</code>. </p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1041665"></a><code>harms<br /></code>or<br /><code>maxharms</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1041667"></a>Use of the <code>harms</code> or <code>maxharms</code> parameter is similar to the usage in driven HB analysis. For more information, see <a href="chap1.html#74528">Basic HB Parameters for Driven HB Analysis</a> table.</p>

</td>
</tr>
</tbody></table>
<h4>
<a id="pgfId-1041676"></a>Optional Parameters for HB ENVLP Analysis</h4>
<table class="webflareTable" id="#id1041671">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1041673"></a><code>oversamplefactor</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1041675"></a>Use of the <code>oversamplefactor</code> parameter is similar to its usage in driven HB analysis. For more information, see <a href="chap1.html#43998">Optional HB Parameters for Driven HB Analysis</a> table.</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1039976"></a><a id="12570"></a>Using ENVLP Analysis</h3>

<p>
<a id="pgfId-1039977"></a>This analysis computes the envelope response of a circuit. The user specifies the analysis <strong>clockname</strong>. The simulator automatically determines the clock period by looking through all the sources with the specified name. The envelope response is computed over the interval from <strong>start</strong> to <strong>stop</strong>. If the interval is not a multiple of the clock period, it is rounded off to the nearest multiple before the stop time. The initial condition is taken to be the DC steady-state solution or determined by <strong>tstab</strong> if not otherwise given. If <strong>flexbalance</strong> is <code>yes</code>, HB ENVLP will be used, otherwise TD ENVLP will be used. The default value is <code>no</code>.</p>
<p>
<a id="pgfId-1039978"></a>As discussed previously, the clock might be referred to differently in different applications LO with mixers, carrier with detectors, and clock with switched-capacitor filters. The clock is normally the most rapidly changing signal in the circuit and thus causes the most nonlinearity.</p>
<p>
<a id="pgfId-1039979"></a>ENVLP analysis is most efficient for circuits where the modulation bandwidth is orders of magnitude lower than the clock frequency. This is typically the case in RF circuits. Passing a narrowband signal through a nonlinear RF circuit results in a broadband signal whose spectrum is relatively sparse, as shown in Figure <a href="chap2.html#90385">2-15</a>. The spectrum shows that due to nonlinearity, narrowband responses centered at the carrier harmonics are generated.</p>

<p><strong>Figure 2-15
<a id="pgfId-1039984"></a><a id="90385"></a>Spectrum of a Narrowband Signal</strong></p>
<p>
<a id="pgfId-1039988"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig6.gif" /></div>

<p>
<a id="pgfId-1039989"></a>In general, this spectrum consists of clusters of frequencies near the harmonics of the carrier. When the modulation is periodic or quasi-periodic, these clusters take the form of a discrete set of frequencies. Otherwise they form a continuous distribution of frequencies.</p>
<p>
<a id="pgfId-1039996"></a>Figures <a href="chap2.html#64957">2-16</a> and <a href="chap2.html#37595">2-17</a> present examples of calculating spectrum regrowth. Here the carrier is a periodic high-frequency signal, while the modulation is a low frequency arbitrary digital modulation. ENVLP analysis is used to accurately calculate the sparse spectrums centered at clock harmonics. A continuous spectrum in each cluster is expected because the modulation is neither periodic nor quasi-periodic.</p>
<p>
<a id="pgfId-1039997"></a>In two typical situations, ENVLP analysis is very efficient and effective in simulating the transient behavior of circuits driven by two periodic signals.</p>
<p>
<a id="pgfId-1039998"></a>In the first situation, one fundamental frequency is much higher than the other one, as would be the case for an up-conversion mixer. As shown in Figure <a href="chap2.html#64957">2-16</a>, you can interpret a quasiperiodic signal with two widely separated fundamentals as a periodically modulated periodic signal. To do this, designate the high frequency signal as the carrier and the low frequency signal as the modulation. If the carrier is much higher in frequency than the modulation, then the carrier will appear to vary only slightly from cycle to cycle. When this is the case, the envelope can be efficiently followed with ENVLP analysis.</p>

<p><strong>Figure 2-16
<a id="pgfId-1040003"></a><a id="64957"></a>A Two-Fundamental Quasiperiodic Signal</strong></p>
<p>
<a id="pgfId-1040007"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig7.gif" /></div>

<p>
<a id="pgfId-1040008"></a>In the second situation, both inputs are high frequency signals but their frequencies are close to each other. The down-conversion of these closely placed frequencies can generate a slow-varying modulation envelope whose frequency is orders of magnitude lower than the input frequencies. For example, Figure <a href="chap2.html#37595">2-17</a> shows a down-conversion mixer where TD ENVLP analysis can be used to trace out the modulation envelope by choosing either of the fast varying signals as the clock. In general, you should choose as the clock signal the signal that causes the most nonlinearity. Be aware that single carrier HB ENVLP analysis does not<em> </em>handle this well because HB ENVLP treats signals other than the clock signal as DC signals in one cycle of the clock. Multi-carrier HB ENVLP can handle this case.</p>

<p><strong>Figure 2-17
<a id="pgfId-1040014"></a><a id="37595"></a>Down Conversion of Two Closely Placed Frequencies</strong></p>
<p>
<a id="pgfId-1040018"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig8.gif" /></div>

<p>
<a id="pgfId-1044806"></a>As is true for Periodic Steady-State (PSS) analysis, you can use ENVLP analysis for particular classes of circuits operating with multiple clock fundamentals. For PSS analysis, the multiple fundamentals are commensurate. For ENVLP analysis, you can use the greatest common denominator of all fundamental clock frequencies as the clock beat frequency. The process of selecting the clock beat frequency for ENVLP analysis is similar to the process of figuring out the beat frequency for PSS analysis. In similar situations where multiple clock fundamentals are present, ENVLP analysis is also analogous to PSS in terms of efficiency. Each time the clock period is integrated, a large number of fast cycles might be involved. The efficiency of the method depends on how many fast cycles occur per beat period. The more fast cycles you need to simulate, the less efficient the method. Because HB ENVLP regards the signals other than clock as DC signals, currently HB ENVLP is <em>not</em> a good choice to simulate a circuit with fast cycles other than clock. Multi-carrier HB Envelope should be used instead by either</p>
<ul><li>
<a id="pgfId-1044807"></a>Setting LO and RF as the fundamentals, and regarding IF as slow signals.</li><li>
<a id="pgfId-1044808"></a>Regarding IF as a modulated wave, and setting LO, RF and IF as the fundamentals.</li></ul>

<p>
<a id="pgfId-1040020"></a>One difference between the ENVLP and PSS analyses is that for ENVLP analysis, you use a single <code>clockname</code> to identify the fundamentals. The simulator automatically calculates the beat frequency. For PSS analysis, you figure out the beat frequency either at the UI level or by entering it as an analysis parameter.</p>
<p>
<a id="pgfId-1040021"></a>In a certain sense, an ENVLP analysis might be considered as a fast transient analysis whose efficiency comes from skipping simulation cycles. However, when an ENVLP analysis cannot find cycles to skip, the analysis effectively reduces to a transient analysis. Therefore, ENVLP analysis might not always be more efficient than transient analysis due to the greater computational overhead required for ENVLP analysis when it cannot find enough cycles to skip. Nevertheless, ENVLP analysis is always as accurate as PSS analysis.</p>

<h4>
<a id="pgfId-1040023"></a><a id="22684"></a>ENVLP Parameters</h4>

<p>
<a id="pgfId-1062819"></a>For information on ENVLP analysis parameters, refer to the <em><a actuate="user" class="URL" href="../spectreref/chap3.html#envlp" show="replace" xml:link="simple">Envelope Following Analysis (envlp)</a></em> section in the Spectre Circuit Simulator Reference manual.</p>
<p>
<a id="pgfId-1040266"></a>The Envelope Choose Analysis form is similar to the transient Choose Analysis form. Most ENVLP analysis parameters are inherited from either transient or PSS analysis and their meanings are consistent. However, a few parameters need clarification.</p>
<p>
<a id="pgfId-1044823"></a>The procedure for setting up an ENVLP analysis is similar to the set-up procedure for transient analysis. Important parameters for ENVLP analysis include: <code>clockname</code>, <code>period</code>, <code>fund</code>, <code>funds</code>, <code>flexbalance</code>, <code>maxharms</code>, <code>harmonicbalance</code>, <code>harms</code>, <code>stop</code>, <code>envmaxstep</code>, <code>modulationbw</code>, <code>fixstepsize</code>, <code>swapfile</code>, and <code>fmspeedup</code>.</p>
<p>
<a id="pgfId-1040268"></a>The following list summarizes several important differences between ENVLP analysis and transient analysis. The parameter names are those used inside Spectre RF. For ENVLP analysis, do the following:</p>
<ul><li>
<a id="pgfId-1040269"></a>Identify a periodic, built-in source with the <code>clockname</code> parameter. This requirement is similar to QPSS analysis requirements. However, for ENVLP analysis, you need only name the clock source. You can select any periodic, built-in source (<code>sine</code>, <code>pulse</code>, or <code>pwl</code>) as the clock. The simulator examines all the sources whose name matches the <code>clockname</code> to determine the clock frequency. If more than one frequency is found, the greatest common factor of these frequencies is used as the clock frequency.<br />
<a id="pgfId-1040270"></a>When applied to autonomous circuits, ENVLP analysis requires that you specify a pair of nodes, <code>p</code> and <code>n</code>, as for PSS analysis. You cannot use <code>clockname</code> for autonomous circuits. If the period of the carrier is known, <code>period</code> of <code>fund</code> could be set to get the clock frequency directly, and <code>clockname</code> is ignored.</li><li>
<a id="pgfId-1044835"></a>To use multi-carrier HB Envelope, <code>funds</code> and <code>maxharms</code> must be provided, just like QPSS. Multi-carrier HB Envelope uses the QPSS HB engine and adopts the same parameters <code>funds</code> and <code>maxharms</code>.</li><li>
<a id="pgfId-1044836"></a>If <code>harmonicbalance </code>is <code>yes</code>, HB Envelope is used. If it is <code>no</code>, TD Envelope is used. The default is no. For multi-carrier HB Envelope, this parameter is regarded as yes automatically.</li><li>
<a id="pgfId-1044837"></a>Specify which harmonics of the clock frequency are of interest with the <code>harms</code>/<code>harmsvec</code> parameter. For TD Envelope, the default for <code>harms</code><em> is </em>1, which is appropriate for most applications. The number of harmonics you specify affects both output and computation time, but it does not affect accuracy. Hence, you should avoid specifying unnecessary harmonics. For example, in a power amplifier, only the first harmonic is needed because the signal of interest is near the fundamental frequency. In a mixer, both the zeroth and the first harmonics are needed because signals at both the baseband and near the fundamental frequency are of interest. For single carrier HB Envelope, the default for <code>harms</code><em> is 3</em>. The number of harmonics does affect accuracy because HB Envelope calculates in frequency domain. For multi carrier HB Envelope, <code>harms</code> is replaced by <code>maxharms</code>. For multi-carrier HB Envelope, <code>harmsvec</code> also specifies the harmonics which need output, each group of elements with the size equal to that of <code>funds</code> is a selection of specific harmonic combinations of fundamental frequencies.</li><li>
<a id="pgfId-1040275"></a>Specify a <code>stop</code> time long enough to detect slow signals. For example, complete at least a few clock cycles.</li><li>
<a id="pgfId-1044846"></a>The maximum envelope step size is affected by many parameters. It can be directly limited by <code>envmaxstep</code>. It is helpful to specify a <code>modulationbw</code> frequency that reflects how the envelope is varying. This parameter provides an estimate of the modulation bandwidth and the simulator puts at least eight points within the modulation period. An approximate value is sufficient. To improve the noise floor in power spectrum density computation, use <code>strobeperiod</code> to get equally spaced envelope points.</li><li>
<a id="pgfId-1040277"></a>If <code>fixstepsize </code>is <code>yes</code>, ENVLP analysis skips cycles indicated by <code>stepsize</code>. The efficiency of Envelope analysis depends on how many cycles are skipped. The strategy is designed for general situations. For some cases, Envelope is faster with an appropriate fixed <code>stepsize</code>.</li><li>
<a id="pgfId-1040278"></a>Specify a <code>swapfile</code> for simulation of large circuits. The same requirement holds for PSS and QPSS analyses. The <code>swapfile</code> parameter is supported for only the shooting engine.</li><li>
<a id="pgfId-1040279"></a>Specify <code>fmspeedup=yes</code> for circuits with frequency modulated input.</li></ul>











<p>
<a id="pgfId-1040280"></a>Most of the remaining parameter requirements are the same as for the Spectre RF transient (<code>tran</code>) analysis and their meanings are consistent.</p>

<h4>
<a id="pgfId-1040281"></a>The errpreset Parameter in ENVLP Analysis</h4>

<p>
<a id="pgfId-1040282"></a>The effect of <code>errpreset</code> on some particular ENVLP analysis parameters is shown in Table <a href="chap2.html#75769">2-6</a>.</p>

<h4>Table 2-6
<a id="pgfId-1040283"></a><a id="75769"></a>Parameter Defaults as a Function of errpreset</h4>
<p>
<a id="pgfId-1040333"></a></p>
<table class="webflareTable" id="#id1040284">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040286">
<a id="pgfId-1040286"></a>errpreset</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1043058">
<a id="pgfId-1043058"></a>maxstep</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040288">
<a id="pgfId-1040288"></a>envmaxstep</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040290">
<a id="pgfId-1040290"></a>reltol</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040292">
<a id="pgfId-1040292"></a>relref</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040294">
<a id="pgfId-1040294"></a>steady
ratio</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1040296">
<a id="pgfId-1040296"></a>envlteratio</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040298"></a><code>liberal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043060"></a>T/20</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040300"></a><code>Interval/10</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040302"></a><code>0.01</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040304"></a><code>sigglobal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040306"></a><code>0.1 </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1040308"></a><code>0.35</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040310"></a><code>moderate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043062"></a>T/20</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040312"></a><code>Interval/25</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040314"></a><code>0.001</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040316"></a><code>sigglobal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040318"></a><code>0.1 </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040320"></a><code>3.5</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040322"></a><code>conservative</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043064"></a>T/50</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040324"></a><code>Interval/50</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040326"></a><code>0.0001</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040328"></a><code>alllocal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040330"></a><code>1.0</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040332"></a><code>35.0</code></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1040334"></a>The effect of <code>errpreset</code><a id="errpresetENVLP"></a> on parameters such as <code>reltol</code>, <code>relref</code>, <code>method</code>, <code>maxstep</code>, and <code>lteratio</code> is the same as defined for transient analysis with one exception. The transient simulation interval in ENVLP analysis is always a clock period.</p>
<p>
<a id="pgfId-1040336"></a>The default value for<strong> </strong><code>compression=no</code><a id="ENVLPCompressionDiscussion"></a>.</p>
<ul><li>
<a id="pgfId-1040337"></a>For <code>compression=no</code>, the output file stores data for every signal at every timepoint for which Spectre RF calculates a solution. Spectre RF saves the x axis data only once, because every signal has the same x value.</li><li>
<a id="pgfId-1040338"></a>For <code>compression=yes</code>, Spectre RF writes data to the output file only when the signal value changes by at least twice the convergence criteria. To save data for each signal independently, x axis information corresponding to each signal must be saved.<ul><li>
<a id="pgfId-1040339"></a>If the signals in your circuit stay at constant values for large periods of the simulation time, setting <code>compression=yes</code> results in a smaller output data file.</li><li>
<a id="pgfId-1040340"></a>If the signals in your circuit move around a lot, setting <code>compression=yes</code> results in a larger output data file.</li></ul></li></ul>



<p>
<a id="pgfId-1040341"></a>ENVLP analysis generates two types of output files for each specified harmonic of the clock fundamental</p>
<ul><li>
<a id="pgfId-1040342"></a>A voltage versus time (<code>td</code>) file</li><li>
<a id="pgfId-1040343"></a>An amplitude/phase versus time (<code>fd</code>) file</li></ul>

<p>
<a id="pgfId-1040344"></a>The <code>td</code> file contains real time-domain waveforms. This file is generated when <code>outputtype</code>={<span class="webflare-courier-new" style="white-space:pre"><em>envelope</em></span>, <span class="webflare-courier-new" style="white-space:pre"><em>both</em></span>}. The waveforms are similar to waveforms generated by Transient analysis. The difference between the two is that for ENVLP analysis the integration of a clock cycle is done occasionally. Consequently, you normally see gaps between integrated clock cycles. Note that multi-carrier HB Envelope analysis does not generate a <code>td</code> file.</p>
<p>
<a id="pgfId-1040345"></a>The <code>fd</code> file contains time varying Fourier coefficients (complex) of the circuit response at clock harmonics. The <code>fd</code> file is generated when <code>outputtype=</code>{<span class="webflare-courier-new" style="white-space:pre"><em>spectrum</em></span>, <span class="webflare-courier-new" style="white-space:pre"><em>both</em></span>}. Time varying Fourier coefficients are discussed in <a href="chap2.html#77107">&#8220;ACPR Calculation&#8221;</a>.</p>
<p>
<a id="pgfId-1040349"></a>The actual spectrum of each harmonic response is calculated from the Analog Design Environment (ADE) GUI. This is useful for applications such as ACPR calculation.</p>

<h4>
<a id="pgfId-1040351"></a><a id="51026"></a>Plotting the Results of ENVLP Analysis</h4>

<p>
<a id="pgfId-1040353"></a>The Envelope Following Direct Plot form plots</p>
<ul><li>
<a id="pgfId-1040354"></a>Three different waveform (or <em>Function</em>) types<ul><li>
<a id="pgfId-1040355"></a><em>Voltage</em></li><li>
<a id="pgfId-1040356"></a><em>Current</em></li><li>
<a id="pgfId-1040357"></a><em>Power</em></li></ul></li><li>
<a id="pgfId-1040358"></a>Three <em>sweep</em> types<ul><li>
<a id="pgfId-1040359"></a><em>Time</em></li><li>
<a id="pgfId-1040360"></a><em>Harmonic Time</em></li><li>
<a id="pgfId-1040361"></a><em>Spectrum</em>.</li></ul></li></ul>







<p>
<a id="pgfId-1040365"></a>As shown in Figure <a href="chap2.html#18473">2-18</a>, waveforms are called <em>Functions</em> on the ENVLP analysis Direct Plot form.</p>

<p><strong>Figure 2-18
<a id="pgfId-1040367"></a><a id="18473"></a>A Typical ENVLP Direct Plot Form</strong></p>
<p>
<a id="pgfId-1040370"></a></p>
<div class="webflare-div-image">
<img src="images/TRANSdirectPlot1.gif" /></div>
<h4><em>
<a id="pgfId-1040371"></a>Plotting Voltage vs Time Waveforms</em></h4>

<p>
<a id="pgfId-1040374"></a>When you select both a waveform (<em>Signal</em>) and the <em>sweep</em> type <em>Time</em>, you plot a cycle-sampled version of the waveform.</p>
<p>
<a id="pgfId-1040375"></a>When you use an Amplitude Modulated (AM) example with a 1 GHz carrier and a 1 MHz baseband tone, the resulting plot is a sampled version of the AM waveform. Instead of taking a continuous set of points as a transient analysis would, the ENVLP analysis saves simulation time by taking intelligently spaced samples of the waveform. When you visually connect the tops of the waveform samples, you can see the envelope that results from an equivalent transient analysis.</p>
<p>
<a id="pgfId-1040376"></a>Depending on the phase of the clock at which the sampling occurs, different time domain envelopes result. Figure <a href="chap2.html#74181">2-19</a> shows two envelopes that might result from sampling at different clock phases. Either envelope might be traced out by an ENVLP analysis.</p>

<p><strong>Figure 2-19
<a id="pgfId-1040381"></a><a id="74181"></a>Sample Envelopes</strong></p>
<p>
<a id="pgfId-1040385"></a></p>
<div class="webflare-div-image">
<img width="668" height="175" src="images/chap2-101.gif" /></div>

<p>
<a id="pgfId-1040388"></a>The other two <em>sweep</em> types (<em>harmonic time</em> and <em>spectrum</em>) plot <em>voltage</em> as a complex waveform. For complex waveforms, you can plot either the magnitude/phase or the real/imaginary parts of the waveform. Note that if you change the clock phase at which sampling occurs, these complex waveforms are not affected.</p>
<p>
<a id="pgfId-1040390"></a>When you select both <em>signal</em> and <em>harmonic time</em> as the <em>sweep</em> type, you plot the complex, time-varying Fourier coefficient for each harmonic. Using the AM example, when you select the 1<sup>st</sup> harmonic you see the 1 MHz baseband signal. In other words, the ENVLP analysis essentially strips off the 1 GHz carrier.</p>

<h4>
<a id="pgfId-1040391"></a>Plotting Power Spectral Density</h4>

<p>
<a id="pgfId-1040392"></a>When you select both <em>signal</em> and <em>spectrum</em>, the <em>Power Spectral Density Parameter </em>fields appear at the bottom of the plot form. After you provide values for the fields, the Direct Plot form calculates the <em>total number of samples</em>, <em>window size</em>, and <em>number of bins,</em> and then calls the <em>psdbb </em>calculator function.</p>
<p>
<a id="pgfId-1040396"></a>Table <a href="chap2.html#23068">2-7</a> describes the <em>Power Spectral Density Parameter </em>fields.</p>

<p>
<a id="pgfId-1040427"></a></p>
<table class="webflareTable" id="#id1040397">
<caption style="text-align:left;"><p>
</p><h4>Table 2-7
<a id="pgfId-1040400"></a><a id="23068"></a>Power Spectral Density Parameters </h4></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040404"></a><em>From</em> time and <em>to</em> time</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040406"></a>Starting and ending times, respectively, for the time interval during which the spectral analysis is to be performed. Normally, these parameters are set to the simulator start and stop times, respectively. However, you might want to make the <em>From</em> time different than zero to exclude the start-up transient from the analysis. The Time Interval should be long enough to support the frequency resolution you want.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040408"></a><em>Nyquist <br />half-bandwidth</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040411"></a>Normally this parameter is set to 3 to 5 times the maximum modulation bandwidth frequency. The <em>Nyquist half-bandwidth</em> indirectly determines the spacing of the time points used in the FFT calculations. When the original time domain data points are too far apart to support the Nyquist bandwidth, you might see strange results such as unexpected spikes in the spectrum. The Nyquist half-bandwidth should be less than half the inverse of the smallest time step. To avoid aliasing, all signals in the system must have negligible power at the Nyquist half-bandwidth and beyond.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040413"></a><em>bin-width</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040415"></a>The <em>Frequency bin width</em> determines the frequency resolution. A smaller frequency resolution usually produces a noisier spectrum. The power spectral density is a frequency-by-frequency average of the FFT taken over several time windows within the main time interval. A smaller<em> Frequency bin width</em> produces fewer samples to average together at each frequency. If you chose a small bin width, the resulting PSD looks &#8220;noisy&#8221; and has a jagged appearance. If you make the bin width too large you might soften what should be sharp edges in the spectrum.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040417"></a><em>Max plotting frequency <br /></em>and <br /><em>Min plotting frequency</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040419"></a>The <em>Min </em>and <em>Max plotting frequencies</em> are the minimum and maximum frequency you wish to display. The <em>Min plotting frequency</em> is negative because the resulting plot is the power spectral density of a baseband signal. The power spectral density of a baseband signal does not necessarily have complex conjugate symmetry because the signal is generally complex. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043072"></a><em>windowing name</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1043074"></a>A preset list of available windowing functions used during the spectrum calculation. The <em>Window</em> selection determines how data at the edges of a time window is attenuated to control spectral leakage. Spectral leakage occurs because an FFT is always taken over a finite time interval. That is like multiplying the original waveform by a pulse of amplitude one and duration equal to the duration of the data. Multiplication in the time domain corresponds to convolution in the frequency domain. The transform of the long pulse is a high and narrow sinc function. As the pulse length goes to infinity, the main lobe of the sinc function approaches a Dirac delta function. When estimating the spectrum at a given frequency, the sinc function&#8217;s side lobes cause spectral components of the untruncated signal to leak into the estimation of the spectrum at the main lobe. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040421"></a><em>detrending</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040423"></a>Allows you to remove certain trends from the data before the spectral analysis. The options are None, Mean and Linear.</p>

<ul><li>
<a id="pgfId-1040424"></a>None means do not detrend</li><li>
<a id="pgfId-1040425"></a>Mean removes the mean</li><li>
<a id="pgfId-1040426"></a>Linear removes the linearly growing component</li></ul>



</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1045026"></a>The following typical parameter settings are used for the AM example just mentioned. These numbers assume that the <em>Stop time</em> is set to 60 us: </p>
<table class="webflareTable" id="#id1044993">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1044995"></a><code>Start time</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1044997"></a>0</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1044999"></a><code>Stop time</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045001"></a>60us</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045003"></a><code>Nyquist half-bandwidth</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045005"></a>5e6</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045007"></a><code>Bin-width</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045009"></a>20e3</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045011"></a><code>Max plotting freq</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045013"></a>5e6</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045015"></a><code>Min plotting freq</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045017"></a>-5e6</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045019"></a><code>Windowing name</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045021"></a>hamming</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045023"></a><code>Detrending</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045025"></a>none</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1040428"></a>For the AM example, you see a waveform displayed as <em>
V</em>
<sup>2</sup> / (<em>
Hz</em>
) versus frequency. You can think of this as</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1040465"></a><code>(rms passband volts) *&#160;&#160; (rms passband volts) / Hz</code></pre>

<p>
<a id="pgfId-1041803"></a>The spectrum plot is the estimated power spectral density of the complex envelope divided by two. The division by two occurs because the envelope is in units of peak carrier volts but power in the carrier equals the square of the peak divided by two. It is convenient to express the envelope in peak units because it can then be directly compared against an input baseband signal.</p>
<p>
<a id="pgfId-1041805"></a>The calculated <em>total number of samples</em>, <em>window size</em>, and <em>bin-width</em> are printed to the CIW (Command Interpreter Window) so you have the option of using the <em>psdbb</em> calculator function. As shown later, direct use of the <em>psdbb</em> function together with strobing can dramatically drop the noise floor. The following list displays the calculations that generate the <em>psdbb</em> parameters:</p>
<ul><li>
<a id="pgfId-1040469"></a><em>
L =To - From</em>
 (the <em>
To</em>
 and <em>
From</em>
 times are user inputs)</li><li>
<a id="pgfId-1040470"></a><em>
fmax</em>
 (<strong>Nyquist half-bandwidth</strong>) and <strong>bin-width</strong> are user inputs</li><li>
<a id="pgfId-1040471"></a><em>
#bins = floor(L*binwidth)</em>
, compute with <em>
#bins &gt;= 1</em>
. Here, <em>
floor</em>
 means <em>
take the integer part of..., </em>
or truncate to the nearest integer.</li><li>
<a id="pgfId-1040472"></a>Compute the smallest <code>m</code> such that<br />
<a id="pgfId-1040473"></a><em>
2</em>
<code><sup>m</sup></code><em></em>
∗<em>
 (#bins) &gt; 2</em>
∗<em>
L</em>
∗<em>
fmax</em>
</li><li>
<a id="pgfId-1040474"></a><em>
windowsize</em>
 = <em>
2</em>
<code><sup>m</sup></code></li><li>
<a id="pgfId-1040475"></a><em>
number of samples = #bins </em>
∗<em>
 windowsize</em>
</li></ul>









<h3>
<a id="pgfId-1040477"></a><a id="41947"></a>AGC Example</h3>

<p>
<a id="pgfId-1040478"></a>One application of ENVLP analysis is to assess the Automatic Gain Control (AGC) loop dynamics. AGC loops are important in communication systems where wide amplitude variations in the output signal leads to a loss of information. These signals need a good control to maintain a constant signal level at the output.</p>
<p>
<a id="pgfId-1043096"></a>The PSS and QPSS analyses cannot compute the AGC response because the response is not periodic. The loop might have a periodic response if it were unstable but PSS and QPSS would be difficult to apply because the period of the instability would not be known before running the simulation. Transient analysis is not usually a good choice because the frequencies of the amplitude oscillation and carrier are too far apart. ENVLP analysis is an efficient and accurate alternative for assessing the stability of AGC loops as this example shows.</p>
<p>
<a id="pgfId-1040482"></a>Consider the AGC loop shown in Figure <a href="chap2.html#33751">2-20</a>. The behavioral blocks are simple multipliers from the <em>ahdl</em> library. The upper left multiplier is the variable gain amplifier (VGA). After filtering, the amplitude detector produces the square of the amplitude of the VGA output. The AGC loop input is a fixed-amplitude 100 Mhz carrier. A stable version of this circuit would generate an output signal with the same phase as the input signal but with the amplitude determined by the feedback loop. This design has an extra integration in the feedback loop that makes the loop unstable. The simulator&#8217;s challenge here is to detect the design error by quickly and accurately simulating the unstable behavior.</p>

<p><strong>Figure 2-20
<a id="pgfId-1040484"></a><a id="33751"></a>AGC Loop</strong></p>
<p>
<a id="pgfId-1040488"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig11.gif" /></div>

<p>
<a id="pgfId-1040492"></a>Figure <a href="chap2.html#33751">2-20</a> compares the results of transient analysis with the TD ENVLP and HB ENVLP analyses.</p>
<p>
<a id="pgfId-1040494"></a>The common parameters for all three analyses are</p>

<p class="webflare-indent1">
<a id="pgfId-1040495"></a><em>Stop</em> time=<code>2m</code></p>
<p class="webflare-indent1">
<a id="pgfId-1040496"></a><em>Accuracy Defaults(errpreset)=moderate</em></p>

<p>
<a id="pgfId-1040497"></a>For both ENVLP analyses</p>

<p class="webflare-indent1">
<a id="pgfId-1040498"></a><em>Number of harmonics=1</em></p>

<p>
<a id="pgfId-1040502"></a>In Figure <a href="chap2.html#20764">2-21</a>, waveforms for all three analyses show the instability in the output amplitude. Both ENVLP analyses (top) avoid a number of redundant carrier cycles and run much faster than the transient analysis (bottom). The TD ENVLP analysis is about 47 times faster than the transient analysis. The HB ENVLP analysis is 293 times faster than the transient analysis because this case is quite linear. The time savings is even greater with a 1 GHz carrier.</p>
<p>
<a id="pgfId-1043112"></a>Figure <a href="chap2.html#34707">2-22</a> compares the ENVLP analyses with the transient analysis (bottom) for a single cycle. The ENVLP simulation is not only fast, it is accurate.</p>
<p>
<a id="pgfId-1043120"></a>The Spectre RF workshop includes this example. It shows how to set up an envelope analysis for this case and how to see further results. Refer to the workshop for more information.</p>

<p><strong>Figure 2-21
<a id="pgfId-1040504"></a><a id="20764"></a>Comparison Between Transient and ENVLP Analyses Results</strong></p>
<p>
<a id="pgfId-1040508"></a></p>
<div class="webflare-div-image">
<img width="668" height="708" src="images/chap2-103.gif" /></div>
<p><strong>Figure 2-22
<a id="pgfId-1040514"></a><a id="34707"></a>Blow-up of One ENVLP Cycle with the Transient Waveform</strong></p>
<p>
<a id="pgfId-1040518"></a></p>
<div class="webflare-div-image">
<img width="602" height="352" src="images/chap2-104.gif" /></div>
<h3>
<a id="pgfId-1040520"></a><a id="77107"></a>ACPR Calculation</h3>

<p>
<a id="pgfId-1040521"></a>ACPR (Adjacent Channel Power Ratio) is a common measure of how much power a transmitter emits outside its allotted frequency band. It is the ratio of the power in an adjacent band divided by the power in the allotted band. Regardless of exactly how you chose the frequencies and bands for the ACPR measurement, it is always extracted from the power spectral density of the transmitted signal. This section describes how the Analog Design Environment (ADE) estimates power spectral density (PSD).</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1040522"></a>You cannot compute the PSD directly from PSS and QPSS analyses because the input baseband signals carry information and are therefore not periodic. The J-model (see [5] for details) is a very fast indirect method for computing ACPR, but like all behavioral models, has limitations. Using an ENVLP analysis, you can check J-model ACPR calculations much faster than you can with transient analysis.</div>
<p>
<a id="pgfId-1040523"></a>PSDs are always estimated because the information riding on the carrier is a stochastic process and the Fourier transform of a stochastic process is ill defined. No matter how you chose to define the spectral nature of a stochastic process, it must involve an averaging process. Any empirically derived average is an estimate because one can never take an infinite number of samples.</p>
<p>
<a id="pgfId-1040524"></a>The PSD is a frequency-by-frequency average of a set of DFTs (discrete Fourier transforms) of the baseband signal. Here, the baseband signal is the harmonic-time result of an ENVLP analysis.</p>
<p>
<a id="pgfId-1040525"></a>The waveform is first interpolated, if necessary, to generate evenly spaced data points in time. The spacing of the data points is the inverse of the DFT sampling frequency. The PSD is computed by first breaking the time Interval up into overlapping segments. Each segment is multiplied, time point by time point, by the specified Windowing function. Windowing reduces errors caused by a finite time record. It is impossible to work with an infinite time record. Direct use of an unwindowed finite time record is equivalent to multiplying the infinite record by a rectangular pulse that lasts as long as the data record. Multiplication in the time domain corresponds to convolution in the frequency domain. The Fourier transform of a rectangular pulse is a sinc function. Considering the frequency domain convolution, the side lobes of the sinc function cause parts of the true spectrum to leak into the frequency of interest, the frequency of the main lobe. Ideally, the sinc function would be a Dirac delta function but that requires an infinite time record. Good windowing functions have smaller side lobes than a sinc function.</p>
<p>
<a id="pgfId-1040526"></a>The DFT is performed on each windowed segment of the baseband waveform. At each frequency, the DFTs from all segments are averaged together. Fewer segments means fewer data points in the average at a particular frequency. The length of each segment is inversely proportional to the Frequency bin width. This is why a small bin width produces a jagged PSD. A smaller bin width means a longer time segment. Fewer long segments fit into the given Time Interval so there are fewer DFTs to average together. In the extreme, there is only one segment and no averaging. Without averaging, the PSD is just the square of the magnitude of the DFT of a stochastic process. At the other extreme, large bin widths produce lots of points to average at each frequency but there are fewer frequencies at which to average because fewer large bins fit into the Nyquist frequency. The PSD is smoother but it does not have as much resolution.</p>

<h4>
<a id="pgfId-1040527"></a>A PSD Example</h4>

<p>
<a id="pgfId-1040528"></a>This section describes the various ENVLP outputs and how to use them to generate a PSD. Figure <a href="chap2.html#76148">2-23</a> shows the ACPR test circuit.</p>
<ul><li>
<a id="pgfId-1040532"></a>The behavioral blocks are two multipliers and one adder that model an ideal I/Q modulator</li><li>
<a id="pgfId-1040533"></a>The carrier frequency is 1 GHz</li><li>
<a id="pgfId-1040534"></a>The amplifiers are transistor-level models</li></ul>


<p>
<a id="pgfId-1040535"></a>The baseband input signals are read in with piecewise linear sources. The piecewise linear sources read data files. In this example, the data files contain CDMA baseband signals and are stored in the <em>rfLib</em>. The files are listed as <code>cdma_2ms_idata</code> and <code>cdma_2ms_qdata</code>. The stored signals were created with the CDMA signal generator, which is also in the<em> rfLib</em>. You cannot use the CDMA signal generator directly because its internal DSP filters have a hidden state. Spectre RF does not work with any AHDL model that has a hidden state. You can also generate the baseband signals with SPW. The piecewise linear sources also read SPW&#8217;s data format.</p>

<p><strong>Figure 2-23
<a id="pgfId-1040538"></a><a id="76148"></a>ACPR Test Circuit</strong></p>
<p>
<a id="pgfId-1040544"></a></p>
<div class="webflare-div-image">
<img width="668" height="205" src="images/chap2-105.gif" /></div>

<p>
<a id="pgfId-1040548"></a>Figure <a href="chap2.html#16914">2-24</a> displays the <em>time</em> response of the RF output. The top picture shows some of the cycles. A number of cycles are missing. This illustrates why ENVLP analysis is faster than transient analysis.</p>

<p><strong>Figure 2-24
<a id="pgfId-1040550"></a><a id="16914"></a>ENVLP Analysis Time Response</strong></p>
<p>
<a id="pgfId-1040555"></a></p>
<div class="webflare-div-image">
<img width="647" height="311" src="images/chap2-106.gif" /></div>

<p>
<a id="pgfId-1040556"></a>Although you can see something resembling an envelope in the <em>time</em> response, the detailed cycles can obscure it on larger time scales and it is not guaranteed to represent any particular phase of the envelope. The <em>harmonic time</em><em> </em>response is designed to extract the baseband components or any other harmonic of interest. Most of the time the fundamental, or first harmonic, is the most interesting.</p>
<p>
<a id="pgfId-1040557"></a>The <em>harmonic</em> analysis plots the real and imaginary parts of the specified Fourier component of each cycle as a function of its location in time. <a href="chap2.html#94748">Figure&#160;2-25</a> and <a href="chap2.html#82510">Figure&#160;2-26</a> show how the real and imaginary parts of the fundamental components of the RF input and output signals evolve with time. These signals are the baseband representations of the RF signals.</p>

<p><strong>Figure 2-25
<a id="pgfId-1040565"></a><a id="94748"></a>Input (top) and Output (bottom) Baseband Waveforms</strong></p>
<p>
<a id="pgfId-1040572"></a></p>
<div class="webflare-div-image">
<img width="671" height="570" src="images/chap2-107.gif" /></div>

<p>
<a id="pgfId-1040582"></a>Not much can be ascertained directly from time-domain baseband waveforms. However, x-y plots of real and imaginary waveforms show the trajectory traced out by the baseband signal in the symbol constellation space. Figure <a href="chap2.html#82510">2-26</a> shows the input and output baseband trajectories. A trajectory is displayed by changing the x-axis to be the real waveform. The output trajectory is a scaled and rotated version of the input trajectory. The scaling factor is evident in the time domain waveforms but the trajectories also make the phase shift obvious. The transmitter introduces about 45 degrees of phase shift.</p>

<p><strong>Figure 2-26
<a id="pgfId-1040593"></a><a id="82510"></a>Baseband Input and Output Trajectories</strong></p>
<p>
<a id="pgfId-1040598"></a></p>
<div class="webflare-div-image">
<img width="667" height="231" src="images/chap2-108.gif" /></div>

<p>
<a id="pgfId-1040599"></a>ACPR estimation requires power spectral densities. Use the <em>spectrum</em> button on the ENVLP Results form to estimate the power spectral density of a baseband signal. The baseband signal is the time-varying fundamental Fourier component described above. Figure <a href="chap2.html#26538">2-27</a> compares input and output power spectral densities. Because the input and output power spectral densities have the same shape, you can tell that this example shows very little spectral regrowth</p>

<p><strong>Figure 2-27
<a id="pgfId-1040604"></a><a id="26538"></a>Power Spectral Densities of the Input and Output RF Signals</strong></p>
<p>
<a id="pgfId-1040610"></a></p>
<div class="webflare-div-image">
<img width="667" height="420" src="images/chap2-109.gif" /></div>

<p>
<a id="pgfId-1040614"></a>The power spectral densities shown in Figure <a href="chap2.html#26538">2-27</a> were created with the following option values.</p>

<p>
<a id="pgfId-1040648"></a></p>
<table class="webflareTable" id="#id1045087">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045089"></a><em>From</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045091"></a>0 s</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045093"></a><em>To</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045095"></a>300 us</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045097"></a><em>Nyquist half-bandwidth</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045099"></a>3 MHz</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045101"></a><em>Frequency bin width</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045103"></a>10 KHz</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045105"></a><em>Max. plotting frequency</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045107"></a>3 MHz</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045109"></a><em>Min plotting frequency</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045111"></a>-3 MhZ</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045113"></a><em>Window</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045115"></a>Hanning</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045117"></a><em>Detrending</em></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1045119"></a>None</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1040649"></a>The baseband signal driving the transmitter dominates the transmitted PSD. In most cases, the baseband signals come from digital filters and the digital filters constrain the spectrum of the input baseband signal. Distortion in the transmitter causes the spectrum to grow where it should not, hence the need for an ACPR measurement. In measuring ACPR it is crucial to drive the transmitter with the proper baseband signals.</p>
<p>
<a id="pgfId-1045129"></a>It is not practical to model digital filters in Spectre RF because Spectre RF cannot simulate state variables inside Verilog-A modules. Consequently, for now, you must pre-compute and store the baseband inputs and read them into the Spectre RF analysis through the <code>ppwlf</code> sources found in the <em>analogLib</em>, as shown in this example. The <code>ppwlf</code> sources also read SPW format, so you can also generate and record the input baseband waveforms using SPW.</p>
<p>
<a id="pgfId-1040652"></a>The <em>rfLib</em> contains three sets of stored baseband waveforms, <code>cdma</code>, <code>dqpsk</code>, and <code>gsm</code>. These waveforms were created with the baseband signal generators in the <em>measurement</em> category of the <em>rfLib</em>.</p>
<p>
<a id="pgfId-1040653"></a>If you want to measure ACPR with the noise floor much more than 40dB below the peak of the output power spectral density, you need to create baseband drive signals with a noise floor at or below the required noise floor. If you use a DSP tool like SPW to create the signals, the filters in the baseband signal generator have to operate perhaps hundreds of times faster than those in the actual generator. Otherwise the signals do not have enough resolution. The noise floor depends heavily on interpolation error. You can strobe the harmonic time results to eliminate interpolation of the output but you can not eliminate interpolation of the baseband drive signals. The only way to reduce interpolation errors at the input is to use ultra-high resolution drive signals so that no matter where the interpolation occurs, the error is small. It is up to the user to generate ultra-high resolution drive signals.</p>
<p>
<a id="pgfId-1040654"></a>The Fourier analysis used to compute the power spectral density uses evenly spaced time points. If data does not exist at one of the Fourier time points, the Fourier algorithm must interpolate to create it.</p>
<p>
<a id="pgfId-1043142"></a>The Spectre RF workshop includes this example. To see how to setup envelope analysis for this case or to get further information, see the workshop.</p>

<h4>
<a id="pgfId-1040655"></a>Validation</h4>

<p>
<a id="pgfId-1040656"></a>A practical transmitter circuit [6] was simulated using the ENVLP analysis. The circuit has 185 MOSFETs, 79 nodes and 127 equations. It is driven by a 1.7475 GHz carrier and GSM baseband signals. The transient behavior was simulated for 2.5 ms, or roughly 4.5 million carrier cycles. It would take traditional transient analysis 154 days to simulate on an UltraSparc 10 with a 299 MHz CPU and generate 10 GB of data. In contrast, it took the ENVLP analysis 17.5 hours to finish in the same computing environment and it generated 1.2 MB of data. More importantly, the ACPR calculation from the ENVLP analysis results matched very well with measured data as shown in Figure <a href="chap2.html#99679">2-28</a>. The two results diverge past about 400 KHz but that is irrelevant to ACPR in this case because GSM channels are only 200 KHz wide.</p>

<p><strong>Figure 2-28
<a id="pgfId-1040661"></a><a id="99679"></a>ACPR Simulation Results</strong></p>
<p>
<a id="pgfId-1040665"></a></p>
<div class="webflare-div-image">
<img width="574" height="254" src="images/chap2-110.gif" /></div>
<h3>
<a id="pgfId-1040667"></a><a id="99821"></a>Autonomous ENVLP <a id="AutoENVLP"></a>Analysis</h3>

<p>
<a id="pgfId-1040668"></a>RF circuits used in communication systems make great demands on the accuracy and efficiency of simulators. This is especially true when a strongly nonlinear circuit operates at high-frequency oscillating modes and contains slowly time-varying driving sources.</p>
<p>
<a id="pgfId-1043153"></a>Circuits exhibiting these characteristics include</p>
<ul><li>
<a id="pgfId-1040669"></a>A PLL with time-varying reference</li><li>
<a id="pgfId-1040670"></a>An RF mixer with a local oscillator</li><li>
<a id="pgfId-1040671"></a>An AGC plus VCO</li><li>
<a id="pgfId-1040672"></a>An oscillator followed by a power amplifier (PA)</li></ul>



<p>
<a id="pgfId-1040673"></a>Usually, the dynamics of these circuits involve multiple time scales and frequency-modulated (FM) signals. In these circuits, the fast time-scale oscillating frequency is modulated by slow time-scale signals.</p>
<p>
<a id="pgfId-1040674"></a>Because transient analysis is very expensive for circuits with multi-rate dynamics, Cadence uses various envelope technologies to speed up the simulation. Traditional TD ENVLP analysis is efficient for non-autonomous circuits with AM, PM, FM or mixed modulated signals. However, in the FM case, if the modulation index is large, the signal spectrum contains Bessel functions that are distributed in a wide frequency range. Standard ENVLP analysis does not handle this situation accurately and efficiently. Furthermore, ENVLP analysis requires a fixed frequency so it cannot handle the unknown frequencies of oscillator circuits. On the other hand, periodic steady-state analyses, such as HB PSS, can be used to simulate oscillator circuits but they do not allow any time-varying sources in the circuit.</p>
<p>
<a id="pgfId-1040675"></a>The autonomous ENVLP analysis combines ENVLP analysis and autonomous steady-state PSS analysis. In this form of analysis, the oscillator problem is solved for each slow-varying time step. Then, the slow-varying characteristics of the circuit (including instantaneous oscillating frequencies and other envelope information) is obtained by integrating occasional cycles.</p>

<h4>
<a id="pgfId-1040678"></a>A Faster Steady State Oscillator Analysis</h4>

<p>
<a id="pgfId-1040679"></a>In the steady state (PSS) oscillator analysis, the initial values specified for oscillating frequency and other conditions are important for Newton convergence. To estimate the value of the stabilized frequency, a transient analysis can be performed before the steady state oscillator analysis. In some oscillator circuits, such as high Q circuits, it takes a long time for the oscillation to build up and stabilize. In this case, autonomous envelope can be used to speed up the analysis.</p>

<p><strong>Figure 2-29
<a id="pgfId-1040681"></a><a id="54941"></a>The rfOsc Oscillator Schematic</strong></p>
<p>
<a id="pgfId-1040685"></a></p>
<div class="webflare-div-image">
<img src="images/247_rfOscOscillatorSchematic.gif" /></div>

<p>
<a id="pgfId-1040689"></a>For the <code>rfOsc</code> example shown in Figure <a href="chap2.html#54941">2-29</a>, the oscillator takes about 1.5 microseconds to start up and 3.5 microseconds to stabilize. The results are shown in Figure <a href="chap2.html#97099">2-30</a>.</p>
<p>
<a id="pgfId-1040693"></a>Use the following analysis commands to speed up the PSS analysis.</p>
<ol><li>
<a id="pgfId-1040694"></a>Do enough microseconds of autonomous ENVLP analysis to ensure the oscillation is stable and write the solution into the <code>env</code>.<code>dat</code> file.</li><li>
<a id="pgfId-1040695"></a>Do an autonomous PSS analysis that skips the DC analysis and reads the initial condition from the <code>env</code>.<code>dat</code> file.</li><li>
<a id="pgfId-1040696"></a>Do a Pnoise analysis and calculate the phase noise for the oscillator.</li></ol>


<p>
<a id="pgfId-1040700"></a>Example <a href="chap2.html#65439">2-1</a> illustrates the three analysis statements.</p>

<p><strong>Example 2-1
<a id="pgfId-1048886"></a><a id="65439"></a>Analysis Commands for a Faster PSS Analysis</strong></p>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1048891"></a>envlp (Out 0) envlp harms=3 stop=20u maxstep=100p envmaxstep=100n flexbalance=1<br />+ tstab=2u fund=400M method=traponly envmethod=traponly errpreset=moderate<br />+ annotate=status writefinal=&quot;env.dat&quot;</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1048855"></a>pss  (  Out 0 )  pss  fund=410M  harms=10 skipdc=yes readic=&quot;env.dat&quot;<br />+ annotate=status&#160;&#160;tstabenvlp=no</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1048857"></a>pnoise  (  Out  )  pnoise  sweeptype=relative relharmnum=1 start=1K stop=300M<br />+ dec=5 maxsideband=10&#160;&#160;annotate=status</pre>

<p>
<a id="pgfId-1045256"></a>To run autonomous ENVLP analysis efficiently</p>
<ul><li>
<a id="pgfId-1045257"></a>To use HB Envelope, <code>flexbalance</code> must be set to yes. Otherwise, TD Envelope is used. If <code>flexbalance</code> is <code>yes</code>, <code>harms</code> is the maxharms of the clock fundamental and the default value is 3. The <code>harms</code> is an output parameter for TD but it is an input parameter for HB. Consequently, <code>harms</code> has a significant impact on the performance.</li><li>
<a id="pgfId-1045258"></a>A reference port, for example, (<code>Out 0</code>), must be specified to indicate <code>autonomous</code>. This is similar to autonomous PSS. The reference port is used for two purposes:<ul><li>
<a id="pgfId-1045259"></a>Estimating the initial fundamental frequency and calculating instantaneous frequencies at each envelope time step.</li><li>
<a id="pgfId-1045260"></a>Checking the <code>phase=0</code> condition for the port when doing shooting or HB Newton iterations.</li></ul><br />
<a id="pgfId-1045261"></a>The reference port for ENVLP and the reference port for PSS can be different. For a better estimate of the period, select one of the output ports of an oscillator whose output waveform is close to sinusoidal.</li><li>
<a id="pgfId-1045262"></a>In a non-autonomous envelope analysis (but not in an autonomous analysis), the <code>clockname</code> must be specified. However, in an autonomous envelope analysis, the fund or period option must be specified as an initial guess of the fundamental frequency.</li><li>
<a id="pgfId-1045263"></a>Usually, you must set a <code>tstab</code> value. The default value of <code>tstab</code> for an autonomous envelope analysis is 4 cycles of the fundamental, which might not be enough to ensure convergence. During an HB Envelope analysis, especially for high-Q designs, enough <code>tstab</code> is needed to ensure that the oscillation starts.</li><li>
<a id="pgfId-1045264"></a>Sometimes tightening the <code>reltol</code> parameters for the HB autonomous envelope analysis can make the result more accurate at the calculated cycle, which might improve the prediction and allow more cycles to be skipped. However, do not set <code>reltol</code> tighter than 1e-6 because that decreases the performance dramatically.</li></ul>









<p>
<a id="pgfId-1045265"></a>The oscillating frequency is 410 MHz, which corresponds to the period 2.44 nanoseconds. Figure <a href="chap2.html#97099">2-30</a> shows that there are about 0.1 microseconds between two occasional ENVLP analysis cycles. This implies that about 40 cycles were skipped for each ENVLP analysis step.</p>

<p><strong>Figure 2-30
<a id="pgfId-1040724"></a><a id="97099"></a>Autonomous ENVLP Analysis Results over 20 Microseconds</strong></p>
<p>
<a id="pgfId-1040728"></a></p>
<div class="webflare-div-image">
<img src="images/249_envlp.gif" /></div>
<p><strong>Figure 2-31
<a id="pgfId-1048834"></a>Transient Analysis Results over 20 Microseconds</strong></p>
<p>
<a id="pgfId-1048838"></a></p>
<div class="webflare-div-image">
<img src="images/249_tran.gif" /></div>

<p>
<a id="pgfId-1040729"></a>After the autonomous ENVLP analysis, you can plot the time-varying instantaneous frequency. For example, applying a 1 MHz sinusoidal source on the control voltage of a 3.46 GHz VCO circuit and then displaying the instantaneous frequency produces the plot shown in Figure <a href="chap2.html#66270">2-32</a>. The ripple on the curve indicates that the VCO frequency follows the 1 MHz modulation signal. This circuit cannot be analyzed using either autonomous PSS or non-autonomous ENVLP analysis. The transient analysis can be used but it is very time consuming as discussed in the previous example.</p>

<p><strong>Figure 2-32
<a id="pgfId-1040734"></a><a id="66270"></a>Instantaneous Frequency of VCO with Sinusoidal Control Voltage</strong></p>
<p>
<a id="pgfId-1040738"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig23.gif" /></div>
<h4>
<a id="pgfId-1040739"></a>Simulating a Mixer with a VCO</h4>

<p>
<a id="pgfId-1040740"></a>This example simulates a mixer with two inputs</p>
<ul><li>
<a id="pgfId-1040741"></a>Baseband data</li><li>
<a id="pgfId-1040742"></a>Output from the VCO circuit (LO)</li></ul>

<p>
<a id="pgfId-1040743"></a>The results show that the VCO frequency is affected by the baseband data signal.</p>
<p>
<a id="pgfId-1047852"></a>Figure <a href="chap2.html#33374">2-33</a> is the circuit schematic for the example. The details of the VCO are not shown in the schematic. Figure <a href="chap2.html#71196">2-34</a> and Figure <a href="chap2.html#72564">2-35</a> show the modulation effects to oscillating frequency from a sinusoidal and a digital data input of port <code>Prf</code><em> </em>respectively.</p>

<p><strong>Figure 2-33
<a id="pgfId-1047860"></a><a id="33374"></a>Schematic of Mixer with VCO</strong></p>
<p>
<a id="pgfId-1040759"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig24.gif" /></div>
<p><strong>Figure 2-34
<a id="pgfId-1040762"></a><a id="71196"></a>Results with Sinusoidal Data at Prf</strong></p>
<p>
<a id="pgfId-1040766"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig25.gif" /></div>
<p><strong>Figure 2-35
<a id="pgfId-1040768"></a><a id="72564"></a>Results with Digital Data at Prf</strong></p>
<p>
<a id="pgfId-1040772"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig26.gif" /></div>
<h4>
<a id="pgfId-1040773"></a>Simulating Oscillator-Pulling Effects for a Power Amplifier</h4>

<p>
<a id="pgfId-1040774"></a>In oscillator design, the oscillator-pulling effect is a common problem that can degrade performance. LO pulling is a phenomenon in which the LO frequency is influenced by a strong power amplifier signal when both the power amplifier output and the oscillator are at a high frequency.</p>
<p>
<a id="pgfId-1040778"></a>This example simulates the system whose block diagram is shown in Figure <a href="chap2.html#40612">2-36</a>. The system contains a local oscillator and a mixer followed by two power amplifier stages.</p>

<p><strong>Figure 2-36
<a id="pgfId-1040780"></a><a id="40612"></a>Circuit to Measure the Load Pulling Effect for an Oscillator</strong></p>
<p>
<a id="pgfId-1040784"></a></p>
<div class="webflare-div-image">
<img src="images/EnvlpFig27.gif" /></div>

<p>
<a id="pgfId-1040788"></a>The simulation results are plotted in Figure <a href="chap2.html#33251">2-37</a>. The upper plot is the instantaneous frequency from the VCO output. The lower plot is the baseband data signal. The figure shows that the oscillating frequency is affected by the power amplifier.</p>

<p><strong>Figure 2-37
<a id="pgfId-1040793"></a><a id="33251"></a>Simulation Results Showing Pulling Effect of the Oscillator</strong></p>
<p>
<a id="pgfId-1040799"></a></p>
<div class="webflare-div-image">
<img width="671" height="168" src="images/chap2-119.gif" /></div>
<p>
<a id="pgfId-1040800"></a></p>
<div class="webflare-div-image">
<img width="668" height="172" src="images/chap2-120.gif" /></div>
<h3>
<a id="pgfId-1040802"></a><a id="57192"></a>Simulating Circuits with Driven FM Sources</h3>

<p>
<a id="pgfId-1040803"></a>Another new feature of ENVLP analysis is faster simulation for circuits with driven FM sources.</p>
<p>
<a id="pgfId-1045295"></a>Standard envelope analysis handles FM signals by sampling the signal at equal interval time points. The period is determined by the carrier frequency. For FM signals with large modulation indexes, standard envelope analysis is</p>
<ul><li>
<a id="pgfId-1045296"></a>Not efficient due to Newton iteration failures. The failures occurs because the polynomial condition is not satisfied. This can be seen in <a href="chap2.html#68947">Figure&#160;2-38</a> and <a href="chap2.html#87208">Figure&#160;2-39</a>. <a href="chap2.html#68947">Figure 2-38&#160;</a> indicates that standard envelope analysis is not working at all and the simulator is just doing a transient analysis.</li><li>
<a id="pgfId-1045306"></a>Not accurate for computing the harmonic coefficients, which have been defined as the envelopes of the signal, because the real instantaneous frequency is different from the frequency used to do the Fourier transform. This can be seen by examining the output results of post-processing in <a href="chap2.html#74526">Figure&#160;2-40</a> and <a href="chap2.html#97076">Figure&#160;2-41</a>, which display the derivative of phase for the first harmonic for the two methods respectively.<br /><strong class="webflare-fig-line-height">Figure 2-38
<a id="pgfId-1040815"></a><a id="68947"></a>Standard ENVLP Analysis for an FM Signal</strong>
<a id="pgfId-1040819"></a><div class="webflare-div-image">
<img width="674" height="166" src="images/chap2-121.gif" /></div><strong>Figure 2-39
<a id="pgfId-1040825"></a><a id="87208"></a>Faster ENVLP Analysis for an FM Signal</strong>
<a id="pgfId-1040829"></a><div class="webflare-div-image">
<img width="668" height="166" src="images/chap2-122.gif" /></div><strong>Figure 2-40
<a id="pgfId-1040838"></a><a id="74526"></a>Frequency Profile Output From the Standard Method</strong>
<a id="pgfId-1040842"></a><div class="webflare-div-image">
<img width="667" height="151" src="images/chap2-123.gif" /></div><strong>Figure 2-41
<a id="pgfId-1040845"></a><a id="97076"></a>Frequency Profile Output From Fast ENVLP Analysis for FM Sources</strong>
<a id="pgfId-1040849"></a><div class="webflare-div-image">
<img width="667" height="156" src="images/chap2-124.gif" /></div></li></ul>















<p>
<a id="pgfId-1040850"></a>To use the fast ENVLP analysis, you must represent the FM driven sources with Spectre internal source models such as the <code>port</code>, <code>vsource</code>, and <code>isource</code> components. Then, set the ENVLP analysis option <code>fmspeedup=yes</code>.</p>

<h4>
<a id="pgfId-1040851"></a>Arbitrary Frequency Modulated Sinusoidal Sources</h4>

<p>
<a id="pgfId-1040852"></a>FM sinusoidal sources can be specified in three different ways using <code>vsource</code>, <code>isource</code>, or <code>port</code>.</p>
<ul><li>
<a id="pgfId-1040853"></a>Specify modulated frequency (sinusoidal modulation)<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1040854">
<a id="pgfId-1040854"></a>V1 (1 2) vsource type=sine freq=ω<sub>0</sub> fmmodindex=k fmmodfreq=ω</pre>
<a id="pgfId-1040855"></a>For this case, write the FM signal from the source as</li></ul>



<p class="webflare-indent1">
<a id="pgfId-1040859"></a><img width="228" height="44" src="images/chap2-125.gif" /></p>

<ul><li>
<a id="pgfId-1040860"></a>Specify one file name, where the file contains the FM data<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1040861">
<a id="pgfId-1040861"></a>V1 (1 2) vsource type=sine freq=ω<sub>0</sub> fmmodindex=k fmmodfiles=[&#8220;f_data&#8221;]</pre>
<a id="pgfId-1040862"></a>For this case, write the FM signal from the source as</li></ul>



<p class="webflare-indent1">
<a id="pgfId-1040866"></a><img width="258" height="55" src="images/chap2-126.gif" /></p>
<p class="webflare-indent1">
<a id="pgfId-1040867"></a>where δω(τ) is the frequency modulation data from the <code>f_data</code> file.</p>

<ul><li>
<a id="pgfId-1043167"></a>Specify the names of two files that contain I and Q data for modulation. For example,<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1040869">
<a id="pgfId-1040869"></a>V1 (1 2) vsource type=sine freq=ω<sub>0</sub> fmmodindex=k fmmodfreq=[&#8220;I&#8221; &#8220;Q&#8221;]</pre>
<a id="pgfId-1040870"></a>For this case, write the FM signal from the source as</li></ul>



<p class="webflare-indent1">
<a id="pgfId-1040874"></a><img width="225" height="39" src="images/chap2-127.gif" /></p>
<p class="webflare-indent1">
<a id="pgfId-1040875"></a>Here, <em>k</em> is the modulation index</p>
<p class="webflare-indent1">
<a id="pgfId-1040879"></a><img width="213" height="46" src="images/chap2-128.gif" /></p>
<p class="webflare-indent1">
<a id="pgfId-1040883"></a><img width="183" height="57" src="images/chap2-129.gif" /></p>
<p class="webflare-indent1">
<a id="pgfId-1040884"></a>Where <em>I(t)</em> and <em>Q(t) </em>are the data from the <code>I</code> and <code>Q</code> files, respectively.</p>

<p>
<a id="pgfId-1040885"></a>The file format for the <code>I</code> and <code>Q</code> files is the same as the PWL file format. The keywords related to PWL files (such as <code>pwldbm</code> and <code>pwlperiod</code>) also work for FM files in this case.</p>

<h4>
<a id="pgfId-1040886"></a>Running a Fast FM ENVLP Analysis</h4>

<p>
<a id="pgfId-1040887"></a>To speed up the FM ENVLP analysis, set the <code>fmspeedup=yes</code> option in the ENVLP analysis command. The default value of <code>fmspeedup</code>=<code>no</code>. Also set <strong>clockname</strong> to be the same as the <strong>fundname</strong> of the FM source.</p>
<p>
<a id="pgfId-1040888"></a>Notice that the fast FM ENVLP analysis has the following limitations.</p>
<ul><li>
<a id="pgfId-1040889"></a>The algorithm that speeds up the ENVLP solver only works with FM sources</li><li>
<a id="pgfId-1040890"></a>Frequency modulation can be applied only to sinusoidal sources (<code>type=sine</code>)</li></ul>

<p>
<a id="pgfId-1040894"></a>The following schematic, shown in Figure <a href="chap2.html#36235">2-42</a>, is a circuit that includes an FM source followed by a PA, an LNA, and several other receiver components that perform demodulation.</p>

<p><strong>Figure 2-42
<a id="pgfId-1040896"></a><a id="36235"></a>The Circuit with an FM Source</strong></p>
<p>
<a id="pgfId-1040900"></a></p>
<div class="webflare-div-image">
<img width="652" height="193" src="images/chap2-130.gif" /></div>

<p>
<a id="pgfId-1040901"></a>The FM source <em>
V</em>
<sub>1</sub> is defined as follows</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1040902"></a>V1 (net22 0) vsource type=sine ampl=180.00m freq=2.442G \</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1040903"></a>fmmodindex=24420000 fundname=&quot;f_carrier&quot; fmmodfiles=[ &quot;f_data&quot; ]</pre>

<p>
<a id="pgfId-1040904"></a>With <code>fmspeedup=0</code>, ENVLP analysis runs for 140 s for this case. The result at <code>net22</code> is shown in Figure <a href="chap2.html#78142">2-43</a>. With <code>fmspeedup</code>=1,ENVLP analysis runs for 27.8 s. The result at <code>net22</code> is shown in Figure <a href="chap2.html#50650">2-44</a>.</p>

<p><strong>Figure 2-43
<a id="pgfId-1040912"></a><a id="78142"></a>Output at net22 From Standard ENVLP Analysis</strong></p>
<p>
<a id="pgfId-1040919"></a></p>
<div class="webflare-div-image">
<img width="666" height="154" src="images/chap2-131.gif" /></div>

<p>
<a id="pgfId-1040920"></a>Because the clock frequency is adjusted while <code>fmspeedup=1</code>, the phase of each clock cycle is constant. Hence, a straight trace line is shown in Figure <a href="chap2.html#50650">2-44</a>. However, with <code>fmspeedup=0</code>, the phase of each clock cycle is changing, which is shown in Figure <a href="chap2.html#78142">2-43</a>.</p>

<p><strong>Figure 2-44
<a id="pgfId-1040928"></a><a id="50650"></a>Output at net22 From ENVLP Analysis with fmspeedup=1</strong></p>
<p>
<a id="pgfId-1040932"></a></p>
<div class="webflare-div-image">
<img width="665" height="149" src="images/chap2-132.gif" /></div>
<h3>
<a id="pgfId-1040934"></a><a id="28273"></a>Frequently Asked Questions</h3>
<h4>
<a id="pgfId-1040935"></a>Is ENVLP analysis as fast as transient analysis?</h4>

<p>
<a id="pgfId-1040936"></a>For circuits without hidden states, (which are usually introduced by Verilog-A modules), the answer is yes. Because a Newton method similar to that of PSS is used in Envelope analysis, circuits with hidden state cause difficulties, just as they do for PSS. However, most hidden states can be overcome [10].</p>

<h4>
<a id="pgfId-1040937"></a>How do I choose which ENVLP analysis to use?</h4>

<p>
<a id="pgfId-1045361"></a>The HB method is very efficient when simulating weakly nonlinear circuits because only a few harmonics are needed to represent the solution accurately. For highly nonlinear circuits with sharply raising or falling signals, time domain shooting is more suitable. However, when exploring design trade-offs using a few harmonics where accuracy is not of primary concerns, HB envelope might be the best choice.</p>

<h4>
<a id="pgfId-1040943"></a>How should I choose the number of harmonics for HB ENVLP analysis?</h4>

<p>
<a id="pgfId-1040944"></a>The default value is 3. The best value to use depends on the linearity in one cycle of the fast signal (LO or clock). For linear cases, a value of 1 is enough for accurate results. However, for nonlinear cases, such as a circuit with a square clock, even a value of 15 might not be large enough.</p>

<h3>
<a id="pgfId-1045370"></a>For what kind of circuits is multi-carrier HB Envelope suited?</h3>

<p>
<a id="pgfId-1045371"></a>As its name suggests, multi-carrier HB envelope analysis is designed for circuits with multi-carrier signals. For example, in a modulation system with a 1G LO and 10M IF where IF is a modulated signal, both LO and IF can be looked on as carriers, so multi-carrier HB Envelope is useful.</p>

<h3>
<a id="pgfId-1045372"></a>Does multi-carrier HB Envelope support the function FM speed up?</h3>

<p>
<a id="pgfId-1045373"></a>No, it does not.</p>

<h3>
<a id="pgfId-1045374"></a>Does multi-carrier HB Envelope handle autonomous circuits?</h3>

<p>
<a id="pgfId-1045375"></a>No, it does not. Multi-carrier HB Envelope uses the multi-tone HB engine, which does not handle autonomous circuits.</p>

<h3>
<a id="pgfId-1040946"></a><a id="24628"></a>References</h3>
<p>
<a id="pgfId-1040988"></a></p>
<table class="webflareTable" id="#id1040947">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040949"></a>[1]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040951"></a>R. Telichevesky, K. Kundert and J. White. &#8220;Efficient steady-state analysis based on matrix-free Krylov-subspace methods&#8221;. Proceedings of the 32nd Design Automation Conference, June 1995.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040953"></a>[2] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040955"></a>D. Feng, J. Phillips, K. Nabors, K. Kundert and J. White, &#8220;Efficient computation of quasi-periodic circuit operating conditions via a mixed frequency/time approach&#8221;. Proceedings of the 36th Design Automation Conference, June 1999. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040957"></a>[3] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040959"></a>L. Petzold, &#8220;An efficient numerical method for highly oscillatory ordinary differential equations&#8221;. SIAM Journal of Numerical Analysis, vol. 18, no. 3, pp 455-479, June 1981.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040961"></a>[4] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040963"></a>K. Kundert, J. White and A. Sangiovanni-Vincentelli. &#8220;An envelope-following method for the efficient transient simulation of switching power and filter circuits&#8221;. IEEE International Conference on Computer-Aided Design: Digest of Technical Papers, November 1988.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040965"></a>[5] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040967"></a>J. Chen, D. Feng, J. Phillips, and K. Kundert, &#8220;Simulation and modeling of intermodulation distortion in communications circuits&#8221;. Proceedings of the Custom Integrated Circuit Conference, San Diego, CA, May 1999.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040969"></a>[6] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040971"></a>K. C. Tsai and P. R. Gray, &#8220;A 1.9GHz 1W CMOS class E power amplifier for wireless communications&#8221;, IEEE Journal of Solid State Circuits, pp. 962-970, Jul. 1999.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040973"></a>[7] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040975"></a>Behzad Razavi. <em>RF Microelectronics</em>, Prentice Hall, c1998. Series: Prentice-Hall Communications Engineering &amp; Emerging Technologies Series.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040977"></a>[8] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040979"></a>E. Ngoya, J. Rousset, and D. Argollo. &#8220;Rigorous RF and microwave oscillator phase noise calculation by envelope transient technique&#8221;. In <em>Microwave Symposium Digest</em>, 2000 IEEE MTT-S International, volume 1, pages 91-94 vol.1, 2000.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040981"></a>[9] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040983"></a>O. Narayan and Jaijeet Roychowdhury, <em>Analyzing Oscillators Using Multitime PDEs</em>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040985"></a>[10] </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1040987"></a>Ken Kundert, <em>Hidden State in SpectreRF</em>, 2003.</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1022504"></a></p>



<p>
<a id="pgfId-1047736"></a>lteratio=10.0 for conservative <code>errpreset</code>. Only if user-specified reltol &lt;= 1e-4 * 10.0/3.5, lteratio is set to 3.5.<code></code></p>


<p>
<a id="pgfId-1047791"></a>* : lteratio=10.0 for conservative <code>errpreset</code> by default. Only if user-specified reltol &lt;= 1e-5*10.0/3.5, lteratio is set to 3.5..</p>


<p>
<a id="pgfId-1063334"></a>* : lteratio=10.0 for conservative errpreset by default. However, when the specified reltol</p>
<p>
<a id="pgfId-1047819"></a>&lt;= 1e-5*10.0/3.5, lteratio is set to 3.5..</p>


<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap1.html" id="prev" title="Basic Reference Information">Basic Reference Information</a></em></b><b><em><a href="chap3.html" id="nex" title="Oscillators and Autonomous PSS Analysis">Oscillators and Autonomous PSS ...</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2020, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
</body></html>