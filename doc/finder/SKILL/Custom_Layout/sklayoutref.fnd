;SKILL Language Functions
("leEnvLoad"
"leEnvLoad( 
) 
=> t / nil"
"Loads the Virtuoso Layout Suite L environment variables from the .cdsenv files. This file must be in your home directory. The variables are read into memory, but the windows are not updated with the new values. When new windows are created, they assume the new values.")
("leGetEnv"
"leGetEnv( 
t_name 
) 
=> g_value / nil"
"Returns the value currently assigned to the layout environment properties with the variable t_name.")
("leSetEnv"
"leSetEnv( 
t_name 
g_value 
) 
=> t / nil"
"Sets the layout environment properties with the variable t_name to the value g_value.")
("leIsLayoutViewerAppEnabled"
"leIsLayoutViewerAppEnabled(
w_windowId
) 
=> t / nil"
"Checks whether the layout viewer application is available.")
("leIsLayoutViewerWindow"
"leIsLayoutViewerWindow(
w_windowId
) 
=> t / nil"
"Checks whether the given window has layout viewer application installed on it. ")
("leCreateAutoPin"
"leCreateAutoPin(
d_cellViewId 
l_point 
t_termName
t_termDir
[ l_lpp ]
)
=> d_pinShapeId / nil"
"Creates a pin shape in cellview d_cellViewId. ")
("leCreatePath"
"leCreatePath(
d_cellViewId 
l_layerPurposePair
l_points 
n_width 
[ t_pathStyle ]
[ n_offset ] 
[ t_justification ]
) 
=> d_pathId / nil"
"Creates a path in cellview d_cellViewId on the specified layer with point list l_points and width n_width.")
("leCreatePin"
"leCreatePin(
d_cellViewId 
l_layerPurposePair
t_shape 
l_points 
t_termName 
t_termDir 
l_accessDir
)
=> d_pinShapeId / nil"
"Creates a pin shape in cellview d_cellViewId on the specified layer. ")
("leHiCreateSlot"
"leHiCreateSlot( 
[ w_windowId ] 
) 
=> t / nil"
"Runs the Create Slot command in the specified window. You are prompted to select a rectangle or path to which you want to add slots. Press F3 to open the Create Slot form and specify the settings for creating slots. If w_windowId is not specified, the current window is used.")
("leDefineMPPTemplate"
"leDefineMPPTemplate(
	?techId              d_techId
	?name                S_name
	?layer               list(layerName layerPurpose)
	[ ?width             n_width ]
	[ ?justification     S_justification ]
	[ ?offset            n_offset ]
	[ ?endType           S_endType ]
	[ ?beginExt          n_beginExt ]
	[ ?endExt            n_endExt ]
	[ ?choppable         g_choppable ]

	[ ROD Connectivity Arguments ]
	[ ?offsetSubPath     l_offsetSubpathArgs... ]
	[ ?encSubPath        l_encSubpathArgs... ]
	[ ?subRect           l_subrectArgs... ]

) ; end leDefineMPPTemplate
=> t / nil

	; ROD Connectivity Arguments
	[ ?termIOType             S_termIOType ]
	[ ?pin                     g_pin ]
	[ ?pinAccessDir           tl_pinAccessDir ]
	[ ?pinLabel               g_pinLabel ]
	[ ?pinLabelHeight         n_pinLabelHeight ]
	[ ?pinLabelLayer          txl_pinLabelLayer ]
	[ ?pinLabelFont           S_pinLabelFont ]
	[ ?pinLabelDrafting        g_pinLabelDrafting ]
	[ ?pinLabelOrient         S_pinLabelOrient ]
	[ ?pinLabelOffsetPoint     l_pinLabelOffsetPoint ]
	[ ?pinLabelJust           S_pinLabelJust ]
	[ ?pinLabelRefHandle      S_pinLabelRefHandle ]
	; end of ROD Connectivity Arguments

	;l_offsetSubpathArgs Offset Subpath Arguments
	list(
		list(
			?layer             list(layerName layerPurpose)
			[ ?width           n_width ]
			[ ?sep             n_sep ]
			[ ?justification   S_justification ]
			[ ?beginOffset     n_beginOffset ]
			[ ?endOffset       n_endOffset ]
			[ ?choppable       g_choppable ]
			[ Repeat ROD Connectivity Arguments here ]
			) ;End of first offset subpath list
			...		
		) ;End of offset subpath lists
	;End of l_offsetSubpathArgs

	;l_encSubpathArgs Enclosure Subpath Arguments
	list(
		list(
			?layer             list(layerName layerPurpose)
			[ ?enclosure       n_enclosure ]
			[ ?beginOffset     n_beginOffset ]
			[ ?endOffset       n_endOffset ]
			[ ?choppable       g_choppable ]	
			[ Repeat ROD Connectivity Arguments here ]
			) ;End of first enclosure subpath list
			...		
		) ;End of enclosure subpath lists
	;End of l_encSubpathArgs

	;l_subrectArgs Subrectangle Arguments
	list(
		list(
			?layer              list(layerName layerPurpose)
			[ ?width            n_width ]
			[ ?length           n_length ]
			[ ?gap              S_gap ]
			[ ?sep              n_sep ]
			[ ?justification    S_justification ]
			[ ?beginOffset      n_beginOffset ]
			[ ?endOffset        n_endOffset ]
			[ ?beginSegOffset   n_beginSegmentOffset
			[ ?endSegOffset     n_endSegmentOffset
			[ ?space            n_space ]
			[ ?choppable        g_choppable ]
			[ Repeat ROD Connectivity Arguments here ]
			[?diagonal g_diagonalSubRect]
			) ;End of first subrectangle list
			...		
		) ;End of subrectangle lists
	;End of l_subrectArgs"
"The syntax of this function provides the structure for defining the field names and default values for one multipart path (MPP) in an ASCII file. This information is referred to as an MPP template. A multipart path is a single relative object design (ROD) object consisting of one or more parts at level zero in the hierarchy on the same or on different layers. The purpose of an MPP template is to create MPPs in layout cellviews using predefined values. You can define any number of MPP templates in a single ASCII file by specifying leDefineMPPTemplate once for each MPP template; each template must be identified by a template name (t_name) that is unique within the ASCII file. ")
("lePlot"
"lePlot(
[ t_fileName ]
)
=> t / nil"
"Procedural plot submission command that generates the plot defined in the t_fileName plot template file. Plot options are stored in a disembodied property list called lePlotOptions. When lePlot() loads the plot template file, it reads the plot options from the lePlotOptions property list. There are two ways to create the plot template file: use vi, or save the options in the Submit Plot form to a file. The plot template file is used by lePlot() and by the Load command in the Submit Plot form. However, the following options are ignored by the Load command: library, cell, view, and plotSize.")
("leAlign"
"leAlign(
t_alignment
)
=> t / nil"
"Aligns the objects in the selection set. The objects are aligned to the left, right, top, or bottom edge of the selection box or along the centre of the selection box in the vertical or horizontal direction.")
("leAttachFig"
"leAttachFig( 
d_figId1 
[ d_figId2 ]
) 
=> t / nil"
"Attaches d_figId1 to d_figId2 by making d_figId1 a child of d_figId2. If d_figId1 is already attached to another object, it is detached from it. If d_figId2 is not specified, d_figId1 is detached from any object it is currently attached to without attaching it to anything else.")
("leChopShape"
"leChopShape(
d_shapeId 
l_points 
g_closed 
[ g_remove ] 
[ x_sides ]
) 
=> l_newShapes / nil"
"Cuts the shape d_shapeId using the chop shape l_points. ")
("leComputeAreaDensity"
"leComputeAreaDensity(
w_windowId
l_lppSpec
[ ?depth x_depth ]
[ ?region l_region ]
) 
=> l_result / nil"
"Computes the total area and the density of shapes with specified layers within a region. If part of the shape is inside the region, only the area of the part that is inside the region is calculated.")
("leConvertIBToDSIB"
"leConvertIBToDSIB(
) 
=> t / nil"
"(IC6.1.8 Only) Converts an info balloon to a sticky info balloon. The balloon remains attached to the object until deleted explicitly or the session is closed. By default, the function is registered to the bindkey.")
("leConvertInstToMosaic"
"leConvertInstToMosaic(
d_instId | ld_instId
[ mode { t | nil } ]
) 
=> ld_mosaicId / nil"
"Converts one or more selected instances into one or more mosaics. ")
("leConvertMosaicToModgen"
"leConvertMosaicToModgen(
d_mosaicId | ld_mosaicId
) 
=> d_modgenId | ld_modgenId / nil"
"Converts one or more selected mosaics into one or more modgens.")
("leConvertPolygonToPath"
"leConvertPolygonToPath(
d_polygonId 
) 
=> d_pathId / nil"
"Converts the polygon d_polygonId to a path. If the conversion is successful, the polygon is replaced by a path with the same boundary as the polygon.")
("leConvertSelectedDynamicShapes"
"leConvertSelectedDynamicShapes( 
d_cellViewId 
) 
=> t / nil"
"(ICADVM20.1 Virtuoso RF Solution Only) Converts the selected dynamic shapes to static shapes.")
("leConvertShapeToPathSeg"
"leConvertShapeToPathSeg(
d_shapeId 
) 
=> l_newShapes / nil"
"Converts shape d_shapeId to an equivalent pathSeg.")
("leConvertShapeToPolygon"
"leConvertShapeToPolygon(
d_shapeId 
[ x_sides ]
) 
=> d_polygonId / nil"
"Converts shape d_shapeId to an equivalent polygon. If it is a conic, the polygon has the specified number of sides.")
("leCopyTemplatesToCellView"
"leCopyTemplatesToCellView( 
d_cellViewId 
) 
=> t / nil"
"(ICADVM20.1 Only) Copies the row region templates and WSPDefs from the source cellview specified with the environment variable autoCopyTemplateCellViewList to the cellview specified in this function. If the cellview has existing templates, the new templates from the source cellview are not copied.")
("leCreateLayerField"
"leCreateLayerField(
s_name
?callback t_callback
?appendChoices l_appendChoices
?prependChoices l_prependChoices
?maxVisibleItems x_maxVisibleItems
?syncedPaletteWindow w_syncedPaletteWindow
?techFileId d_techFileId
?value t_value
?enabled g_enabled
?invisible g_invisible
?layerFunction t_layerFunction
?maxWidth x_maxWidth
) 
=> t_layerfield"
"Creates a cyclic field for to display layer-purpose pair (LPP) names with swatches. The combo box created allows you to type and search for a layer purpose pair within the list of values.")
("leCreateNetField"
"leCreateNetField 
name
?value t_value
?callback t_callback
x_maxVisibleItems
) 
=> netfield"
"Creates cyclic field for showing net names of the current cellview. The combo box created allows you to type in and search for the net names within the list of values.")
("leCycleSnapModes"
"leCycleSnapModes(
) 
=> t"
"Changes both the edit and create snap modes, in the order of diagonal, anyAngle, and orthogonal. If the edit and create mode values are different (unsynchronized), the first value for Create/Edit snap mode will be diagonal.")
("leDecrementStopLevelByOne"
"leDecrementStopLevelByOne(
w_windowId 
[ t_useCellViewMaxDepth ]
) 
=> t / nil"
"Decrements the stop level value of the specified window by one when it is greater than zero.")
("leDefineExternalPins"
"leDefineExternalPins(
)
=> t / nil"
"Starts the Define External Pins enter function in the current window. The Define External Pins enter function provides a user interface for defining one or more pins on a net as being externally connected outside of a device.")
("leDefineInternalPins"
"leDefineInternalPins(
)
=> t / nil"
"Starts the Define Internal Pins enter function in the current window. The Define Internal Pins enter function provides a user interface for defining one or more pins on a net as being internally connected within a device.")
("leDefinePPPins"
"leDefinePPPins(
[ w_windowId ]
) 
=> t / nil"
"Starts the Define Pseudo Parallel Connected Net enter function in the current window. Corresponds to the Connectivity - Pins - Pseudo Parallel Connect command. The Define Pseudo Parallel Connected Net form provides a user interface for defining one or more pins on a net as being pseudo parallel connected. If you do not specify w_windowId, the Virtuoso Layout Suite L uses the current window.")
("leDefineWeaklyConnectedPins"
"leDefineWeaklyConnectedPins(
)
=> t / nil"
"Starts the Define Weak Pins enter function in the current window. The Define Weak Pins enter function provides a user interface for defining one or more pins on a net as being weakly connected within a device.")
("leEnableInstPropEditFields"
"leEnableInstPropEditFields( 
t_libName
[ ?libField g_libField ]
[ ?cellField g_cellField ]
=> t / nil"
"Enables or disables the Library or Cell fields for an instance in the Property Editor form.")
("leHiAreaDensity"
"leHiAreaDensity( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Area and Density Calculator form in the specified window. This form lets you compute area and density of shapes. You can choose options to specify region, LPP, and hierarchical depth for the shapes to be considered for area and density calculations. If w_windowId is not specified, the current window is used.")
("leHiAssignNet"
"leHiAssignNet(
[ w_windowId ]
) 
=> t / nil"
"Assigns new and existing nets to shapes, instance pins, vias and pathSegs.")
("leHiConvertMosaicToInst"
"leHiConvertMosaicToInst(
[ w_windowId ]
) 
=> t / nil"
"Converts mosaics to instances.")
("leHiConvertMosaicToModgen"
"leHiConvertMosaicToModgen(
[ w_windowId ]
) 
=> t / nil"
"Converts one or more selected mosaics to an equivalent number of modgens. If w_windowId is not specified, the current window is used. You are prompted to select one or more mosaics to convert into modgens.")
("leHiEditSlot"
"leHiEditSlot( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Edit Slot form in the specified window. You are prompted to select a rectangle or path containing slots, the settings of which are used to populate the Edit Slot form. If w_windowId is not specified, the current window is used.")
("leHiUnassignNet"
"leHiAssignNet(
[ w_windowId ]
) 
=> t / nil"
"Unassigns nets to shapes, instance pins, and routed objects like vias and pathSegs.")
("leFlattenInst"
"leFlattenInst(
d_instId 
x_levels 
[ g_flattenPCells ]
[ g_preservePins ]
[ g_preserveRODobjs ]
[ g_delDetachedBlockages ]
[ g_preservePinFigs ]
[ g_flattenVias ]
[ g_preserveTermName ]
[ t_excludePcellListFileName ]
) 
=> t / nil"
"Flattens instance d_instId up through x_levels of hierarchy. The optional arguments are positional: you must specify nil for optional arguments prior to an optional argument you want to specify. For example, if you do not want to specify g_flattenPCells, but want to set g_preservePins to t, you need to specify both (nil t). ")
("leFreezeInst"
"leFreezeInst(
d_instId 
t_libName
t_cellName
t_viewName
[ g_overwrite ]
) 
=> t / nil"
"Converts the Pcell instance d_instId to a non-Pcell instance of a new master created on the disk as specified by t_libName, t_cellName, and t_viewName. If the master already exists, it is overwritten. ")
("leIOZoomToFigGroupTopLevelContext"
"leIOZoomToFigGroupTopLevelContext(
) 
=> t / nil"
"Zooms to the location of the selected figGroup occurrence in the main window. ")
("leLmbCtrlOption"
"leLmbCtrlOption( 
) 
=> t / nil"
"Allows some Virtuoso Layout Suite L creating and editing commands to override the Ctrl + Left mouse click. The command options are embedded in the Virtuoso Layout Suite L software and cannot be changed. ")
("leLmbShiftOption"
"leLmbShiftOption( 
) 
=> t / nil"
"Allows some Virtuoso Layout Suite L creating and editing commands to override the Shift + Left mouse click. The command options are embedded in the Virtuoso Layout Suite L software and cannot be changed. ")
("leMakeCell"
"leMakeCell(
l_figs 
t_libName 
t_cellName 
t_viewName 
g_replace 
[ ?preserveConn g_preserveConn ]
[ ?createPins g_createPins ]
[ ?transInst g_transInst ]
[ ?pinsBelowBoundary g_pinsBelowBoundary ]
[ l_point ] 
[ t_cellType ] 
)
=> d_cellViewId / nil"
"Creates the cellview specified by t_libName, t_cellName, and t_viewName. If the cellview already exists, it is overwritten. The arguments ?preserveConn, ?createPins, ?transInst, and ?pinsBelowBoundary are only supported only in Layout XL and higher tiers.")
("leMakeHierReadonlyOrEditableMC"
"leMakeHierReadonlyOrEditableMC(
[ w_windowId ]
) 
=> t / nil"
"Makes a cellview either read-only or editable. When one or more instances are selected before invoking this function, only the selected instance(s) are shown in the browser. When no instances are selected before invoking this function, all instances in the cellview are shown in the browser. If you do not specify w_windowId, the Virtuoso Layout Suite L uses the current window.")
("leMergeShapes"
"leMergeShapes( 
l_shapes 
[ x_sides ]
) 
=> l_newShapes / nil"
"Merges the list of shapes l_shapes. The input shapes can be on multiple layers. Merges only shapes on the same layer. Returns the list of shapes resulting from the operation.")
("leMicroEdit"
"leMicroEdit( 
t_direction 
[ w_windowId ]
) 
=> t / nil"
"Allows using bindkeys instead of the mouse to move, copy, or stretch any shape. When no command is active, the selected shape is either moved or stretched, depending on whether the shape is fully or partially selected, respectively. When the copy, move, or stretch command is active, the selected shape is copied, moved, or stretched, respectively.")
("leModifyCorner"
"leModifyCorner( 
d_figId
l_selArray
g_chamfer
x_distance
[ x_sides ]
) 
=> t / nil"
"Rounds or cuts off selected corners of the rectangle or polygon specified by d_figID.")
("leMoveCellViewOrigin"
"leMoveCellViewOrigin( 
d_cellViewId 
l_point
) 
=> t / nil"
"Moves the contents of cellview d_cellViewId so that the origin is at l_point.")
("lePasteFigs"
"lePasteFigs(
d_cellViewId 
l_destPt 
[ t_rotation ]
[ t_referenceParameter ]
) 
=> t / nil"
"Places the contents of the yank buffer in cellview d_cellViewId at the destination point l_destPt.")
("leQuickAlignToggleMode"
"leQuickAlignToggleMode( 
) 
=> t / nil"
"Allows you to toggle between quick align modes - move or stretch, and copy.")
("leReturn"
"leReturn(
[ w_windowId ]
) 
=> t / nil"
"Applies to instances, nested instances, groups, and nested groups for which you are editing-in-place. When editing instances or nested instances in Edit-in-Place mode, returns one level; when there is only one level, exits Edit-in-Place mode. When editing a un-nested group, exits Edit-in-Place Mode; when editing a nested group, returns to the group of which the edited group is a member. If you do not specify w_windowId, the Virtuoso Layout Suite L uses the current window.")
("leReturnToLevel"
"leReturnToLevel(
[ w_windowId ]
) 
=> t / nil"
"Applies to instances, nested instances, groups, and nested groups for which you are editing-in-place. For instances, returns one or more levels up the hierarchy from the current level in the instance you last edited-in-place. When there is only one level, exits Edit-in-Place mode. When you have descended more than one level, this function displays the Return To Level form, showing the levels to which you can return. You select (highlight) the desired level and click OK. For example, if you are using leHiEditInPlace to edit a cellview two levels deep in your hierarchy, you can use leReturnToLevel to move up one or two levels in the hierarchy. For groups, returns from the group, and if the group is nested, from all groups in the nesting, and exits Edit-in-Place mode. If you do not specify w_windowId, the Virtuoso Layout Suite L uses the current window. ")
("leReturnToTop"
"leReturnToTop(
[ w_windowId ]
) 
=> t / nil"
"(IC6.1.8 Only) Applies to instances, nested instances, groups, and nested groups for which you are editing-in-place. When editing instances or nested instances in Edit-in-Place mode, returns to top level, exits Edit-in-Place mode. For groups, returns from the group, and if the group is nested, from all groups in the nesting, and exits Edit-in-Place mode. If you do not specify w_windowId, the Virtuoso Layout Suite L uses the current window.")
("leSetStopLevelToEditLevel"
"leSetStopLevelToEditLevel ( 
[ w_windowId ] 
) 
=> x_level / nil"
"Sets the display stop level to the current editing level. You can also use the Ctrl + F bindkey to set the display stop level to the current editing level.")
("leSizeShape"
"leSizeShape(
d_shapeId 
g_resize
) 
=> l_shapes / nil"
"Resizes the d_shapeId shapeby the specified g_resize amount.")
("leSlice"
"leSlice(
l_points
) 
=> l_bBox /nil"
"Performs the vertical slicing of a shape.")
("leSplitShape"
"leSplitShape(
d_shapeId 
l_delta 
l_splitLine 
g_leftOrRight 
[ g_lockAngles ]
) 
=> t / nil"
"Splits a shape and moves one portion of it. Uses a multi-segment split line to divide the shape.")
("leStretchFig"
"leStretchFig(
d_shapeId 
l_delta 
l_freePoints 
[ g_lockAngles ]
) 
=> t / nil"
"Stretches shape d_shapeId by the delta l_delta. Donuts cannot be stretched.")
("leStretchShape"
"leStretchShape(
d_shapeId 
l_delta 
l_freePoints 
[ g_lockAngles ]
) 
=> t / nil"
"Stretches shape d_shapeId by the delta l_delta. Donuts cannot be stretched.")
("leUnfreezeInst"
"leUnfreezeInst(
d_instId 
) 
=> t / nil"
"Unfreezes or converts the non-Pcell instance, d_instId, to its original Pcell instance. When an instance is unfreezed the leUnfreezeInst() function only re-evaluates the Pcell instance but does not explicitly call the CDF callbacks. ")
("leUpdateInstanceCDFParameterValues"
"leUpdateInstanceCDFParameterValues( 
d_cellViewId 
d_instId
l_paramNameList
) 
=> t / nil"
"Updates the list of CDF parameters name-value pairs for the specified cellview and instance.")
("leYankFigs"
"leYankFigs(
d_cellViewId 
l_ptArray 
x_nLevels
[ l_refPt ] 
[ x_nSides ]
) 
=> t / nil"
"Copies specified objects into a yank buffer for later pasting. Copies objects in cellview d_cellViewId that fall within the shape defined by the points in l_ptArray and that are in the levels of hierarchy specified by x_nLevels. Optionally uses l_refPt as the reference point for the yank and x_nSides as the number of polygon sides to use when converting objects intersected by the yank shape.")
("leApplyAreaFunction"
"leApplyAreaFunction( 
s_funcs_funcSymbol
d_databaseId
l_paramList
) 
=> f_result / nil"
"Runs the area estimation function (provided as a function symbol) with provided parameters and database Id. This function is added as a part of Area Estimation consolidation.")
("leApplyLastCopyTransform"
"leApplyLastCopyTransform(
)
=> t / nil"
"Copies the selected objects and applies the same transform as done in the last copy command and selects the newly created objects.")
("leFullSelectFigOfSelSet"
"leFullSelectFigOfSelSet( 
[ w_windowId ] 
) 
=> t"
"Fully selects all the partially selected figures. If w_windowId is not specified, the current window is used.")
("leGetAreaEstimationDisplayNames"
"leGetAreaEstimationDisplayNames( 
t_aliasName
l_legalObjectTypes
) 
=> t_funcSymbol / nil"
"Retrieves area estimation function alias name list defined for the specified object types. The object types supported are 'cellView, 'inst, cluster, 'group. This function is added as a part of Area Estimation consolidation.")
("leGetAreaEstimatorFunction"
"leGetAreaEstimatorFunction( 
t_AliasName
l_legalObjectTypes
) 
=> t_funcSymbol / nil"
"Retrieves the function symbol of the area estimation function registered for alias name and object type. This function is added for Area Estimation Consolidation.")
("leGetAreaEstimatorParamList"
"leGetAreaEstimatorParamList( 
t_functionAliasName
l_legalObjectTypes
) 
=> l_funcParamList / nil"
"This function is added as a part of area estimation consolidation. The function can be used to retrieve the parameter list of the area estimation function registered for alias name and object type.")
("leGetAreaEstimatorRunMode"
"leGetAreaEstimatorRunMode( 
t_aliasName
l_legalObjectTypes
) 
=> t_RunMode / nil"
"This function is added as a part of area estimation consolidation. This function can be used to retrieve the Run Mode list of the area estimation function registered for alias name and object types.")
("leGetEditFigGroup"
"leGetEditFigGroup( 
[ w_windowID ] 
) 
=> d_figGroupId / nil"
"Returns the database ID of the currently active figure group for Edit-In-Group mode editing, in the specified window (or the current window).")
("leGetEntryLayer"
"leGetEntryLayer(
[ d_techFileId ]
) 
=> l_layerPurposePair / nil"
"Returns the entry layer for technology file d_techFileId as a list containing the layer name and layer purpose. If d_techFileId is not specified, the current technology file is used.")
("leGetObjectSelectable"
"leGetObjectSelectable( 
t_objectName 
) 
=> t / nil"
"Checks whether or not objects are set to selectable in the LSW.")
("leGetObjectVisible"
"leGetObjectVisible( 
t_objectName 
) 
=> t / nil"
"Checks whether or not objects are set to visible in the LSW.")
("leGetTechFormList"
"leGetTechFormList( 
d_techFileId
) 
=> l_formIds / nil"
"Returns a disembodied property list (DPL) that stores the dynamic form Ids associated with a technology library opened in a Virtuoso session. If the forms have not been opened yet, the SKILL function creates the forms and returns the form ID list.")
("leGetValidLayerList"
"leGetValidLayerList(
[ d_techFileId ]
) 
=> l_layerIdList / nil"
"Returns a list of the valid entry layers for technology file d_techFileId. A layout view must be open for leGetValidLayerList to return the list of valid entry layers.")
("leGetValidPurposeList"
"leGetValidPurposeList(
d_techFileId
)
=> l_purposeIdList / nil"
"Returns a list of all valid purposes for the specified technology file.")
("leIsFigSelectable"
"leIsFigSelectable(
d_figId
) 
=> t / nil"
"Checks whether the figure d_figId is selectable. ")
("leIsInstSelectable"
"leIsInstSelectable(
[ d_techFileId ]
) 
=> t / nil"
"Checks whether the instances in d_techFileId are selectable. If d_techFileId is not specified, the current technology file is used.")
("leIsLayerSelectable"
"leIsLayerSelectable(
l_layerPurposePair
[ d_techFileId ]
) 
=> t / nil"
"Checks whether the layer l_layerPurposePair is selectable. ")
("leIsLayerValid"
"leIsLayerValid( 
l_layerPurposePair
[ d_techFileId ]
) 
=> t / nil"
"Checks whether layer l_layerPurposePair is a valid layer. If d_techFileId is not specified, the current technology file is used.")
("leIsLayerVisible"
"leIsLayerVisible( 
l_layerPurposePair
[ d_techFileId ]
) 
=> t / nil"
"This procedure checks whether the layer specified by l_layerPurposePair is visible. If d_techFileId is not specified, the current technology file is used.")
("leIsNewODCInfraEnabled"
"leIsNewODCInfraEnabled( 
) 
=> t / nil"
"Checks if the new odcInfra is enabled or not in the current Virtuoso session.")
("leIsPinSelectable"
"leIsPinSelectable(
[ d_techFileId ]
) 
=> t / nil"
"Checks whether the pins in d_techFileId are selectable. If d_techFileId is not specified, the current technology file is used.")
("leIsPointInsideFig"
"leIsPointInsideFig"
"Checks if the specified point is inside the figure.")
("leLSWGetBlockageSelectable"
"leLSWGetBlockageSelectable( 
t_blockageTypeName 
t_layerName 
) 
=> t / nil"
"Indicates whether a layer blockage is selectable or not If the blockage is selectable the function returns t. If it is not the function returns nil")
("leLSWGetBlockageVisible"
"leLSWGetBlockageVisible( 
t_blockageTypeName 
t_layerName 
) 
=> t / nil"
"Sets whether a layer blockage is visible or not. If the blockage is successfully set to visible the function returns t. If it is not set to visible the function returns nil.")
("leLSWGetRoutingGridVisible"
"leLSWGetRoutingGridVisible( 
t_layerName 
) 
=> t / nil"
"Returns the visibility of the specified routing grid layer. For the layer specified, the following must be defined in the technology file: in the layerRules section, for routingDirections, the direction for the layer; in the constraintGroups section, for routingGrids, values for the horizontalPitch and verticalPitch. In the LSW, you can check this visibility by clicking on the Grid button, then on the Routing Grid button.")
("leLSWSetBlockageSelectable"
"leLSWSetBlockageSelectable( 
t_blockageTypeName 
t_layerName 
g_status 
) 
=> t / nil"
"Sets whether a layer blockage is selectable or not. If the blockage is successfully set to selectable the function returns t. If it is not set to selectable the function returns nil.")
("leLSWSetBlockageVisible"
"leLSWSetBlockageVisible( 
t_blockageTypeName 
t_layerName 
g_status 
) 
=> t / nil"
"Sets whether a layer blockage is visible or not. If the blockage is successfully set to visible the function returns t. If it is not set to visible the function returns nil.")
("leLSWSetRoutingGridVisible"
"leLSWSetRoutingGridVisible( 
t_layerName 
g_status 
) 
=> t / nil"
"Sets whether a specific routing layer grid is visible. For the layer specified, the following must be defined in the technology file: for routingDirections in the layerRules section, the direction for the layer; for routingGrids in the constraintGroups section, values for the horizontalPitch and verticalPitch. In the LSW, you set this visibility by clicking on the Grid button.")
("leLSWSetTrackPatternVisible"
"leLSWSetTrackPatternVisible( 
g_status 
) 
=> t / nil"
"Sets the status of the visibility of track patterns and the Track grid visibility button in the LSW. This function does not affect the visibility of individual track layer-purpose pairs; use the leSetObjectVisible function to control LLP visibility. To turn track grid visibility on or off using the graphical user interface, in the LSW window, click Grid, then check the Vis box next to Track.")
("lePrintHierarchyTree"
"lePrintHierarchyTree(
) 
=> t / nil"
"Opens a form to choose library, cell, and view and then generates the hierarchy information.")
("leRaiseLSW"
"leRaiseLSW( 
) 
=> t / nil"
"Raises the Layer Selection Window (LSW) to the top of the window stack. It can be used if the LSW has been iconified. If the LSW is already at the top of the window stack, this function has no effect. ")
("leRegAreaEstimator"
"leRegAreaEstimator( 
s_functionSymbol
t_functionAlias 
l_legalObjectTypes
[ l_parameterNameValuePairs ]
[ t_runMode ]
) 
=> t / nil"
"Registers a particular area estimation function. This function is part of area estimation consolidation. The name of the estimator that will appear in the cyclic Area Estimator field in the Create Cluster Boundary form, and the function the software will invoke when you click the Estimate button on the form. Note: While searching for available area estimators, the applications/UI code should know the requirements for object types; the application provides database IDs and executes the area estimator in direct or deferred mode. ")
("leRegClusterBdyEstimator"
"leRegClusterBdyEstimator( 
t_displayName 
t_functionName 
) 
=> t / nil"
"Registers the name of the estimator which will appear in the cyclic field of the Area Estimator field in the Create Cluster Boundary form in the Floorplanning tool, and the function the software will invoke when you click the Estimate button on the form.")
("leRegisterPPNetNameFn"
"leRegisterPPNetNameFn(
S_ppNetNameFn
)
=> t / nil"
"Registers a SKILL function that specifies the names of pseudo-parallel subnets when called by the layout generation commands Generate All From Source and Update Components and Nets.")
("leRegisterUseGravity"
"leRegisterUseGravity( 
t_cmdName
) 
=> t"
"Enables a user-defined SKILL enter function to use the gravity feature. Gravity follows the options specified in the Layout Editor Options form.")
("leRegUserLayerSelectionFilter"
"leRegUserLayerSelectionFilter( 
t_filterName 
) 
=> t / nil"
"Registers a user-defined layer selection filter to prevent you from selecting shapes on the layers.")
("leRegUserObjectSelectionFilter"
"leRegUserObjectSelectionFilter( 
t_filterName 
) 
=> t / nil"
"Registers a user defined object selection filter to prevent you from selecting objects individually or as part of a selected set.")
("leRepeatCopyMoveStretch"
"leRepeatCopyMoveStretch(
)
=> t / nil"
"This function copies, moves, or stretches the selected objects and applies the same transform as done in the last copy, move, or stretch command and selects the newly created objects. This function applies to all the options specified in the last copy, move, or stretch commands, including the Create Synchronous Copy option available only in Layout XL and higher tiers.")
("leResizeLSW"
"leResizeLSW( 
l_bBox 
) 
=> t / nil"
"Sets the Layer Selection Window's (LSW) bounding box to l_bBox. The bounding box specifies the lower left and upper right corners of the LSW window.")
("leSetAllGridObjectsVisible"
"leSetAllGridObjectsVisible(
g_isVisible 
[ d_techFileId ]
) 
=> t"
"Sets all LSW grid pane objects to visible if g_isVisible is t, or invisible if g_isVisible is nil.")
("leSetAllLayerSelectable"
"leSetAllLayerSelectable(
g_isSelectable
[ d_techFileId ]
) 
=> t / nil"
"Sets the selectability of all layers in technology file d_techFileId as specified by g_isSelectable. If d_techFileId is not specified, the current technology file is used.")
("leSetAllLayerValid"
"leSetAllLayerValid(
g_isValid
[ d_techFileId ]
) 
=> t / nil"
"Sets the validity of all layers in technology file d_techFileId as specified by g_isValid. If d_techFileId is not specified, the current technology file is used.")
("leSetAllLayerVisible"
"leSetAllLayerVisible( 
g_isVisible 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the visibility of all layers in technology file d_techFileId as specified by g_isVisible. If d_techFileId is not specified, the current technology file is used.")
("leSetAllObjectsSelectable"
"leSetAllObjectsSelectable(
g_isSelectable
[ d_techFileId ]
) 
=> t / nil"
"Sets the selectability of LSW objects in technology file d_techFileId as specified by g_isSelectable. If d_techFileId is not given, the current LSW technology file is used.")
("leSetAllObjectsVisible"
"leSetAllObjectsVisible( 
g_isVisible 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the visibility of LSW objects in technology file d_techFileId as specified by g_isVisible. If d_techFileId is not given, the current technology file is used.")
("leSetAreaEstimatorParameters"
"leSetAreaEstimatorParameters( 
l_functionParamList
) 
=> l_functionParamList / nil"
"Opens a form to update the parameter list to new values. On pressing OK on the form, the updated parameter list is returned.")
("leSetEditFigGroup"
"leSetEditFigGroup( 
d_figGroupId 
[ w_windowID ] 
) 
=> t / nil"
"Sets the Edit-In-Place context for editing a specific group within a nested set of groups. For example, when fgBottom is contained in fgMiddle, and fgMiddle, is contained in fgTop, you can use this function and the figGroup ID for fgBottom to start Edit-in-Place for fgBottom.")
("leSetEntryLayer"
"leSetEntryLayer( 
l_layerPurposePair 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the entry layer for technology file d_techFileId to the layer specified by l_layerPurposePair, which can be either a list containing a layer name and a layer purpose, or just a layer name (the layer purpose then defaults to drawing). If d_techFileId is not specified, the current technology file is used.")
("leSetFocusToEditableFieldsInStatusToolbar"
"leSetFocusToEditableFieldsInStatusToolbar( 
w_windowId
) 
=> t / nil"
"Sets the focus to the editable X field on the Status toolbar of the window, w_windowId. ")
("leSetFormSnapMode"
"leSetFormSnapMode(
t_SnapMode
) 
=> t_SnapMode"
"Sets the cursor snap mode in a valid active window.")
("leSetInstSelectable"
"leSetInstSelectable( 
g_isSelectable 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the selectability of instances in the technology file specified by d_techFileId as specified by g_isSelectable. If d_techFileId is not specified, the current technology file is used.")
("leSetLayerAttributes"
"leSetLayerAttributes( 
d_techFileId 
g_layerPurposePair 
l_attributeList 
) 
=> t / nil"
"Sets the attributes of the specified layer in the technology file d_techFileId as specified by g_layerPurposePair and l_attributeList.")
("leSetLayerSelectable"
"leSetLayerSelectable( 
l_layerPurposePair 
g_isSelectable 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the selectability of shapes on layer l_layerPurposePair in technology file d_techFileId as specified by g_isSelectable. If d_techFileId is not specified, the current technology file is used. For shapes on a layer to be selectable, the layer must be valid, visible, and selectable.")
("leSetLayerValid"
"leSetLayerValid( 
l_layerPurposePair 
g_isValid 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the validity of layer l_layerPurposePair as specified by g_isValid. If d_techFileId is not specified, the current technology file is used. Only valid layers are displayed in the Layer Selection Window.")
("leSetLayerVisible"
"leSetLayerVisible( 
l_layerPurposePair 
g_isVisible 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the visibility of the layer specified by the layer-purpose pair as specified by g_isVisible. If d_techFileId is not specified, the current technology file Layer Selection Window (LSW) is used. ")
("leSetLSWFilter"
"leSetLSWFilter( 
l_filters 
) 
=> t / nil"
"The filter layers command specifies which layer-purpose pairs in the technology database to display in the Layer Selection Window (LSW). You can include one or more of the following types of layers: valid layers, rule layers, user layers.")
("leSetObjectSelectable"
"leSetObjectSelectable(
t_objectName
g_isSelectable
) 
=> t / nil"
"Turns on or off the selectability of the layers used for objectName or updates the selectability of instances or pins as specified by g_isSelectable.")
("leSetObjectVisible"
"leSetObjectVisible(
t_objectName
g_isVisible
) 
=> t / nil"
"Turns on or off the visibility of the layers used for objectName or updates the visibility of instances or pins as specified by g_isVisible.")
("leSetPinSelectable"
"leSetPinSelectable( 
g_isSelectable 
[ d_techFileId ] 
) 
=> t / nil"
"Sets the selectability of pins in the technology file specified by d_techFileId as specified by g_isSelectable. If d_techFileId is not specified, the current technology file is used.")
("leToggleAutoZoomPan"
"leToggleAutoZoomPan( 
[ w_windowId ] 
) 
=> t / nil"
"Toggles the current value of dynamic zoom for the specified w_windowId. If w_windowId is not specified, the current window is used.")
("leToggleGravity"
"leToggleGravity( 
) 
=> t / nil"
"Turns gravity on or off.")
("leToggleKeepFirstName"
"leToggleKeepFirstName(
)
=> t / nil"
"Toggles the Keep First Name option on or off on the Create Shape Pin form. When this option is on, you can create multiple pins with the same terminal name.")
("leToggleMagnifier"
"leToggleMagnifier( 
) 
=> t / nil"
"Toggles the visibility of the magnifier between on and off.")
("leToggleMaintainConnections"
"leToggleMaintainConnections( 
) 
=> t / nil"
"Turns Maintain Connections on or off.")
("leToggleRuleGravity"
"leToggleRuleGravity( 
) 
=> t / nil"
"(ICADVM20.1 Only) Turns rule gravity on or off.")
("leToggleSmartSnap"
"leToggleSmartSnap( 
) 
=> t / nil"
"Toggles the smart snap mode of ruler between no snapping (off) and snap to any target (on).")
("leUnregisterUseGravity"
"leUnregisterUseGravity( 
t_cmdName
) 
=> t / nil"
"Use this function to not allow a user-defined SKILL enter function to use gravity. By default, gravity is available oly for SKILL enter functions for which gravity has been enabled using the leRegisterUseGravity function.")
("leUnregUserLayerSelectionFilter"
"leUnregUserLayerSelectionFilter( 
) 
=> t / nil"
"Unregisters user defined layer selection filter.")
("leUnregUserObjectSelectionFilter"
"leUnregUserObjectSelectionFilter( 
) 
=> t / nil"
"Unregisters user defined object selection filter.")
("leUnRegAreaEstimator"
"leUnRegAreaEstimator( 
t_functionAlias
l_legalObjectTypes
) 
=> t / nil"
"Unregisters a particular area estimation function for one or more object types.")
("leUnRegClusterBdyEstimator"
"leUnRegClusterBdyEstimator( 
t_displayName 
) 
=> t / nil"
"Unregisters the name of the estimator which will subsequently no longer appear in the cyclic field of the Area Estimator field in the Create Cluster Boundary form in Layout XL.")
("leZoomToPoint"
"leZoomToPoint( 
w_windowId 
l_points 
) 
=> t / nil"
"Places the cursor in the window, w_windowId, at the coordinates specified in l_points.")
("leZoomToSelSet"
"leZoomToSelSet( 
[ w_windowId ] 
) 
=> t / nil"
"Zooms to fit the selected objects in the specified window. If w_windowId is not specified, the current window is used.")
("leGetRefPoint"
"leGetRefPoint( 
d_cellViewId 
) 
=> l_point / nil"
"Returns the reference point of cellview d_cellViewId. The reference point must be active. ")
("leIsRefPointActive"
"leIsRefPointActive( 
d_cellViewId 
) 
=> t / nil"
"Checks whether the cellview d_cellViewId contains an active reference point.")
("leMoveCursor"
"leMoveCursor( 
f_dX 
f_dY 
) 
=> t / nil"
"Moves the cursor in the current window a relative distance specified by f_dX and f_dY.")
("leMoveCursorToRefPoint"
"leMoveCursorToRefPoint( 
) 
=> t / nil"
"Moves the cursor to the reference point of the cellview contained in the current window. ")
("leSetRefPoint"
"leSetRefPoint( 
d_cellViewId 
l_point 
) 
=> t / nil"
"Sets the reference point of cellview d_cellViewId to the point l_point. The reference point is set to be active if it was inactive. ")
("leSetRefPointInactive"
"leSetRefPointInactive( 
d_cellViewId 
) 
=> t / nil"
"Marks the reference point for cellview d_cellViewId as inactive. To make a reference point active again, use leSetRefPoint.")
("leClearAllMeasurement"
"leClearAllMeasurement( 
d_cellViewId ]
) 
=> t "
"Deletes all measurements in the specified cellview. ")
("leCreateMeasurement"
"leCreateMeasurement( 
d_cellViewId 
l_points 
[ g_saveRulers ]
[ t_rulerDisplayType ]
) 
=> d_rulerID / nil"
"Creates a measurement in cellview d_cellViewId with the coordinates listed in l_points. ")
("leHiClearMeasurement"
"leHiClearMeasurement(
[ w_windowId ]
)
=> t"
"Clears the edit cellview measurement for the specified window. If windowId is not specified, the current window is used.")
("leHiClearMeasurementInHier"
"leHiClearMeasurementInHier(
[ w_windowId ]
)
=> t"
"Clears the measurements in the hierarchy in the specified window. If windowId is not specified, the current window is used.")
("leHiCreateMeasurement"
"leHiCreateMeasurement(
[ w_windowId ]
)
=> t / nil"
"Starts the create measurement enter function in the edited cellview of the specified window. If windowId is not specified, the current window is used.")
("leBalloonCycleThru"
"leBalloonCycleThru( 
) 
=> t / nil"
"Cycles through overlapping objects displaying Info Balloon information for the individual objects. By default, the function is registered to Ctrl + i.")
("leBalloonToggleOnOff"
"leBalloonToggleOnOff( 
) 
=> t / nil"
"Turns Info Balloons on or off. Info Balloons opens a window which displays information about an object when the mouse cursor is placed over the object.")
("leHiEditBalloonOptions"
"leHiEditBalloonOptions( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Info Balloon form.")
("leHiEditObjectInfo"
"leHiEditObjectInfo( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Setup tab of the Dynamic Display form. The form allows you to customize data displayed by Info Balloon and Dynamic Measurement.")
("leRemasterInstances"
"leRemasterInstances( 
d_cellViewId 
t_searchLibrary 
t_searchCellview 
t_searchViewName 
t_updateLibrary 
t_updateCellview 
t_updateViewName 
[ g_checkTerminals ]
) 
=> t / nil"
"Searches for instances based on the view name, cell name, and the library name for a given cellviewID, then re-masters those instances with the master that matches the update library, update cell and update view names you provide. The * wildcard can be used in any search string to replace any number of characters prior to or following the asterisk. If any of the search strings are empty then all matches in the cds.lib are considered, if matches exist. If any of the update strings are empty the update string uses the equivalent search string value. If both the search and the update strings are empty, only exact matches of the respective strings are considered. Due to the extensive changes available when using this command, making a backup copy of your design to guard against errors when replacing data is recommended.")
("leReplace"
"leReplace( 
d_cellViewId 
l_objects 
l_replaceValues 
) 
=> t / nil"
"Replaces the specified values on the specified list of objects in the cellview d_cellViewId.")
("leReplaceAnyInstMaster"
"leReplaceAnyInstMaster( 
d_instId
{ t_libName | nil } 
{ t_cellName | nil } 
{ t_viewName | nil } 
) 
=>t / nil"
"Changes the master library, cell, or view name for the instance. If you do not want to change any of these names, you must type nil in its place.")
("leSearchHierarchy"
"leSearchHierarchy(
d_cellViewId
l_bBox
x_stopLevel
t_objectType
l_criteriaList
)
=> l_objects / nil"
"Searches the cellview d_cellViewId for objects that match the type and criteria specified. The search is bound by the specified l_bBox and restricted to the specified x_stopLevel. The search assumes all figures are valid if the Layer Selection Window (LSW) has not been initialized.")
("leDescend"
"leDescend(
w_windowId 
d_instId 
[ x_row ] 
[ x_column ] 
) 
=> w_windowId / nil"
"Descends through the hierarchy to open the master of instance d_instId. leDescend attempts to open the cellview in the same mode as the current cellview, but if an editable version is not available, leDescend opens the master in read-only mode.")
("leDoubleClick"
"leDoubleClick(
)
=> t / nil"
"Runs the Edit In Place command on the object if the object at the point of double-click is either an instance or a group.")
("leEditInPlace"
"leEditInPlace( 
w_windowId 
l_hierlist 
) 
=> t / nil"
"Descends through the hierarchy to edit a cell in place.")
("leEIPZoomAbsoluteScale"
"leEIPZoomAbsoluteScale( 
) 
=> t / nil"
"Fits the master cell of the instance you want to edit in the window. The window is redrawn so the edit-in-place cell fills it.")
("leUniquifyCellView"
"leUniquifyCellView(
)"
"Opens the Uniquify form to specify the library, cell, and view name of the cellview to be uniquified. Alternatively, you can use the Uniquify command on the Tools menu in the CIW. A message displays after the successful uniquification of the cellview. If the cellview is already uniquified or the cellview cannot be opened, the command exits and displays an appropriate message.")
("leLayerAnd"
"leLayerAnd( 
d_cellViewId 
g_lpp1 
g_lpp2 
g_lpp3 
) 
=> l_shapes / nil"
"Creates shapes in cellview d_cellViewId on layer g_lpp3 that correspond to the intersections of all shapes on layers g_lpp1 and g_lpp2. A layer-purpose pair is a list containing a layer name followed by a layer purpose.")
("leLayerAndNot"
"leLayerAndNot( 
d_cellViewId 
g_lpp1 
g_lpp2 
g_lpp3 
) 
=> l_shapes / nil"
"Creates shapes in cellview d_cellViewId on layer g_lpp3 that correspond to the shapes on layer g_lpp1 minus the intersections with the shapes on layer g_lpp2. A layer-purpose pair is a list containing a layer name followed by a layer purpose. ")
("leLayerOr"
"leLayerOr( 
d_cellViewId 
g_lpp1 
g_lpp2 
g_lpp3 
) 
=> l_shapes / nil"
"Creates shapes in cellview d_cellViewId on layer g_lpp3 that correspond to the union of shapes on layers g_lpp1 and g_lpp2. A layer-purpose pair is a list containing a layer name followed by a layer purpose. ")
("leLayerSize"
"leLayerSize( 
d_cellViewId 
g_lpp1 
n_sizeAmount 
g_lpp2 
) 
=> l_shapes / nil"
"Creates shapes in cellview d_cellViewId on layer g_lpp2 by over sizing the shapes on layer g_lpp1 by n_sizeAmount number of units, which can be either positive (oversize) or negative (undersize). A layer-purpose pair is either a layer name or a list containing a layer name followed by a layer purpose. ")
("leLayerXor"
"leLayerXor( 
d_cellViewId 
g_lpp1 
g_lpp2 
g_lpp3 
) 
=> l_shapes / nil"
"Creates shapes in cellview d_cellViewId on layer g_lpp3 that are the result of the union of the shapes on layers g_lpp1 and g_lpp2 minus their intersection. A layer-purpose pair is a list containing a layer name followed by a layer purpose. ")
("hiMakeLPChoiceList"
"hiMakeLPChoiceList( 
d_techFileID 
l_layerName&Purpose 
[ g_layerNum ]
[ g_swatchIcon ]
) 
=> l_iconList / nil"
"Creates a layer purpose icon list for use in a form field or menu.")
("cmdCtrlOption"
"cmdCtrlOption(
) 
=> t / nil"
"Implements a command option for Virtuoso Layout Suite L creating and editing commands when you press the Control key and press the bindkey. The command options are embedded in the Virtuoso Layout Suite L software and cannot be changed. The default bindkey for this function is the right mouse button. You can change the default to another key.")
("cmdOption"
"cmdOption( 
) 
=> t / nil"
"Implements a command option for Virtuoso Layout Suite L creating and editing commands when you press the bindkey. The command options are embedded in the Virtuoso Layout Suite L software and cannot be changed. The default bindkey for this function is the right mouse button. You can change the default to another key.")
("cmdShiftOption"
"cmdShiftOption( 
) 
=> t / nil"
"Implements a command option for Virtuoso Layout Suite L creating and editing commands when you press the Shift key and press the bindkey. The command options are embedded in the Virtuoso Layout Suite L software and cannot be changed. The default bindkey for this function is the right mouse button. You can change the default to another key.")
("leArrowFunc"
"leArrowFunc( 
t_keyName
[ g_optionalArg ] 
) 
=> return value from the called function or function bound by default or nil"
"Executes the function specified in the layout environmental variable spaceFuncName, passing the ID of the current window, the key name, and the optional argument. If spaceFuncName is empty, this function executes the current non-enter function binding for the specified key name.")
("leSelBoxOrStretch"
"leSelBoxOrStretch( 
[ w_windowId ] 
) 
=> t"
"The Virtuoso Layout Suite L binds this function to the mouse button DrawThru1 action. The default behavior for mouse button DrawThru1 is select by bBox. When you select using a bBox, rather than a point, the software checks what is under the selected area. If something under the initial point of the bBox is already selected, the software automatically calls the stretch command. If nothing under the cursor is selected the software selects the bBox you have drawn. If w_windowId is not specified, the current window is used. This function should not be changed.")
("leSpaceBarFunc"
"leSpaceBarFunc( 
[ w_windowId ] 
[ g_useDefault ] 
[ g_shift ] 
) 
=> return value from the called function"
"Invokes the function specified by name in the Virtuoso Layout Suite L environment variable spaceFuncName when the g_useDefault argument is set to t. When the g_useDefault argument is set to nil the space bar is not used as a bindkey. If w_windowId is not specified, the current window is used.")
("mbGetAction"
"mbGetAction(
t_viewType
t_uniqueId
)
=> o_action / nil"
"Retrieves an action from the menu builder data structure.")
("mbRegisterAction"
"mbRegisterAction(
t_viewType
t_uniqueId
t_name
t_callback
t_enableCB
[ ?iconFile g_iconFile ]
[ ?icon g_icon ]
[ ?checkable g_checkable ]
[ ?checkedCB t_checkedCB ]
)
=> o_action / nil"
"Creates an action and registers it with the menu builder for future retrieval and use within menus. This action will appear only when mbSetContextData is used to set its visibility location.")
("mbRegisterCustomMenu"
"mbRegisterCustomMenu(
t_viewType
t_uniqueId
t_enableCB
t_customCB
)
=> t / nil"
"Registers a custom menu with the menu builder for future retrieval and use within menus. A custom menu item is a single or slider menu that is built using the hi function calls, independently of the menu builder. The t_customCB argument is used to specify the function that is responsible for building and returning the menu item. The menu will display only when the mbSetContextData function is called.")
("mbRegisterHierMenu"
"mbRegisterHierMenu(
t_viewType
t_uniqueId
t_name
t_enableCB
)
=> t / nil"
"Registers a hierarchical menu with the menu builder for future retrieval and use within menus.")
("mbRegisterMenuItem"
"mbRegisterMenuItem(
t_viewType
l_menuItemDef
t_enableCB
)
=> t_menuItemId / nil"
"Registers a menu item with the menu builder that has been defined using the older menu creation syntax. mbSetContextData needs to be called before the menu item is visible.")
("mbSetContextData"
"mbSetContextData(
t_viewType
t_uniqueId
t_validObjs
t_validWidgets
t_grouping
[ ?parent t_parent ]
[ ?removeWhenDisabled g_removeWhenDisabled ]
)
=> t / nil"
"Sets various attributes to determine the menus with which the registered action is to be associated.")
("mbUnregisterAction"
"mbUnregisterAction(
t_name
[ ?objType t_objType ]
[ ?viewType t_viewType ]
[ ?silent g_silent ]
)
=> t / nil"
"Removes the provided menu item from the RMB menu. The optional arguments can be used to limit the removal of a menu item to specific object types or view types for which it is registered.")
("hiLayerDispMainForm"
"hiLayerDispMainForm( 
) 
=> t"
"Opens the Layer Purpose Pair Editor form. You can also access this form using the CIW - Tools - Technology File Manager - Edit Layers command.")
("leCloseWindow"
"leCloseWindow( 
) 
=> t / nil"
"Closes the current layout window. Similar to the hiCloseWindow function. To customize a bindkey you must use leCloseWindow because it is the function used in the callback of the File - Close menu command.")
("leDesignSummary"
"leDesignSummary( 
d_cellViewId 
t_fileName 
g_append 
[ w_windowId ] 
[ basicSummary ]
[ netStats ]
[ connectivityStats ]
[ routingStats ]
) 
=> t / nil"
"Stores or outputs leHiSummary results to an external specified file.")
("leEditDesignProperties"
"leEditDesignProperties( 
[ d_cellviewId ] 
) 
=> t / nil"
"Opens the Edit Cellview Properties form, which lets you change the design properties in the cellview d_cellViewId. If d_cellViewId is not specified, the cellview in the current window is used.")
("leExportLabel"
"leExportLabel( 
[ t_fileName ] 
) 
=> t / nil"
"Saves the label information in the current cellview to the specified file.")
("leGetCoordinateForm"
"leGetCoordinatesForm( 
)"
"Opens the Enter Points form which is used to specify the coordinates required to allow a command to proceed.")
("leHiAbout"
"leHiAbout( 
) 
=> t / nil"
"Opens the product information window, which includes the release number and copyright information.")
("leHiAddToGroup"
"leHiAddToGroup( 
) 
=> t / nil"
"Opens the Select Target Group form to add shapes to an existing group.")
("leHiAddShapeToNet"
"leHiAddShapeToNet( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Add Shape To Net form, which lets you associate a shape with a net. If w_windowId is not specified, the current window is used.")
("leHiAlign"
"leHiAlign(
)
=> t"
"Opens the Align form, and returns the value of t.")
("leHiAttach"
"leHiAttach( 
[ w_windowId ] 
) 
=> t / nil"
"Attaches a selected object in the specified window to another object in the window. The attached object is called the child object, and the object it is attached to is called the parent object. When you move, copy, or delete the parent, the child is also moved, copied, or deleted. If w_windowId is not specified, the current window is used.")
("leHiCellviewTrackPatterns"
"leHiCellviewTrackPatterns( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Track Pattern Editor form, which lets you add, update or delete track patterns. If w_windowId is not specified, the current window is used.")
("leHiChop"
"leHiChop( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Chop form, which lets you remove parts of objects or break objects into multiple objects. If w_windowId is not specified, the current window is used.")
("leHiClearRuler"
"leHiClearRuler( 
[ w_windowId ] 
) 
=> t / nil"
"Clears the rulers that stay in the window when the Keep Ruler option is selected using leHiCreateRuler. If w_windowId is not specified, the current window is used.")
("leHiConvertInstToMosaic"
"leHiConvertInstToMosaic( 
[ w_windowId ]
) 
=> t / nil"
"Starts the Convert To Mosaic command, which lets you convert one or more selected instances either into an equivalent number of mosaics or into a single mosaic. If w_windowId is not specified, the current window is used. You are prompted to select one or more instances to convert into mosaics.")
("leHiConvertPolygonToPath"
"leHiConvertPolygonToPath( 
[ w_windowId ] 
) 
=> t / nil"
"Converts a selected polygon in the specified window to a path if a uniform width path can be inferred. If w_windowId is not specified, the current window is used.")
("leHiConvertShapeToPathSeg"
"leHiConvertShapeToPathSeg( 
[ w_windowId ] 
) 
=> t / nil"
"Converts a selected polygon, rectangle, or path in the specified window to a pathSeg, if a uniform width path can be inferred. If w_windowId is not specified, the current window is used.")
("leHiConvertShapeToPolygon"
"leHiConvertShapeToPolygon( 
[ w_windowId ] 
) 
=> t / nil"
"Converts a selected object in the specified window to a polygon. Converts rectangles, paths, donuts, circles, and ellipses using the number of conic sides specified using leHiEditEditorOptions. If w_windowId is not specified, the current window is used.")
("leHiCopy"
"leHiCopy( 
[ w_windowId ]
) 
=> t / nil"
"Opens the Copy form, which lets you copy selected objects in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateAreaBoundary"
"leHiCreateAreaBoundary( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Area Boundary form, which lets you create an Area Boundary. If w_windowId is not specified, the current window is used.")
("leHiCreateBend"
"leHiCreateBend( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Transmission Line Bend form, which lets you create a transmission line bend in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateBlockage"
"leHiCreateBlockage( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Blockage form, which lets you create blockages. If w_windowId is not specified, the current window is used.")
("leHiCreateChoiceOfPin"
"leHiCreateChoiceOfPin( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Shape Pin form in w_windowId. If w_windowId is not specified, the current window is used.")
("leHiCreateCircle"
"leHiCreateCircle( 
[ w_windowId ]
) 
=> t / nil"
"Creates a circle in the specified window. You are prompted to point to a location for the center of the circle and the outer edge of the circle. If w_windowId is not specified, the current window is used.")
("leHiCreateClusterBoundary"
"leHiCreateClusterBoundary( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Cluster Boundary form, which lets you create a cluster boundary. If w_windowId is not specified, the current window is used.")
("leHiCreateClusters"
"leHiCreateClusters( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create - P&R Objects - Clusters form, which lets you create and edit clusters and sub-clusters. If w_windowId is not specified, the current window is used.")
("leHiCreateDonut"
"leHiCreateDonut( 
[ w_windowId ] 
) 
=> t / nil"
"Creates a donut in the specified window. You are prompted to point to a location for the center of the donut, the inner edge of the donut, and the outer edge of the donut. If w_windowId is not specified, the current window is used.")
("leHiCreateEllipse"
"leHiCreateEllipse( 
[ w_windowId ] 
) 
=> t / nil"
"Creates an ellipse in the specified window. You are prompted to point to the corners of the bounding box for the ellipse. If w_windowId is not specified, the current window is used.")
("leHiCreateGroup"
"leHiAddToGroup( 
) 
=> t / nil"
"Opens the Create Group form to select figures to form a new group.")
("leHiCreateGuardRing"
"leHiCreateGuardRing( 
) 
=> t / nil"
"Opens the Create Guard Ring form, which lets you instantiate guard rings. If w_windowId is not specified, the current window is used.")
("leHiCreateInst"
"leHiCreateInst( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Instance form, which lets you create an instance in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateLabel"
"leHiCreateLabel( 
[ w_windowId ] 
[ t_mode ]
) 
=> t / nil"
"Opens the Create Label form, which lets you create a label in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateMPP"
"leHiCreateMPP( 
[ w_windowId ] 
) 
=> t / nil"
"Runs the Create MPP command in the specified window. You can draw the MPP on the canvas or press F3 to open the Create Multipart Path form and specify the settings for creating multipart paths. If w_windowId is not specified, the current window is used.")
("leHiCreatePath"
"leHiCreatePath( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Path form, which lets you create a path in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreatePin"
"leHiCreatePin( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Shape Pin form, which lets you create a geometric pin in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreatePinsFromLabels"
"leHiCreatePinsFromLabels( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Pins From Labels form, which lets you create pins from text labels in your layout cellview or selected instances. This command creates pins with terminal names matching labels on a specified text layer with pin dimensions that you specify, centered on the origin of your text label. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiCreatePlacementArea"
"leHiCreatePlacementArea( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create - P&R Objects - Custom Placement Area form, which lets you create a placement area in one of three modes: Manual, Assisted, or Auto. This form contains a Dressing Template Editor button to bring up the Dressing Template Editor subform. To activate this subform with SKILL, use the SKILL ~> operator like this: leHiCreatePlacementArea~>Dressing~>value=1. If w_windowId is not specified, the current window is used.")
("leHiCreatePolygon"
"leHiCreatePolygon( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Polygon form, which lets you create a polygon in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreatePRBoundary"
"leHiCreatePRBoundary( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create P&R Boundary form, which lets you create a P&R boundary. If w_windowId is not specified, the current window is used.")
("leHiCreateRect"
"leHiCreateRect( 
[ w_windowId ] 
) 
=> t / nil"
"Creates a rectangle in the specified window. You are prompted to point to two coordinates for the opposite corners of the rectangle. If w_windowId is not specified, the current window is used.")
("leHiCreateRow"
"leHiCreateRow( 
[ w_windowId ] 
) 
=> t / nil"
"Makes sure the cellview is writable and opens the Create - P&R Objects - Create Row form, which lets you create a row in the specified window. Prerequisite: site definitions must already exist in your technology file. This form contains a Dressing Template Editor button to bring up the Dressing Template Editor subform. To activate this subform with SKILL, use the SKILL ~> operator like this: leHiCreateRow~>Dressing~>value=1.If w_windowId is not specified, the current window is used.")
("leHiCreateRuler"
"leHiCreateRuler( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Ruler form, which lets you create a ruler in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateSnapBoundary"
"leHiCreateSnapBoundary( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Snap Boundary form, which lets you create a snap boundary. If w_windowId is not specified, the current window is used.")
("leHiCreateTaper"
"leHiCreateTaper( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Create Transmission Line Taper form, which lets you create a transmission line taper in the specified window. If w_windowId is not specified, the current window is used. ")
("leHiCreateTrl"
"leHiCreateTrl( 
[ w_windowId ]
) 
=> t / nil"
"Opens the Create Transmission Line form, which lets you create a transmission line in the specified window. If w_windowId is not specified, the current window is used.")
("leHiCreateVia"
"leHiCreateVia( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Create - Via command and opens the Create Via form, which lets you create a via in the specified window. If w_windowId is not specified, the current window is used.")
("leHiDelete"
"leHiDelete( 
[ w_windowId ] 
) 
=> t / nil"
"Deletes selected objects in the specified window. If you delete a net selected using the Navigator assistant, all shapes on the net, except for pins, are also deleted. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiDeleteAllAreaViewLevel"
"leHiDeleteAllAreaViewLevel( 
[ w_windowId ] 
) 
=> t / nil"
"Removes all special display areas in window w_windowId. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiDeleteAreaViewLevel"
"leHiDeleteAreaViewLevel( 
[ w_windowId ] 
) 
=> t / nil"
"Displays all currently defined area view levels using the layer-purpose pair hilight drawing1, and prompts you to point at the area to be removed. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiDeleteShapeFromNet"
"leHiDeleteShapeFromNet( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Remove Shape From Net form, which lets you remove the selected shape from the net. If w_windowId is not specified, the current window is used.")
("leHiDescend"
"leHiDescend( 
[ w_windowId ] 
[ t_mode ]
) 
=> t / nil"
"Lets you push down one level into the design hierarchy. You can preselect the instance to descend into. If no instances are selected, you are prompted to select an instance. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiDisplayPadOpeningInfoForm"
"leHiDisplayPadOpeningInfoForm( 
)"
"Opens the Pad Opening Info form, which you can use to find pad shapes at lower levels of your hierarchical cellview, generate reports and labels for the pad shapes that are found, and promote the generated labels to the top level of the cellview.")
("leHiDisplayTechGraphForm"
"leHiDisplayTechGraphForm( 
) 
=> t"
"Opens the Technology Database Graph form. You can also access this form using the CIW - Tools - Technology File Manager - Graph command.")
("leHiEditDisplayOptions"
"leHiEditDisplayOptions( 
[ w_windowId ]
) 
=> t / nil"
"Opens the Display Options form, which lets you change the display options in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiEditDRDRuleOptions"
"leHiEditDRDRuleOptions( 
)"
"Opens the DRD Options form, which lets you select the rules that are to be considered by the Design Rule Driven Editing. You can also set the other DRD options, such as mode, hierarchy depth, display, through the DRD Options form. Corresponds to the F7 bindkey in the leBindkeys.il file.")
("leHiEditDynamicMeasurementOptions"
"leHiEditDynamicMeasurementOptions( 
) 
=> t / nil"
"Opens the Dynamic Measurement Options form, which lets you change the dynamic measurement display options. This form turns dynamic measurement on or off, and sets which measurements will display, and the height of the text display in pixels.")
("leHiEditDRDOptions"
"leHiEditDRDOptions( 
) 
=> t / nil"
"Opens the DRD Options form, which lets you select the rules that are to be considered by the Design Rule Driven Editing. You can also set the other DRD options, such as mode, hierarchy depth, display, through the DRD Options form. Corresponds to the F7 bindkey in the leBindkeys.il file.")
("leHiEditEditorOptions"
"leHiEditEditorOptions( 
) 
=> t / nil"
"Opens the Layout Editor Options form, which lets you change the layout editor environment. You can also set these variables in your .cdsenv file, so the layout editor defaults to these options on start up.")
("leHiEditInPlace"
"leHiEditInPlace( 
[ w_windowId ] 
) 
=> t / nil"
"Lets you edit an instance's master while viewing it in the context of the instance placement. If you do not specify w_windowId, the layout editor uses the current window. You can preselect the instance to be edited in place. If no instance is selected, you are prompted to point at a shape contained in the instance to be edited in place. If you point at several shapes at different levels of the hierarchy, the shape in the higher-level instance is the one that is used.")
("leHiEditProp"
"leHiEditProp( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Edit Properties form, which lets you edit the properties set in the specified window. You are prompted to select objects whose properties you want to edit. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiFlatten"
"leHiFlatten( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Flatten form, which lets you explode a cell instance or array, moving the contents of the cell or array up one or more levels into the current level of the hierarchy. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiFlip"
"leHiFlip( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Flip form that you can use to flip an object horizontally or vertically in the specified window.")
("leHiIncrementalViolation"
"leHiIncrementalViolation( 
) 
=> t / nil"
"Specifies the incremental command mode.")
("leHiIncrementalViolationUpdater"
"leHiIncrementalViolationUpdater( 
)"
"Enables you to iterate between the violations of the command.")
("leHiLayerGen"
"leHiLayerGen( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Layer Generation form, which lets you create new shapes by performing logical operations on selected objects in the specified layers. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiLayerTap"
"leHiLayerTap( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Tools - Tap command and opens the Tap form when Options Displayed When Commands Start is set to on. Tapping sets the entry layer to the layer of an indicated shape in the current window. You can also use the tap command to seed create forms with information such as nets and attributes of objects. You are prompted to point at a shape with attributes to be tapped. You can point to shapes anywhere in the hierarchy. If the shape you want to select is overlapped by other shapes, you can cycle through the shapes until the shape you want is displayed, by setting the environment variable layerTapCycle to t, which takes precedence over Select from overlaps. If layerTapCycle is nil and layerTapPick is t, then the Select from overlaps form will appear if you click more than one overlapped shape. If you do not point to any shapes that are on valid layers, the function calls hiGetAttention and prompts you again. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiMakeCell"
"leHiMakeCell( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Make Cell form, which lets you create a cell from the selected objects in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiMerge"
"leHiMerge( 
[ w_windowId ] 
) 
=> t / nil"
"Merges selected objects that touch or overlap each other into one object. You can merge shapes of different types that are on the same layer. You cannot merge shapes on different layers. If you do not specify w_windowId, the layout editor uses the current window.

Note: Pins cannot be merged.")
("leHiModifyCorner"
"leHiModifyCorner( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Modify Corner form, which lets you modify corners of rectangles and polygons in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiMousePopUp"
"leHiMousePopUp( 
) 
=> t / nil"
"Opens the layout editor Middle Mouse Button Pop Up form. It is context sensitive. Returns t if the current window is a layout window, returns nil if the current window is not a layout window.")
("leHiMove"
"leHiMove( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Move form, which lets you move an object in the specified window to another location or layer in the same window or in a different window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiMoveOrigin"
"leHiMoveOrigin( 
[ w_windowId ] 
) 
=> t / nil"
"Enter this function with only the window ID argument; the system prompts you to point to the new origin. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiOptionLayer"
"leHiOptionLayer( 
) 
=> t / nil"
"Opens the LSW Option form. Returns t when you click OK, returns nil when you click Cancel.")
("leHiPaste"
"leHiPaste( 
[ w_windowId ]
) 
=> t / nil"
"Opens the Paste form, which lets you place the contents of the yank buffer in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiPlotQueueStatus"
"leHiPlotQueueStatus( 
) 
=> t / nil"
"Opens the Plot Job Queue form, which shows the status of the plot job queue.")
("leHiPropagateNets"
"leHiPropagateNets( 
[ w_windowId ]
) 
=> t / nil"
"Opens the Propagate Nets form, which lets you promote net information from pins in selected blocks one level down in the hierarchy up to the top level where the router can recognize and route the nets. You use this command when you do not have a schematic for your layout cellview. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiQuery"
"leHiQuery( 
[ w_windowId ]
) 
=> t / nil"
"Invokes the Query command to initiate a query in which you can select a shape to have descriptive data about it displayed.")
("leHiQuickAlign"
"leHiQuickAlign( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Quick Align command in the specified window. You are prompted to select a reference edge, centerline, or point. In the post-select mode, you can select the reference edge, centerline, or point after selecting the reference set objects. You can press F3 to open the Quick Align form and specify the settings for alignment.")
("leHiReShape"
"leHiReShape( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Reshape form, which lets you modify the vertices of rectangles, polygons, paths, and transmission lines. You can add vertices, remove vertices, or modify vertex locations. The modified shape is stored in its most efficient form. For example, if a polygon is modified to have a rectangular shape, it is converted into a rectangle. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiRemasterInstances"
"leHiRemasterInstances( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Remaster Instances form, in which you specify instances to search for based on the view name, cell name, and the library name for a given cellviewID, then re-masters those instances with the master that matches the update library, update cell and update view names you provide in the form. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiRemoveFromGroup"
"leHiRemoveFromGroup( 
) 
=> t / nil"
"This function operates only when nested within the leHiEditInPlace function. After executing the leHiEditInPlace function, select the group from which you want to remove a figure, and then execute leHiRemoveFromGroup, which prompts you to select figures to remove from the current group. If you select all of the figures in the group, you can exit the function with an escape or by starting another function. However, if you select fewer figures than the group contains, you must exit Edit-In-Place mode with the leReturnToLevel function (Edit - Hierarchy - Return To Level). ")
("leHiRepeatCopy"
"leHiRepeatCopy( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Repeat Copy command in the specified window.")
("leHiRotate"
"leHiRotate( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Rotate form, which lets you change the orientation of geometric objects. If w_windowId is not specified, the current window is used.")
("leHiSave"
"leHiSave( 
) 
=> t / nil"
"Executes the File - Save command, which saves the current cellview. ")
("leHiSaveACopy"
"leHiSaveACopy( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Save As Copy form, which lets you copy the current cellview to another library, cellview name, and/or view name. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSaveHier"
"leHiSaveHier( 
[ w_windowId ] 
) 
=> t / nil"
"Enables you to save a hierarchical instance that is modified without running the Edit In Place or Descend Edit command.")
("leHiSearch"
"leHiSearch(
[ w_windowId ]
) 
=> t / nil"
"Opens the Search form, which lets you search the specified window for objects that match user-specified query requests. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSetAreaViewLevel"
"leHiSetAreaViewLevel( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Set Area View Level form, which lets you create a special display area in the window. This lets you override the window's display start and stop levels for a specified area. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSetRefPoint"
"leHiSetRefPoint( 
[ w_windowId ] 
) 
=> t / nil"
"Sets a reference point in the specified window. You are prompted to point to location for the reference point. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiShowAngles"
"leHiShowAngles( 
[ w_windowId ] 
) 
=> t / nil"
"Runs the Show Angles command in the specified window. You are prompted to point to a vertex, an edge, or an object to view the angle formed at the intersection of two edges. If w_windowId is not specified, the current window is used.")
("leHiShowCoords"
"leHiShowCoords( 
[ w_windowId ] 
) 
=> t / nil"
"Runs the Show Coordinates command in the specified window. You are prompted to point to a vertex, an edge, or an object to view the coordinates of the selected shape. If w_windowId is not specified, the current window is used.")
("leHiShowSelSet"
"leHiShowSelSet( 
[ w_windowId ] 
) 
=> t / nil"
"Displays information about the selected set in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSize"
"leHiSize( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Size form, which lets you enlarge or reduce a shape in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSplit"
"leHiSplit( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Split form, which lets you reshape an object by stretching part of it relative to a split line in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiStretch"
"leHiStretch( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Stretch form, which lets you stretch objects in the specified window. If you do not specify w_windowId, the layout editor uses the current window.")
("leHiSubmitPlot"
"leHiSubmitPlot( 
) 
=> t / nil"
"Opens the Submit Plot form, which lets you submit plots to a plotter.")
("leHiSummary"
"leHiSummary( 
[ w_windowId ] 
) 
=> t / nil"
"Displays information about the specified window. If you do not specify w_windowId, the layout editor uses the current window. ")
("leHiTree"
"leHiTree( 
[ w_windowId ] 
) 
=> t / nil"
"Displays information about the design hierarchy in the specified window. If you do not specify w_windowId, the layout editor uses the current window. ")
("leHiUngroup"
"leHiUngroup( 
) 
=> t / nil"
"Starts the Edit - Group - Ungroup command and prompts you to point at the group you want to ungroup.")
("leHiYank"
"leHiYank( 
[ w_windowId ] 
) 
=> t / nil"
"Opens the Yank form, which lets you copy a set of objects in a cellview into the yank buffer for later pasting. A yank shape defines the area enclosing the objects to copy. If you do not specify w_windowId, the layout editor uses the current window.")
("leiDiscardEdits"
"leiDiscardEdits( 
) 
=> t / nil"
"Discards edits. Corresponds to the cellview window Design - Discard Edits command.")
("lePinModelInitFunction"
"lePinModelInitFunction( 
) 
=> t / nil"
"Opens the Pin Connectivity Model graphical user interface, which you can use to set the connectivity model for the pins and terminals in your design.")
("updateReturnPopupMenuItem"
"updateReturnPopupMenuItem(
s_popUpMenu
w_windowId
)
=> t / nil"
"Adds the Return menu item to the pop up menu specified.")
("leHiDisplayStartRouterForm"
"leHiDisplayStartRouterForm( 
[ ?layoutLCV list(t_library t_cell t_view) ] 
) 
=> t"
"Opens the Virtuoso Chip Assembly Router form.")
("leStartRouter"
"leStartRouter( 
[ ?layoutLCV list(t_libraryName t_cellName t_viewName) ]
[ ?layoutRoutedLCV list(t_libraryName t_cellName t_viewName) ]
[ ?constraintGroup t_constraintGroupName ]
[ ?doFile S_doFile ]
[ ?initCommand S_initCommand ]
[ ?showGraphics g_showGraphics ]
[ ?quitAtFinish g_quitAtFinish ]
[ ?useStartupFiles g_useStartupFiles ]
[ ?usePreroutes g_usePreroutes ]
[ ?usePreroutedIO g_usePreroutedIO ]
[ ?stripOrphanShapes g_stripOrphanShapes ]
[ ?checkAtStartup g_checkAtStartup ]
[ ?cutKeepoutByClearance g_cutKeepoutByClearance ]
[ ?cutKeepoutToImageEdge g_cutKeepoutToImageEdge ]
[ ?createDidFile g_createDidFile ]
[ ?didFile S_didFile ]
[ ?messageFile S_messageFile ]
[ ?statusFile S_statusFile ]
[ ?startupOptions S_startupOptions ]
) 
=> t / nil"
"Starts the Virtuoso Chip Assembly Router with specified data and startup options.")
("viaFindTransitions"
"viaFindTransitions(
t_constraintGroupSetup
t_topLayerName
t_bottomLayerName
) 
=> l_viaTransitionsObject / nil"
"Returns the list of transitions of the given constraint group setup object found between the specified top and bottom layers.")
("viaGenerateViasAtPoint"
"viaGenerateViasAtPoint(
w_windowId | d_cellViewId
l_point
t_viaOptionsObject
[ ?topAndBottomLayers lt_topAndBottomLayers ]
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Generates vias with the specified options at a given location in the specified window or cellview.The figures present at the given location are queried, and if they form valid overlaps, vias are created to connect the figures.")
("viaGenerateViasFromShapes"
"viaGenerateViasFromShapes(
w_windowId | d_cellViewId
l_shapes
t_viaOptionsObject
[ ?topAndBottomLayers lt_topAndBottomLayers ]
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Generates vias from the specified shapes with the given via options in the specified window or cellview. If the specified shapes form valid overlaps, vias are created to connect the shapes.")
("viaGenerateViasInArea"
"viaGenerateViasInArea(
w_windowId | d_cellViewId
l_ptArray
t_viaOptionsObject
[ ?topAndBottomLayers lt_topAndBottomLayers ]
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Generates vias with the specified options within a given area in the specified window or cellview. The figures present at the given location are queried, and if they form valid overlaps, vias are created to connect the figures.")
("viaGetViaOptions"
"viaGetViaOptions(
d_ConstraintGroupID
) 
=> t_viaOptionsObject / nil"
"Returns a via options object from the specified constraint group. This via options object can be used by any SKILL procedure enabling generation or re-computation of vias.")
("viaLoadViaVariants"
"viaLoadViaVariants (
d_cellViewId
) 
=> t"
"Loads the via variants from the specified cellview for the Create Via command.")
("viaRecomputeVias"
"viaRecomputeVias(
w_windowId | d_cellViewId
l_via
t_viaOptionsObject
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Recomputes the via list with the given via options in the specified window or cellview. The figures connected by the vias are searched and the vias are recomputed with the via options specified to connect the figures.")
("viaRecomputeViasAtPoint"
"viaRecomputeViasAtPoint(
w_windowId | d_cellViewId
l_point
t_viaOptionsObject
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Recomputes vias with the specified options at a given location in the specified window or cellview. The vias present at the given location are queried along with the figures connected by the vias. The vias are then recomputed with the via options specified to connect the figures.")
("viaRecomputeViasInArea"
"viaRecomputeViasInArea(
w_windowId | d_cellViewId
l_ptArray
t_viaOptionsObject
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
) 
=> l_via / nil"
"Recomputes vias with the specified options within a given area in the specified window or cellview. The vias present at the given location are queried along with the figures connected by the vias. The vias are then recomputed with the via options specified to connect the figures.")
("viaRegisterCreateViaInitCallback"
"viaRegisterCreateViaInitCallback(
t_functionName
) 
=> t / nil"
"Registers the function to be called each time the Create Via form is opened. The registered function name should be a valid SKILL procedure and the init procedure that is registered should be defined without arguments.")
("viaRegisterPostViaEngineCallback"
"viaRegisterPostViaEngineCallback(
t_functionName
) 
=> t / nil"
"Registers the function name to be called after the viaEngine processing. The registered function name should be a valid SKILL procedure. The postViaEngine procedure that is registered should be declared with one argument, the viaEngineContext. This argument is a user type representing the context of the viaEngine call. The viaRegisterPostViaEngineCallback function that is registered should be declared with the viaEngineContext argument. This argument is a user type representing the context of the viaEngine call. The function returns t or nil. If nil is returned by the viaRegisterPostViaEngineCallback function registered, vias are not created.")
("viaRegisterPostViaServerCallback"
"viaRegisterPostViaServerCallback(
t_functionName
) 
=> t / nil"
"Registers the function name to be called after the via server processing. The function should be a valid SKILL procedure. The postViaServer procedure that is registered should be declared with three arguments, the constraintGroup, the overlapInfo, and the list of viaViaDef user type computed by the via server. The postViaServer procedure returns a list of viaViaDef user types. You can update all viaViaDefs specified in the viaViaDef argument. You also have the option to modify the sequence of the viaViaDef list.")
("viaRegisterPreViaEngineCallback"
"viaRegisterPreViaEngineCallback(
t_functionName
) 
=> t / nil"
"Registers the function name to be called before via engine processing. The registered function name should be a valid SKILL procedure. The preViaEngine procedure that is registered should be declared with one argument, viaEngineContext. This argument is a user type representing the context of the viaEngine call. The viaRegisterPreViaEngineCallback function that is registered should be declared with the viaEngineContext argument. This argument is a user type representing the context of the viaEngine call. The function returns t or nil. If nil is returned by the viaRegisterPreViaEngineCallback function registered, vias are not created.")
("viaSaveViaVariants"
"viaSaveViaVariants(
d_cellViewId
) 
=> t"
"Saves the via variants from the Create Via command into the specified cellview.")
("viaSetDefaultCutClasses"
"viaSetDefaultCutClasses(
t_techLibName
[ t_constraintGroupName ]
((bottomLayer topLayer cutClass) ...)
[ g_reset ]
) 
=> t / nil"
"Sets the default cut classes to be used for each layer.")
("viaSetDefaultValidViaDefs"
"viaSetDefaultValidViaDefs(
t_techLibName
t_constraintGroupName
l_viaDef
[ g_reset ]
) 
=> t / nil"
"Sets the default vias to be used by Wire Edit and Create Via commands from the list of valid vias of the specified constraint group.")
("viaUnregisterCreateViaInitCallback"
"viaUnregisterCreateViaInitCallback(
)
=> t / nil"
"Unregisters the createVia initialization procedure if it has been registered. If it has not been registered, this function does nothing.")
("viaUnregisterPostViaEngineCallback"
"viaUnregisterPostViaEngineCallback(
)
=> t / nil"
"Unregisters the postViaEngine procedure if it has been registered. If it has not been registered, this function does nothing.")
("viaUnregisterPostViaServerCallback"
"viaUnregisterPostViaServerCallback(
)
=> t / nil"
"Unregisters the postViaServer procedure if it has been registered.")
("viaUnregisterPreViaEngineCallback"
"viaUnregisterPreViaEngineCallback(
)
=> t / nil"
"Unregisters the preViaEngine procedure if it has been registered. If it has not been registered, this function does nothing.")
("leHiMarkNet"
"leHiMarkNet( 
[ w_windowId ] 
)"
"Starts the Connectivity - Nets - Mark command and opens the Mark Net form in w_windowId, which lets you mark a net which you are prompted to select. If w_windowId is not specified, the current window is used.")
("leMarkNetGetNumThreads"
"leMarkNetGetNumThreads( 
[ w_windowId ] 
)
=> integer"
"Returns the thread mode of the Mark Net command. In Layout L, the Mark Net command always runs in a mono thread mode. In Layout XL and higher tiers, this command can run in auto or customizable thread mode.")
("leHiSaveAllHighLightMarkNet"
"leHiSaveAllHighLightMarkNet(
)
=> t / nil"
"Opens the Save All Mark Nets form.")
("leHiUnmarkNet"
"leHiUnmarkNet( 
[ w_windowId ] 
)
=> t / nil"
"Opens the Unmark Net form. If w_windowId is not specified, the current window is used.")
("leHiUnmarkNetAll"
"leHiUnmarkNetAll( 
[ w_windowId ] 
)
=> t / nil"
"Deletes the highlighting of all marked nets in w_windowId. If w_windowId is not specified, the current window is used.")
("leIsAnyMarkNetHighLighted"
"leIsAnyMarkNetHighLighted( 
w_windowId
)
=> t / nil"
"Checks if the specified window has a marked net.")
("leMarkNet"
"leMarkNet( 
l_point
[ ?startLevel startLevel ]
[ ?stopLevel stopLevel ]
[ ?hilightIncrementally hilightIncrementally ]
[ ?saveViaInfo saveViaInfo ]
[ ?thickLine thickLine ]
[ ?optionFile optionFile ]
[ ?startLpp startLpp ]
[ ?markNetColor markNetColor ]
)
=> t / nil"
"Marks a net in the current cellview. It traces the physical connectivity of a net(s) in a layout design starting from the input point (l_point) and highlights the traced net(s).")
("leSaveMarkNet"
"leSaveMarkNet(
cellName
[ ?libName t_libName ]
[ ?viewName t_viewName ]
[ ?pt l_pt ]
)
=> t / nil"
"Saves a particular highlighted net at the specified point (l_point). If no point is specified, all the highlighted nets in current cellview are saved in the specified cellview (lib/cell/view).")
("leUnmarkNet"
"leUnmarkNet( 
[ l_point ]
=> t / nil"
"Deletes the highlighting of the marked nets in the current cellview. This function can delete the highlights of a particular net at the specified point (l_point). If no point is specified, the highlights of all the marked nets in current cellview are deleted.")
("leGetWirebondProfileVisible"
"leGetWirebondProfileVisible( 
t_wpName 
) 
=> t / nil"
"(ICADVM20.1 Virtuoso RF Solution Only) Returns the visibility setting of the specified wirebond profile.")
("leSetWirebondProfileVisible"
"leSetWirebondProfileVisible( 
t_wpName 
g_isVisible
) 
=> t / nil"
"(ICADVM20.1 Virtuoso RF Solution Only) Sets the visibility of the specified wirebond profile.")
("pteCancelForm"
"pteCancelForm(
t_formName
[ w_windowId ]
)
=> t / nil"
"Closes the specified Palette form.")
("pteClearSearchHistory"
"pteClearSearchHistory(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Clears the search history for the specified Palette panel.")
("pteCloseLayerSetEdition"
"pteCloseLayerSetEdition(
[ w_windowId ]
)
=> t / nil"
"Closes layer set editing mode for the specified window, or for the current window if no window ID is specified.")
("pteCloseMPTSupportMode"
"pteCloseMPTSupportMode(
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Hides the MPT-support-related Palette UI options.")
("pteCollapse"
"pteCollapse(
t_rowPath
t_panelName
[ w_windowId ]
)
=> t / nil"
"Collapses the specified item in the specified Palette panel in the specified window.")
("pteCollapseAll"
"pteCollapseAll(
[ t_panelName ]
[ w_windowId ]
)
=> t / nil"
"Collapses all items in the specified Palette panel.")
("pteContextMenu"
"pteContextMenu(
[ t_panelName ]
[ w_windowId ]
)
=> t / nil"
"Displays the contextual menu for the specified Palette panel.")
("pteDeleteLayerSet"
"pteDeleteLayerSet(
t_layerSetName
t_layerSetRepositoryPath
)
=> t / nil"
"Deletes the specified layer set and the corresponding layer set file.")
("pteDeselect"
"pteDeselect(
t_rowPath
t_panelName
[ w_windowId ]
)
=> t / nil"
"Deselects an individual item in the specified Palette panel.")
("pteDeselectAll"
"pteDeselectAll(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Deselects all items in the specified Palette panel.")
("pteDiscardLayerSetEdition"
"pteDiscardLayerSetEdition(
[ w_windowId ]
) 
=> t / nil"
"Discards the changes made to the validity or membership state of a layer-purpose pair during the current layer set editing session.")
("pteDockWindow"
"pteDockWindow(
t_assistantName
[ w_windowId ]
) 
=> t / nil"
"Docks the specified Palette assistant.")
("pteEditLayerSet"
"pteEditLayerSet(
[ w_windowId ]
) 
=> t / nil"
"Enables addition or deletion of layer-purpose pairs in a layer set.")
("pteEditLayerSetValidity"
"pteEditLayerSetValidity(
[ w_windowId ]
) 
=> t / nil"
"Enables you to edit the validity and membership state of layer-purpose pairs in the selected layer sets.")
("pteExpand"
"pteExpand(
t_rowPath
t_panelName
[ w_windowId ]
) 
=> t / nil"
"Expands the specified item in the specified Palette panel in the specified window.")
("pteExpandAll"
"pteExpandAll(
t_panelName
[ w_windowId ]
) 
=> t / nil"
"Expands all objects in the specified Palette panel.")
("pteExportLayerSet"
"pteExportLayerSet(
t_layerSetName
t_layerSetRepositoryPath
t_layerSetFilePath
[ g_overwrite ]
)
=> t / nil"
"Exports a layer set from a Palette layer set repository to the file system.")
("pteFindNext"
"pteFindNext(
[ t_panelName ]
[ w_windowId ]
)
=> t / nil"
"Finds and sets as active the next layer-purpose pair that matches the search string, in the specified panel. This function works only if the Search Mode option in the Palette Options form is set to Filter.")
("pteFindPrev"
"pteFindPrev(
[ t_panelName ]
[ w_windowId ]
)
=> t / nil"
"Finds and sets as active the previous layer-purpose pair that matches the search string, in the specified panel. This function works only if the Search Mode option in the Palette Options form is set as Filter.")
("pteGetActiveScopeModes"
"pteGetActiveScopeModes(
[ w_windowId ]
)
=> l_result / nil"
"Returns a list containing the scope modes that are set as active in the specified window.")
("pteGetAllActiveLayerSets"
"pteGetAllActiveLayerSets(
[ w_windowId ]
)
=> l_layerSets / nil"
"Returns a list containing the layer sets that are set as active in the design open in the specified window.")
("pteGetAllLayerSets"
"pteGetAllLayerSets(
[ w_windowId ]
)
=> l_layerSets / nil"
"Returns a list containing all the layer sets available in the design open in the specified window.")
("pteGetCurrentPanel"
"pteGetCurrentPanel(
) 
=> t_panelName / nil"
"Retrieves the name of the currently active Palette panel.")
("pteGetLayerPath"
"pteGetLayerPath(
t_layerPurposeName
[ w_windowId ]
)
=> t_elementPath / nil"
"Retrieves the element path of the specified layer-purpose pair when the View By mode is applied to the Palette. The result can be used to provide the t_paletteElementPath argument needed by the pteSetVisible, pteSetSelectability, pteSetValidity, pteSetOnlyVisible, pteSetOnlySelectable, ptePropagateVisibility, and ptePropagateSelectability functions in the View By mode.")
("pteGetLayerSetMembers"
"pteGetLayerSetMembers(
t_layerSetName
[ w_windowId ]
)
=> l_result / nil"
"Returns the attribute settings for layer-purpose pairs, objects, and grids that are members of the specified layer set. For layer-purpose pairs, attributes include visibility, selectability, validity, priority, and routing direction (if set). For objects, attributes include visibility and selectability; and for grids, the attribute returned is visibility.")
("pteGetLPPDisplayedInPalette"
"pteGetLPPDisplayedInPalette(
[ w_windowId ]
)
=> t_layerPurposeNames / nil"
"Lists the layer-purpose pairs currently displayed in the Layers panel.")
("pteGetLSAtPosition"
"pteGetLSAtPosition(
x_position
[ w_windowId ]
)
=> t_layersetName / nil"
"Displays the name of the layer set that is listed at the specified position in the Layer Set Manager.")
("pteGetMPTSupportMode"
"pteGetMPTSupportMode(
w_windowId
)
=> t / nil"
"(ICADVM20.1 Only) Determines if MPT support is enabled in the window with the specified ID.")
("pteGetNextLayerSets"
"pteGetNextLayerSets(
[ w_windowId ]
) 
=> l_layerSets / nil"
"If only one layer set is selected in the Layer Set Manager, returns the layer set listed immediately below that layer set. If multiple layer sets are selected in the Layer Set Manager, returns a list comprising layer sets listed immediately below each selected layer set.")
("pteGetPrevLayerSets"
"pteGetPrevLayerSets(
[ w_windowId ]
) 
=> l_layerSets / nil"
"If only one layer set is selected in the Layer Set Manager, returns the layer set listed immediately above that layer set. If multiple layer sets are selected in the Layer Set Manager, returns a list comprising layer sets listed immediately above each selected layer set.")
("pteGetSelection"
"pteGetSelection(
t_panelName
[ w_windowId ]
) 
=> l_layerSetItems / nil"
"Retrieves a list of the selected layer-purpose pairs, objects, or grids from the specified panel.")
("pteHideAllTools"
"pteHideAllTools(
[ w_windowId ]
)
=> t / nil"
"Hides all Palette tools and toolbars.")
("pteImportLayerSet"
"pteImportLayerSet(
t_layerSetFilePath
t_layerSetRepositoryPath
t_layerSetName
[ g_overwrite ]
)
=> t / nil"
"Imports the specified layer set file from the file system to the Palette repository and saves it with the specified name.")
("pteInfraGetPaletteMode"
"pteInfraGetPaletteMode(
)
=> SingleAssistant / MultiAssistant / SingleWindow"
"Returns the container type of the Palette that is currently active.")
("pteIsSelectable"
"pteIsSelectable(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
) 
=> t / nil"
"Retrieves the selectability state for the specified layer-purpose pair or object (see also pteSetSelectable).")
("pteIsVisible"
"pteIsVisible(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
) 
=> t / nil"
"Retrieves the visibility state for the specified layer-purpose pair, object, or grid (see also pteSetVisible).")
("pteLoadConfig"
"pteLoadConfig(
t_configFilePath
[ w_windowId ]
) 
=> t / nil"
"Loads the specified Palette configuration file. A Palette configuration file contains Palette-related information, such as the columns and toolbars to be displayed and their location.")
("pteLoadDefaults"
"pteLoadDefaults(
[ w_windowId ]
) 
=> t / nil"
"Loads the display context with the default values. A display context determines display properties, such as visibility and selectability of layer-purpose pairs, objects, and grids.")
("pteLoadFromTechFile"
"pteLoadFromTechFile(
[ w_windowId ]
) 
=> t / nil"
"Loads the display context from the technology file into the Palette. A display context determines display properties such as visibility and selectability of layer-purpose pairs, objects, and grids.")
("pteLoadGDSNumber"
"pteLoadGDSNumber(
t_gdsNumberLayermapFilePath
[ w_windowId ]
) 
=> t / nil"
"Loads the GDS number layermap file from the specified location into the Palette.")
("pteLoadLayerSet"
"pteLoadLayerSet(
t_layerSetFileName
t_layerSetRepositoryPath
) 
=> t / nil"
"Loads a layer set from a layer set file existing in a palette repository.")
("pteLoadLSWInfo"
"pteLoadLSWInfo(
t_configFilePath
[ w_windowId ]
) 
=> t / nil"
"Loads the specified Layer Selection Window (LSW) information file into the Palette. The visibility and selectability settings stored in the LSW information file for layer-purpose pairs and objects are loaded into the Palette.")
("pteMapWindow"
"pteMapWindow(
t_assistantName
[ w_windowId ]
)
=> t / nil"
"Displays, if hidden, the specified Palette panel.")
("pteMinimizeSingleWindowPalette"
"pteMinimizeSingleWindowPalette(
)
=> t / nil"
"Minimizes the Palette, but only if the Palette container type is set to Single Window.")
("pteMoveLayerSelection"
"pteMoveLayerSelection(
x_position
[ w_windowId ]
)
=> t / nil"
"Moves the layer-purpose pairs selected in the Layers panel to the specified position. This function works only if the View By mode is set to None.")
("pteMoveSingleWindowPalette"
"pteMoveSingleWindowPalette(
x_xcoordinate
x_ycoordinate
)
=> t / nil"
"Places the upper-left corner of the Palette at the specified x- and y-coordinate, if the Palette container type is set to Single Window.")
("pteMPTSupportMode"
"pteMPTSupportMode(
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Displays the MPT-support-related Palette UI options.")
("pteOpenForm"
"pteOpenForm(
t_formName
[ w_windowId ]
)
=> t / nil"
"Displays the specified Palette form.")
("ptePropagateSelectability"
"ptePropagateSelectability(
{ t_layerPurposeName | t_paletteElementPath }
g_selectabilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Propagates selectability changes to child items when the parent and child items are in a desynchronized state. Specify either t_layerPurposeName or t_paletteElementPath.")
("ptePropagateVisibility"
"ptePropagateVisibility(
{ t_layerPurposeName | t_paletteElementPath }
g_visibilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Propagates visibility changes to child items when the parent and child items are in a desynchronized state. Specify either t_layerPurposeName or t_paletteElementPath.")
("pteRaiseSingleWindowPalette"
"pteRaiseSingleWindowPalette(
)
=> t / nil"
"Places the Palette on top of the other open windows, if the Palette container type is set to Single Window.")
("pteRegisterUserLSManagerTrigger"
"pteRegisterUserLSManagerTrigger(
t_funcName
)
=> t / nil"
"Registers a trigger, which is a user-defined SKILL procedure, from CIW. This trigger is called with an argument list containing modifier, mouseButton, event, editedLS, and activeLSList when an action (other than a drag-and-drop action) is performed in the Layer Set Manager.")
("pteRegisterUserSelectionTrigger"
"pteRegisterUserSelectionTrigger(
t_funcName
)
=> t / nil"
"Registers a trigger, which is a user-defined SKILL procedure, from CIW. This trigger is called with an argument list containing windowId, layerName, purposeName, mouseButton, and modifier for every selection action. Valid values for mouseButton are Left, Right, and Middle; valid values for modifier are None, Shift, and Ctrl.")
("pteReloadLayerSet"
"pteReloadLayerSet(
[ w_windowId ]
)
=> t / nil"
"Reloads the layer set file for the layer set that is currently in use. This resynchronizes the visibility and selectability status of the layers, objects, or grids items with that available in the layer set file.")
("pteResizeSingleWindowPalette"
"pteResizeSingleWindowPalette(
x_width
x_height
)
=> t / nil"
"Resizes the Palette by using the specified width and height values, if the Palette container type is set to Single Window.")
("pteSaveAsLayerSet"
"pteSaveAsLayerSet(
t_layerSetName
t_layerSetRepositoryPath
[ g_overwrite ]
[ w_windowId ]
)
=> t / nil"
"Saves the layer set currently in use with a new name.")
("pteSaveAsSynchronizedLayerSet"
"pteSaveAsSynchronizedLayerSet(
t_layerSetName
t_layerSetRepositoryPath
[ g_overwrite ]
[ w_windowId ]
)
=> t / nil"
"Saves the layer set currently in use, as a synchronized layer set, with the specified name in the specified layer set repository. The newly saved layer set is set as active.")
("pteSaveConfig"
"pteSaveConfig(
t_configFilePath
[ g_overwrite ]
[ w_windowId ]
) 
=> t / nil"
"Saves the Palette configuration information in the specified file. This includes information about the Palette settings, such as the columns and toolbars currently displayed in the Palette.")
("pteSaveGDSNumber"
"pteSaveGDSNumber(
g_overwrite
[ w_windowId ]
) 
=> t / nil"
"Saves the active GDSII number layermap file.")
("pteSaveLayerSet"
"pteSaveLayerSet(
[ w_windowId ]
)
=> t / nil"
"Saves the changes made to the layer set that is currently in use.")
("pteSaveLayerSetList"
"pteSaveLayerSetList(
[ w_windowId ]
)
=> t / nil"
"Saves the list of layer sets displayed in the Layer Set Manager to a file named layerset.order. The order in which the layer sets are listed and the enable state of each layer set is also saved.")
("pteSaveLayerSetListInRepository"
"pteSaveLayerSetListInRepository(
t_layerSetRepositoryPath
[ g_overwrite ]
[ w_windowId ]
)
=> t / nil"
"Saves the list of layer sets displayed in the Layer Set Manager to a file named layerset.order in the specified repository. The order in which the layer sets are listed and their state-whether enabled or disabled-is also saved.")
("pteSaveLSWInfo"
"pteSaveLSWInfo(
t_configFilePath
[ g_overwrite ]
[ w_windowId ]
)
=> t / nil"
"Saves the current LSW Info file at the specified location. This file contains information about the state of the Palette.")
("pteSaveToTechFile"
"pteSaveToTechFile(
[ w_windowId ]
) 
=> t / nil"
"Saves the display context from the Palette to the technology file. A display context determines display properties such as visibility and selectability of layer-purpose pairs, objects, and grids. The display context stored in individual layer sets is not considered.")
("pteSelect"
"pteSelect(
t_rowPath
t_panelName
[ w_windowId ]
)
=> t / nil"
"Selects the specified layer, object, or grid. An item selected previously is not deselected when you run the command again to select another item. This function works only if the Selection Mode is set to Multi Selection.")
("pteSelectAll"
"pteSelectAll(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Selects all items in the specified Palette panel. This function works only if the Selection Mode is set to Multi Selection.")
("pteSetActiveLpp"
"pteSetActiveLpp(
t_layerPurposeName
[ w_windowId ]
)
=> t / nil"
"Sets the specified layer-purpose pair as active. A layer that is not defined in the technology file is not displayed in the Palette, and an invalid layer cannot be set as active. Therefore, ensure that the specified layer is defined in the technology file and is valid.")
("pteSetActiveLppColor"
"pteSetActiveLppColor(
{ grayColor | mask1Color | mask2Color }
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Sets the specified color for the active layer-purpose pair. The lock state is set to unlocked.")
("pteSetActiveLppColorLock"
"pteSetActiveLppColorLock(
{ t | nil }
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Locks or unlocks the color on the active layer-purpose pair.")
("pteSetAllLayerSetMember"
"pteSetAllLayerSetMember(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets all specified layer-purpose pairs as members of the layer set that is currently in use.")
("pteSetAllLSEnable"
"pteSetAllLSEnable(
g_showState
[ w_windowId ]
)
=> t / nil"
"Enables or disables all the layer sets listed in the Layer Set Manager, except the one that is currently in use.")
("pteSetAllSelectable"
"pteSetAllSelectable(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets as selectable the specified items in the specified Palette panel.")
("pteSetAllStipple"
"pteSetAllStipple(
[ ?mode { Display | Selection } ]
[ ?only { t | nil } ]
[ ?panel { Layers } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets to visible the stipple for the specified layer-purpose pairs.")
("pteSetAllValidity"
"pteSetAllValidity(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets as valid the specified items in the specified Palette panel.")
("pteSetAllVisible"
"pteSetAllVisible(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets as visible the specified items in the specified Palette panel.")
("pteSetBindkeys"
"pteSetBindkeys(
)
=> t / nil"
"Opens the Bindkey Editor form to the Palette section, with the Palette bindkeys displayed in the right pane.")
("pteSetConfig"
"pteSetConfig(
t_configName
t_configValue
t_panelName
[ w_windowId ]
) 
=> t / nil"
"Assigns the specified configValue to the configName configuration parameter in the specified Palette panel.")
("pteSetFindModeOn"
"pteSetFindModeOn (
g_FindState
[ w_windowId ]
)
=> t / nil"
"Toggles the search mode for the specified window between Find and Filter.")
("pteSetLayerSetMember"
"pteSetLayerSetMember(
t_layerPurposeName
g_memberState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Adds or removes the specified layer-purpose pair from the layer set currently in use.")
("pteSetLppVisibleByString"
"pteSetLppVisibleByString(
t_searchPattern
g_visibilityState
[ w_windowId ]
)
=> t / nil"
"Searches for the specified search string based on the advanced search options (casing, match type, and search operator) set in the Layers panel, and sets the visibility state for all layer-purpose pairs that match the search criteria to the specified value.")
("pteSetLSActive"
"pteSetLSActive(
?layerSets t_layerSets
?turnOnVis { t | nil }
?turnOnSel { t | nil }
?turnOffAllVis { t | nil }
?turnOffAllSel { t | nil }
?deactivateOthers { t | nil }
[ w_windowId ]
)
=> t / nil"
"Activates one or more layer sets and can be used to force the visibility and selectability of the layer-purpose pairs contained in those layer sets. The visibility and selectability of layer-purpose pairs contained in layer sets previously set as active is affected only if the visibility or selectability of layer-purpose pairs contained in the layer set being set as active is forced.")
("pteSetLSEnable"
"pteSetLSEnable(
t_layerSetName
g_showState
[ w_windowId ]
)
=> t / nil"
"Enables or disables the specified layer set. The layer set currently in use cannot be disabled.")
("pteSetLSPosition"
"pteSetLSPosition(
t_layerSetName
x_position
[ w_windowId ]
)
=> t / nil"
"Moves the specified layer set to the specified position in the Layer Set Manager.")
("pteSetLSSelectable"
"pteSetLSSelectable(
t_layerSetName
g_selectabilityState
[ w_windowId ]
)
=> t / nil"
"Turns on or off the selectability state of all the layer-purpose pairs contained in the specified layer set.")
("pteSetLSVisible"
"pteSetLSVisible(
t_layerSetName
g_visibilityState
[ w_windowId ]
)
=> t / nil"
"Turns on or off the visibility state of all the layer-purpose pairs contained in the specified layer set.")
("pteSetMPTSupportMode"
"pteSetMPTSupportMode(
w_windowId
{ t | nil }
)
=> t / nil"
"(ICADVM20.1 Only) Enables or disables MPT support in the window with the specified ID.")
("pteSetNoneLayerSetMember"
"pteSetNoneLayerSetMember(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Removes from the active layer set all items that meet the specified criteria.")
("pteSetNoneSelectable"
"pteSetNoneSelectable(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Turns off the selectability of the specified items in the specified Palette panel.")
("pteSetNoneStipple"
"pteSetNoneStipple(
[ ?mode { Display | Selection } ]
[ ?only { t | nil } ]
[ ?panel { Layers } ]
[ ?window w_windowId ]
)
=> t / nil"
"Hides the stipple for the specified layer-purpose pairs.")
("pteSetNoneValidity"
"pteSetNoneValidity(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets as invalid the specified items in the specified Palette panel.")
("pteSetNoneVisible"
"pteSetNoneVisible(
[ ?mode { Display | Selection | Propagate } ]
[ ?only { t | nil } ]
[ ?panel { Layers | Objects | Grids } ]
[ ?window w_windowId ]
)
=> t / nil"
"Sets as invisible the specified items in the specified Palette panel.")
("pteSetOnlySelectable"
"pteSetOnlySelectable(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
)
=> t / nil"
"Turns on the selectability of the specified item in the specified panel. All other items in the specified panel are made non-selectable.")
("pteSetOnlySelectableWithDepth"
"pteSetOnlySelectableWithDepth(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
)
=> t / nil"
"Turns on the selectability of the specified layer-purpose pair and of the n layer-purpose pairs listed both above and below the specified layer-purpose pair in the Layers panel. The value n is obtained from the Depth for Selectability field in the Palette Options form. Selectability of all other layer-purpose pairs is turned off.")
("pteSetOnlyVisible"
"pteSetOnlyVisible(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
)
=> t / nil"
"Turns on the visibility of the specified item in the specified panel. All other items are made invisible.")
("pteSetOnlyVisibleWithDepth"
"pteSetOnlyVisibleWithDepth(
{ t_layerPurposeName | t_paletteElementPath }
t_panelName
[ w_windowId ]
)
=> t / nil"
"Turns on the visibility of the specified layer-purpose pair and of the n layer-purpose pairs listed both above and below the specified layer-purpose pair in the Layers panel. The value n is obtained from the Depth for Visibility field in the Palette Options form. Visibility of all other layer-purpose pairs is turned off.")
("pteSetOption"
"pteSetOption(
t_optionName
g_optionState
[ w_windowId ]
)
=> t / nil"
"Assigns a value to the specified Palette option.")
("pteSetOptionString"
"pteSetOptionString(
t_envName
t_envValue
[ w_windowId ]
)
=> t / nil"
"Changes the state of a Palette environment variable during a Virtuoso session.")
("pteSetRoutingDirection"
"pteSetRoutingDirection(
t_layerPurposeName
t_routingDirectionName
[ w_windowId ]
)
=> t / nil"
"Sets the routing direction for the specified layer-purpose pair.")
("pteSetSearchMatchCase"
"pteSetSearchMatchCase(
t_matchCaseType
t_panelName
[ w_windowId ]
)
=> t / nil"
"Specifies whether search is case-sensitive or case-insensitive.")
("pteSetSearchMatchType"
"pteSetSearchMatchType(
t_searchType
t_panelName
[ w_windowId ]
)
=> t / nil"
"Limits searches to items that match the search string, items with a specific prefix or suffix, or items that contain the search string as a substring.")
("pteSetSearchOperator"
"pteSetSearchOperator
t_searchOperator
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the default operator for the search criteria. Valid values are and, or, phrase, and not. Panel name is one of Layers, Objects, or Grids.")
("pteSetSearchText"
"pteSetSearchText(
t_searchPattern
t_panelName
[ w_windowId ]
)
=> t / nil"
"Searches for the specified search string based on the casing, match type, and search operator set for the panel in which the search is to be performed.")
("pteSetSelectable"
"pteSetSelectable(
{ t_layerPurposeName | t_paletteElementPath }
g_selectabilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the selectability state for the specified item (see also pteIsSelectable).")
("pteSetSelectableWithDepth"
"pteSetSelectableWithDepth(
{ t_layerPurposeName | t_paletteElementPath }
g_selectabilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the selectability for the specified layer-purpose pair and for the n layer-purpose pairs listed both above and below the specified layer-purpose pair in the Layers panel. The value n is obtained from the Depth for Selectability field in the Palette Options form.")
("pteSetShowLockedColors"
"pteSetShowLockedColors(
{ t | nil }
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Displays or hides the colors locked on shapes.")
("pteSetShowUnlockedColors"
"pteSetShowUnlockedColors(
{ t | nil }
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Displays or hides the unlocked colors on shapes.")
("pteSetStipple"
"pteSetStipple(
{ t_layerPurposeName | t_paletteElementPath }
g_stippleVisibilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the stipple visibility state for the specified layer-purpose pair.")
("pteSetValidity"
"pteSetValidity(
{ t_layerPurposeName | t_paletteElementPath }
g_validityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the validity state for the specified item.")
("pteSetVisible"
"pteSetVisible(
{ t_layerPurposeName | t_paletteElementPath }
g_visibilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the visibility state for the specified item (see also pteIsVisible).")
("pteSetVisibleWithDepth"
"pteSetVisibleWithDepth(
{ t_layerPurposeName | t_paletteElementPath }
g_visibilityState
t_panelName
[ w_windowId ]
)
=> t / nil"
"Sets the visibility for the specified layer-purpose pair and for the n layer-purpose pairs listed both above and below the specified layer-purpose pair in the Layers panel. The value n is obtained from the Depth for Visibility field in the Palette Options form.")
("pteSetWindowSynchro"
"pteSetWindowSynchro(
g_synchronizedState
[ w_windowId ]
)
=> t / nil"
"Synchronizes or desynchronizes the Palette.")
("pteShowAllTools"
"pteShowAllTools(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Displays all the toolbars in the specified Palette panel.")
("pteShowMPTLPP"
"pteShowMPTLPP(
{ t | nil }
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Displays in the Layers panel only those layer-purpose pairs that have color information.")
("pteShowRoutingLPP"
"pteShowRoutingLPP(
g_filterState
[ w_windowId ]
)
=> t / nil"
"Displays only the routing layer-purpose pairs in the Layers panel.")
("pteShowUsedLPP"
"pteShowUsedLPP(
g_filterState
[ w_windowId ]
)
=> t / nil"
"Displays only the currently used layer-purpose pairs in the Layers panel.")
("pteShowValidLPP"
"pteShowValidLPP(
g_filterState
[ w_windowId ]
)
=> t / nil"
"Displays only valid layer-purpose pairs in the Layers panel.")
("pteToggleAllLayerSetMember"
"pteToggleAllLayerSetMember(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the layer set membership status of all the items in the specified panel.")
("pteToggleAllSelectable"
"pteToggleAllSelectable(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the selectability status of all the items listed in the specified panel.")
("pteToggleAllStipple"
"pteToggleAllStipple(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the stipple visibility status of all the layer-purpose pairs in the specified panel.")
("pteToggleAllTools"
"pteToggleAllTools(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the display status of all toolbars in the specified panel.")
("pteToggleAllValidity"
"pteToggleAllValidity(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the validity status of all the items in the specified panel.")
("pteToggleAllVisible"
"pteToggleAllVisible(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the visibility status of all the items listed in the specified panel.")
("pteToggleLayerSetEdition"
"pteToggleLayerSetEdition(
[ w_windowId ]
)
=> t / nil"
"Displays or hides the membership status of layer-purpose pairs.")
("pteToggleLayerSetValidityEdition"
"pteToggleLayerSetValidityEdition(
[ w_windowId ]
)
=> t / nil"
"Displays or hides the validity and membership status of layer-purpose pairs.")
("pteToggleLSActive"
"pteToggleLSActive(
?layerSets t_layerSetName
[ ?toggleVis { t | nil } ]
[ ?toggleSel { t | nil } ]
[ w_windowId ]
)
=> t / nil"
"Adds or removes the specified layer set from the list of active layer sets. Additionally, toggles the visibility and selectability status of the various layer-purpose pairs contained in the layer set.")
("pteTogglePanels"
"pteTogglePanels(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Displays the contents of the specified panel and hides the other two panels.")
("pteTogglePropagateAllSelectable"
"pteTogglePropagateAllSelectable(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the selectability status of all parent and child items in the specified panel.")
("pteTogglePropagateAllVisible"
"pteTogglePropagateAllVisible(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the visibility status of all parent and child items in the specified panel.")
("pteToggleShowMPTLPP"
"pteToggleShowMPTLPP (
[ w_windowId ]
)
=> t / nil"
"(ICADVM20.1 Only) Toggles the display of layer-purpose pairs in the Layers panel between all layer-purpose pairs and layer-purpose pairs with color information.")
("pteToggleShowRoutingLPP"
"pteToggleShowRoutingLPP(
[ w_windowId ]
)
=> t / nil"
"Toggles the display of layer-purpose pairs in the Layers panel between routing layer-purpose pairs and all layer-purpose pairs.")
("pteToggleShowUsedLPP"
"pteToggleShowUsedLPP(
[ w_windowId ]
)
=> t / nil"
"Toggles the display of layer-purpose pairs in the Layers panel between currently used layer-purpose pairs and all layer-purpose pairs.")
("pteToggleShowValidLPP"
"pteToggleShowValidLPP(
[ w_windowId ]
)
=> t / nil"
"Toggles the display of layer-purpose pairs in the Layers panel between valid layer-purpose pairs and all layer-purpose pairs.")
("pteToggleToolbars"
"pteToggleToolbars(
t_panelName
[ w_windowId ]
)
=> t / nil"
"Toggles the display status of all toolbars in the specified panel.")
("pteToggleWindowSynchro"
"pteToggleWindowSynchro(
[ w_windowId ]
)
=> t / nil"
"Synchronizes or desynchronizes the Palette.")
("pteUndockWindow"
"pteUndockWindow(
t_assistantName
[ w_windowId ]
) 
=> t / nil"
"Undocks the specified Palette panel.")
("pteUnmapWindow"
"pteUnmapWindow(
t_assistantName
[ w_windowId ]
)
=> t / nil"
"Unmaps (hides, if displayed) the specified Palette panel.")
("pteUnRegisterUserLSManagerTrigger"
"pteUnRegisterUserLSManagerTrigger(
) 
=> t / nil"
"Unregisters the SKILL procedure that was registered using pteRegisterUserLSManagerTrigger.")
("pteUnRegisterUserSelectionTrigger"
"pteUnRegisterUserSelectionTrigger(
) 
=> t / nil"
"Unregisters the SKILL procedure that was registered using pteRegisterUserSelectionTrigger.")
("pteUnsetLSActive"
"pteUnsetLSActive(
?layerSets t_layerSets
?turnOffAllVis { t | nil }
?turnOffAllSel { t | nil }
[ w_windowId ]
)
=> t / nil"
"Deactivates one or more layer sets and can be used to force the visibility and selectability of the layer-purpose pairs contained in those layer sets.")
("leCycleSnapPatternDisplay"
"leCycleSnapPatternDisplay(
[ w_windowId ]
)
=> t_snapPatternDisplayMode"
"(ICADVM20.1 Only) Sets the snap pattern display to the next value in the Snap Pattern Display option, in the order of full, tracks, boundary, and periods.")
("leGetGlobalGridsVisible"
"leGetGlobalGridsVisible(
)
=> t / nil"
"(ICADVM20.1 Only) Returns the visibility setting of global snap pattern grids.")
("leGetLocalGridsVisible"
"leGetLocalGridsVisible(
)
=> t / nil"
"(ICADVM20.1 Only) Returns the visibility setting of local snap pattern grids.")
("leGetSnapPatternVisible"
"leGetSnapPatternVisible(
t_spDefName
)
=> t / nil"
"(ICADVM20.1 Only) Returns the visibility setting of snap pattern grid with the specified name.")
("leGetSnapToSPTransform"
"leGetSnapToSPTransform(
figId
[ ?snapPatternDepth n_snapPatternDepth ]
[ ?movingItemDepth n_movingItemDepth ]
[ ?snapPatternLPP g_snapPatternLPP ]
)
=> x_InstTransform"
"(ICADVM20.1 Only) Returns the transform required to align the given figure with an underlying snap pattern or global grid. If a transform is not found, the function returns the identity transform.")
("leGetWidthSpacingGridsVisible"
"leGetWidthSpacingGridsVisible(
)
=> t / nil"
"(ICADVM20.1 Only) Returns the visibility setting of width spacing snap pattern grids.")
("leGetWidthSpacingSnapPatternVisible"
"leGetWidthSpacingSnapPatternVisible(
t_wspName
)
=> t / nil"
"(ICADVM20.1 Only) Returns the visibility setting of the specified width spacing snap pattern grid.")
("leSetGlobalGridsVisible"
"leSetGlobalGridsVisible(
g_isVisible
)
=> t / nil"
"(ICADVM20.1 Only) Turns on or off the visibility of global snap pattern grids.")
("leSetLocalGridsVisible"
"leSetLocalGridsVisible(
g_isVisible
)
=> t / nil"
"(ICADVM20.1 Only) Turns on or off the visibility of local snap pattern grids.")
("leSetSnapPatternVisible"
"leSetSnapPatternVisible(
t_spDefName
g_isVisible
)
=> t / nil"
"(ICADVM20.1 Only) Turns on or off the visibility of the specified snap pattern grid.")
("leSetWidthSpacingSnapPatternVisible"
"leSetWidthSpacingSnapPatternVisible (
t_gridName
g_isVisible
)
=> t / nil"
"(ICADVM20.1 Only) Turns on or off the visibility of the specified width spacing snap pattern grid.")
("leToggleAllGravity"
"leToggleAllGravity(
)
=> t"
"(ICADVM20.1 Only) Toggles the gravity and rule gravity settings. If the values of gravity (cdsenv gravityOn) and rule gravity (cdsenv ruleGravityOn) are different, leToggleAllGravity() turns on the value of both the environment variables to make them equal.")
("wspCheckActive"
"wspCheckActive(
d_cellviewId 
t_layerName | ?shapes g_selSetId 
[ ?region l_bBox ] 
[ ?purpose t_purposeName ] 
[ ?hilightSet g_hlSetId ] 
[ ?markers g_markers [ ?vioLimit g_limit ] ] 
[ ?checkColor g_checkColor ] 
[ ?checkWidth g_checkWidth ] 
[ ?checkWireType g_checkWireType ] 
[ ?depth x_depth ] 
[ ?mergeShapes g_mergeShapes [ ?ignoreColorOnMerge g_ignoreColor ] ] 
[ ?mergePurposes l_mergePurposes ]
[ ?returnVioShapes g_returnVioShapes ]
[ ?excludeBlockageCheck g_excludeBlockageCheck ]
[ ?ignoreValidJogs g_ignoreValidJogs ]
)
=> t / l_dbID / nil"
"(ICADVM20.1 Only) Checks shapes and blockages for width, color, and wireType conformance to the active width spacing pattern (WSP) on the specified layer or in the specified set. The active WSP can be for the global grid or a pattern region.")
("wspCreateWSP"
"wspCreateWSP (
d_cellViewId 
t_name 
[ ?offset n_offset ] 
[ ?repeatOffset g_repeatOffset ] 
[ ?shiftColor g_shiftColor ] 
[ ?allowedRepeatMode t_allowedRepeatMode ]
[ ?defaultRepeatMode t_defaultRepeatMode ]
[ ?wsspDef t_wsspDefName ]
n_width n_space [ repeat n_repeats ] [ wireType t_wireType ] [ color n_mask ] [ displayPacket t_displayPacket ]
)
=> d_wspId"
"(ICADVM20.1 Only) Creates a WSP in the specified cellview. If the WSP already exists, it is replaced. This function creates simple WSPs and not nested lists. It checks the shapes for width, color, and wire type conformance to the active width spacing pattern (WSP) on the specified layer or set. The active WSP can be for the global grid or a pattern region.")
("wspCreateWSPByAttr"
"wspCreateWSPByAttr (
d_cellViewId 
list (nil
	'name t_name
	'offset n_offset
	'shiftColor g_shiftColor
	'repeatOffset g_repeatOffset
	'allowedRepeatMode t_allowedRepeatMode
	'defaultRepeatMode t_defaultRepeatMode
	tracks  ( list(nil
			'width n_width
			'space n_space
			[ 'wireType t_wireType ]
			[ 'color t_color ]
			[ 'displayPacket t_displayPacket ]
			 )
)
)
=> d_wspId"
"(ICADVM20.1 Only) Creates a WSP. The pattern attributes are specified as a DPL. This function is specified with the wspGetFlatAttr function, which returns an existing pattern as a DPL. It lets you convert the existing patterns to a DPL, modify them, and recreate them.")
("wspCreateWSPGroup"
"wspCreateWSPGroup (
d_cellViewId 
t_name
l_members
) 
=> d_wspGroupId"
"(ICADVM20.1 Only) Creates a WSP group in the specified cellview. The argument after t_name are interpreted as group members. ")
("wspCreateWSSPDef"
"wspCreateWSSPDef (
d_cellViewId 
t_name
tx_layer
t_direction
n_period
[ ?defaultActive t_defaultActive ]
[ ?allowedPatterns l_patterns ]
[ ?allowedPatternGroups l_groups ]
[ ?defPurpose tx_purpose ]
[ ?offset n_offset ]
[ ?orthogonalGrid t_orthogonalGrid]
) 
=> d_wsspDefId"
"(ICADVM20.1 Only) Creates a WSSPDef in the specified cellview. If t_defaultActive is specified, the WSSPDef is created immediately. If it is not specified, the creation of WSSPDef is deferred until the first call to the function wspCreateWSP that references this WSSPDef. This enables all WSSPDefs to be specified first, followed by calls to wspCreateWSP that reference the WSSPDef.")
("wspCreateWSSPDefByAttr"
"wspCreateWSSPDefByAttr (
d_cellViewId 
l_attrs
) 
=> d_wspId"
"(ICADVM20.1 Only) Creates a WSSPDef using an attribute DPL.")
("wspDeleteCellViewAllWSPData"
"wspDeleteCellViewAllWSPData (
d_cellViewId
) 
=> t / nil"
"(ICADVM20.1 Only) Deletes all the WSP data from the specified cellview.")
("wspDeleteMetalFill"
"wspDeleteMetalFill (
t_LayerName
?removeTrim g_removeTrim
?removePatch g_removePatch
?removePassive g_removePassive
) 
=> t / nil"
"(ICADVM20.1 Only) Deletes the shapes created by the wspMetalFillTrim() function.")
("wspDumpToFile"
"wspDumpToFile (
d_cellViewId 
t_fileName
) 
=> t / nil"
"(ICADVM20.1 Only) Creates a SKILL file that can be used to recreate the WSP information in the specified cellview.")
("wspGetLineEndGrids"
"wspGetLineEndGrids (
d_cellViewId 
t_layerName
) 
=> l_gridNames / nil"
"(ICADVM20.1 Only) Returns a list of line-end grid names for the specified layer.")
("wspGetWSSPDefLP"
"wspGetWSSPDefLP(
d_wsspDefId 
) 
=> t_layerName t_purposeName"
"(ICADVM20.1 Only) Returns the layer and purpose name of a widthSpacingSnapPatternDef.")
("wspMetalFillTrim"
"wspMetalFillTrim (
d_cellViewId 
t_LayerName
?region l_region
?passivePurpose t_passiveFillPurpose
?patchFillPurpose t_patchFillPurpose
?gapFillPurpose t_gapFillPurpose
?lockColor g_lockColor
?boundaryCut g_boundaryCut
?forceBoundaryCut g_forceBoundaryCut
?insertFillOnly g_insertFillOnly
?insertTrimOnly g_insertTrimOnly
?allowTrimWithError g_allowTrimWithError
?horizontal t_horizontal
?snapToOrthGrid t_snapToOrthGrid
?ctrlFile t_ctrlFileName
) 
=> t / nil"
"(ICADVM20.1 Only) Fills metal shapes based on WSP tracks and inserts trim shapes as needed.")
("wspRegionFindByLayer"
"wspRegionFindByLayer (
d_cellViewId 
t_routingLayerName
) 
=> l_regionIds"
"(ICADVM20.1 Only) Returns a list of the WSP region IDs for the specified routing layer name in a cellview.")
("wspRegionFindByWSSPDef"
"wspRegionFindByWSSPDef (
d_cellViewId 
t_WSSPDefName
) 
=> l_regionIds"
"(ICADVM20.1 Only) Returns a list of region IDs in the specified cellview for a WSSPDef.")
("wspRegionGetActivePattern"
"wspRegionGetActivePattern(
d_regionId 
) 
=> t_activePatternName"
"(ICADVM20.1 Only) Returns the name of the active pattern for a WSP region.")
("wspRegionGetAllowedPatternGroups"
"wspRegionGetAllowedPatternGroups (
d_regionId 
) 
=> l_allowedPatternGroupNames"
"(ICADVM20.1 Only) Returns a list of names of allowed pattern groups for the specified WSP region.")
("wspRegionGetAllowedPatterns"
"wspRegionGetAllowedPatterns (
d_regionId 
[ ?excludeGroups g_excludeGroups ]
) 
=> l_allowedPatternNames"
"(ICADVM20.1 Only) Returns a list with the names of the allowed patterns for a WSP region. By default, this function returns the effective set of patterns by combining the allowed patterns and allowed pattern groups. You can use the g_excludeGroups argument to ignore the allowed pattern groups.")
("wspRegionGetWSSPDef"
"wspRegionGetWSSPDef(
d_regionId 
) 
=> d_wsspDefId"
"(ICADVM20.1 Only) Returns the ID of the WSSPDef to which the specified region is bound.")
("wspSetWSSPDefRegionPurpose"
"wspSetWSSPDefRegionPurpose (
d_wsspDefId 
t_purposeName
) 
=> t / nil"
"(ICADVM20.1 Only) Overrides the region purpose attribute for the specified WSSPDef.")
("wspSPDefFind"
"wspSPDefFind (
d_cellViewId 
t_layerName 
[ ?enabledOnly g_enabledOnly ]
) 
=> l_spdef / nil"
"(ICADVM20.1 Only) Finds all the snapPatternDefs (SPDefs) that apply to the specified routing layer name. In a cellview, one SPDef or WSSPDef per layer is enabled as a global grid. With the optional argument g_enabledOnly set to t, WSSPDefs that are enabled as global for the specified routing layer are returned.")
("wspWSPFindByName"
"wspWSPFindByName (
d_cellViewId 
t_wspname 
[ cellViewOnly g_cellViewOnly ]
) 
=> d_wspId"
"(ICADVM20.1 Only) Finds a WSP by name in a cellview or in the technology database.")
("wspWSPGetFlatAttr"
"wspWSPGetFlatAttr (
d_wspId 
[ ?numMasks n_numMasks ]
) 
=> l_wspAttrs"
"(ICADVM20.1 Only) Return the attributes of a WSP as a DPL.")
("wspWSPGroupFindByName"
"wspWSPGroupFindByName (
d_cellViewId 
t_wspname 
[ cellViewOnly g_cellViewOnly ]
) 
=> d_wspGroupId"
"(ICADVM20.1 Only) Finds a WSP group by its name in a cellview or in the technology database.")
("wspWSSPDefAddToAllowedPatternGroups"
"wspWSSPDefAddToAllowedPatternGroups(	
d_cellViewId 
t_wsspDefName 
t_patternGroupName
)
=> t / nil"
"(ICADVM20.1 Only) Adds a WSP group to the list of allowed pattern groups for a WSSPDef.")
("wspWSSPDefAddToAllowedPatterns"
"wspWSSPDefAddToAllowedPatterns(
d_cellViewId 
t_wsspDefName 
t_patternName
)
=> t / nil"
"(ICADVM20.1 Only) Adds a WSP to the allowed patterns for a WSSPDef.")
("wspWSSPDefAddToEnabled"
"wspWSSPDefAddToEnabled(	
d_cellViewId
l_wsspDefName
)
=> t / nil"
"(ICADVM20.1 Only) Adds a list of WSSPDefs to the list of WSSPDefs enabled as global grids in the specified cellview. This will filter out any duplicate, undefined wsspDefs, and wsspDefs with direction mis-match.")
("wspWSSPDefClearEnabledOverrides"
"wspWSSPDefClearEnabledOverrides(
d_cellViewId
)
=> t / nil"
"(ICADVM20.1 Only) Removes any global grid overrides from the specified cellview.")
("wspWSSPDefFind"
"wspWSSPDefFind (
d_cellViewId 
t_layerName 
[ ?enabledOnly g_enabledOnly ]
) 
=> l_wsspDefIds"
"(ICADVM20.1 Only) Returns a list of WSSPDefs that apply to a given routing layer name. The WSSPDefs may exist in the cellview or in the technology database. With the optional argument g_enabledOnly set to t, routing WSSPDefs that are enabled as global for the given layer are returned.")
("wspWSSPDefFindByName"
"wspWSSPDefFindByName (
d_cellViewId 
t_wspname 
[ ?cellViewOnly g_cellViewOnly ]
) 
=> d_wsspDefId"
"(ICADVM20.1 Only) Finds a WSSPDef by its name in a cellview or technology database.")
("wspWSSPDefGetActivePattern"
"wspWSSPDefGetActivePattern(
d_cellViewId
d_wsspDefId
)
=> t_activePatternName"
"(ICADVM20.1 Only) Returns the active pattern name for a WSSPDef in the specified cellview. The active pattern may be set by a constraint in the cellview or from the WSSPDef in the cellview or technology database.")
("wspWSSPDefGetAllowedPatternGroups"
"wspWSSPDefGetAllowedPatternGroups(
d_cellViewId
d_wsspDefId

)
=> l_allowedPatternGroupNames"
"(ICADVM20.1 Only) Returns a list with the names of the allowed pattern groups for the specified WSSPDef.")
("wspWSSPDefGetAllowedPatterns"
"wspWSSPDefGetAllowedPatterns(
d_cellViewId 
d_wsspDefId
[ ?excludeGroups g_excludeGroups ]
)
=> l_allowedPatternNames"
"(ICADVM20.1 Only) Returns a list of names of allowed WSPs for a given WSSPDef in the specified cellview. A WSSPDef has a list of allowed patterns and allowed pattern groups. The effective set of allowed patterns is a combination of the allowed WSPs and a WSP that is a member of an allowed pattern group. By default, this function returns the effective set of allowed patterns. You can use the g_excludeGroups argument to get only the directly allowed WSPs.")
("wspWSSPDefGetAttr"
"wspWSSPDefGetAttr (
d_wsspDefId 
) 
=> l_wsspDefAttrs"
"(ICADVM20.1 Only) The attributes of the specified WSSPDef are converted to a DPL format. All the of attribute representations are the same as the source representation, except the snappingLayers attribute, which is stored as an association table for LPP look up.")
("wspWSSPDefGetEnabledOverrides"
"wspWSSPDefGetEnabledOverrides (
d_cellViewId 
[ ?direction t_direction ]
) 
=> l_wsspDefNames"
"(ICADVM20.1 Only) Returns the names of all the WSSPDefs in the specified direction that are enabled as global grids. The WSSPDef direction is orthogonal to the routing direction. This filters out any duplicates, undefined wsspDefs, and wsspDefs with a direction mis-match.")
("wspWSSPDefRemoveFromAllowedPatternGroups"
"wspWSSPDefRemoveFromAllowedPatternGroups(
d_cellViewId
t_wsspDefName
t_patternGroupName
)
=> t / nil"
"(ICADVM20.1 Only) Removes a pattern group from the allowed pattern groups of a WSSPDef.")
("wspWSSPDefRemoveFromAllowedPatterns"
"wspWSSPDefRemoveFromAllowedPatterns(	
d_cellViewId
t_wsspDefName
t_patternName

=> t / nil"
"(ICADVM20.1 Only) Removes a WSP from the allowed patterns of the specified cellview. This function only removes the directly-allowed WSP. If a pattern is allowed because it is a member of an allowed pattern group, then no update is made.")
("wspWSSPDefRemoveFromEnabled"
"wspWSSPDefRemoveFromEnabled(
d_cellViewId 
l_wsspDefName
)
=> t / nil"
"(ICADVM20.1 Only) Removes the specified WSSPDefs from the list of WSSPDefs that are enabled as global grids in the cellview.")
("wspWSSPDefRename"
"wspWSSPDefRename (
d_wsspDef 
t_newName
) 
=> d_wsspDefId"
"(ICADVM20.1 Only) Renames a WSSPDef by deleting and recreating it. So, the DB ID may change. This function updates the global grid and any regions that reference the WSSPDef.")
("wspWSSPDefSetActivePattern"
"wspWSSPDefSetActivePattern(
d_cellViewId 
t_wsspDefName
t_defaultActiveName
)
=> t / nil"
"(ICADVM20.1 Only) Sets the default active WSP for a WSSPDef in the specified cellview.")
("wspWSSPDefSetAllowedPatternGroups"
"wspWSSPDefSetAllowedPatternGroups(
d_cellViewId 
t_wsspDefName
l_patternGroupNames
)
=> t / nil"
"(ICADVM20.1 Only) Sets the allowed pattern groups for a WSSPDef in the specified cellview.")
("wspWSSPDefSetAllowedPatterns"
"wspWSSPDefSetAllowedPatterns(
d_cellViewId 
t_wsspDefName
l_patternNames
[ ?keepGroups g_keepGroups ]
)
=> t / nil"
"(ICADVM20.1 Only) Sets the allowed patterns for a WSSPDef in the specified cellview. If the WSSPDef is enabled as global, the patterns apply to the global grid of the WSSPDef and to any regions for the WSSPDef for which the allowed patterns are not overridden.")
("wspWSSPDefSetEnabledOverrides"
"wspWSSPDefSetEnabledOverrides(
d_cellViewId 
l_wsspDefNames
[ ?direction t_direction ]
)
=> t / nil"
"(ICADVM20.1 Only) Overrides the global grid in the specified cellview and by enabling the specified list of WSSPDefs as global grids. If the l_wsspDefNames argument does not contain any WSSPDef in a direction, there is no global grid for that direction even if the technology database specifies a global grid for that direction.")
("tpaSelectWSSPDef"
"tpaSelectWSSPDef(
t_defName 
)
=> t / nil"
"(ICADVM20.1 Only) Selects the specified WSSPDef on the Track Pattern Assistant. This is similar to selecting the WSSPDef in the Track Pattern Assistant.")
("tpaSetActivePattern"
"tpaSetActivePattern(
t_defName 
t_activePatternName
)
=> t / nil"
"(ICADVM20.1 Only) Sets the active pattern for the given width spacing snap pattern definition (WSSPDef).")
("tpaSetAllDefsVisible"
"tpaSetAllDefsVisible(
g_visible
)
=> t / nil"
"(ICADVM20.1 Only) Sets the visibility of the active WSSPDefs to All Visible (AV) or None Visible (NV) for a cellview.")
("tpaSetDefVisible"
"tpaSetDefVisible(
t_defName 
g_visible
)
=> t / nil"
"(ICADVM20.1 Only) Sets the visibility of the active pattern for the given WSSPDef or snap pattern definition (SPDef) in the Track Pattern table. If the WSSPDef or SPDef is enabled in the Track Pattern table, this also controls the visibility of the active pattern in the canvas.")
("tpaSetFilterByName"
"tpaSetFilterByName(
t_filterName 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the related snap pattern (RSP) filter by name or by other filters specified in the Track Pattern assistant.")
("tpaSetFilterByNumber"
"tpaSetFilterByNumber(
x_filterNumber 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the Track Pattern Assistant Filter field using the list order number for the desired setting.")
("tpaSetWireType"
"tpaSetWireType(
t_wspDefName 
l_wireTypeNames 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the active wire types for the active width spacing pattern (WSP) of the given WSSPDef.")
("tpaToggleDef"
"tpaToggleDef(
t_defName 
g_enabled 
)
=> t / nil"
"(ICADVM20.1 Only) Enables or disables the specified WSSPDef or SPDef.")
("tpaToggleLayer"
"tpaToggleLayer(
t_layerName 
g_visible 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the visibility for the active pattern of the enabled WSSPDef or SPDef on the given snapping layer.")
("abGetCurrentIncompleteNetFilter"
"abGetCurrentIncompleteNetFilter(
w_windowID 
)
=> t_filterState / nil"
"Returns the incomplete net filter currently applied on the specified window. An incomplete net filter is used to control the display of incomplete net markers in the Connectivity tab of the Annotation Browser assistant by showing or hiding a subset of net names.")
("abHiFindMarker"
"abHiFindMarker(
[ w_windowID ]
)
=> t / nil"
"In the specified window, selects the row corresponding to a marker in the Annotation Browser when the corresponding marker object is clicked in the layout canvas. Even though the marker object is selected in the layout canvas, this does not modify the selection in the canvas. If the corresponding marker is not displayed in the Annotation Browser due to the applied filtering, nothing is selected in the Annotation Browser. If a window ID is not specified, the current window is used.")
("abSetIncompleteNetFilter"
"abSetIncompleteNetFilter(
w_windowID
t_filterState { Show | Hide }
l_netNamess
g_enable
)
=> t / nil"
"Sets the specified incomplete net filter state for the specified list of nets in the given window. An incomplete net filter is used to control the display of incomplete net markers in the Connectivity tab of the Annotation Browser assistant by showing or hiding a subset of net names.")
("bndAddInstsBindingByName"
"bndAddInstsBindingByName(
d_schCellViewID 
t_schInstName 
d_layCellViewID 
t_layInstName 
)
=> t / nil"
"Adds a named instance to an existing binding. If no binding exists, a new one is created. The schematic and layout instances must both be leaf instances. You can also use bndSetInstsBindingByName() to add the first binding and then add additional bindings to the same source or target instance by using the bndAddInstBindingByName() SKILL function.")
("bndAddObjectsBinding"
"bndAddObjectsBinding(
d_schDbID
d_layDbID

=> t / nil"
"Adds one or more objects to an existing binding. If no binding exists, a new binding is created. The specified objects must all be leaf-level instances. For more information on leaf-level instances, see Additional Information.")
("bndGetBoundObjects"
"bndGetBoundObjects(
d_dbID
[ d_layCV ]
)
=> l_list_of_dbIDs / nil"
"Returns a list of objects bound to a specified object. The object ID of the bound objects can be specified in different formats. See the argument description for more information.")
("bndGetSiblingBoundObjects"
"bndGetSiblingBoundObjects(
d_dbID
[ d_layCV ]
)
=> ( dbID membInst row col ) / ( list_of_dbIDs )"
"Returns the objects bound in the same many-to-many relationship as the specified object, or the objects bound to the same mfactored, sfactored, folded or lxCombination instance as the specified object. However, the specified object is not included in the result. The object ID can be specified in different formats. See the argument description for more information. ")
("bndRemoveInstBindingByName"
"bndRemoveInstBindingByName(
d_dbCellViewID
t_objName
[ d_dbCellViewID ]
)
=> t / nil"
"Removes the binding of a named instance.")
("bndRegRemoveDeviceGetSurvivingNet"
"bndRegRemoveDeviceGetSurvivingNet(
S_function
)
=> t / nil"
"Registers a user-defined SKILL function that takes a list of net IDs and returns the ID of the single net that survives when devices are removed during layout generation.")
("bndRemoveObjectBinding"
"bndRemoveObjectBinding(
d_dbID
[ d_layCV ]
)
=> t / nil"
"Removes the binding of the specified objects. The object ID can be specified in different formats. See the argument description for more information.")
("bndRemoveTermBindingByName"
"bndRemoveTermBindingByName(
d_cellViewID
t_name
)
=> t / nil"
"Removes the binding from a named terminal.")
("bndReplaceInstsBindingByName"
"bndReplaceInstsBindingByName(
d_schCellViewID
t_schInstName
d_layCellViewID
t_layInstName
)
=> t / nil"
"Sets a binding between specified schematic and layout instances, replacing any existing bindings in the process. The specified instances must all be leaf objects.")
("bndReplaceObjectsBinding"
"bndReplaceObjectsBinding(
d_schDbID
d_layDbID
)
=> t / nil"
"Sets a binding between specified schematic and layout objects, replacing any existing bindings in the process. The specified objects must all be leaf objects.")
("bndReplaceTermsBindingByName"
"bndReplaceTermsBindingByName(
d_schCellViewID
t_schTermName
d_layCellViewID
t_layTermName
)
=> t / nil"
"Sets a binding between specified schematic and layout terminals, replacing any existing bindings in the process. The specified terminals must all be leaf objects.")
("bndSetInstsBindingByName"
"bndSetInstsBindingByName(
d_schCellViewID
t_schInstName
d_layCellViewID
t_layInstName
)
=> t / nil"
"Sets a binding between specified schematic and layout instances. Any existing bindings are removed and a new one created. The specified instances must all be leaf instances.")
("bndSetObjectsBinding"
"bndSetObjectsBinding(
d_schDbID
d_layDbID
)
=> t / nil"
"Set a binding between schematic and layout objects. The specified objects must be leaf objects and must not be bound already. The object ID can be specified in different formats. See the argument description for more information.")
("bndSetTermsBindingByName"
"bndSetTermsBindingByName(
d_schCellViewID
t_schTermName
d_layCellViewID
t_layTermName
)
=> t / nil"
"Sets a binding between specified schematic and layout terminals. The specified terminals must not already be bound.")
("bndUnregRemoveDeviceGetSurvivingNet"
"bndUnregRemoveDeviceGetSurvivingNet(
)
=> t / nil"
"Unregisters the user-defined SKILL function that is used to get the ID of the surviving net when devices are removed during layout generation.")
("dbSetSoftConnectTermConnectToLayer"
"dbSetSoftConnectTermConnectToLayer(
d_termID
tx_layer
)
=> t / nil"
"Sets a connect-to-layer value on a soft-connect terminal that indicates the layer name to which the terminal must connect.")
("dbSetSoftConnectTermPinlessLayer"
"dbSetSoftConnectTermPinlessLayer(
d_termID
tx_layer
)
=> t / nil"
"Sets a soft-connect terminal as a pinless layer based on the layer name value you specify. If you specify a text value, the corresponding definition must exist in the current tech database. The pinless layer attribute can be set only on a soft-connect terminal. Setting the value on a non-soft-connect terminal generates an error.")
("dbSetTermSoftConnect"
"dbSetTermSoftConnect(
d_termID
g_value
)
=> t / nil"
"Sets the soft-connect attribute of an instance terminal to a specific value if the existing value is different from the value you specify.")
("lceAddSimpleStopLayers"
"lceAddSimpleStopLayers(
libName
l_LayerNamePairs
)
=> x_derivedLayers / nil"
"Adds simple derived layers to the validLayers section of the technology file that has the virtuosoDefaultExtractorSetup constraint group defined. This SKILL function can be useful for adding simple stop layers in memory when the technology file cannot be edited on disk. If a stop layer is added and the second layer has an unknown material, the material is automatically changed to recognition. If you add an invalid stop layer, you must close the design or launch a new Virtuoso session to refresh the memory. ")
("lceClearLogicalConn"
"lceClearLogicalConn(
d_cellViewID
)
=> t / nil"
"Removes the logical connectivity on the specified cellview, such as nets that are not attached to terminals, and the nets and lxStickyNet property on all routes, shapes, and vias. In addition, the function clears all connectivity on instTerms and removes the markers created by the extractor.")
("lceDestroyVoidShapes"
"lceDestroyVoidShapes(
d_cellViewID
[ ?layerName layerName ]
)
=> t"
"(ICADVM20.1 Only) Destroys void shapes in the given layout cellview.")
("lceExtract"
"lceExtract(
d_layCellViewID
[ ?reportType reportType ]
)
=> t / nil"
"Runs the Layout XL connectivity extractor on the specified cellview.")
("lceExtractArea"
"lceExtractArea(
d_layCellViewID
l_points
[ ?reportType reportType ]
)
=> t / nil"
"Extracts connectivity for a specified area of the design.")
("lceExtractAreas"
"lceExtractAreas(
d_layCellViewID
l_points
[ ?reportType reportType ]
)
=> t / nil"
"Extracts connectivity for the specified areas of the design.")
("lceExtractNet"
"lceExtractNet(
net
[ ?reportType reportType ]

)
=> t / nil"
"Runs the Layout XL connectivity extractor on the specified net.")
("lceExtractNets"
"lceExtractNets(
l_nets
[ ?reportType reportType ]
)
=> t / nil"
"Runs the Layout XL connectivity extractor on the specified nets.")
("lceExtractUnverifiedAreas"
"lceExtractUnverifiedAreas(
lt_markers
[ ?reportType reportType ]
)
=> t / nil"
"Extracts connectivity for the unverified areas that are defined by the bounding box of the specified markers.")
("lceGetExtractLayers"
"lceGetExtractLayers(
d_layCellViewID
)
=> l_extractLayers / nil"
"Lists the extractable layer-purpose pairs (LPPs) defined for a specified layout cellview. Layout XL can extract through the LPPs that are listed.")
("lceGetFracturedShapes"
"lceGetFracturedShapes(
d_dbFigID
[ g_points ]
[ g_floatingOnly ]
[ d_netID ]
)
=> t / nil"
"Generates a report of the geometry and connectivity of fractured shapes that exist within a figure (shape or prBoundary).")
("lceGetFracturedShapesFromNet"
"lceGetFracturedShapesFromNet(
d_netID
[ g_substrateOnly ]
)
=> t / nil"
"Generates a report of fractured shapes corresponding to a specific net.")
("lceGetIncompleteNets"
"lceGetIncompleteNets(
d_layCellViewID
)
=> t / nil"
"Generates a list of incomplete nets.")
("lceGetIncompleteNetMarkers"
"lceGetIncompleteNetMarkers(
[ netID | l_netID ]
)
=> l_incompleteNetMarkerID"
"Generates a list of open markers on the specified incomplete nets. If a single net is specified, the opens on that net are returned. If multiple nets are specified, the opens on each net in the list are returned. If no nets are specified, all the opens in the design are returned.")
("lceGetOption"
"lceGetOption(
name
[ cvID ]
)
=> t / nil"
"Returns the value of the specified Connectivity Extractor option for the current or given cellview.")
("lceGetShortMarkers"
"lceGetShortMarkers(
[ netID | l_netID ]
)
=> l_shortMarkerID"
"Prints a list of short markers between the passed nets. If a single net is specified, the shorts between this net and all the other nets are returned. If two nets are specified, the shorts between these two nets are returned. If more nets are specified, the shorts between pairs of nets in the list are returned.")
("lceHierExtract"
"lceHierExtract(
d_cellViewID
g_searchDepth
g_extractAll
g_autoSave
g_skipCurrentEditedCellView
[ ?fromUserList { t | nil } ]
[ ?fromSelectedInsts { t | nil } ]
)
=> t"
"Performs connectivity extraction of a hierarchy of cellviews from bottom to top.")
("lceHiExtract"
"lceHiExtract(
)
=> t"
"Opens the Extract Layout form, which you can use to extract the design either at the top level or hierarchically.")
("lceIsExtractLayer"
"lceIsExtractLayer(
d_layCellViewID
ltx_layer
)
=> t / nil"
"Checks whether the specified layer or layer-purpose pair (LPP) is extractable.")
("lcePrintConstraintGroupWarnings"
"lcePrintConstraintGroupWarnings (
d_techID
)
=> t / nil"
"Prints the warnings issued by the connectivity extractor for the specified technology library. The constraint group for which the warnings are issued is the one defined using the setupConstraintGroup environment variable.")
("lcePrintExtractLayers"
"lcePrintExtractLayers(
d_layCellViewID
[ ?cgName d_cgName ]
[ ?verifyWellSubstrateConnections { t | nil } ]
[ ?useOverlappingLabelsAsConnectivitySources { t | nil } ]
[ ?enableVirtualConnections { t | nil } ]
[ ?fileName t_fileName ]
[ ?appendToFile { t | nil } ]
)
=> t / nil"
"Generates a report about the extractable layers. For more information, see Diagnostics Report.")
("lcePrintExtractVias"
"lcePrintExtractVias(
d_layCellViewID
[ ?cgName d_cgName ]
[ ?verifyWellSubstrateConnections { t | nil } ]
[ ?useOverlappingLabelsAsConnectivitySources { t | nil } ]
[ ?enableVirtualConnections { t | nil } ]
[ ?fileName t_fileName ]
[ ?appendToFile { t | nil } ]
)
=> t / nil"
"Generates a report about the extractable vias. For more information, see Diagnostics Report.")
("lcePrintTechDiagnostics"
"lcePrintTechDiagnostics(
d_layCellViewID
[ ?cgName d_cgName ]
[ ?verifyWellSubstrateConnections { t | nil } ]
[ ?useOverlappingLabelsAsConnectivitySources { t | nil } ]
[ ?enableVirtualConnections { t | nil } ]
[ ?fileName t_fileName ]
[ ?appendToFile { t | nil } ]
)
=> t"
"Generates a report about the connectivity extractor technology diagnostics and indicates if the technology file has been correctly set up for extraction. For more information, see Diagnostics Report.")
("lceRegenerateVoidShapes"
"lceRegenerateVoidShapes(
d_cellViewID
[ ?layerName layerName ]
)
=> t"
"(ICADVM20.1 Only) Regenerates void shapes in the given layout cellview.")
("lceSetOption"
"lceSetOption(
name
value
[ cvID ]

)
=> t / nil"
"Sets the specified Connectivity Extractor option for the current or given cellview.")
("lceShortLocatorChaseAndSave"
"lceShortLocatorChaseAndSave(
d_winID
g_shapes
g_hierStart
t_viewName
)
=> t / nil"
"Chases islands from the specified start shapes and saves them along with the shortest paths between their points of stickiness.")
("lceShortLocatorRaiseForm"
"lceShortLocatorRaiseForm(
)
=> t"
"Opens the Short Locator form, which you can use to locate the shapes in a layout that are causing shorts.")
(" lntAddTrace"
"lntAddTrace(
w_window
{ d_figId | t_netName }
[ ?hierPath l_hierPath ]
[ ?startLevel x_startLevel ]
[ ?stopLevel x_stopLevel ]
[ ?userArea l_userArea ]
[ ?hilightIncrementally g_hilightIncrementally ]
[ ?retainColornStateInfo g_retainColornStateInfo ]
[ ?hilightColor t_hilightColor ]
[ ?maxCutShapes t_maxCutShapes ]
[ ?constraintGroup t_constraintGroup ]
)
=> x_traceId / nil"
"Creates a trace starting from the specified figure or net name in the specified window.")
(" lntClearNeighbors"
"lntClearNeighbors(
w_window
)
=> t /nil"
"Deletes all computed neighbors in the specified window.")
("lntComputeNeighbors"
"lntComputeNeighbors(
w_window
f_distance
)
=> t"
"For existing traces in the specified window, finds all shapes on the same layer that fall within the given distance and creates highlights for the overlapped portions.")
("lntContSteps"
"lntContSteps(
)
=> t / nil"
"Generates the complete trace from the current step to the last when the Net Tracer is invoked in Step trace mode.")
("lntGetAllTraces"
"lntGetAllTraces(
d_cellviewID
)
=> l_traceIDs / nil"
"Lists all the traces in the specified cellview.")
("lntGetCurrentStep"
"lntGetCurrentStep(
)
=> x_val"
"Returns the current step value when the Net Tracer is invoked in Step trace mode.")
("lntGetTailVal"
"lntGetTailVal(
)
=> x_val"
"Returns the current value of the tail of a trace when the Net Tracer is invoked in Step trace mode.")
("lntGetTraceInfo"
"lntGetTraceInfo(
x_traceID
)
=> l_paramList / nil"
"Returns information for a specified trace. The returned information contains the trace container, its name, color, and visibility status, and the number of chased shapes.")
("lntHideNeighbors"
"lntHideNeighbors(
w_window
)
=> t / nil"
"Hides displayed neighbors for the specified window. The computed neighbors are retained and can be displayed again using the lntShowNeighbors command. Use lntClearNeighbors to delete all neighbors.")
("lntHiEditTrace"
"lntHiEditTrace(
[ w_window ]
)
=> t / nil"
"Invokes the Net Tracer Edit In Place command that lets you edit in place the instances that contain the traced objects.")
("lntHiNetTracer"
"lntHiNetTracer(
[ w_window ]
)
=> t / nil"
"Invokes the Net Tracer command, which you can use to add, update, or delete traces in a layout window.")
("lntIsNeighborsVisible"
"lntIsNeighborsVisible(
w_window
)
=> t / nil"
"Checks whether Net Tracer neighbors are visible in the specified window.")
("lntIsStepTrace"
"lntIsStepTrace(
x_traceID
)
=> t / nil"
"Checks whether the specified trace was created using Step mode.")
("lntNeighbors"
"lntNeighbors(
w_window
)
=> t / nil"
"Displays the Net Tracer Neighbors form, which you can use to compute all neighboring shapes within a given distance for all the traces in the window.")
("lntNextStep"
"lntNextStep(
)
=> t / nil"
"Increments the current step value by one when the Net Tracer is invoked in Step trace mode.")
("lntNextToSetStep"
"lntNextToSetStep(
)
=> t / nil"
"Forwards tracing of all Step mode traces to the newly specified step value. For information about how the SKILL function behaves differently for each trace, depending on the maximum step value for the trace, see Additional Information.")
("lntPrevStep"
"lntPrevStep(
)
=> t / nil"
"Decrements the current step value by one when the Net Tracer is invoked in Step trace mode.")
("lntRemoveAll"
"lntRemoveAll(
)
=> t / nil"
"Removes all traces created by the Net Tracer command from the current layout window.")
("lntRemoveAllTraces"
"lntRemoveAllTraces(
[ w_window ]
)
=> t / nil"
"Removes all traces from the specified window.")
("lntRemoveTrace"
"lntRemoveTrace(
x_traceID
[ w_window ]
)
=> t / nil"
"Removes the specified trace from the specified window.")
("lntSaveTraces"
"lntSaveTraces(
w_windowID
l_traceID
libName
cellName
viewName
[ saveNeighbors g_saveNeighbors ]
[ appendTraces g_appendTraces ]
[ replaceSameNameTrace g_replaceSameNameTrace ]
)
=> t / nil"
"Saves the shapes of the specified traces that are displayed in the library cellview open in the specified window.")
("lntSetCurrentStep"
"lntSetCurrentStep(
x_val
)
=> t / nil"
"Sets the current step value for a trace when the Net Tracer is invoked in Step trace mode.")
("lntSetTailVal"
"lntSetTailVal(
x_val
)
=> t / nil"
"Sets the current value of the tail for all traces when the Net Tracer is invoked in Step trace mode.")
("lntSetTraceColor"
"lntSetTraceColor(
x_traceID
t_color
[ w_window ]
)
=> t / nil"
"Changes the color of the specified trace to the specified color in the given window.")
("lntSetTraceVisibility"
"lntSetTraceVisibility(
x_traceID
x_visibility
[ w_window ]
)
=> t / nil"
"Sets the visibility of the specified trace in the specified window.")
("lntShowHideAllTraces"
"lntShowHideAllTraces(
x_showHide
[ w_window ]
)
=> t / nil"
"Shows or hides all traces in the cellview contained in the specified window.")
("lntShowNeighbors"
"lntShowNeighbors(
w_window
)
=> t / nil"
"Displays computed neighbors for the specified window. The computed neighbors can be hidden using the lntHideNeighbors SKILL function. Use lntClearNeighbors to delete all neighbors.")
("lxAbutGetNeighbors"
"lxAbutGetNeighbors(
{ ld_instId | d_instId }
[ ?direction { 'up | 'down | 'left | 'right | 'horizontal | 'vertical | 'all } ]
[ ?depth { 0 ... INT_MAX } ]
[ ?stopGroup d_stopGroup ]
[ ?select { t | nil } ]
)
=> ld_instId / nil"
"The traversal can be restricted by providing a maximum traversal depth. A value of 0 or nil indicates no restriction. If an abutment group object is supplied via the ?stopGroup argument, the group is not traversed. The ?select argument, when true, selects the returned instances.")
("lxChain"
"lxChain(
l_insts
l_point
[ ?groups l_groups ]
[ ?preserveExistingChains { t | nil } ]
[ ?useDeviceOrder { t | nil } ]
[ ?interdigitateChains { t | nil } ]
[ ?mirror { t | nil } ]
[ ?permute { t | nil } ]
[ ?allowSingleBulk { t | nil } ]
[ ?dummyFlexBothEndNets { t | nil } ]
[ ?syncChains { t | nil } ]
[ ?mirrorEquivOrients { t | nil } ]
[ ?preserveRows { t | nil } ]
[ ?useAbutSpacing { t | nil } ]
[ ?maxChainSize x_maxChainSize ]
[ ?contacts { 0 | 1 | 2 } ]
[ ?chainAlignPMOS { Top | Center | Bottom } ]
[ ?chainAlignNMOS { Top | Center | Bottom } ]
[ ?chainLeftNet { Source | Drain | Either } ]
[ ?abutStrategy { sdFirst | dummyFirst } ]
[ ?optimize { Tracks | Abutments | Both } ]
[ ?multiRow { NP | PN | NPPN | PNNP } ]
[ ?effort { Minimal | Nominal | Maximal } ]
)
=> l_chains / nil"
"Chains a list of instances and places the generated chains at the specified position in the layout. Using the optional arguments will override the existing settings of the environment variables: chainPreserveExistingChains, chainUseDeviceOrder, lxAllowPseudoParallelNets, chainMirror, chainPermutePins, chainAllowSingleBulk, chainDummyFlexBothEndNets (IC6.1.8 Only), chainSyncChains, chainMirrorEquivOrients, chainPreserveRows,chainUseAbutSpacing, lxChainAlignPMOS, lxChainAlignNMOS, chainLeftNet and chainAbutStrategy. For information on each of these environment variables, see Layout XL Environment Variables in the Virtuoso Layout Suite documentation.")
("lxCheck"
"lxCheck(
d_layCV
[ ?schCV d_schCV ]
[ ?checkDevices { t | nil } ]
[ ?checkExtractLayout { t | nil } ]
[ ?extractStopLevel [0-32] ]
)
=> t / nil"
"Checks the layout for XL compliance and reports binding status in an Info pop-up box. It is recommended to use the lxCheck SKILL function to look for any possible problems in the design if the Navigator XL Status column is not clean. After the issues reported by lxCheck are resolved, running the Connectivity - Update Binding command should give an improved XL Status.")
("lxCheckLib"
"lxCheckLib(
libName
[ ?checkBindings { t | nil } ]
[ ?checkExtractLayout { t | nil } ]
[ ?summaryLogFileName t_summaryLogFileName ]
[ ?extractStopLevel [0-32] ]
)
=> t / nil"
"Checks the layouts in the specified library for opens and shorts when extracted to extractStopLevel, and displays the results in CIW and in the Info window. CAD engineers are advised to run this SKILL function to identify the instances that are likely to cause issues with Update Binding. ")
("lxCheckAgainstSource"
"lxCheckAgainstSource(
d_schCellViewID
d_layCellViewID
[ ?masterDiff { t | nil } ]
[ ?paramDiff { t | nil } ]
[ ?unboundInsts { t | nil } ]
[ ?connectivity { t | nil } ]
[ ?maxDiffsLimit x_maxDiffsLimit ]
[ ?logFileName t_logFileName ]
[ ?appendToLog { t | nil } ]
[ ?nameDiff { t | nil } ]
[ ?dummyDiff { t | nil } ]
[ ?busTermDiff { t | nil } ]
[ ?virtualHierDiff { t | nil } ]
)
=> t / nil"
"Generates a report highlighting the differences between the schematic and the layout cellview. If you use the optional arguments, they override the existing environment variable settings in the .cdsenv file.")
("lxCmdOptions"
"lxCmdOptions(
)"
"Implements a command option for the listed Virtuoso Layout Suite XL commands when the right-mouse button bindkey is pressed. For other Layout XL commands, the right-mouse button bindkey performs the operations as supported by cmdOptions.")
("lxCmdShiftOptions"
"lxCmdShiftOptions(
)
=> nil"
"Activates the bindkeys associated with Shift-click and Shift-right click during the operation of enterFunction commands. Typing this command in the Command Interpreter Window has no effect.")
("lxComputeViaParams"
"lxComputeViaParams(
d_viaDefID
d_objID
[ ds_constraintGroup ]
[ l_params ]
[ f_pathWidth1 ]
[ t_pathDirection1 ]
[ f_pathWidth2 ]
[ t_pathDirection2 ]
[ l_options ]
)
=> list_of_params | nil"
"Returns a list of DRC-correct via parameters for a specified standard via definition or a custom via definition that references either a cdsVia or a correctly-defined syEnhContact. The via parameters returned are: n_cutWidth, n_cutHeight, l_cutSpacing (X and Y), l_layer1Enc and l_layer2Enc (top, bottom, left, and right).")
("lxConvertSlotToPolygon"
"lxConvertSlotToPolygon(
[ ?all { t | nil } ]
[ ?region l_region ]
[ ?layers l_layers ]
)
=> t / nil"
"Converts the metal shapes on the drawing purpose to one slotted metal polygon by creating holes where the slot purpose shapes cover the original metal shapes. The original metal shapes and the slot purpose shapes are removed.")
("lxCreateBndFile"
"lxCreateBndFile(
[ t_ixfFile ]
[ t_netFile ]
[ t_bndFile ]
[ d_layId ]
[ g_graphical ]
)
=> t / nil"
"Creates a binding file based on the PVS instance cross-reference file and the extracted netlist file.")
("lxCreateSynchronousClonesFromFigGroups"
"lxCreateSynchronousClonesFromFigGroups(
( figGroupList )
[ dumpConsistencyCheckMsg ]
[ dumpNonClonableFigGroups ]
)
=> t / nil"
"Creates a new clone family from a list of basic figGroups. When the clone family is created, the function runs the Clone Consistency Checker to verify that the figGroups are effectively synchronous. The checks that are run include verifying that the figGroups are identical, which means their shapes exist on the same layer, instances belong to the same master, and have the same relative position, and so on.")
("lxDeleteSynchronousCloneFamily"
"lxDeleteSynchronousCloneFamily(
[ cloneList ]
)
=> t / nil"
"Deletes the specified family of synchronous clones. As a result, the member clones are desynchronized and they behave as basic groups.")
("lxFold"
"lxFold(
l_insts
l_point
x_numFolds
[ ?widths l_widths ]
[ ?chainFolds { t | nil } ]
[ ?ignoreMFactor { t | nil } ]
[ ?chainAlignPMOS { Top | Center | Bottom } ]
[ ?chainAlignNMOS { Top | Center | Bottom } ]
[ ?enforceWidthMatch { t | nil } ]
[ ?keepFolds { t | nil } ]
)
=> l_chains / nil"
"Folds a list of valid instances into the specified number of folds and places them at the specified location. If the disableFolding environment variable is set and the folding threshold for the component type is set to 0, folding is disabled.")
("lxGenerateFinish"
"lxGenerateFinish(
d_schId
d_layId
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Finishes the layout generation process by executing the Generate All From Source command with the form values supplied by lxSet* functions and after the previous call to lxGenerateStart.")
("lxGenerateStart"
"lxGenerateStart(
d_schId
d_layId
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Starts the Generate All From Source command, building the Generate Layout form without displaying it to the screen.")
("lxGenFromSource"
"lxGenFromSource(
d_schCellViewID
[ ?layLibName t_layLibName ]
[ ?layCellName t_layCellName ]
[ ?layViewName t_layViewName ]
[ ?configLib t_configLib ]
[ ?configCell t_configCell ]
[ ?configView t_configView ]
[ ?initCreateInstances { t | nil } ]
[ ?initDoStacking { t | nil } ]
[ ?initDoFolding { t | nil } ]
[ ?initCreatePins { t | nil } ]
[ ?initGlobalNetPins { t | nil } ]
[ ?initCreatePadPins { t | nil } ]
[ ?initCreateBoundary { t | nil } ]
[ ?initCreateSnapBoundary { t | nil } ]
[ ?lxPositionMinSep n_lxPositionMinSep ]
[ ?lxGenerateInBoundary { t | nil } ]
[ ?initCreateMTM { t | nil } ]
[ ?extractAfterGenerateAll { t | nil } ]
[ ?extractSchematic { t | nil } ]
[ ?ignoreSchematicCheck { t | nil } ]
[ ?initPrBoundaryShape t_initPrBoundaryShape ]
[ ?initPrBoundaryOrigin l_initPrBoundaryOrigin ]
[ ?initPrBoundaryPoints l_initPrBoundaryPoints ]
[ ?initAreaSource1 t_initAreaSource1 ]
[ ?areaCalc t_areaCalc ]
[ ?initAreaSource2 t_initAreaSource2 ]
[ ?initAreaSource1Val n_initAreaSource1Val ]
[ ?initAreaSource2Val n_initAreaSource2Val ]
[ ?virtualHierarchy { t | nil } ]
[ ?softBlocks { t | nil } ]
[ ?softBlockArea { t | nil } ]
[ ?useAreaBoundaryUtilization { t | nil } ]
[ ?areaBoundaryEnclosure n_areaBoundaryEnclosure ]
[ ?allAreaBoundaries { t | nil } ]
)
=> dbCellViewID"
"Generates a layout from a specified schematic cellview. If you do not specify the layout library, cell, and view names, the layout view is created with the same name as the schematic cell. If you do not specify the physConfig library, cell and view names, the layout view is created with the same name as the layout cell with physConfig as the default physConfigView. If you use the optional arguments, they override the existing environment variables set in the .cdsenv file.")
("lxGetAvailablePinLPPs"
"lxGetAvailablePinLPPs(
)
=> lt_layerPurposePair / nil"
"Lists the valid layer-purpose pairs to use for setting the pin layer. This function must always be called between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish. It is typically used to find a layer-purpose pair to pass to lxSetNetPinSpecs.")
("lxGetCloneFamilyName"
"lxGetCloneFamilyName(
clone
)
=> familyName / nil"
"Returns the family name of the specified clone.")
("lxGetConnRef"
"lxGetConnRef(
{ w_windowID | d_layCellviewID }
=> l_connref"
"Gets the connectivity reference for the specified layout cellview or for the layout cellview opened in the specified window. The layout cellview does not need to be open in a Layout XL session for the connectivity reference to be returned.")
("lxGetEditedSyncClone"
"lxGetEditedSyncClone(
d_layCellViewId
)
=> d_syncCloneId / nil"
"Returns the database ID of the synchronous clone currently being edited in the specified layout cellview. If the function finds a currently-edited layout group which is not a synchronous clone, it recursively checks to determine if its parent group is a synchronous clone. If it is, the function returns the ID of the parent synchronous clone.")
("lxGetLXInfo"
"lxGetLXInfo(
{ srcView | dstView | workingWinID }
[ d_cellviewID ]
)
=> d_dbID / w_winID / nil"
"Returns the value of the specified Layout XL internal variable. You can use this function to get the library, cell, and view name of the source schematic for a specified layout cellview.")
("lxGetOtherClonesInFamily"
"lxGetOtherClonesInFamily(
clone
)
=> cloneList / nil"
"The generated list does not contain the specified clone.")
("lxGetPermutedInstTerms"
"lxGetPermutedInstTerms(
d_layInstID
)
=> ld_instTermIDs / nil"
"Returns the list of database IDs of instance terminals that have been permuted on a specified layout instance. The function can identify instance terminals that have been permuted, even if there is no permuteRule property on the schematic or layout instances or their masters.")
("lxGetPinNets"
"lxGetPinNets(
)
=> lt_netName / nil"
"Lists the pin net names from the Generate Layout or Update Components and Nets form. This function must always be called between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish. It is typically used to find net names to pass to lxSetNetPinSpecs.")
("lxGetSource"
"lxGetSource(
{ w_windowID | d_layCellviewID }
=> d_schCellviewID / nil"
"Returns the source (schematic) cellview ID for the specified layout window ID or layout cellview ID in the current Layout XL session. If the schematic reference for the specified layout window has changed since the current Layout XL session was started, Layout XL must be relaunched for lxGetSource to return the updated schematic reference. ")
("lxGetSyncClone"
"lxGetSyncClone(
d_objectId
)
=> d_syncCloneId / nil"
"Returns the database ID of the synchronous clone to which the specified object belongs. If the object belongs to a layout group which is not a synchronous clone, the function recursively checks to determine if its parent group is a synchronous clone. If it is, the function returns the ID of the parent synchronous clone.")
("lxGetValidViaDefs"
"lxGetValidViaDefs(
d_objID
[ ds_constraintGroup ]
[ ltx_bottomLayer ]
[ ltx_topLayer ]
)
=> list_of_viaDefs / nil"
"Returns a list of via definitions associated with a specified design object. You can restrict the list to include only vias defined in a specified constraint group or which feature a specific top and/or bottom layer. If you specify a technology file, no constraint groups, and no layers, the function returns all the via definitions in the technology database. If you specify both top and bottom layers, the function returns only via definitions featuring those layers. If you specify either a top or bottom layer, the function returns only via definitions featuring the layer in question.")
("lxHierCheck"
"lxHierCheck(
layCV
[ ?checkDevices { t | nil } ]
[ ?checkExtractLayout { t | nil } ]
[ ?extractStopLevel [0-32] ]
[ ?hierSummaryLogFileName t_hierSummaryLogFileName ]
)
=> t / nil"
"Arguments")
("lxHierCheckAgainstSource"
"lxHierCheckAgainstSource(
d_layCellViewID
[ ?masterDiff { t | nil } ]
[ ?paramDiff { t | nil } ]
[ ?unboundInsts { t | nil } ]
[ ?connectivity { t | nil } ]
[ ?maxDiffsLimit x_maxDiffsLimit ]
[ ?logFileName t_logFileName ]
[ ?appendToLog { t | nil } ]
[ ?nameDiff { t | nil } ]
[ ?dummyDiff { t | nil } ]
)
=> t / nil"
"Generates a report highlighting the differences between the schematic and layout cellviews for unique layout masters in the specified layout hierarchy. If you use the optional arguments, they override the existing environment variables set in the .cdsenv file. This SKILL function always skips any layouts that have no instances. If a log file name is specified for the hierSummaryLogFileName environment variable, the SKILL function prints the summary information to the specified log file, in addition to printing the information to the default Virtuoso log file.")
("lxHierUpdateComponentsAndNets"
"lxHierUpdateComponentsAndNets(
d_layCellViewID
[ ?initCreatePins { t | nil } ]
[ ?initGlobalNetPins { t | nil } ]
[ ?initCreatePadPins { t | nil } ]
[ ?initCreateInstances { t | nil } ]
[ ?initCreateBoundary { t | nil } ]
[ ?initCreateSnapBoundary { t | nil } ]
[ ?initDoStacking { t | nil } ]
[ ?initDoFolding { t | nil } ]
[ ?initCreateMTM { t | nil } ]
[ ?deleteUnmatchedInsts { t | nil } ]
[ ?deleteUnmatchedPins { t | nil } ]
[ ?updateReplacesMasters { t | nil } ]
[ ?updateWithMarkers { t | nil } ]
[ ?updateLayoutParameters { t | nil } ]
[ ?updateNetSigType { t | nil } ]
[ ?updateNetMinMaxVoltage { t | nil } ]
[ ?updateNetsOnly { t | nil } ]
[ ?virtualHierarchy { t | nil } ]
[ ?skipLeafs { t | nil } ]
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Updates the components and nets for all unique layout masters in the specified layout cellview hierarchy. The layouts are automatically opened in edit mode for update. If a log file name is specified for the hierSummaryLogFileName environment variable, the SKILL function prints the summary information to the specified log file, in addition to printing the information to the default Virtuoso log file.")
("lxHiAbout"
"lxHiAbout(
)
=> t"
"Opens the product information window for Layout XL, which includes the release number and the copyright information.")
("lxHiAlign"
"lxHiAlign(
)
=> t"
"Opens the Align form, in which you can specify how selected objects are to be aligned in the layout window design area.")
("lxHiBackAnnotateAllActiveDummies"
"lxHiBackAnnotateAllActiveDummies(
[ ?schCV d_schCellViewId ]
[ ?layCV d_layCellViewId ]
[ ?autoSchExtract { t | nil } ]
)
=> t"
"Backannotates to schematic the symbols of all the active dummy devices-dummy devices that are not tied to a power or ground net and are not bound in the current layout view. If the schematic and the layout cellview IDs are not supplied, Virtuoso tries to determine them automatically.")
("lxHiBackAnnotateSelectedDummies"
"lxHiBackAnnotateSelectedDummies(
[ ?schCV d_schCellViewId ]
[ ?layCV d_layCellViewId ]
[ ?autoSchExtract { t | nil } ]
[ ?figs l_figs ]
)
=> t"
"Backannotates to schematic the symbols of selected active dummy devices-dummy devices that are not tied to a power or ground net and are not bound in the current layout view. If the schematic and the layout cellview IDs are not supplied, Virtuoso tries to determine them automatically.")
("lxHiChain"
"lxHiChain(
[ w_windowID ]
)
=> t / nil"
"Opens the Generate Chained Devices form, which you can use to specify the transistors in the design to be chained, and starts the interactive chaining function on the design in the specified window. If you do not specify a window, it operates on the design in the current window.")
("lxHiCheck"
"lxHiCheck(
)"
"Checks XL compliance of the layout when called using the Connectivity - Check - XL Compliance command.")
("lxHiClone"
"lxHiClone(
[ w_windowID ]
)
=> t / nil"
"Opens the Generate Clones form, which you can use to specify cloning parameters, and starts the interactive cloning function, which lets you replicate a section of the layout in such a way that the new piece of layout material can be placed at more than one location, with each part preserving the hierarchical structure and connectivity of the source. You can clone devices, pins, and (if selected from the layout window) interconnect structures such as wires and paths made of shapes. The interactive cloning function operates on the design in the specified window. If you do not specify a window, the function operates on the design in the current window.")
("lxHiConnectInstPin"
"lxHiConnectInstPin(
)
=> nil"
"Opens the Assign Nets form and starts the Assign Nets command, which let you assign instance pins to nets in the design.")
("lxHiCreateInstFromSch"
"lxHiCreateInstFromSch(
[ w_windowID ]
)
=> t / nil"
"Opens the Generate Selected Components form and starts the interactive command which lets you generate selected schematic components in the layout view. The function operates on the design in the specified window. If you do not specify a window, the function operates on the current window.")
("lxHiCreateMPP"
"lxHiCreateMPP(
[ w_windowID ]
)
=> nil"
"Opens the Create Multipart Path form, which you can use to specify the parameters for creating a multipart path, and starts the interactive command which lets you create a path in the layout window. The function operates on the design in the specified window. If you do not specify a window, the function operates on the design in the current window.")
("lxHiDefineDeviceCorr"
"lxHiDefineDeviceCorr(
)
=> t"
"Opens the Define Device Correspondence form, which lets you bind schematic devices to layout devices.")
("lxHiEditComponentTypes"
"lxHiEditComponentTypes(
[ w_windowID ]
)
=> t"
"Opens the Configure Physical Hierarchy window in Component Types mode, which lets you define component types and assign cells to them. The function operates on the design in the specified layout window. If you do not specify a layout window, it operates on the design in the current one; if there is no current layout window, the function exits.")
("lxHiGenerateSelectedFromLayout"
"lxHiGenerateSelectedFromLayout(
[ w_windowID ]
)
=> t | nil"
"(ICADVM20.1 Only) Starts the Generate Selected From Layout enter function, which lets you generate selected layout components in the corresponding schematic cellview. The layout window from which the components are selected is specified. If the layout window is not specified, the function operates on the current window.")
("lxHiLockSelected"
"lxHiLockSelected(
)
=> t / nil"
"Sets the placement status of the currently selected objects to locked. Each object is locked at its current location and orientation in the layout view.")
("lxHiMoveAutomatically"
"lxHiMoveAutomatically(
)
=> t / nil"
"Runs the Place As In Schematic command, which moves all of the components into the design boundary, maintaining the relative positions of the components in the schematic. If there is no connectivity reference, the Update Connectivity Reference form is opened.")
("lxHiProbe"
"lxHiProbe(
)
=> t"
"Opens the Probe Options form and starts the XL Probe command, which lets you select a component in either the layout or schematic and highlights the corresponding component the other cellview of the pair.")
("lxHiReInitDesign"
"lxHiReInitDesign(
)
=> t"
"Opens the Generate Layout form, which you can use to specify which layout components are to be generated from the schematic cellview, or clears the existing layout cellview so that you can restart.")
("lxHiSetOptions"
"lxHiSetOptions(
[ x_tabNumber { 1 | 2 | 3 | 4 | 5 | 6 } ]
)
=> t / nil"
"Opens the Connectivity form. The form opens with the General tab on top, unless you specify a different tab using the optional argument.")
("lxHiStack"
"lxHiStack( 
[ w_windowID ]
)
=> t / nil"
"Opens the Generate Folded Devices form and starts the Generate Folded Devices command, which lets you fold a single transistor or an abutted group of MOS transistors into two or more fingers. The command operates on the design in the specified window. If you do not specify a window, it operates on the design in the current window.")
("lxHiSwap"
"lxHiSwap(
[ w_windowID ]
)"
"Swaps instances and figGroups by launching the Swap Components command. You can pre-select, partial-select, or post-select instances and figGroups. You can use the function to swap by origin with an option to swap with transform, or you can select one of the nine points on a bounding box: lower-left, center-left, upper-left, lower-center, center-center, upper-center, lower-right, center-right, or upper-right.")
("lxHiUnlockSelected"
"lxHiUnlockSelected(
g_all
)
=> t / nil"
"Changes the placement status of the selected objects from locked, placed, or firm to unplaced.If the original placement status is unknown or unplaced, this command does not change it.")
("lxHiUpdateBinding"
"lxHiUpdateBinding(
)
=> t / nil"
"Displays the Update Binding form.")
("lxHiUpdateCellViewPair"
"lxHiUpdateCellViewPair(
[ d_cellviewID ]
)
=> ( { t_source t_lib t_cell t_view [ t_topcell ] | nil } )"
"Starts the Update Connectivity Reference command and opens the Update Connectivity Reference form, where you can specify which schematic view provides the connectivity source for the specified layout view. If you do not specify a layout cellview, the function uses the current layout cellview.")
("lxHiUpdateComponentsAndNets"
"lxHiUpdateComponentsAndNets(
)
=> t"
"Starts the Update Components and Nets command, which lets you update the devices and pins in the layout view based on the devices in the schematic cellview.")
("lxHiUpdateLayoutConstraints"
"lxHiUpdateLayoutConstraints(
)
=> t"
"Runs the Update Layout Constraints command, which transfers constraints from the schematic view to the layout view. Constraints that have been created in the schematic but not yet saved are also transferred. Constraints are transferred only to the top-level layout view and are made read-only.")
("lxHiUpdateLayoutParameters"
"lxHiUpdateLayoutParameters(
)
=> t"
"Starts the Update Layout Parameters command, which updates the parameters and values in the layout view to match those set in the schematic view.")
("lxHiUpdateSchematicParameters"
"lxHiUpdateSchematicParameters(
)
=> t"
"Starts the Update Schematic Parameters command, which updates the parameters and values in the schematic view to match those set in the layout view.")
("lxHiVerifyDesign"
"lxHiVerifyDesign(
)
=> t"
"Starts the Check Against Source command and opens the Check Against Source dialog where you can specify how Layout XL is to check the current layout implementation against corresponding schematic view. When you accept the dialog, the command checks the schematic cellview for any changes made since the layout cellview was last changed. It also opens an Info window detailing the differences between the views.")
("lxHiIChain"
"lxHiIChain(
)
=> t / nil"
"Starts the enter function available through the shortcut menu of selected instances, pins, or a group of abutted instances to support incremental interactive chaining. The selected instances, pins, or a single group of abutted objects are considered as anchors to start the chain and the subsequent user-specified points are then used to interactively chain the instances and top-level pins until the Esc key is pressed to stop the function.")
("lxLaunchLayoutEXL"
"lxLaunchLayoutEXL(
[ w_windowID ]
)
=> t"
"(ICADVM20.1 Only) Launches Layout EXL from a specified schematic window. If you do not specify a window ID, Layout EXL is launched from the window returned by the hiGetCurrentWindow() function, but only if it is a schematic window.")
("lxLaunchLayoutGXL"
"lxLaunchLayoutGXL(
[ w_windowID ]
)
=> t"
"(IC6.1.8 Only) Launches Layout GXL from a specified schematic window. If you do not specify a window ID, Layout GXL is launched from the window returned by the hiGetCurrentWindow() function, but only if it is a schematic window.")
("lxLaunchLayoutXL"
"lxLaunchLayoutXL(
[ w_windowID ]
)
=> t"
"Launches Layout XL from a specified schematic window. If you do not specify a window ID, Layout XL is launched from the window returned by the hiGetCurrentWindow() function, but only if it is a schematic window.")
("lxMakeDummy"
"lxMakeDummy(
t_netName
)
=> t / nil"
"Starts the Make Dummy enter function for the selected set of instances which can include mosaics. The function requires a reference point and a position for the created dummy devices. The dummy devices are tied to the named net passed in via netName.")
("lxMakePrBoundarySelectable"
"lxMakePrBoundarySelectable(
)
=> t / nil"
"Makes the place and route boundary in the current layout selectable.")
("lxMakePrBoundaryUnselectable"
"lxMakePrBoundaryUnselectable(
)
=> t / nil"
"Makes the place and route boundary in the current layout unselectable.")
("lxPermPermutePins"
"lxPermPermutePins(
)
=> t"
"Starts the Permute Pins command, which lets you swap the connectivity or net connections of the pins of a component. You specify the pins you want to permute by selecting them when prompted by the function. The pins to be permuted must belong to different nets and must first be defined as permutable terminals using the permuteRule property for the device.")
("lxProbeRemoveAll"
"lxProbeRemoveAll(
)
=> t"
"Removes all probes from the layout cellview.")
(" lxRegMasterDiffName"
"lxRegMasterDiffName(
S_function
)
=> t / nil"
"Registers a SKILL function that can return a name for the master difference reported by the Check Against Source command.")
("lxRegPostUpdateComponentsAndNets"
"lxRegPostUpdateComponentsAndNets(
S_function
)
=> t / nil"
"Registers a SKILL function to be used as a post-function hook for lxUpdateComponentsAndNets to enable replacement of pins that have their layer and width characteristics defined using the Design Intent tool. lxRegPostUpdateComponentsAndNetsFn, when used in combination with lxRegPostUpdateComponentsAndNetsFn, avoids the need for deleting the pins defined in Design Intent before the pins can be updated.")
("lxRegPreUpdateComponentsAndNets"
"lxRegPreUpdateComponentsAndNets(
S_function
)
=> t / nil"
"Registers a SKILL function to be used as a pre-function hook for lxUpdateComponentsAndNets to enable replacement of pins that have their layer and width characteristics defined using the Design Intent tool. lxRegPreUpdateComponentsAndNetsFn, when used in combination with lxRegPostUpdateComponentsAndNetsFn, avoids the need for deleting the pins defined in Design Intent before the pins can be updated.")
("lxRemoveSynchronousCloneFromFamily"
"lxRemoveSynchronousCloneFromFamily(
[ cloneList ]
)
=> t / nil"
"Removes a specified synchronous clone from its family. As a result, the clone is desynchronized and it behaves as a basic group. If a clone that belongs to a two-member synchronous family is removed from the family, the other member clone is also removed and the family is deleted.")
("lxRunCmdInVXL"
"lxRunCmdInVXL(
d_layCV 
u_cmd 
g_cmdArgs 
[ ?schCV d_schCV ]
)
=> t / nil"
"This function is being maintained only to support backward compatibility. Cadence recommends that you use lxRunCmdInXL instead. If you were to use lxRunCmdInVXL, use it to run a user-supplied command in Layout XL, with CPH and the Binder enabled, without opening the windows. The PhysConfig used is obtained from the layout cellview. If you want to work in Automatic mode, the schematic cellview, an optional argument, is required. The batch function does not work with the following: Interactive editing, Incremental binding, and Incremental extraction.")
("lxRunCmdInXL"
"lxRunCmdInXL(
d_layCV 
u_cmd 
[ ?cmdArgs g_cmdArgs ] 
[ ?hierarchical {t | nil} ]
[ ?editLayout {t | nil} ]
[ ?editSchematic {t | nil} ]
[ ?skipLeafs {t | nil} ]
)
=> t / nil"
"Runs a user-defined command in Layout XL in the current layout or for each unique layout master in the specified layout cellviews hierarchy. When the lxRunCmdInXL SKILL function is run, the CPH and the binder are enabled, but no windows open. The physConfig and the schematic connectivity reference is obtained from the layout cellviews by setting the SKILL functions lxSetConnRef and lxSetConfigRef. The lxRunCmdInXL function does not support the following commands: interactive edits, incremental binding, and incremental extraction. The user-supplied command must have at least two arguments-the schematic cellview ID and the layout cellview ID for the Layout XL session.")
("lxSelectedDeleteNetRouting"
"lxSelectedDeleteNetRouting(
)
=> t / nil"
"Deletes routing of the selected nets.")
("lxSelectedExtendChain"
"lxSelectedExtendChain(
)
=> t / nil"
"Extends the current selection to all the instances abutted to a selected instance such that the entire chain is selected.")
("lxSelectedExtendSelection"
"lxSelectedExtendSelection(
)
=> t / nil"
"Extends the current selection to any associated instances, terms, or nets such that any unselected instances that are part of folded, mfactored, sfactored, vectored, lxCombination devices, buses, or bundle nets. If the binder is not available, the selection extends to any instances, terms, or nets that share the same base name. Unselected devices whose base name cannot be determined in the absence of the binder, remain unselected.")
("lxSelectedLock"
"lxSelectedLock(
)
=> t / nil"
"Locks the nets currently selected in the layout cellview.")
("lxSelectedLockNet"
"lxSelectedLockNet(
)
=> t / nil"
"Locks the nets attached to the shapes currently selected in the layout cellview")
("lxSelectedRemoveIgnore"
"lxSelectedRemoveIgnore(
)
=> t / nil"
"Removes the ignore property on selected instances and pins.")
("lxSelectedRoute"
"lxSelectedRoute(
g_useWAOverrides
)
=> t / nil"
"Routes the nets currently selected in the layout cellview.")
("lxSelectedRouteNet"
"lxSelectedRouteNet(
g_useWAOverrides
)
=> t / nil"
"Routes the nets attached to the shapes currently selected in the layout cellview.")
("lxSelectedSelectAttachedNets"
"lxSelectedSelectAttachedNets(
)
=> t / nil"
"Selects the nets attached to the objects currently selected in the layout cellview.")
("lxSelectedSelectAttachedGlobalNets"
"lxSelectedSelectAttachedGlobalNets(
)
=> t / nil"
"Selects the power, ground, or global nets attached to the objects currently selected in the layout cellview.")
("lxSelectedSelectAttachedSignalNets"
"lxSelectedSelectAttachedSignalNets(
)
=> t / nil"
"Selects nets other than power, ground, or global nets attached to the objects currently selected in the layout cellview.")
("lxSelectedSelectExternalNets"
"lxSelectedSelectExternalNets(
)
=> t / nil"
"Selects the external nets for the groups, clones, or modgens currently selected in the layout cellview. An external net connects an object within a group to an object outside the group.")
("lxSelectedSelectExternalGlobalNets"
"lxSelectedSelectExternalGlobalNets(
)
=> t / nil"
"Selects any power, ground, or global nets that are externally connected to the groups, clones, or modgens currently selected in the layout cellview. An external net connects an object within a group to an object outside the group.")
("lxSelectedSelectExternalSignalNets"
"lxSelectedSelectExternalSignalNets(
)
=> t / nil"
"Selects any nets other than power, ground, or global nets that are externally connected to the groups, clones, or modgens currently selected in the layout cellview. An external net connects an object within a group to an object outside the group.")
("lxSelectedSelectInternalNets"
"lxSelectedSelectInternalNets(
)
=> t / nil"
"Selects the internal nets for the groups, clones, or modgens currently selected in the layout view. An internal net connects objects contained within a group.")
("lxSelectedSelectInternalGlobalNets"
"lxSelectedSelectInternalGlobalNets(
)
=> t / nil"
"Selects any power, ground, or global nets that are internal to the groups, clones, or modgens currently selected in the layout view. An internal net connects objects contained within a group.")
("lxSelectedSelectInternalSignalNets"
"lxSelectedSelectInternalSignalNets(
)
=> t / nil"
"Selects any nets other than power, ground, or global nets that are internal to the groups, clones, or modgens currently selected in the layout view. An internal net connects objects contained within a group.")
("lxSelectedSelectNetsShapes"
"lxSelectedSelectNetsShapes(
)
=> t / nil"
"Selects all the shapes attached to the nets currently selected in the layout cellview.")
("lxSelectedUnlock"
"lxSelectedUnlock(
)
=> t / nil"
"Unlocks the nets currently selected in the layout cellview.")
("lxSelectedUnlockNet"
"lxSelectedUnlockNet(
)
=> t / nil"
"Unlocks the nets attached to the shapes currently selected in the layout cellview.")
("lxSelectedUpdateFromSource"
"lxSelectedUpdateFromSource(
)
=> t / nil"
"Updates the masters, connectivity, and parameters of the instances currently selected in the layout cellview.")
("lxSelectedUpdateIgnore"
"lxSelectedUpdateIgnore(
)
=> t / nil"
"Sets the ignore property on selected instances and pins.")
("lxSelectSynchronousFamily"
"lxSelectSynchronousFamily(
[ cloneList ]
)
=> t / nil"
"Selects all the clones in the layout canvas and the Navigator that are members of the specified clone family. If all the family members are already selected, no more clones are selected on the canvas or in the Navigator. If any new clones are identified, they are selected on the canvas and in the Navigator.")
("lxSetAreaEstimationOptions"
"lxSetAreaEstimationOptions(
[ ?source1 t_source1 ]
[ ?source1Val source1Val ]
[ ?source2 t_source2 ]
[ ?source2Val source2Val ]
[ ?calcMethod t_calcMethod ]
[ ?areaCalc t_areaCalc ]
)
=> t / nil"
"Sets the area estimation options to be used in generating a rectangular boundary in either the Generate Layout or Update Components and Nets form. The function is valid only if you specify a rectangular boundary using the lxSetBoundaryOptions function. It must be called between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish.")
("lxSetBoundaryOptions"
"lxSetBoundaryOptions(
[ ?shape t_shape ]
[ ?origin g_origin ]
[ ?points lg_points ]
)
=> t / nil"
"Sets the boundary options in the Generate Layout and Update Components and Nets forms. It must be called between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish.")
("lxSetCloneFamilyName"
"lxSetCloneFamilyName(
clone familyName
)
=> t / nil"
"Sets a new name for the family to which the specified clone belongs.")
("lxSetConfigRef"
"lxSetConfigRef(
t_layLib 
t_layCell
t_layView 
t_referenceType
[ ?cfgLib t_cfgLib ]
[ ?cfgCell t_cfgCell ]
[ ?cfgView t_cfgView ]
)
=> t / nil"
"Sets or unsets the physical configuration cellview for a specified layout cellview. You specify the layout cellview in question and whether the reference type is NONE or physConfig. If the reference type is physConfig, specify the library, cell, and view names of the physical configuration to use.")
("lxSetConnRef"
"lxSetConnRef(
t_layLib 
t_layCell
t_layView 
t_sourceType { CELLVIEW | NONE }
[ ?schLib t_schLib ]
[ ?schCell t_schCell ]
[ ?schView t_schView ]
)
=> t / nil"
"Sets or unsets the connectivity reference for a specified layout cellview without opening the layout view graphically. You must specify the layout view and whether the source type is NONE or CELLVIEW. If the source type is CELLVIEW, you can specify the schematic cellview to use (by default it is set to the schematic view in the same library and cell). The function also saves the layout cellview, but only if had not been modified prior to lxSetConnRef being called.")
("lxSetGenerateOptions"
"lxSetGenerateOptions(
[ ?pins { t | nil } ]
[ ?instances { t | nil } ]
[ ?boundary { t | nil } ]
[ ?snapBoundary { t | nil } ]
[ ?stacks { t | nil } ]
[ ?folds { t | nil } ]
[ ?posMinSep n_posMinSep ]
[ ?inBoundary { t | nil } ]
[ ?mtm { t | nil } ]
[ ?extract { t | nil } ]
[ ?virtualHierarchy { t | nil } ]
)
=> t"
"Tells Generate All From Source or Update Components And Nets what types of objects to generate. You can call it between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish.")
("lxSetNetPinSpecs"
"lxSetNetPinSpecs(
[ ?nets lt_nets ]
[ ?lpp lt_lpp ]
[ ?width n_width ]
[ ?height n_height ]
[ ?numPins x_numPins ]
[ ?create g_create ]
)
=> t / nil"
"Takes a list of nets and with the specified parameters sets the pin information in either the Generate Layout or Update Components and Nets form. This function must always be called between calls to lxGenerateStart and lxGenerateFinish or lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish. If optional arguments are not supplied the normal default values for the form fields apply.")
("lxSetPreserveFloorplanningOptions"
"lxSetPreserveFloorplanningOptions(
[ ?preserve { all | none } ]
[ ?rows { t | nil } ]
[ ?blockages { t | nil } ]
[ ?areaBoundaries { t | nil } ]
[ ?trackPatterns { t | nil } ]
[ ?clusters { t | nil } ]
[ ?clusterBoundaries { t | nil } ]
)
=> t / nil"
"Sets the preserve floorplanning objects options in the Generate Layout form. It must be called between calls to lxGenerateStart and lxGenerateFinish.")
("lxSetSchematicDriven"
"lxSetSchematicDriven(
g_value
)
=> t / nil"
"Sets the various schematic-driven options that are controlled by the Configure tab on the Layout XL Connectivity form. The SKILL function can be used to control the following environment variables: lxSchematicDefaultApp, openConnRefTab, extractEnabled, constraintAwareEditing, flightLineEnable, autoUpdateFlightlines, netNameDisplayEnabled.")
("lxSetUpdateOptions"
"lxSetUpdateOptions(
[ ?deletePins { t | nil } ]
[ ?deleteInstances { t | nil } ]
[ ?replaceMaster { t | nil } ]
[ ?withMarkers { t | nil } ]
[ ?netsOnly { t | nil } ]
[ ?selected nil { t | nil } ]
[ ?layoutParameters { t | nil } ]
[ ?layoutConstraints { t | nil } ]
[ ?sigType { t | nil } ]
[ ?netVoltage { t | nil } ]
)
=> t / nil"
"Sets the options in the Update group box of the Update Components and Nets form. It must be called between calls to lxUpdateComponentsAndNetsStart and lxUpdateComponentsAndNetsFinish.")
("lxShapeSlotting"
"lxShapeSlotting( 
[ ?cv d_cellViewId ] 
[ ?all { t | nil } ]
[ ?region l_region ]
[ ?layers l_layers 
[ ?widthThreshold n_widthThreshold ]
[ ?slotLength n_slotLength ]
[ ?slotWidth n_slotWidth ]
[ ?lSpacing n_lSpacing ]
[ ?wSpacing n_wSpacing ]
[ ?slotToEdge n_slotToEdge ]
[ ?slotVia { t | nil } ]
[ ?windowSize n_windowSize ]
[ ?stepSize n_stepSize ]
[ ?maxDensity n_maxDensity ]
[ ?slotStaggered { t | nil } ]
[ ?lengthWidthRatio n_lengthWidthRatio ]
[ ?excludePins { t | nil } ]
[ ?slotSpacingAtTurn n_slotSpacingAtTurn ]
[ ?onlyComplexPolygons { t | nil }
[ ?halfManhattan { t | nil } ]
[ ?halfManhattanStyle l_halfManhattanStyle ]
[ ?directionalSlotPattern l_directionalSlotPattern ]
[ ?shapes l_shapes ]
[ ?turnSlotPattern l_turnSlotPattern ]
) 
=> t / nil"
"Creates slots on shapes to ensure that wide wires are in compliance with maxDensity and maxWidth constraint rules. It also preserves viable electromigration and resistance attributes by creating rectangular slots in the direction of the current over the wires and square slots at turns (same layer or changed layer). There are two modes depending on the arguments specified: Geometric and Density Aware. In Geometric mode, the slotting shapes are fully specified (size, spacing, and step size), while in Density Aware mode, the slotting shape geometries are automatically computed based on the maxDensity specification. Also, in Geometric mode, you can create slots on shapes on non-metal layers. It is still possible to override any of the geometric information, such as the width, length, or spacing.")
("lxShowCommonIncompleteNetsForSelectedInsts"
"lxShowCommonIncompleteNetsForSelectedInsts(
[ w_windowID ]
)
=> t / nil"
"Runs the Enter function named Show Common Incomplete Nets for Selected Instances, which displays the incomplete nets that are common to the instances selected in the layout. The SKILL function can also be run in pre-select mode on the set of instances that are already selected in the layout. The post-selection mode is supported when only one instance is pre-selected.")
("lxShowHideIncompleteNets"
"lxShowHideIncompleteNets(
[ w_windowID ]
)
=> t / nil"
"Shows and hides any incomplete nets associated with selected objects in the specified layout window. The function establishes the incomplete nets associated with the selected objects and toggles the visibility of the markers representing those incomplete nets on or off depending on their previous state.")
("lxToggleLocalAbutment"
"lxToggleLocalAbutment(
)
=> t"
"Changes the state of the lxLocalAbutment environment variable and honors the change immediately in Layout XL. Use this function to switch local abutment on and off without having to restart the software.")
("lxToggleShowAllIncompleteNets"
"lxToggleShowAllIncompleteNets(
[ w_windowID ]
)
=> t / nil"
"Toggles the visibility of all the incomplete nets displayed in the design canvas.")
("lxToggleShowIncompleteNets"
"lxToggleShowIncompleteNets(
[ w_windowID ]
)
=> t / nil"
"Toggles the visibility of the current set of incomplete nets displayed in the design canvas. The first time you run the command, it hides all currently visible incomplete nets and stores the list of incomplete nets for later retrieval. The next time you run the command, it restores the visibility of the stored set of incomplete nets.")
("lxUnfold"
"lxUnfold(
)
=> t / nil"
"Deletes all the folds of the selected folded device and creates a single, unfolded device at the same coordinates in the layout as the selected fold. The width of the new unfolded device is determined based on the width of the corresponding schematic device, if one exists. If the corresponding schematic device does not exist and the unfoldUseLayoutWidths environment variable is set to t, the sum of the fold widths is used to determine the total width of the unfolded device.")
("lxUnregMasterDiffName"
"lxUnregMasterDiffName(
)
=> t / nil"
"Unregisters the SKILL function used to return a name for a master difference reported by the Check Against Source command.")
("lxUnSlotVia"
"lxUnSlotVia(
[ ?cv d_cellViewId ] 
[ ?all { t | nil } ]
[ ?region l_region ]
[ ?layers l_layers ]
) 
=> t / nil"
"Restores the via that has been slotted by the command lxShapeSlotting.")
("lxUpdateAllPhysBinding"
"lxUpdateAllPhysBinding(
d_layCV
)
=> t / nil"
"Updates the physical bindings of all the instances in the specified layout cellview.")
("lxUpdateBinding"
"lxUpdateBinding(
d_layCV
[ ?schCV d_schCV ]
[ ?nameOnly { t | nil } ]
[ ?currentLevel { t | nil } ]
[ ?extract { t | nil } ]
[ ?clearConn { t | nil } ]
[ ?extractStopLevel [0-32] ]
[ ?preserveUserBindings { t | nil } ]
[ ?preserveLayoutHierarchy { t | nil } ]
[ ?flattenLayoutCreate { Synchronized Family | Grouped Objects| Free Objects } ]
[ ?bindingFile t_fileName ]
[ ?crossRefFile t_fileName ]
[ ?extractedNetlistFile t_fileName ]
[ ?PVSRulesFile t_fileName ]
[ ?PVSScale n_PVSScale ]
[ ?correctMaster { t | nil } ]
[ ?ignoreRouteCells { t | nil } ]
[ ?ignoreDummies { t | nil } ]
[ ?preserveExistingBindings { t | nil } ]
[ ?hierarchical { t | nil } ]
[ ?allCellsInDesign { t | nil } ]
[ ?createTransparent { t | nil } ]
[ ?createPinsFromLabels { t | nil } ]
[ ?checkDuplicateObjects { t | nil } ]
[ ?removeDuplicateObjects { t | nil } ]
)
=> t / nil"
"Improves the binding between the schematic and the layout by setting options that control how the connectivity, the manual bindings, and the design hierarchy is processed. If a log file name is specified for the hierSummaryLogFileName environment variable, the SKILL function prints the summary information to the specified log file, in addition to printing the information to the default Virtuoso log file")
("lxUpdateComponentsAndNets"
"lxUpdateComponentsAndNets(
d_schCellViewID
d_layCellViewID
[ ?initCreatePins { t | nil } ]
[ ?initGlobalNetPins { t | nil } ]
[ ?initCreatePadPins { t | nil } ]
[ ?initCreateInstances { t | nil } ]
[ ?initCreateBoundary { t | nil } ]
[ ?initCreateSnapBoundary { t | nil } ]
[ ?initDoStacking { t | nil } ]
[ ?initDoFolding { t | nil } ]
[ ?initCreateMTM { t | nil } ]
[ ?deleteUnmatchedInsts { t | nil } ]
[ ?deleteUnmatchedPins { t | nil } ]
[ ?updateReplacesMasters { t | nil } ]
[ ?updateWithMarkers { t | nil } ]
[ ?updateLayoutParameters { t | nil } ]
[ ?updateNetSigType { t | nil } ]
[ ?updateNetMinMaxVoltage { t | nil } ]
[ ?updateNetsOnly { t | nil } ]
[ ?virtualHierarchy { t | nil } ]
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Updates the components and nets for the specified schematic and layout cellviews. If you use the optional arguments, they override the existing environment variables set in the .cdsenv file. The default value for each optional argument corresponds to the default value of the associated environment variable.")
("lxUpdateComponentsAndNetsFinish"
"lxUpdateComponentsAndNetsFinish(
d_schId
d_layId
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Finishes the update process by executing the Update Components And Nets command with the form values supplied by lxSet* functions and after the previous call to lxUpdateComponentsAndNetsStart.")
("lxUpdateComponentsAndNetsStart"
"lxUpdateComponentsAndNetsStart(
d_schId
d_layId
[ ?extractSchematic { t | nil } ]
)
=> t / nil"
"Starts the Update Components And Nets command, building the Update Components and Nets form without displaying it to the screen.")
("lxUpdatePhysBinding"
"lxUpdatePhysBinding(
d_layCV
)
=> t / nil"
"Updates the physical bindings of the currently selected instances in the specified layout cellview.")
("lxUpdatePlacementStatus"
"lxUpdatePlacementStatus(
)
=> t / nil"
"Updates the placement status of instances and pins in the current cellview. Instances and pins that are wholly inside the PR boundary with status unknown are updated to status placed. Instances and pins wholly outside the PR boundary with status placed are updated to unknown.")
("lxVerifyCloneFamily"
"lxVerifyCloneFamily(
[ cloneList ]
)
=> t / nil"
"Runs a consistency check on the specified synchronous clone family to verify if the family members are identical to each other.")
("nclRunConstraintValidation"
"nclRunConstraintValidation(
d_cellviewID
)
=> t"
"Validates the constraints supported by constraint-aware editing mode in the specified cellview.")
("nclToggleCAEMode"
"nclToggleCAEMode(
)
=> t"
"Toggles constraint-aware editing mode, which causes figures in the layout to move in a constraint-correct fashion. For example, moving a device that is part of a symmetry constraint moves its constrained partner devices appropriately.")
("soiEnableDrcDfm"
"soiEnableDrcDfm(
)
=> t"
"Enables the DRC/DFM tab in the Annotation Browser and the DRC/DFM commands in the Optimize menu in Layout XL.")
("techGetLxExtractLayers"
"techGetLxExtractLayers(
d_techFileID
)
=> l_extractLayers / nil"
"Returns the list of extract layers from the virtuosoDefaultExtractorSetup constraint group in the specified technology file. These layers are listed as validLayers in the interconnect subsection of the constraint group.")
("techGetLxNoOverlapLayers"
"techGetLxNoOverlapLayers(
d_techFileID
)
=> l_noOverlapLayers / nil"
"Lists the pairs of layers that cannot overlap.")
("techIsLxExtractLayer"
"techIsLxExtractLayer(
d_techFileID
tx_layer
)
=> t / nil"
"Indicates whether the specified layer is listed as an extract layer in the virtuosoDefaultExtractorSetup constraint group in the specified technology file. The extract layers are listed under validLayers in the interconnect subsection of the constraint group.")
("techIsLxNoOverlapLayer"
"techIsLxNoOverlapLayer(
d_techFileID
tx_layer1
tx_layer2
)
=> t / nil"
"Indicates whether the specified pair of layers is a derived no overlap layer in the specified technology file. The order in which the layers is specified does not matter.")
("techSetLxExtractLayer"
"techSetLxExtractLayer(
d_techFileID 
tx_extractLayer
)
=> t / nil"
"Adds the specified layer to the list of extract layers in the virtuosoDefaultExtractorSetup constraint group in the specified technology file. The extract layers are listed under validLayers in the interconnect subsection of the constraint group. If any of the necessary technology file sections do not already exist, this function creates them.")
("techSetLxExtractLayers"
"techSetLxExtractLayers(
d_techFileID 
l_extractLayers
)
=> t / nil"
"Adds the specified layers to the list of extract layers in the virtuosoDefaultExtractorSetup constraint group in the specified technology file. The extract layers are listed under validLayers in the interconnect subsection of the constraint group. If any of the necessary technology file sections do not already exist, this function creates them.")
("techSetLxNoOverlapLayer"
"techSetLxNoOverlapLayer(
d_techFileID
tx_layer1
tx_layer2
)
=> t / nil"
"Derives a no overlap layer by performing an AND operation on the two specified layers, and flags it as an error layer in the virtuosoDefaultExtractorSetup constraint group in the specified technology file. The derived layer is defined in the techDerivedLayers subsection in the layerDefinitions section of the technology file and is listed as an errorLayer in the interconnect subsection of the constraint group. No overlap layers are named and numbered consecutively; each is named noOverlapLayern, where n is the next available consecutive integer. If any of the necessary technology file sections does not already exist, the function creates them.")
("techSetLxNoOverlapLayers"
"techSetLxNoOverlapLayers(
d_techFileID
l_noOverlapLayers
)
=> t / nil"
"Creates a list of layers that cannot overlap. The function creates a derived layer by performing an AND operation on each pair of layers and flags the resultant layer as an error layer in the virtuosoDefaultExtractorSetup constraint group in the specified technology file. Each derived layer is defined in the techDerivedLayers subsection in the layerDefinitions section of the technology file and is listed as an errorLayer in the interconnect subsection of the constraint group.")
("vfoAbut"
"vfoAbut(
g_obj
l_instsList
[ @rest l_args ]
)
=> t / nil"
"Abuts the instances provided in the l_instList. You can pass optional arguments to this SKILL API.
Note: The Abut command does not call the vfoAbut function for fluid devices.")
("vfoAdvGRUpdateCDF"
"vfoAdvGRUpdateCDF(
g_obj
t_libName
t_cellName
t_viewName
)
=> l_cdfParams"
"(ICADVM20.1 Only) Helps to modify the existing CDFs on a FGR device and add more CDFs on it. The function can be defined for subclasses of vfoAdvGuardRing. It works based on callback mechanism, that is, the user defines it and the infrastructure calls it.")
("vfoAllocateProtocolObj"
"vfoAllocateProtocolObj(
d_obj
)
=> g_instance / nil"
"Allocates and returns the newly allocated and initialized instance of the vfo protocol class of the Pcell. You can use the vfoGetProtocolClassName SKILL function to determine the name of the protocol class.")
("vfoAllocateShapeData"
"vfoAllocateShapeData(
d_shape
)
=> g_instance / nil"
"Returns a newly allocated and initialized instance of the subclass of the vfoShapeData  class for the specified database shape ID.")
("vfoChopInstance"
"vfoChopInstance(
g_obj
d_instId
chopShapeData
[ @rest l_args ]
)
=> t / nil"
"Chops the fluid shape of a given instance. The information of the chop rectangle or polygon is provided by chopShapeData which is a class object of vfoShapeData. The shape data points are in the design coordinates. This function transforms the chopShapeData before chopping the fluid shape.

Note: The Chop command for fluid Pcells does not pass these arguments. This function updates the relevant Pcell parameters. If the chop operation results in multiple shapes, it may need to create multiple Pcell instances.")
("vfoConvertToPolygon"
"vfoConvertToPolygon( 
g_obj
d_instId
[ @rest l_args ]
) 
=> t / nil"
"Converts the fluid shape of the given instance to a polygon. This is used for instances containing path type fluid shape. The Convert to Polygon command for fluid Pcells does not pass these arguments. This function updates the relevant Pcell parameters.")
("vfoCreateAutoFGR"
"vfoCreateAutoFGR(
) 
=> nil"
"Wraps obstacles in wrap mode on clicking an obstacle if AUTO mode is selected in the Device field of the Create Guard Ring form. This function is used to specify the bindkey for creation of FGR in auto mode.")
("vfoCreateObstruction"
"vfoCreateObstructions(
g_obj
d_instId
layerPurposePair
obstructionShapeData
[ @rest l_args ]
) 
=> t / nil"
"Creates obstruction or tunnel on a given instance that has an associated fluid shape. A tunnel helps you to cut a specific layer-purpose of a guard ring device for connectivity purpose. There are four types of tunneling mechanisms-Path, Rectangle, Polygon, and Overlapping Shape. For procedural details about creating tunnels using GUI, refer to the Creating a Tunnel Through a Fluid Guard Ring section in the Editing Fluid Guard Rings chapter of the Virtuoso Fluid Guard Ring User Guide.

Note: To remove any existing obstructions, use the vfoDeleteObstruction SKILL function.")
("vfoCreateObstructions"
"vfoCreateObstructions(
g_obj
d_instId
l_lppPoint
[ @rest l_args ]
) 
=> nil"
"(IC6.1.8 Only) Creates obstruction or tunnel on a given instance that has an associated fluid shape. A tunnel helps you to cut a specific layer-purpose of a guard ring device for connectivity purpose. There are four types of tunneling mechanisms-Path, Rectangle, Polygon, and Overlapping Shape. For procedural details about creating tunnels using GUI, refer to the Creating a Tunnel Through a Fluid Guard Ring section in the Editing Fluid Guard Rings chapter of the Virtuoso Fluid Guard Ring User Guide.

Note: To remove any existing obstructions, use the vfoDeleteObstruction SKILL function.")
("vfoCreateShapeData"
"vfoCreateShapeData(
t_shapeType
[ @rest l_args ]
)
=> g_instance / nil"
"Allocates, initializes, and returns an instance of the subclass of the vfoShapeData of the given shape type.")
("vfoDeleteObstruction"
"vfoDeleteObstruction(
g_obj
d_instId
layerPurposePair
obstructionShapeData
[ @rest l_args ]
) 
=> t / nil"
"Deletes the obstruction or tunnel on a given instance that has an associated fluid shape. This SKILL function is equivalent to healing.

For procedural details about healing an obstruction using GUI, refer to the Healing a Fluid Guard Ring section in the Editing Fluid Guard Rings chapter of the Virtuoso Fluid Guard Ring User Guide.

Note: To create an obstruction, use the vfoCreateObstruction SKILL function.")
("vfoDoSnapToSnapPattern"
"vfoDoSnapToSnapPattern (
d_inst
)
=> t / nil"
"(ICADVM20.1 Only) Snaps the fluid object to the snap pattern.")
("vfoDrawFluidShape"
"vfoDrawFluidShape(
g_shapeObj
cellView
layerPurposePair
)
=> d_obj / nil"
"Creates a dbObject corresponding to shapeData object in the given cellview on the given layer purpose pair.")
("vfoGetDeviceClassParam"
"vfoGetDeviceClassParam( 
t_libName
t_deviceName
t_classParam
) 
=> value / nil"
"(ICADVM20.1 Only) Returns the class parameter of the specified cdsGuardRing device. This SKILL function also supports the incremental technology database (ITDB). Therefore, the information is retrieved for FGR devices in both the library and the referenced library.")
("vfoGetDeviceFormalParam"
"vfoGetDeviceFormalParam( 
t_libName
t_deviceName
t_formalParam
) 
=> value / nil"
"(ICADVM20.1 Only) Returns the implementation formal parameter of the specified cdsGuardRing device. This SKILL function also supports ITDB. Therefore, the information is retrieved for FGR devices in both the library and the referenced library.")
("vfoGetFileListWithLoadSequence"
"vfoGetFileListWithLoadSequence( 
) 
=> l_vfoFilename"
"Returns a list of vfo*.ils filenames with their loading sequence.")
("vfoGetImplementationClassName"
"vfoGetImplementationClassName( 
t_libName
t_deviceName
) 
=> value"
"Returns the value of the vfoGRImpl class parameter, that is the implementation class name, of an FGR device from the specified library. This SKILL function also supports the incremental technology database (ITDB). Therefore, the information is retrieved for FGR devices in both the library and the referenced library.")
("vfoGetInstWithMissingCache"
"vfoGetInstWithMissingCache( 
t_libName
t_cellName
t_viewName
) 
=> l_dbIDs"
"Returns three lists of dbIDs. The first is the list of dbIDs of all instances whose submaster is not found in index.pcl file. The second is the list of dbIDs of all instances whose submaster is found in index.pcl file but not found in cache.pcl file because the file is corrupt or missing. The third is the list of dbIDs of instances whose submaster is not found because the supermaster has been updated after instance creation.")
("vfoGetParam"
"vfoGetParam( 
g_obj
s_param
) 
=> value / nil"
"Returns the value of a CDF parameter for the given object.")
("vfoGetProtocolClassName"
"vfoGetProtocolClassName(
t_cellViewID
) 
=> s_cellView / nil"
"Returns the symbol naming the protocol class to use with the fluid Pcell functions.")
("vfoGetVersion"
"vfoGetVersion( 
) 
=> t_version"
"Returns the version of the VFO SKILL code used in Virtuoso. This SKILL function is available from IC6.1.6 ISR2 and ICADV12.1 ISR4 onwards.")
("vfoGRCleanVersionCache"
"vfoGRCleanVersionCache(
t_libName
[ ?cellName t_cellName ]
[ ?viewName t_viewName ]
)
=> t / nil"
"Updates the index.pcl and cache.pcl files by removing any unused entries of sub-masters from these files. This is an alternative to cleaning the cache if you have disabled the automatic FGR cache cleaning mechanism described in the Automatic Cache Cleaning section, or even if the Automatic Cache Cleaning mechanism is enabled by you and would like to clean the FGR caches on-demand.")
("vfoGRCompareParams"
"vfoGRCompareParams(
g_obj
d_inst1
d_inst2
) 
=> t / nil"
"(ICADVM20.1 Only) Checks the equality of FGR instances. You override this function and can define its new  equality for FGR instances. By default, it checks the value of the following parameters: verticalPitch, horizontalPitch, verticalSegWidth, and horizontalSegWidth. This function is called by the Merge command. For the Merge command to succeed, this function should return t for the two FGR instances being compared.")
("vfoGrCreateCDF"
"vfoGrCreateCDF(
t_libName
t_cellName
t_viewName
)
=> l_cdfParams"
"Creates fluid guard ring CDF parameters on the given library, cell view of the fluid guard ring device. It deletes any existing CDF parameters on the device.")
("vfoGRCreateDeviceClass"
"vfoGRCreateDeviceClass(
t_techLibName
[ ?override g_override ]
) 
=> t / nil"
"Creates the device class definition for fluid guard ring (cdsGuardRing) in the given technology file. If the device class already exists in the technology file, it is updated when override is set to true.")
("vfoGRDisableVersionCache"
"vfoGRDisableVersionCache(
l_FGRcellDDID
t_libName
[ ?cellName t_cellName ]
[ ?viewName t_viewName ]
)
=> t / nil"
"Disables version cache for all instances that belong to the specified super-master list and found in the specified library, cell, or view. All instances are updated and the value of their createVersionCache parameter is set to 0.")
("vfoGREnableVersionCache"
"vfoGREnableVersionCache(
l_FGRcellDDID
t_libName
[ ?cellName t_cellName ]
[ ?viewName t_viewName ]
)
=> t / nil"
"Enables version cache on all instances currently not cache-enabled that belong to the specified list of FGR super-masters and found in the in the specified library, cell, or view. The createVersionCache parameter of such instances will get updated from 0 to the VFO version of the current Virtuoso session.")
("vfoGRGetCreateFormFieldProp"
"vfoGRGetCreateFormFieldProp(
t_promptName
t_propertyName
)
=> value"
"Gets the value of a property assigned to an existing field or GUI component displayed on the Create Guard Ring form.")
("vfoGRGetCreateFormIdentifier"
"vfoGRGetCreateFormIdentifier(
r_formPointer
) 
=> t_uniqueFormIdentifier"
"Returns the unique identifier string used for creating the Create Guard Ring form.")
("vfoGRGetCreateFormPointer"
"vfoGRGetCreateFormPointer(
t_uniqueFormIdentifier
) 
=> r_formPointer"
"Returns the form pointer corresponding to the unique identifier that creates the Create Guard Ring form.")
("vfoGRGetCommonQPtr"
"vfoGRGetCommonQPtr(
) 
=> t_queuePointer"
"Returns the common queue pointer of the Create Guard Ring form customized by you.")
("vfoGRGetExtraArgument"
"vfoGRGetExtraArgument(
) 
=> l_keyValuePair"
"Retrieves the value of user-defined fields, that is, list of `key value' pair set using the vfoGRSetExtraArgument SKILL function.")
("vfoGRGetExtraArgumentName"
"vfoGRGetExtraArgumentName(
g_obj
) 
=> l_argName"
"(ICADVM20.1 Only) Returns the extra parameter names in a list. The end user should override this function for its class that has been extended from vfoAdvGuardRing.")
("vfoGRGetQueuePointer"
"vfoGRGetQueuePointer(
t_qName
)
=> t_qPointer"
"Returns the pointer corresponding to the name of the queue of the customized Create Guard Ring form.")
("vfoGRGeometry"
"vfoGRGeometry(
(pcell vfoSfPCellClass)
) 
=> t / nil"
"Calls three generic functions in the following order: vfoSfInitialize(pcell), vfoSfDraw(pcell), and then vfoSfFinalize(pcell) for drawing the fluid Pcell geometry.

NOTE: This is the top-level entry point to the vfo space-filling Pcell.")
("vfoGRMaximizeShapes"
"vfoGRMaximizeShapes(
d_instId
) 
=> t / nil"
"Tries all possible combinations of fillStyle and decompositionMode to find the combination that maximizes the number of shapes, and thereby the number of contact cuts.")
("vfoGRNewCreateForm"
"vfoGRNewCreateForm(
t_uniqueFormIdentifier
t_formType
[ l_callbackList ]
) 
=> r_formPointer / nil"
"Creates the new Create Guard Ring form, that is, a new form pointer along with the unique fields and form symbol.")
("vfoGRRegCreateFormUpdateCallback"
"vfoGRRegCreateFormUpdateCallback(
r_formPointer
t_procedureName
[ l_callbackList ]
)"
"Registers the user-defined form customization procedure. This procedure gets called for the particular form pointer after the vfoGRUpdateCreateForm trigger is called.")
("vfoGRSetCreateFormAllFieldsInvisible"
"vfoGRSetCreateFormAllFieldsInvisible(
{ t | nil }
)"
"Sets the visible property for the predefined system fields, except the Technology and Device fields, on the Create Guard Ring form. This function cannot be used to set the properties of fields that you add while customizing the Create Guard Ring form.")
("vfoGRSetCreateFormFieldProp"
"vfoGRSetCreateFormFieldProp(
t_promptName
t_propertyName
t_propertyValue
)"
"Sets the properties of the fields or components displayed on the Create Guard Ring form.")
("vfoGRSetExtraArgument"
"vfoGRSetExtraArgument(
l_associativeList
)"
"Makes the values of the user-defined GUI components available for processing to the FGR infrastructure that resides in Virtuoso, and sets the corresponding CDF parameters. This SKILL function helps in binding the front-end data for back-end processing.")
("vfoGRSmoothen"
"vfoGRSmoothen(
d_inst
[ ?tmpLpp t_tmpLpp ]
[ ?direction t_direction ]
) 
=> d_inst"
"Removes the small notches in the given direction from the fluid shape of the given fluid Pcell instance. The temporary shapes are created on tmpLpp.")
("vfoGRUpdateCreateFormSize"
"vfoGRUpdateCreateFormSize(
x_width
x_height
)
=> t / nil"
"Resizes the Create Guard Ring forms, including the form used for modgens. This function updates the size of all tabs and subtabs proportionately. However, there is no change in the size of the fields on the form. ")
("vfoGRUpdateTunnelLPPs"
"vfoGRUpdateTunnelLPPs ( 
) 
=> l_lpp / nil"
"(ICADVM20.1 Only) Returns the layer-purpose pairs on which tunnelling is allowed. The VFO infrastructure selects common layer-purpose present in the FGR and LPPs returned by the function vfoGRUpdateTunnelLPPs. If the function vfoGRUpdateTunnelLLPs returns nil, all FGR layer-purposes are displayed on the Create Tunnel in Fluid Object form.")
("vfoGRUpdateTunnelOptions"
"vfoGRUpdateTunnelOptions ( 
) 
=> l_optionTypes / nil"
"(ICADVM20.1 Only) Returns the list of supported options for FGR tunnel shape types. VFO infrastructure uses options returned by this function and checks with the existing options. The first value returned by this function is selected by default when the Create Tunnel in Fluid Object form opens. If the vfoGRUpdateTunnelOptions function is not defined, returns nil, or any invalid option is returned, all tunnel options are displayed on the Create Tunnel in Fluid Object form.")
("vfoGRUpdateVersionCache"
"vfoGRUpdateVersionCache(
l_FGRcellDDID
t_libName
[ ?cellName t_cellName ]
[ ?viewName t_viewName ]
)
=> t / nil"
"Updates the vfoCreateVersion parameter of an instance to the current Virtuoso version. If the vfoCreateVersion parameter is set to 0, the vfoGRUpdateVersionCache function does not update the vfoCreateVersion parameter to the latest Virtuoso version. You have to call the vfoGREnableVersionCache function to update this parameter to the latest Virtuoso version. If the vfoCreateVersion parameter is set to an older Virtuoso version and the image of the sub-master is not found in the cache files, cache.pcl and index.pcl, the vfoGRUpdateVersionCache function does not update the vfoCreateVersion parameter to the latest Virtuoso version. You have to call the vfoGRDisableVersionCache function and then the vfoGREnableVersionCache function to update this parameter to the latest Virtuoso version.")
("vfoInstallFluidDeviceFiles"
"vfoInstallFluidDeviceFiles( 
[ ?installPath t_installPath ]
[ ?overwrite { t | nil } ]
[ ?showMsg { t | nil } ]
) 
=> t / nil"
"Loads a set of Cadence-supplied SKILL files in a specific sequence in the Virtuoso environment. These files are required to work with fluid guard rings. These files are automatically loaded when you start Virtuoso.")
("vfoIsCommandInDragMode"
"vfoIsCommandInDragMode ( 
) 
=> t / nil"
"Returns t if the vfo-related command is in drag mode, else returns nil.")
("vfoIsGuardRing"
"vfoIsGuardRing( 
t_object
) 
=> t / nil"
"Returns t if the object to be queried is a valid guard ring instance, else returns nil.")
("vfoMergeInstances"
"vfoMergeInstances(
g_obj
d_inst1
d_inst2
[ @rest l_args ]
) 
=> dbId / nil"
"Merges the fluid Pcell instances inst1 and inst2. The Merge command for fluid Pcells does not pass these arguments. This function updates the relevant Pcell parameters.")
("vfoPostChopCBHandler"
"vfoPostChopCBHandler
t_mode
S_callbackFunction
) 
=> t / nil"
"Registers or deregisters a user-defined callback function that is called after the chop command completes on an FGR instance. You can do post-processing on the edited FGR instance in the registered callback function.")
("vfoPostReshapeCBHandler"
"vfoPostReshapeCBHandler
t_mode
S_callbackFunction
) 
=> t / nil"
"Registers or deregisters a user-defined callback function that is called after the reshape command completes on an FGR instance. You can do post-processing on the edited FGR instance in the registered callback function.")
("vfoPostSplitCBHandler"
"vfoPostSplitCBHandler
t_mode
S_callbackFunction
) 
=> t / nil"
"Registers or deregisters a user-defined callback function that is called after the split command completes on an FGR instance. You can do post-processing on the edited FGR instance in the registered callback function.")
("vfoPostStretchCBHandler"
"vfoPostStretchCBHandler
t_mode
S_callbackFunction
) 
=> t / nil"
"Registers or deregisters a user-defined callback function that is called after the stretch command completes on an FGR instance. You can do post-processing on the edited FGR instance in the registered callback function.")
("vfoReInstallAllFluidGuardRingDevices"
"vfoReInstallAllFluidGuardRingDevices( 
t_techFileId
) 
=> t / nil"
"Reinstalls all the FGR devices in the specified technology file.")
("vfoReInstallGuardRingDevice"
"vfoReInstallGuardRingDevice( 
t_techFileId
l_devices
) 
=> t / nil"
"Reinstalls the specified FGR devices in the specified technology file.")
("vfoRotateInstance"
"vfoRotateInstance(
g_obj
d_inst1
x_angle_in_degrees
[ @rest l_args ]
) 
=> t / nil"
"Applies the rotation angle on the FGR instance. This function applies to Pcells.")
("vfoSetParam"
"vfoSetParam(
obj
s_param
value
) 
=> value / nil"
"Sets the value of a CDF parameter to the given value and triggers the callback, if any. The callback is triggered recursively so that if the callback changes another parameter, that callback is also triggered, recursively.")
("vfoSetParams"
"vfoSetParams(
d_inst
l_paramlist
) 
=> t / nil"
"Sets the value of multiple parameters in a single call. The l_paramlist argument contains a list of parameter name and value pairs.")
("vfoSetProtocolClassName"
"vfoSetProtocolClassName(
cellview
className
) 
=> t / nil"
"Sets the protocol class for fluid Pcell for the given Pcell supermaster. This function gets called in the Pcell code for creating the supermaster of a fluid guard ring device in a text file.")
("vfoSfDraw"
"vfoSfDraw(
(pcell vfoSfPCellClass)
) 
=> t / nil"
"Draws the Pcell geometries using the information populated by the vfoSfInitialize function.")
("vfoSfFinalize"
"vfoSfFinalize(
pcell vfoSfPCellClass
) 
=> t / nil"
"Performs any required cleanup.")
("vfoSfInitialize"
"vfoSfInitialize( 
(pcell vfoSfPCellClass)
) 
=> t / nil"
"This is the initialization function that is called during space-filling Pcell evaluation. This function initializes the slots and populates other required information for Pcell drawing (vfoSfDraw).")
("vfoSfOuterEdgeCornerContRemoval"
"vfoSfOuterEdgeCornerContRemoval( 
(pcell vfoSfPCellClass)
) 
=> t / nil"
"Removes the ear-vertex and end-corner contacts from the corners of an FGR to ensure it is created with a smaller footprint. This is achieved by allowing specification of enclosure values lesser than the maximum value, but greater than the minimum value of the minOppExtension rule.")
("vfoSmoothen"
"vfoSmoothen(
d_shape
s_direction
[ ?tmpLpp t_tmpLpp ]
) 
=> t / nil"
"Smoothens the given polygon shape. If the shape is not a polygon, then the shape is returned unchanged.")
("vfoSupportsAbut?"
"vfoSupportsAbut?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Abut operation is supported on the given instance.")
("vfoSupportsChop?"
"vfoSupportsChop?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Chop operation is supported on the given instance.")
("vfoSupportsConvertToPolygon?"
"vfoSupportsConvertToPolygon?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Convert to Polygon operation is supported on the given instance.")
("vfoSupportsCreateObstruction?"
"vfoSupportsCreateObstruction?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Create Obstruction (Tunnel) operation is supported on the given instance.")
("vfoSupportsCreateObstructions?"
"vfoSupportsCreateObstructions?(
g_obj
d_instId
) 
=> t / nil"
"(IC6.1.8 Only) Checks if the Create Obstruction (Tunnel) operation is supported on the given instance.")
("vfoSupportsDeleteObstruction?"
"vfoSupportsDeleteObstruction?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Delete Obstruction (Heal) operation is supported on the given instance.")
("vfoSupportsMerge?"
"vfoSupportsMerge?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the Merge operation is supported on the given instance.")
("vfoSupportsRotation"
"vfoSupportsRotation(
d_instId
) 
=> t / nil"
"Checks of the Pcell instance supports rotation.")
("vfoSupportsUpdateModelShape?"
"vfoSupportsUpdateModelShape?(
g_obj
d_instId
) 
=> t / nil"
"Checks if the fluid shape of the given instance can be modified. This function is called by commands that directly update the fluid shape, such as Stretch, Reshape, Split, and Align.")
("vfoSupportsVersionCache"
"vfoSupportsVersionCache(
g_obj
) 
=> t / nil"
"(IC6.1.8 Only) Checks whether the Version Cache Management feature is supported on the specified instance.")
("vfoTransformFluidShape"
"vfoTransformFluidShape( 
(shapeObj vfoShapeData)
transform
) 
=> g_instance / nil"
"Applies the transform to the given shapeData. This function modifies the given shapeData object and returns it. ")
("vfoTunnelHigherMetalLayers"
"vfoTunnelHigherMetalLayers( 
(pcell vfoSfPCellClass)
) 
=> t / nil"
"Enables tunneling of high metal layers in a stacked metal fluid guard ring device. This function is called during the Pcell evaluation of fluid guard ring devices.")
("vfoUpdateModelShape"
"vfoUpdateModelShape( 
g_obj
d_instId
shapeId
newShapeType
newPointList
[ @rest l_args ]
) 
=> t / nil"
"Updates the given fluid shape of the Pcell instance. The new shape type and points are specified in the newShapeType and newPointList arguments, respectively. The newPointList points are in the design coordinates. This function transforms the newPointList before updating the fluid shape. The Edit command for fluid shapes does not pass these arguments. This function updates the relevant Pcell parameters.")
("iccIsConnected"
"iccIsConnected(
[ d_cellviewId ]
) 
=> t / nil"
"Indicates if a connection from the Virtuoso design environment to the router has been established.")
("iccSendCommand"
"iccSendCommand(
d_cellviewId 
t_command
) 
=> t_retString"
"Sends a command to the router command line interpreter.")
("iccSendSkillCommand"
"iccSendSkillCommand(
d_cellviewId 
t_command
)
=> t_retString"
"Sends a SKILL command to the router.")
("lxDressingTemplateEditor"
"lxDressingTemplateEditor(
)
=> t"
"Invokes the Dressing Template Editor form.")
("lxEditPinPlacement"
"lxEditPinPlacement(
[ g_fromLayoutGenFormP ]
)
=> t"
"Opens the Pin Placement form in which you can view pin information, constrain a pin to a boundary edge, order and fix pins, specify the pitch for pin placement, and start the Pin Placement function.")
("lxEditPlacementStyle"
"lxEditPlacementStyle(
)
=> t"
"Opens the Placement Planning form in which you can plan the placement of CMOS, standard cells, or a mixture of CMOS and standard cells. Each of the three modes generates rows based on the parameters you enter in the form.")
("lxHiAutoPlace"
"lxHiAutoPlace(
[ d_cellViewID ]
)
=> t / nil"
"Opens the Auto Placer form in which you can set placement parameters and run the Virtuoso Custom Digital Placer automatic placement function.")
("lxHiPlaceBoundaryCell"
"lxHiPlaceBoundaryCell(
)
=> t / nil"
"(ICADVM20.1 Only) Opens the Boundary Cell Placement form.")
("lxHiPlaceFiller"
"lxHiPlaceFiller(
)
=> t / nil"
"Displays the Insert/Delete Filler Cells form.")
("lxMovePorts"
"lxMovePorts(
d_cellViewID
)
=> t"
"Moves top-level ports over components based on their connectivity.")
("vcpfeCreateRows"
"vcpfeCreateRows(
d_cv
t_mode
[ ?partitionName t_partitionName ]
[ ?area l_area ] 
[ ?createRows g_createRows ]
[ ?insertTapCells g_insertTapCells ]
[ ?insertBoundaryCells g_insertBoundaryCells ]
)
=> t / nil"
"Estimates and creates rows according to the specified arguments. This command also places tap cells and boundary cells after row creation, which can be controlled using arguments.")
("vcpfePlaceFillers"
"vcpfePlaceFillers(
d_cv
g_mode
?partitionName { prBoundary | g_clusterBoundaryName }
?fillerCompTypes t_fillerCompTypes
?fillerCellNames t_fillerCellNames
?ignoreBlockages { t | nil }
?createphysOnly { t | nil }
)
=> t / nil"
"Inserts or deletes filler cells from the specified cellview.")
("vcpfePlaceTapCells"
"vcpfePlaceTapCells(
d_cv
t_mode {insert | delete}
[ ?partitionName t_name ]
[ ?tapCompTypes t_types ]
[ ?tapCellNames t_cellNames ]
[ ?tapToTapSpacing f_value ]
[ ?tapBackOff f_value ]
[ ?minTapSpacing f_value ]
[ ?tapPattern {Regular | Checker Board} ] 
[ ?skipRow x_number ]
[ ?tapRowOffset f_value ]
[ ?tapRowEndOffset f_value ]
[ ?periodicTap {t | nil} ]
[ ?lockTap {t | nil} ]
[ ?avoidAbutment {t | nil} ] 
[ ?ignoreBlockages {t | nil} ]
)
=> l_tapCellIDs / nil"
"Inserts tap cells in the empty spaces between standard cells in the specified cellview as per the specified arguments. When t_mode is set to delete, all tap cells in the given cellview are deleted.")
("vcpfePlaceBoundaryCells"
"vcpfePlaceBoundaryCells(
d_cvId
t_mode { insert | delete }
[ ?regionList l_list ]
[ ?leftCell t_name ]
[ ?rightCell t_name ]
[ ?leftBottomCornerCell t_name ]
[ ?rightBottomCornerCell t_name ]
[ ?leftTopCornerCell t_name ]
[ ?rightTopCornerCell t_name ]
[ ?topEdgeCell t_name ]
[ ?bottomEdgeCell t_name ]
[ ?leftMirror { t | nil } ]
[ ?rightMirror { t | nil } ]
[ ?leftCornerMirror { t | nil } ]
[ ?rightCornerMirror { t | nil } ]
[ ?outside { t | nil } ]
[ ?topBotRowPlaceable { t | nil } ]
[ ?boundaryCompTypes t_name ]
[ ?libraryFilter t_name ]
[ ?selectedBoundaryCells t_name ]
)
=> l_cellIDs / nil"
"(ICADVM20.1 Only) Places boundary cells around core cells to isolate the core cells from each other.")
("vcpfePlaceConstraintGroup"
"vcpfePlaceConstraintGroup(
d_cellViewID
)
=> s_constraintGroupName"
"Returns the name of the constraint group that will be used when the placer is run on the specified cellview.")
("vcpfeRunCustomDigitalPlacer"
"vcpfeRunCustomDigitalPlacer(
d_schCvID
d_layCvID
[ ?groupCMOSPairs { t | nil } ]
[ ?preserveChains { t | nil } ]
[ ?groupMFactors { t | nil } ]
[ ?allowRotation { t | nil } ]
[ ?selectedCompList l_selectedCompList ]
[ ?placementMode { Auto Placement | ECO Placement } ]
[ ?optimization { none | basic | moderate | optimized } ]
[ ?ecoModeImpact { none | localized | maximized } ]
[ ?insertSubstrateContacts { t | nil } ]
[ ?saveAs { t | nil } ]
[ ?saveAsLibName t_libName ]
[ ?saveAsCellName t_cellName ]
[ ?saveAsViewName t_viewName ]
[ ?overwrite { t | nil } ]
[ ?intraRowSpacer { t | nil } ]
[ ?interRowSpacer t | nil } ]
[ ?adjustBdy { t | nil } ]
[ ?reserveTracksForRouting { -1 | 0 | 1 ... 10 } ]
[ ?vcpRulesConstraintGroup t_constraintGroupName ]
[ ?minBoundaryOffset f_offset ]
[ ?maxPinsPerNet x_numPins ]
[ ?mixedMode { t | nil } ]
[ ?placeCluster t_clusterName ]
[ ?componentEdge { Boundary | Bounding Box } ]
)
=> t"
"Runs the custom digital placer, specifying the type of placement that is done, the technology rules to be used, any automatic spacing adjustments to be done, and how the modified cellview is saved.")
("rteCheckAntenna"
"rteCheckAntenna(
[ ?cv d_cvid ]
[ ?all g_all ]
[ ?nets l_nets ]
[ ?set g_set ]
[ ?excludeNets l_excludeNets ]
[ ?model l_models ]
) ;
=> t / nil"
"Checks for process antenna violations for the entire design, specific nets, or nets in a set. You can choose to ignore specific nets.")
("rteFixAntenna"
"rteFixAntenna(
[ ?cv d_cvid ]
[ ?all g_all ]
[ ?nets l_nets ]
[ ?set g_set ]
[ ?excludeNets l_excludeNets ]
[ ?layerList l_layerList ]
[ ?fullRulesChecking g_fullRulesChecking ]
[ ?maxWiresToPush x_maxWiresToPush ]
[ ?model l_models ]
[ ?useDiodes g_useDiodes ]
[ ?useJumpers g_useJumpers ]
) ;
=> t / nil"
"Fixes process antenna violations for the entire design, a specific net, or nets in a set by inserting jumpers and/or diodes. You can choose to ignore specific nets.")
("rteCheckRoutability"
"rteCheckRoutability(
[ ?cv d_cvId ]
[ ?noBlockageCheck g_noBlockageCheck ]
[ ?noMinSpaceCheck g_noMinSpaceCheck ]
[ ?noMinWidthCheck g_noMinWidthCheck ]
[ ?noViaCheck g_noViaCheck ]
) ;
=> t / nil"
"Checks the design for known conditions that can cause potential routing problems. Design Rule Checks applied to pins and some routability checks are performed primarily to determine the accessibility of pins. You can exclude any of the checks by specifying the appropriate argument. Annotations are automatically created for violations.")
("rteDeleteRoutedNets"
"rteDeleteRoutedNets(
[ ?cv d_cvid ]
[ ?keepPower g_keepPower ]
) ;
=> t / nil"
"Deletes the routed paths of all nets in the design. Optionally, you can preserve routed power nets.")
("rteSearchAndRepair"
"rteSearchAndRepair(
[ ?cv d_cvid ]
[ ?closeOpens g_closeOpens ]
[ ?excludeNet t_excludeNet ]
[ ?excludeType t_excludeType ]
[ ?set g_set ]
[ ?region l_region ]
[ ?fullRulesChecking g_fullRulesChecking ]
) ;
=> t / nil"
"Searches for and fixes same net and different net spacing violations.")
("rteCheckDataForRouting"
"rteCheckDataForRouting(
[ ?mode t_mode ]
[ ?designRuleSpec t_designRuleSpec ]
[ ?fromRoutingLayer t_fromRoutingLayer ]
[ ?toRoutingLayer t_toRoutingLayer ]
[ ?annotate g_annotate ]
[ ?reportFileName t_reportFileName ]
[ ?selected g_selected ]
) ;
=> t / nil"
"Checks the technology data and the design data to ensure that the VSR router is able to perform correctly.")
("rteFixViolations"
"rteFixViolations(
[ ?cv d_cvID ]
[ ?closeOpens g_closeOpens ]
[ ?excludeNet t_excludeNet ]
[ ?excludePowerGround g_excludePowerGround ]
[ ?fixCrossing g_fixCrossing ]
[ ?fixMfgGrid g_fixMfgGrid ]
[ ?fixMinArea g_fixMinArea ]
[ ?fixMinAreaAtPins g_fixMinAreaAtPins ]
[ ?fixMinEdge g_fixMinEdge ]
[ ?fixMinEncArea g_fixMinEncArea ]
[ ?fixMinWidth g_fixMinWidth ]
[ ?fixNumCuts g_fixNumCuts ]
[ ?fixPortShort g_fixPortShort ]
[ ?fixRouteGrid g_fixRouteGrid ]
[ ?reducePinWireNotches g_ReducePinWireNotches ]
[ ?maximizeCuts g_maximizeCuts ]
[ ?offsetVia g_offsetVia ]
[ ?region l_region ]
[ ?searchAndRepair g_searchAndRepair ]
[ ?set g_set ]
s_value
) ;
=> t / nil"
"This function allows you to fix violations for a selected area or for an entire cellview.")
("rteOptimizeRoute"
"rteOptimizeRoute(
[ ?cv d_cvID ]
[ ?checkAntenna g_checkAntenna ]
[ ?detailCritic g_detailCritic ]
[ ?excludeNet t_excludeNet ]
[ ?excludePowerGround g_excludePowerGround ]
[ ?reduceVias g_reduceVias ]
[ ?region l_region ]
[ ?set g_set ]
[ ?useDoubleCutVias g_useDoubleCutVias ]
) ;
=> t / nil"
"This function is used to optimize routing by performing refinement routing steps, such as reducing the vias, master vias, straighten wire.")
("rteComposeTrunks"
"rteComposeTrunks(
) ;
=> t / nil"
"Converts pathSegs and vias to power trunks usable by both the power and signal routers. The function uses the current cellview and the selected set.")
("rteDecomposeTrunks"
"rteDecomposeTrunks(
) ;
=> t / nil"
"Converts pathSegs and vias in power trunks to normal, routed pathSegs and vias. The function uses the current cellview and the selected set.")
("rteCoverObstructionHilite"
"rteCoverObstructionHilite (
)
=> none"
"Turns on the cover obstruction hilite sets if at least one cover obstruction has been defined in the top-level or masters.")
("rteCoverObstructionUnHilite"
"rteCoverObstructionUnHilite (
)
=> none"
"Turns off the cover obstruction hilite sets for the ones that are already turned on, if at least one cover obstruction has been defined in the top-level or masters.")
("rteGeomAnd"
"rteGeomAnd(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?lpp2 g_lpp2 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?polygons g_polygons ]
[ ?region l_region ]
) ;
=> t / nil"
"Generates new shapes that are common on two or more layer purposes.")
("rteGeomAndNot"
"rteGeomAndNot(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?lpp2 g_lpp2 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?polygons g_polygons ]
[ ?region l_region ]
[ ?size1 f_size1 ]
[ ?size2 f_size2 ]
[ ?trimCorners g_trimCorners ]
) ;
=> t / nil"
"Generates new shapes that exist on one layer purpose and do not overlap shapes on another layer purpose. You can optionally use sized shapes from one or both of the layer purposes. And you can choose to operate on a specific region or the entire design.")
("rteGeomNot"
"rteGeomNot(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?polygons g_polygons ]
[ ?region l_region ]
) ;
=> t / nil"
"Inverts the shapes on a layer purpose to generate new shapes.")
("rteGeomOr"
"rteGeomOr(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?lpp2 g_lpp2 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?polygons g_polygons ]
[ ?region l_region ]
) ;
=> t / nil"
"Merges all shapes on the input layer purposes and generates new shapes on the output layer purpose.")
("rteGeomSize"
"rteGeomSize(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?size f_size ]
[ ?polygons g_polygons ]
[ ?region l_region ]
[ ?trimCorners g_trimCorners ]
[ ?fixEdgesToRegion g_fixEdgesToRegion ]
) ;
=> t / nil"
"Performs an oversize or undersize shapes on a specific layer purpose.")
("rteGeomXor"
"rteGeomXor(
[ ?cv d_cvId ]
[ ?lpp1 g_lpp1 ]
[ ?lpp2 g_lpp2 ]
[ ?outputLpp l_outputLpp ]
[ ?blockedLayer l_blockedLayer ]
[ ?polygons g_polygons ]
[ ?region l_region ]
) ;
=> t / nil"
"Generates new shapes from shapes on either input layer purpose that do not overlap the other layer purpose.")
("rtePowerRouteBlockRing"
"rtePowerRouteBlockRing(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?instances t_instances ]
[ ?channels g_channel ]
[ ?contour g_contour ]
[ ?blockClearance f_blockClearance ]
[ ?layers l_layers ]
[ ?lattice g_lattice ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
) ;
=> t / nil"
"Executes block ring routing for a layout cellview.")
("rtePowerRouteCellRow"
"rtePowerRouteCellRow(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?layers l_layers ]
[ ?routingArea l_routingArea ]
[ ?rowEnd g_rowEnd ]
[ ?extend g_extend ]
) ;
=> t / nil"
"Executes cell row routing for a layout cellview.")
("rtePowerRouteCoreRing"
"rtePowerRouteCoreRing(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?coreClearance f_coreClearance ]
[ ?padClearance f_padClearance ]
[ ?inAreaClearance f_inAreaClearance ]
[ ?outAreaClearance f_outAreaClearance ]
[ ?routingArea l_routingArea ]
[ ?layers l_layers ]
[ ?lattice g_lattice ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
) ;
=> t / nil"
"Executes core ring power routing for a layout cellview.")
("rtePowerRoutePadRing"
"rtePowerRoutePadRing(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?pads l_pads ]
[ ?layers l_layers ]
[ ?railPins g_railPins ]
[ ?edgePins g_edgePins ]
) ;
=> t / nil"
"Executes pad ring power routing for a layout cellview.")
("rtePowerRoutePinToTrunk"
"rtePowerRoutePinToTrunk(
[ ?cv d_cvId ]
[ ?instances l_instances ]
[ ?layers l_layers ]
[ ?nets l_nets ]
[ ?trunkLayer t_trunkLayer ]
[ ?minTrunkWidth f_minTrunkWidth ]
[ ?minWireWidth f_minWireWidth ]
[ ?maxWireWidth f_maxWireWidth ]
) ;
=> t / nil"
"Executes pin to trunk routing for a layout cellview. A trunk is usually a power net created by power routing commands such as pad ring, core ring, block ring, stripes, or cell rows.")
("rtePowerRouteStripes"
"rtePowerRouteStripes(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?routingArea l_routingArea ]
[ ?xStep f_sStep ]
[ ?yStep f_yStep ]
[ ?layers l_layers ]
[ ?pinClearance f_pinClearance ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
[ ?minLength f_minLength ]
[ ?leftOffset f_leftOffset ]
[ ?bottomOffset f_bottomOffset ]
[ ?xOffset f_xOffset ]
[ ?yOffset f_yOffset ]
[ ?centerLine g_centerLine ]
) ;
=> t / nil"
"Executes stripes power routing for a layout cellview.")
("rtePowerRouteTrimStripes"
"rtePowerRouteTrimStripes(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?layers l_layers ]
[ ?includeStraps g_includeStraps ]
[ ?undoable g_undoable ]
) ;
=> t / nil"
"Trim existing stripes created by the rtePowerRouteStripes function.")
("rtePowerRouteViaInsertion"
"rtePowerRouteViaInsertion(
[ ?cv d_cvId ]
[ ?nets l_nets ]
[ ?instances l_instances ]
[ ?layers l_layers ]
[ ?minLayer t_minLayer ]
[ ?maxLayer t_maxLayer ]
[ ?rows n_rows ]
[ ?columns n_columns ]
[ ?squareCutArray g_squareCutArray ]
[ ?useValidRoutingVias g_useValidRoutingVias ]
) ;
=> t / nil"
"Executes via insertion between previously routed power rings, stripes, and cell rows.")
("rtePowerRouteTieShield"
"rtePowerRouteTieShield(
[ ?cv d_cvId ]
[ ?shieldTieFreq n_shieldTieFreq ]
[ ?coaxTieFreq n_coaxTieFreq ]
) ;
=> t / nil"
"Ties shield wires to the shield nets in the entire design. Executed after creating shield nets either automatically or interactively.")
("rteCreateBlockRingScheme"
"rteCreateBlockRingScheme(
[ ?name s_name ]
[ ?contour g_contour ]
[ ?channel g_channel ]
[ ?blockClearance f_blockClearance ]
[ ?horiLayer t_horiLayer ]
[ ?vertLayer t_vertLayer ]
[ ?latticeStyle g_latticeStyle ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
) ;
=> t / nil"
"Creates a block ring routing scheme.")
("rteCreateCellRowsScheme"
"rteCreateCellRowsScheme(
[ ?name s_name ]
[ ?allRouteLayers g_allRouteLayers ]
[ ?routeLayers l_routeLayers ]
[ ?endOfRow g_endOfRow ]
[ ?extendToNearest g_extendToNearest ]
) ;
=> t / nil"
"Creates a cell rows routing scheme.")
("rteCreateCoreRingScheme"
"rteCreateCoreRingScheme(
[ ?name s_name ]
[ ?ringAtCenter g_ringAtCenter ]
[ ?relativeTo s_relativeTo ]
[ ?coreClearance f_coreClearance ]
[ ?padClearance f_padClearance ]
[ ?inAreaClearance f_inAreaClearance ]
[ ?outAreaClearance f_outAreaClearance ]
[ ?areaXLo f_areaXLo ]
[ ?areaYLo f_areaYLo ]
[ ?areaXHi f_areaXHi ]
[ ?areaYHi f_areaYHi ]
[ ?horiLayer t_horiLayer ]
[ ?vertLayer t_vertLayer ]
[ ?latticeStyle g_latticeStyle ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
) ;
=> t / nil"
"Creates a core ring routing scheme.")
("rteCreatePadRingScheme"
"rteCreatePadRingScheme(
[ ?name s_name ]
[ ?allPinLayers g_allPinLayers ]
[ ?pinLayers l_pinLayers ]
[ ?railPins g_railPins ]
[ ?edgePins g_edgePins ]
) ;
=> t / nil"
"Creates a pad ring routing scheme.")
("rteCreatePinToTrunkScheme"
"rteCreatePinToTrunkScheme(
[ ?name s_name ]
[ ?allPinLayers g_allPinLayers ]
[ ?pinLayers l_pinLayers ]
[ ?useTrunkLayer g_useTrunkLayer ]
[ ?trunkLayer t_trunkLayer ]
[ ?minTrunkWidth f_minTrunkWidth ]
[ ?minWireWidth f_minWireWidth ]
[ ?maxWireWidth f_maxWireWidth ]
) ;
=> t / nil"
"Creates a pin to trunk routing scheme. A trunk is usually a power net created by power routing commands such as pad ring, core ring, block ring, stripes, or cell rows.")
("rteCreateStripesScheme"
"rteCreateStripesScheme(
[ ?name s_name ]
[ ?horiStripes g_horiStripes ]
[ ?yStep f_yStep ]
[ ?horiLayers l_horiLayers ]
[ ?vertStripes g_vertStripes ]
[ ?xStep f_sStep ]
[ ?vertLayers l_vertLayers ]
[ ?pinClearance f_pinClearance ]
[ ?netClearance f_netClearance ]
[ ?netWidth f_netWidth ]
[ ?minStripeWidth f_minStripeWidth ]
[ ?offsetFrom s_offsetFrom ]
[ ?leftOffset f_leftOffset ]
[ ?bottomOffset f_bottomOffset ]
[ ?useCenterLine g_useCenterLine ]
) ;
=> t / nil"
"Creates a stripes routing scheme.")
("rteCreateViasScheme"
"rteCreateViasScheme(
[ ?name s_name ]
[ ?layerRange g_layerRange ]
[ ?minLayer t_minLayer ]
[ ?maxLayer t_maxLayer ]
[ ?cutArrayRule s_cutArrayRule ]
[ ?cutArrayRows n_cutArrayRows ]
[ ?cutArrayColumns n_cutArrayColumns ]
) ;
=> t / nil"
"Creates a via insertion scheme.")
("vsrLoadPreset"
"vsrLoadPreset(
t_fileName
[ ?directory t_directory ]
[ ?execMode s_execMode ]
[ ?path t_path ]
) ;
=> t / nil"
"Loads a preset file to the Wire Assistant form and the Virtuoso Space-based Router Options form.")
("vsrSavePreset"
"vsrSavePreset(
t_PresetLabel
t_fileName
[ ?directory t_directory ]
[ ?path t_path ]
[ ?tooltip t_tooltip ]
[ ?description t_description ]
[ ?iconFileName t_iconFileName ]
[ ?iconText t_iconText ]
[ ?location s_location ]
[ ?mode s_mode ]
[ ?envGroups l_envGroups ]
) ;
=> t / nil"
"Saves the current settings to a preset file for later re-use.")
("vsrDeletePreset"
"vsrDeletePreset(
t_fileName
[ ?directory t_directory ]
[ ?path t_path ]
[ ?confirmation g_confirmation ]
) ;
=> t / nil"
"Deletes a preset file.")
("rdeCloseSession"
"rdeCloseSession(
) ;
=> t / nil"
"This function terminates the current Virtuoso Routing IDE session and closes the Virtuoso Routing IDE window. The rdeCloseSession function returns the GXL tokens if it was checked out by the rdeShow function.")
("rdeDone"
"rdeDone(
) ;
=> t / nil"
"This function closes the Virtuoso Routing IDE system.")
("rdeEval"
"rdeEval(
t_expression
[ g_openCurrentDesign ]
[ s_doCheckPoint ]
) ;
=> t / nil"
"This function evaluates the Tcl expression that is supplied. There are no arguments to open the current design and also perform a checkpoint once the Tcl expression is evaluated.")
("rdeGetVar"
"rdeGetVar(
[ t_varname ]
) ;
=> t / nil"
"This function returns the Virtuoso Routing IDE environment variable. The Virtuoso Routing IDE environment variables are independent of the dfII environment package.")
("rdeHide"
"rdeHide(
) ;
=> t / nil"
"This function terminates the current Virtuoso Routing IDE session and closes the Virtuoso Routing IDE window. The rdeHide function returns the GXL tokens if it was checked out by the rdeShow function.")
("rdeInspect"
"rdeInspect(
[ d_dbID ]
) ;
=> t / nil"
"This function displays the Virtuoso Routing IDE property inspector GUI. If a dbObject is supplied, then the inspector will show that object and its properties. If no object is supplied, then the currently open geWindow's cellview will be inspected.")
("rdeOpenCurrentDesign"
"rdeOpenCurrentDesign(
[ g_showWindow ]
) ;
=> t / nil"
"This function will open the Virtuoso Routing IDE window and start the Virtuoso Routing IDE environment on the cellview that the geWindow has currently loaded. It will also make the current Virtuoso window ReadOnly until the window is closed.")
("rdeReplay"
"rdeReplay(
t_fileName 
[ g_openCurrentDesign ]
[ s_doCheckPoint ]
) ;
=> t / nil"
"This function reads the supplied file name and send each line one-at-a-time to the Tcl interpreter. This is in contrast to rdeSource, in which the entire Tcl file is read into the interpreter and then executed. It may be useful in determining which line of a script file had an error, in case an error occurs. Since each line is executed independently, it is not possible to create expressions (such as function definitions) that span more than one line.")
("rdeSequencer"
"rdeSequencer(
[ t_designStyle ]
) ;
=> t / nil"
"This function will display the auto router sequencer dialog box. It will obtain some values from the current geWindow. If there is no current geWindow, it will return nil.")
("rdeSetVar"
"rdeSetVar(
t_varName 
g_varValue 
) ;
=> t / nil"
"This function sets the Virtuoso Routing IDE environment variable to the supplied value. The Virtuoso Routing IDE environment variables are independent of the dfII environment package.")
("rdeShow"
"rdeShow(
) ;
=> t / nil"
"This function displays the Virtuoso Routing IDE window.")
("rdeSource"
"rdeSource(
t_fileName
[ g_openCurrentDesign ]
[ s_doCheckPoint ]
) ;
=> t / nil"
"This function sources the Tcl expression that is supplied. There are arguments to open the current design and also perform a checkpoint once the Tcl file has been sourced.")
("rdeCreateChamferFill"
"rdeCreateChamferFill(
[ ?all { t | nil } ] 
[ ?cv d_cvid ]
[ ?region l_region ] 
[ ?layer lt_layer ] 
[ ?lengthThreshold f_length ] 
[ ?chamferValue1 {f_value1 | l_chamfer1} ]
[ ?chamferValue2 {f_value2 | l_chamfer2} ]
[ ?extendViaChamfer { t | nil } ]
[ ?allowViolation { t | nil } ]
[ ?outputPurpose t_purposeName ]
[ ?materialRemovalPurpose t_purposeName ]
[ ?chamferFilter l_filterCriteria ]
)
=> t / nil"
"Creates chamfer fill on wires (pathSegs). The chamfer fill mechanism removes 90-degree corners by filling the corners of wires that form T-junctions, L-shaped wires, wire-to-via, wire-to-rectangle, and wire-to-polygon connections. T-junctions and L shapes created using only rectangles or polygons are not considered for chamfer fill.")
("rdeCreateWireChamfer"
"rdeCreateWireChamfer(
[ ?all { t | nil } ]
[ ?cv d_cvid ]
[ ?region l_region ] 
[ ?layer lt_layer ] 
[ ?lengthThreshold f_length ]
[ ?chamferValue1 {f_value1 | l_chamfer1} ]
[ ?chamferValue2 {f_value2 | l_chamfer2} ]
[ ?allowViolation { t | nil } ]
[ ?innerChamfer { t | nil } ]
[ ?chamferFilter l_filterCriteria ]
[ ?chamferEndOfStripe { t | nil } ]
)
=> t / nil"
"Creates chamfers on wires (pathSegs). The wire chamfer mechanism replaces 90-degree wires with 45-degree wires.")
("rdeRemoveChamferFill"
"rdeRemoveChamferFill(
[ ?all { t | nil } ] 
[ ?region l_region ] 
[ ?layer lt_layer ] 
[ ?outputPurpose t_purposeName ]
[ ?materialRemovalPurpose t_purposeName ]
[ ?concaveOnly { t | nil }
)
=> t / nil"
"Removes all the right-angled triangle shapes of purposes specified by outputPurpose and materialRemovalPurpose (except if concaveOnly is true). Usually, these shapes are created by the command rdeCreateChamferFill.")
("adpInitFloorPlan"
"adpInitFloorplan(
d_cv
t_engine
?all g_all
?deleteClusterBndry g_deleteClusterBndry
?deleteCluster g_deleteCluster
?deleteBlockages g_deleteBlockages
?prsvPlacementBkg g_prsvPlacementBkg
?prsvRoutingBkg g_prsvRoutingBkg
?prsvAreaHaloBkg g_prsvAreaHaloBkg
?prsvFeedthruBkg g_prsvFeedthruBkg
?prsvFillBkg g_prsvFillBkg
?prsvPinBkg g_prsvPinBkg
?prsvScreenBkg g_prsvScreenBkg
?prsvSlotBkg g_prsvSlotBkg
?prsvWiringBkg g_prsvWiringBkg
?deleteWires g_deleteWires
?deleteRows g_deleteRows
?deleteFillers g_deleteFillers
?fillerPrefix t_fillerPrefix
?deleteShapes g_deleteShapes
?prsvCircle g_prsvCircle
?prsvDonut g_prsvDonut
?prsvEllipse g_prsvEllipse
?prsvPath g_prsvPath
?prsvPolygon g_prsvPolygon
?prsvRectangle g_prsvRectangle
?deleteBndry g_deleteBndry
?prsvAreaBndry g_prsvAreaBndry
?prsvSnapBndry g_prsvSnapBndry
?initGrid g_initGrid
?designBndry g_designBndry
?origin t_origin
?aspectRatio f_aspectRatio
?chipWidth f_chipWidth
?chipHeight f_chipHeight
?boundaryShapeType t_boundaryShapeType
?boundaryPoints g_boundaryPoints
?designArea f_designArea
?initInstances g_initInstances
?prsvIO g_prsvIO
?prsvStd g_prsvStd
?prsvMacro g_prsvMacro
?prsvCustomCell g_prsvCustomCell
?initPins g_initPins
?prsvPlacedPin g_prsvPlacedPin
?prsvFixedPin g_prsvFixedPin
?prsvLockedPin g_prsvLockedPin
?prsvFigGrp g_prsvFigGrp
?window g_window
)
=> t / nil"
"Initializes the floorplan of a design based on the options you specify. Most of the options being keywords, you need to specify only those parameters that you want to control. The parameters that you do not specify use the default values.")
("adpnlSetEnv"
"adpnlSetEnv(
t_variable
g_value
[ ?domain s_domain ]
)
=> t / nil"
"Sets a variable in the specified domain. If the environment variable does not exist in the domain, a variable is created.")
("vfpAlignPins"
"vfpAlignPins(
t_referencePinFigNameList
t_targetPinfigNameList
g_topCellViewId
)
=> t / nil"
"Aligns a list of target pins with respect to the position of a list of reference pins.")
("vfpAutoPin"
"vfpAutoPin(
d_refView
?mode { cellview | selected }
[ ?validRoutingLayer g_shapesOnRoutingLayersOnly ] 
[ ?purpose t_shapesOnSpecificPurpose ] 
[ ?schematicCheck g_schematicCheck ] 
[ ?deleteMode { auto | all } ] 
[ ?checkDuplicatePin g_checkDuplicatePin ]
[ ?boundarySignalMode { single | multiple } ] 
[ ?buriedSignalMode { single | multiple } ]
[ ?boundaryMultipleMode { topLayer | useLayer } ]
[ ?buriedMultipleMode { topLayer | useLayer } ]
[ ?boundarySignalPinLayers t_boundarySignalPinLayers ]
[ ?buriedSignalPinLayers t_buriedSignalPinLayers ]
[ ?boundaryPowerPinLayers t_boundaryPowerPinLayers ] 
[ ?buriedPowerPinLayers t_buriedPowerPinLayers ] 
[ ?boundaryPinSize t_boundaryPinSize ] 
[ ?targetLPP t_targetLPP ] 
[ ?pinConnectivity t_pinConnectivity ] 
[ ?createLabel g_createLabel ] 
[ ?enableColoring g_enableColoring ]
[ ?createMetalShape g_createMetalShape ]
[ ?metalShapeType { path | rectangle } ]
[ ?preview g_preview ] 
)
=> t / nil"
"Searches for net shapes in the specified window or cellview and automatically creates boundary and buried pins on these net shapes.")
("vfpCPHGenPhysicalHier"
"vfpCPHGenPhysicalHier(
t_topLogicalLibName
t_topLogicalCellName
t_topLogicalViewName
t_topPhysicalLibName
t_topPhysicalCellName
t_topPhysicalViewName
t_FloorplanPropertyFileName
)
=> t / nil"
"Generates a hierarchical floorplan. It takes the Floorplan property file and the names of the logical and physical top cell view names as inputs. The top logical lib cell view name should match the names provided in the Floorplan property file.")
("vfpCPHGenPhysicalHierNoPropFile"
"vfpCPHGenPhysicalHierNoPropFile(
t_topLogicalLibName
t_topLogicalCellName
t_topLogicalViewName
t_topPhysicalLibName
t_topPhysicalCellName
t_topPhysicalViewName
)
=> t / nil"
"Generates a physical configuration without a Floorplanning property file.")
("vfpCPHLoadFloorplanFile"
"vfpCPHLoadFloorplanFile(
t_topLogicalLibName
t_topLogicalCellName
t_topLogicalViewName
t_FloorplanPropertyFileName
)
=> t / nil"
"Populates the CPH form in Soft Block mode by using the Floorplan property file.")
("vfpCreateBoundaryPinsForSelectedShapes"
"vfpCreateBoundaryPinsForSelectedShapes(
d_cellViewId 
[ n_distanceFromBoundary ]
)
=> l_pinIds / nil"
"Creates boundary pins on selected shapes.")
("vfpLoadPhysicalView"
"vfpLoadPhysicalView(
t_sourceLibName
t_sourceCellName
t_sourceViewName
t_targetLibName
t_targetCellName
t_targetViewName
[ ?updateInstances g_updateInstances ]
[ ?updateInstanceOptions l_updateInstanceOptions ]
[ ?updateDesignOptions l_updateDesignOptions ]
[ ?loadPins s_updatePins ]
[ ?addGeometries g_addGeometries ]
[ ?addGeometryOptions l_addGeometryOptions ]
[ ?updateBoundaries g_updateBoundaries ]
[ ?updateBoundaryOptions l_updateBoundaryOptions ]
[ ?replaceRows g_replaceRows ]
[ ?replaceRowOptions l_replaceRowOptions ]
[ ?replaceBlockages g_replaceBlockages ] 
[ ?replaceHalos g_replaceHalos ] 
[ ?replaceObstructionOptions l_replaceObstructionOptions ]
[ ?transferConstraints g_transferConstraints ] 
)
=> t / nil"
"Updates the instances, pins, geometries, and P&R information from a source cell view to a target cell view. The source cell view acts as a template to perform the following in the target cell view:")
("vfpHiPushPreRoutesDown"
"vfpHiPushPreRoutesDown(
w_windowId
)"
"Invokes the GUI for pushing pre-routes down.")
("vfpPtAddPinResizeEstimator"
"vfpPtAddPinResizeEstimator(
t_functionName
t_nickname
)
=> t / nil"
"Register a custom SKILL function for resizing pins. This registered function is passed as a parameter to vfpPtRunPinResizeEstimator to resize pins.")
("vfpPtGetPinResizeEstimators"
"vfpPtGetPinResizeEstimators(
[ g_nicknameOnly ]
)
=> ( l_nickname l_functionName ) / nil"
"Retrieves a list of registered pin resize estimator SKILL functions. You can specify whether the list must include only the function nicknames or both the function names and their nicknames.")
("vfpPtLoadPinResizeFile"
"vfpPtLoadPinResizeFile(
t_pathID
)
=> t / nil"
"Loads the specified SKILL file containing pin-resize functions.")
("vfpPtRemovePinResizeEstimator"
"vfpPtRemovePinResizeEstimator(
t_nickname
)
=> t / nil"
"Deregisters the given pin resize estimator SKILL function.")
("vfpPtRunPinResizeEstimator"
"vfpPtRunPinResizeEstimator(
d_topCellViewID
t_nickname
?mode { all | selected | specify }
?pinList l_pinList
)
=> t / nil"
"Runs the given registered pin resize estimator SKILL function on pins as specified in the mode argument.")
("vfpPushPreRoutesDown"
"vfpPushPreRoutesDown(
t_topCVLibName 
t_topCVCellName 
t_topCVViewName
t_softBlockInstName 
t_targetLibName 
t_targetCellName 
t_targetViewName
g_pushCloseWireBlkg
g_rebindInst
[ g_pushOverlappingBlockages ]
[ g_pushPowerNetGeometry ]
[ g_pushRegularNetGeometry ]
[ g_pushRow ]
[ g_pushWSP ]
)
=> t / nil"
"Pushes the top level power-structures of a cell view topCVLibName:topCVCellName:
topCVViewName over soft block instance softBlockInstName into target cell view targetLibName:targetCellName:targetViewName.")
("vfpReportIOPadLocation"
"vfpReportIOPadLocation(
d_dbCellviewID 
g_printFillerPads
)
=> t / nil"
"Prints the IO pad information in formatted manner for all the pads which are placed in the IO rows within the design.")
("vfpPinConnectivitySetting"
"vfpPinConnectivitySetting(
)
=> t / nil"
"This function takes no arguments. It invokes a GUI to enable the pin connectivity information setting.")
("vfpSbDefineObstruction"
"vfpSbDefineObstruction(
l_PhysLCV
t_obstructionType
[ ?topOffset  n_topOffset ]
[ ?bottomOffset n_BottomOffset ]
[ ?leftOffset n_LeftOffset ]
[ ?rightOffset n_RightOffset ]
[ ?layerName t_layerName ]
)
=> t / nil"
"Creates placement, routing, or other obstructions based on the obstructionType argument. All conditions that are enforced for these obstructions through GUI-based flow are applicable here. For example, only one placement blockage would be applied per soft block. If a second placement blockage is applied through this API, a warning is issued. The latest applied placement blockage will not replace the existing placement blockage.")
("vfpSbDeleteObstruction"
"vfpSbDeleteObstruction(
l_PhysLCV
t_obstructionType
[ ?topOffset  n_topOffset ]
[ ?bottomOffset n_BottomOffset ]
[ ?leftOffset n_LeftOffset ]
[ ?rightOffset  n_RightOffset ]
[ ?layerName t_layerName ]
)
=> t / nil"
"Deletes the specified obstruction.")
("vfpSbEditIOPin"
"vfpSbEditIOPin(
l_PhysLCV
t_termName
[ ?lpp txl_lpp ]
[ ?width n_width ]
[ ?height n_height ]
[ ?number x_number ]
[ ?criticality x_criticality ]
[ ?sigType t_sigType ]
)
=> t / nil"
"Edits attributes of the pin that is associated with the specified termName.")
("vfpSbEditSoftBlockType"
"vfpSbEditSoftBlockType(
l_PhysLCV
t_blockType
)
=> t / nil"
"Edits the blockType of the specified soft block.")
("vfpSbSetPolygonalBoundary"
"vfpSbSetPolygonalBoundary(
l_PhysLCV
l_ listOfPolygonPoints
)
=> t / nil"
"Specifies the boundary attributes of soft blocks that are polygonal in shape.")
("vfpSbSetRectangularBoundary"
"vfpSbSetRectangularBoundary(
l_PhysLCV
n_width
n_height
)
=> t  / nil"
"Specifies the boundary vertices of the rectangular soft block.")
("vpaOptimizePins"
"vpaOptimizePins(
?cv d_cellViewId
?layoutLCV l_LCVName
[ ?cphId g_cphId ]
[ ?selectedOnly g_selectedOnly ]
[ ?spacingType t_spacingType ]
[ ?spacingValue n_spacingValue ]
[ ?targetPinSide l_targetPinSides ]
[ ?enableCongestion g_enableCongestion ]
[ ?congestionValue n_congestionValue ]
)
=> t / nil / List of (sbId lib:cell:view status)"
"Runs pin optimization on the specified cellview or design based on the options you specify. You can specify only those parameters that you want to control. The parameters that you do not specify get their values from the corresponding LayoutXL environment variable.")
("nclAnalogAdjCellPins"
"nclAnalogAdjCellPins(
[ d_cellViewID ]
)
=> t / nil"
"Adjusts the pins in the specified cellview to be close to the terminals to which they are connected, while also respecting any constraints set on the pins. If you do not specify a cellview, the function operates on the currently open cellview.")
("nclAnalogAdjCellSides"
"nclAnalogAdjCellSides(
[ d_cellViewID ]
)
=> t / nil"
"Adjusts the location of any place and route boundary in the current cellview so that it encloses all the instances in the design in a manner consistent with constraints. If you do not specify a cellview, the function operates on the currently open cellview.")
("nclAnalogAutoPlaceCB"
"nclAnalogAutoPlaceCB(
[ d_cellViewID ]
[ g_effortLevel ]
[ g_updatePRBoundary ]
)
=> t / nil"
"Opens the Analog AutoPlace form to run Analog Automatic Placement, which optimizes the placement of instances and pins to meet any constraints set on the design, while also optimizing the design for both area and wire length. If you specify d_cellViewID, Analog Automatic Placement runs automatically without displaying the form.")
("nclAnalogFixDRCs"
"nclAnalogFixDRCs(
[ d_cellViewID ]
)
=> t / nil"
"Attempts to remove overlaps between instances, while enforcing any constraints specified on the design. If you do not specify a cellview, the function operates on the currently open cellview.")
("nclAnalogQuickPlace"
"nclAnalogQuickPlace(
[ d_cellViewID ]
)
=> t / nil"
"Runs Analog Quick Place on the specified cellview. The resulting layout will be constraint-correct with non-overlapping instances, but will not be optimized for area or wire length.")
("nclAnalogQuickPlaceLikeSchemCB"
"nclAnalogQuickPlaceLikeSchemCB(
[ layoutCV ]
[ schemCV ]
)
=> t / nil"
"Runs Analog Place Like Schematic on the currently open cellview. This places instances in the same relative position as their schematic counterparts, while also enforcing any specified constraints. If run without an active window, both layoutCV and schemCV need to be specified.")
("nclCreateXSym"
"nclCreateXSym (
d_cv
[ d_net1 d_net2]
)
=> l_figGroupsCreated"
"This function creates either a single figGroup or all of the needed cross symmetric figGroups depending on the options provided to allow cross symmetric routing.")
("nclRegPostPlacementTrigger"
"nclRegPostPlacementTrigger(
S_triggerFuncName
[ x_priority ]
)
=> t / nil"
"Registers a function to be called after analog placement is complete. The registered functions should take only one argument specifying the cellview that was placed. The functions are called in the specified order (lowest to highest priority) after any automatic or batch analog placement operations are finished.")
("nclRegPrePlacementTrigger"
"nclRegPrePlacementTrigger(
S_triggerFuncName
[ x_priority ]
)
=> t / nil"
"Registers a function to be called before analog placement runs. The registered functions should take only one argument specifying the cellview the placer is to run on. The functions are called in the specified order (lowest to highest priority) before any automatic or batch analog placement operations start.")
("nclSetAspectRatioRange"
"nclSetAspectRatioRange(
d_cv
f_minAspectRatio
f_maxAspectRatio
[ f_overrideArea ]
)
=> d_cbc / nil"
"Modifies the cell boundary constraint on the prBoundary of the specified cellview by specifying the minimum and maximum acceptable aspect ratios. A new cell boundary constraint and prBoundary is created, if required.")
("nclUnregPostPlacementTrigger"
"nclUnregPostPlacementTrigger(
S_triggerFuncName
)
=> t / nil"
"Unregisters a post-placement trigger function.")
("nclUnregPrePlacementTrigger"
"nclUnregPrePlacementTrigger(
S_triggerFuncName
)
=> t / nil"
"Unregisters a pre-placement trigger function.")
("mgAbutCB"
"mgAbutCB(
d_cellViewID
)
=> t / nil"
"Attempts to abut the selected instances in the Modgen currently being edited.")
("mgAbutAllCB"
"mgAbutAllCB(
g_abutFlag
)
=> t / nil"
"Abuts all currently selected instances.")
("mgAddBodyContact"
"mgAddBodyContact(
s_side
)
=> t / nil"
"Adds a body contact on the specified side to the selected instances inside a Modgen. Side can be one of left, right, top, or bottom.")
("mgAddCopyDummies"
"mgAddCopyDummies(
d_mgID
t_sideString
S_netName
l_insts
)
=> t / nil"
"Creates copies of the specified Modgen dummy and places them on the t_sideString side of the instance.")
("mgAddDummyBottomCB"
"mgAddDummyBottomCB(
)
=> t / nil"
"Adds dummy devices to the bottom of the selected instances.")
("mgAddDummyLeftCB"
"mgAddDummyLeftCB(
)
=> t / nil"
"Adds dummy devices to the left side of the selected instances.")
("mgAddDummyRightCB"
"mgAddDummyRightCB(
)
=> t / nil"
"Adds dummy devices to the right side of the selected instances.")
("mgAddDummyTopCB"
"mgAddDummyTopCB(
)
=> t / nil"
"Adds dummy devices to the top of the selected instances.")
("mgAddDummyRCBottomCB"
"mgAddDummyRCBottomCB(
)
=> t / nil"
"Adds a complete row of dummy devices to the bottom of the selected instances.")
("mgAddDummyRCLeftCB"
"mgAddDummyRCLeftCB(
)
=> t / nil"
"Adds a complete row of dummy devices to the left of the selected instances.")
("mgAddDummyRCRightCB"
"mgAddDummyRCRightCB(
)
=> t / nil"
"Adds a complete row of dummy devices to the right of the selected instances.")
("mgAddDummyRCTopCB"
"mgAddDummyRCTopCB(
)
=> t / nil"
"Adds a complete row of dummy devices to the top of the selected instances.")
("mgAddEmptyRCCB"
"mgAddEmptyRCCB(
t_side
)
=> nil"
"Adds an empty row or column to the specified side of a selected instance. To add empty row or column only one instance should be selected.")
("mgAddGuardRingCB"
"mgAddGuardRingCB(
)
=> t / nil"
"Displays the Guard Ring Options form for creating and modifying the guard ring for the current Modgen.")
("mgAddShapeToTopo"
"mgAddShapeToTopo(
d_topoId
d_figId
)
=> t / nil"
"Adds a user-generated shape, such as a rectangle, to a topology group, usually a topological strap.")
("mgAddTopologyToModgen"
"mgAddTopologyToModgen(
d_tpObjectId
d_modgenId
)
=> t / nil"
"Adds the specified topology object to the specified Modgen.")
("mgCreateOrEdit"
"mgCreateOrEdit(
d_cellViewId 
d_constraintId
[ d_figGroupId ]
)
=> t / nil"
"Opens the Modgen editor to create a new Modgen or to edit parameters of an existing Modgen. After making edits, the Modgen constraint is updated. If the source is a layout cellview, then the Modgen layout, the associated geometry, and the associated database objects are updated.")
("mgCreateMatchGroupInModgen"
"mgCreateMatchGroupInModgen(
d_modgenConId
l_tpObjects
t_twigMatchType
[ t_trunkMatchType ]
)
=> t / nil"
"Creates a matchGroup in the specified Modgen storage.")
("mgCreateModgenAsLayout"
"mgCreateModgenAsLayout(
d_cvId
[ l_InstanceList ]
)
=> figGroupID / nil"
"Creates a Modgen from the list of specified instances and keeps the relative instance locations inside the Modgen, as similar as possible to the original instances in the layout. If instance list is not specified, the selected instances from the cellview are used.")
("mgCreateModgenConstraintAsLayout"
"mgCreateModgenConstraintAsLayout(
d_cvId
l_InstanceList
[ l_AbuttedInstances ]
)
=> g_constraintID / nil"
"Creates a Modgen constraint that uses the current layout to drive the initial Modgen constraint and row/column assignments.")
("mgDeleteAllBodyContacts"
"mgDeleteAllBodyContacts(
)
=> t / nil"
"Deletes all body contacts of the Modgen when the current window is the Modgen edit window.")
("mgDeleteAllDummies"
"mgDeleteAllDummies(
[ d_mgID ]
)
=> t / nil"
"Deletes all dummies from the specified Modgen.")
("mgDeleteAllDummyRowColumnCB "
"mgDeleteAllDummyRowColumnCB(
)
=> t / nil"
"Deletes all dummy rows and columns of the Modgen when the current window is the Modgen Editing window.")
("mgDeleteAllEmptyRowColumnCB"
"mgDeleteAllEmptyRowColumnCB(
)
=> t / nil"
"Deletes all empty rows and columns of the Modgen when the current window is the Modgen Editing window.")
("mgDeleteCB"
"mgDeleteCB(
)
=> t / nil"
"Deletes the selected dummy devices or body contacts.")
("mgDeleteEmptyRowColumnCB"
"mgDeleteEmptyRowColumnCB(
t_type 
x_rowColNum
)
=> nil"
"Interactively deletes an empty row or column in Modgen Editor.")
("mgDestroyMatchGroupOnObject"
"mgDestroyMatchGroupOnObject(
d_dbObjectId
)
=> t / nil"
"Destroys the matchGroups that include the specified database object.")
("mgEditGuardRingCB"
"mgEditGuardRingCB(
)
=> t / nil"
"Displays the Guard Ring Options form for creating and modifying the guard ring for the current Modgen.")
("mgExecNoConObs"
"mgExecNoConObs(
g_constraintID 
[ l_arguments ]
)
=> t / nil"
"Disables the Modgen constraint observer and evaluates the expressions in the specified sequence. Next, the function updates the constraint with any changes encountered while evaluating the expressions. After the process is complete, the Modgen constraint observer is re-enabled. This function helps change geometries or parameters of a Modgen or its instances without requiring the Modgen to enforce any consistency constraints on the resulting geometries. For example, increasing the numRows Modgen parameter using this function will cause the Modgen to have more rows, but will not rearrange the Modgen instances to fit in the new number of rows. This function is a defmacro.")
("mgExitCB"
"mgExitCB(
)
=> t / nil"
"Closes the Modgen editing environment.")
("mgEvalInBackgroundModgen"
"mgEvalInBackgroundModgen(
d_schCV
o_schCon
s_callback
[ g_updateSrcConstraint ]
) 
=> l_userCallbackReturnVal / nil"
"Creates a Modgen scratch cellview for the specified schematic Modgen constraint, evaluates the specified user callback in the Modgen context, and then closes and deletes the scratch cellview.")
("mgFGREnterHandEdit"
"mgFGREnterHandEdit(
d_modgenId
)
=> t / nil"
"Enters the hand edit mode for the fluid guard rings in the specified Modgen. In this mode, the fluid guard rings are not regenerated each time the Modgen is updated. Therefore, all customizations remain. The guard rings that are not edited in the hand edit mode are regenerated, and all manual edits are lost. Use mgFGRExitHandEdit to exit the hand edit mode.")
("mgFGRExitHandEdit"
"mgFGRExitHandEdit(
d_modgenId
[ g_showForm ]
)
=> t / nil"
"Exits the hand edit mode for the fluid guard rings in the specified Modgen. Unlike the hand edit mode, the fluid guard rings will now be regenerated each time the Modgen is updated. To enter the hand edit mode, use mgFGREnterHandEdit.")
("mgFGRIsHandEdit"
"mgFGRIsHandEdit(
d_modgenId
)
=> t / nil"
"Checks the status of the hand edit mode of the fluid guard rings in the specified Modgen.")
("mgFlattenModgens"
"mgFlattenModgens(
d_cellViewID
ld_modgenID
)
=> t / nil"
"Flattens the specified modgens in the specified cellview. When a Modgen is flattened, its constraint is removed, it is ungrouped, and all geometry created by it remains ungrouped in the layout cellview.")
("mgFlipHorizontalCB"
"mgFlipHorizontalCB(
)
=> t / nil"
"Horizontally flips the selected instance. To flip an instance, at least one instance should be selected. After you flip the instance, the orientation of the selected instance changes to reflect the flip.")
("mgFlipVerticalCB"
"mgFlipVerticalCB(
)
=> t / nil"
"Vertically flips the selected instance. To flip an instance, at least one instance should be selected. After you flip the instance, the orientation of the selected instance changes to reflect the flip.")
("mgGetBoxLPPArea"
"mgGetBoxLPPArea(
d_cellViewID
l_bBox
tx_layerName
t_purposeList
)
=> x_TotalModgenArea / nil"
"(ICADVM20.1 Only) Calculates the total area on the specified layer within the specified bounding box. If you specify a Modgen ID as the l_bBox parameter, then the total Modgen area is calculated and displayed.")
("mgGetChannelTrunks"
"mgGetChannelTrunks(
d_mgCon
n_channel
g_isHoriz
)
=> l_topologyTrunks / nil"
"Returns a list of topology trunks that belong to the specified channel.")
("mgGetColumnRoutingChannelWidth"
"mgGetColumnRoutingChannelWidth(
d_constraintId
x_channelIndex
)
=> f_channelWidth / nil"
"Returns the routing channel width of the specified Modgen column.")
("mgGetConstraintFromFG"
"mgGetConstraintFromFG(
d_modgenID
)
=> d_constraint_ID / nil"
"Returns the database ID of the Modgen constraint for the specified Modgen figGroup ID.")
("mgGetGuardRingConnectObject"
"mgGetGuardRingConnectObject(
d_constraintId
d_modgenId
)
=> d_grObjectId / nil"
"Returns the guard ring object for the topology connection for the specified Modgen.")
("mgGetIsLocalTrunk"
"mgGetIsLocalTrunk(
d_trunkId
)
=> t / nil"
"Checks whether the specified trunk is local. Trunks inside a Modgen are called local trunks. These trunks can be connected only within the same Modgen, and not from outside the Modgen.")
("mgIsTopologyInsideModgen"
"mgIsTopologyInsideModgen(
d_tpObjectId
[ d_figGroupId ]
)
=> t / nil"
"Checks whether the specified topology object belongs to a Modgen. For example, this function can be used to identify Modgen topologies or to find all topologies that are available in the Modgen specified by the optional d_figGroupId argument.")
("mgGetLayerSpacing"
"mgGetLayerSpacing(
d_instance1
d_instance2
t_referenceLayer
t_direction
x_spacing
)
=> x_effectiveSpacing / nil"
"Returns the effective spacing between two instances, given the spacing between a reference layer inside the instances. For example, if the reference layer is Oxide_thk drawing, then x_spacing would indicate the spacing between the bounding box of the Oxide_thk layer inside the instances. The t_direction argument specifies the position of the instances relative to each other, either horizontal (next to each other) or vertical (above and below each other).")
("mgGetMatchGroupMembers"
"mgGetMatchGroupMembers(
d_dbObjectId
)
=> t / nil"
"Displays a list of matchGroup members that belong to the same matchGroup as the specified database object d_dbObjectId.")
("mgGetModgenConstraintFromTopology"
"mgGetModgenConstraintFromTopology(
d_tpObjectId
)
=> d_modgenId / nil"
"Returns the Modgen constraint ID that is associated with the specified topology object.")
("mgGetModgenFigGroupFromTopology"
"mgGetModgenFigGroupFromTopology(
d_tpObjectId
)
=> d_figGroupId / nil"
"Retrieves the Modgen figGroup object that is associated with the specified topology object.")
("mgGetModgenFGFromConstraint"
"mgGetModgenFGFromConstraint(
d_cellViewID
d_constraintName
)
=> d_figGroupID / nil"
"Returns the database ID of the Modgen figGroup for a specified Modgen constraint ID in a specified cellview.")
("mgGetRegisteredDummyNetProc"
"mgGetRegisteredDummyNetProc(
)
=> l_dummyNetProc / nil"
"Returns a list of dummyNet procedures that are currently registered.")
("mgGetRegUserProc"
"mgGetRegUserProc(
s_userFunction
)
=> user_functions / nil"
"Accepts a user function symbol and returns the names of the user functions that are registered corresponding to the specified user function symbol.")
("mgGetRowRoutingChannelWidth"
"mgGetRowRoutingChannelWidth(
d_constraintId
x_channelIndex
)
=> f_channelWidth / nil"
"Returns the routing channel width of the specified Modgen row.")
("mgGetStrapDirection"
"mgGetStrapDirection(
d_strapId
)=> d_dir / nil"
"Returns the direction of the specified strap. This function is valid if the strap has a single strap object. Otherwise, the router determines the strap direction.")
("mgGetStrapHasDirection"
"mgGetStrapHasDirection(
d_strapId
) => t / nil"
"Determines whether the strap direction is set for the specified strap.")
("mgGetStrapHasOffset"
"mgGetStrapHasOffset(
d_strapId
)
=> t / nil"
"Determines whether the specified strap has an associated offset value.")
("mgGetStrapOffset"
"mgGetStrapOffset(
d_strapId
)
=> n_offset / nil"
"Returns the strap offset attribute, which represents the distance from the bottom or left of the bBox of the strapObject.")
("mgGetStrapLongOffset1"
"mgGetStrapLongOffset1(
d_strapId
)
=> n_longOffset1 / nil"
"Returns the long offset attribute of the specified strap for the bottom or left edge. This value determines how far beyond the strap object that the strap can extend.")
("mgGetStrapLongOffset2 "
"mgGetStrapLongOffset2(
d_strapId
)
=> n_longOffset2 / nil"
"Returns the long offset attribute of the specified strap for the top or right edge. This value determines how far beyond the strap object that the strap can extend.")
("mgGetTopologyFromModgen"
"mgGetTopologyFromModgen(
d_modgenId
)
=> l_tpObjects / nil"
"Returns a list of topology objects that are available in the specified Modgen.")
("mgGetTopoTrunkShapes"
"mgGetTopologyFromModgen(
d_topoTrunkId
)
=> l_shapeIds / nil"
"Retrieves the shapes associated with a topological trunk.")
("mgGetTopoShapes"
"mgGetTopoShapes(
d_topoId
)
=> l_shapeIds / nil"
"Retrieves all user-generated shapes from the specified topology group object, usually a topological strap.")
("mgGetTrunkChannel"
"mgGetTrunkChannel(
d_mgConId
d_trunkId
)
=> x_channel / nil"
"Returns the channel number in which the specified topological trunk pattern is located.")
("mgGetTrunkRefLayerPurpose"
"mgGetTrunkRefLayerPurpose(
d_trunkId
)
=> l_layerPurposePair / nil"
"Returns the reference layer and purpose of a topological trunk. This function returns a list containing the layer and purpose names.")
("mgGetTrunkRefLPPEnclosure"
"mgGetTrunkRefLPPEnclosure(
d_instID
t_side
t_layerName
t_purposeName
)
=> x_enclosure / nil"
"Returns the enclosure of a topological trunk reference layer and the purpose within an instance. For example, if the LPP of a trunk reference is Oxide drawing, then the function returns the distance from one side of the Oxide bounding box to the instance bounding box. This value is subtracted from the channel width of the topological trunk to derive the trunk-to-device spacing to the reference layer in the instances above (or to the right of) a trunk.")
("mgGetTrunkTopo"
"mgGetTrunkTopo(
d_pathSeg
)
=> l_trunkIds / nil"
"Returns a list of topology trunks belonging to the specified pathSeg.")
("mgHilightEmptyRowColumnCB"
"mgHilightEmptyRowColumnCB(
t_disp
)
=> t / nil"
"Turns on or off highlighting of empty rows and columns.")
("mgIsInBackAnnotation"
"mgIsInBackAnnotation(
)
=> t / nil"
"Checks if there are any Modgens currently running dummy backannotation. Use this function for user callbacks to allow changes to the Modgen constraint caused by backannotation, while preventing other changes to the Modgen constraint.")
("mgModgenHasTopology"
"mgModgenHasTopology(
d_modgenId
)
=> t / nil"
"Checks whether the specified Modgen contains a topology.")
("mgObjectHasMatchGroup"
"mgObjectHasMatchGroup(
d_dbObjectId
)
=> t / nil"
"Checks whether the specified database object is part of a matchGroup.")
("mgPatternCB"
"mgPatternCB(
)
=> t / nil"
"Displays the Modgen Pattern Editor form for the current module.")
("mgRegenerateModgen"
"mgRegenerateModgen(
d_modgenId
)
=> t / nil"
"Forces a Modgen-type group to rebuild its geometry.")
("mgRegisterDummyNetProc"
"mgRegisterDummyNetProc(
s_userProc
)
=> t / nil"
"Registers a function that specifies a net for a specified dummy instance ID and terminal ID.")
("mgRegUserProc
"
"mgRegUserProc(
s_userFunction
)
=> t / nil"
"Accepts user functions based on their keywords and registers them in the Modgen code to enable callbacks.")
("mgRemoveMemberFromMatchGroup"
"mgRemoveMemberFromMatchGroup(
d_dbObjectId
)
=> t / nil"
"Removes the specified database object from its associated matchGroup.")
("mgRemoveTopologyFromModgen"
"mgRemoveTopologyFromModgen(
d_tpObjectId
d_modgenId
)
=> t / nil"
"Removes the specified topology object from the specified Modgen.")
("mgRotateLeftCB"
"mgRotateLeftCB(
)
=> t / nil"
"Rotates the selected instance to the left. To rotate an instance at least one instance should be selected.")
("mgRotateMXCB"
"mgRotateMXCB(
)
=> t / nil"
"Rotates the selected Modgen around its center using the MX transform.")
("mgRotateMYCB"
"mgRotateMYCB(
)
=> t / nil"
"Rotates the selected Modgen around its center using the MY transform.")
("mgRotateR270CB"
"mgRotateR270CB(
)
=> t / nil"
"Rotates the selected Modgen around its center using the R270 transform.")
("mgRotateR90CB"
"mgRotateR90CB(
)
=> t / nil"
"Rotates the selected Modgen around its center using the R90 transform.")
("mgRotateRightCB"
"mgRotateRightCB(
)
=> t / nil"
"Rotates the selected instance to the right. To rotate an instance at least one instance should be selected.")
("mgRouteCB"
"mgRouteCB(
)
=> t / nil"
"Displays the Routing Style form for the current module.")
("mgRoutePToTCB"
"mgRoutePToTCB(
)
=> t / nil"
"Routes the currently open Modgen using the Modgen Pin To Trunk Router.")
("mgSelectRowColCB"
"mgSelectRowColCB(
t_type
)
=> nil"
"Selects all of the instances in the current row or column from the currently selected instance.")
("mgSetIsLocalTrunk"
"mgSetIsLocalTrunk(
d_trunkId
g_isLocal
)
=> t / nil"
"Sets the specified trunk as local. Trunks inside a Modgen are called local trunks. These trunks can be connected only within the same Modgen, and not from outside the Modgen.")
("mgSetStrapDirection"
"mgSetStrapDirection(
d_strapId
t_direction
)"
"Sets the strap direction. This value is valid only for straps with a single strap object. For straps with more than one strap objects, the router determines strap direction.")
("mgSetStrapHasDirection"
"mgSetStrapHasDirection(
d_strapId
g_hasDirection
)"
"Specifies whether the given strap can have a direction.")
("mgSetStrapHasOffset"
"mgSetStrapHasOffset(
d_strapId
g_hasOffset
)"
"Specifies whether the given strap has a valid offset value.")
("mgSetStrapLongOffset1"
"mgSetStrapLongOffset1(
d_strapId
n_longOffset1
) => t / nil"
"Sets the long offset attribute for the bottom and left edge of the specified strap. This value determines the distance that the strap will extend from the strap object.")
("mgSetStrapLongOffset2"
"mgSetStrapLongOffset2(
d_strapId
n_longOffset2
)=> t / nil"
"Sets the long offset attribute for the top and right edge of the specified strap. This value determines the distance that the strap will extend from the strap object.")
("mgSetStrapOffset"
"mgSetStrapOffset(
d_strapId
n_offset
)
=> t / nil"
"Sets the strap offset attribute, which represents the distance from the bottom or left of the bBox of the strap object.")
("mgSetTrunkRefLayerPurpose"
"mgSetTrunkRefLayerPurpose(
d_trunkId
t_layerName
[ t_purposeName ]
)
=> t / nil"
"Sets the layer and purpose of a topological trunk that is anchored to an instance. The bounding box of the specified layer and purpose inside the instance is used to determine the trunk's location. In other words, the trunk's orthogonal offset is from one side of the reference layer and purpose bounding box. The purpose argument is optional. If not specified, then the purpose argument defaults to any. A trunk's reference layer and purpose can be removed by setting both the layer and purpose arguments to any.")
("mgSetColumnRoutingChannelWidth"
"mgSetColumnRoutingChannelWidth(
d_constraintId
x_channelIndex
f_channelWidth
)
=> f_channelWidth / nil"
"Sets the routing channel width for the specified Modgen column.")
("mgSetRowRoutingChannelWidth"
"mgSetRowRoutingChannelWidth(
d_constraintId
x_channelIndex
f_channelWidth
)
=> f_channelWidth / nil"
"Sets the routing channel width for the specified Modgen row.")
("mgSwapCB"
"mgSwapCB(
t_swap
)
=> nil"
"Swaps two selected instances, two rows of instances, or two columns of instances in Modgen.")
("mgUnAbutCB"
"mgUnAbutCB(
d_cellViewID
)
=> t / nil"
"Unabuts the selected instances in the current Modgen in the specified cellview.")
("mgUnRegUserProc"
"mgUnRegUserProc(
s_userFunction
)
=> t / nil"
"Accepts user functions based on the keywords and unregisters them in the Modgen code.")
("mgUpdateCB"
"mgUpdateCB(
S_modgenName
d_cellViewID
)
=> t / nil"
"Lets the Modgen ConObserver update the Modgen layout module.")
("mgUpdateEmptyRowColumnHilightCB"
"mgUpdateEmptyRowColumnHilightCB(
)
=> t / nil"
"Update highlights of empty rows to follow any other changes in the Modgen.")
("mgUpdateHoriAlignCB"
"mgUpdateHoriAlignCB(
d_cellViewID
s_side
)
=> t / nil"
"Aligns the selected instances on the specified side. Side can be one of left, right, or center.")
("mgUpdateVertAlignCB"
"mgUpdateVertAlignCB(
d_cellViewID
s_side
)
=> t / nil"
"Aligns the selected instances on the specified side. Side can be one of top, bottom, or center.")
("mgUnRegisterDummyNetProc"
"mgUnRegisterDummyNetProc(
s_userProc
)
=> t / nil"
"Unregisters a function that specifies a net for a given dummy instance ID and terminal ID.")
("gpeRegisterPresetGen"
"gpeRegisterPresetGen(
t_displayName 
t_functionName 
t_checkFunctionName
[ g_noStacks ]
)
=> t / nil"
"Registers the specified function as a preset generator.")
("gpeIsRegisteredPresetGen"
"gpeIsRegisteredPresetGen(
t_functionName 
)
=> t / nil"
"Checks whether the specified function is a registered preset generator function.")
("gpeIsPresetGenDisplayable"
"gpeIsPresetGenDisplayable(
t_functionName 
d_figGroupId
)
=> t / nil"
"Checks whether the given preset generator is displayed in the Preset drop-down of the Grid Pattern Editor for the selected Modgen.")
("gpeUnregisterPresetGen"
"gpeUnregisterPresetGen(
t_functionName
)
=> t / nil"
"Unregisters the given preset generator function from the Grid Pattern Editor.")
("gpeClearPresetGenerators"
"gpeClearPresetGenerators(
)
=> t / nil"
"Deletes all the registered preset generator functions from the system.")
("gpeRunPresetGen"
"gpeRunPresetGen(
t_functionName
d_figGroupId
)
=> t / nil"
"Invokes the specified preset generator function on the active figGroup. The figGroup is updated according to the preset generator logic. Ensure that the Grid Pattern Editor (GPE) assistant is open when running this command. Also ensure that the selection argument specifies a valid Modgen figGroup and that the preset is registered correctly.")
("gpeAddInstance"
"gpeAddInstance(
d_modgenID
l_instances
)
=> t / nil"
"Adds the given list of instances to the specified Modgen.")
("gpeExtractReuseTemplate"
"gpeExtractReuseTemplate(
u_constraint | d_fig
g_structureName
t_fileName
)
=> t | nil"
"(ICADVM20.1 Only) Extracts the given Modgen a into a reusable text file.")
("gpeExtractTemplateFromMG"
"gpeExtractTemplateFromMG(
u_constraintCache
)
=> t / nil"
"(ICADVM20.1 Only) Generates a reusable template for each Modgen constraint present in the specified constraint cache.")
("gpeGetGridValue"
"gpeGetGridValue(
g_tableView
[ g_location ] 
[ s_type ]
)
=> grid_value"
"Returns the value of the cells in the Grid Pattern Editor table view.")
("gpeGetSelection"
"gpeGetSelection(
g_tableView
)
=> list(row column) / list(bottom:left top:right)"
"Returns a list of currently selected cells or a range of cells in a grid-pattern-editor table format.")
("gpeLoadReuseTemplate"
"gpeLoadReuseTemplate(
l_instances
l_map
t_structureName
t_fileName
)
=> u_sandbox / nil"
"(ICADVM20.1 Only) Creates a new Modgen constraint by applying the given Modgen reuse template to the specified list of instances.")
("gpeLoadTemplateLaunchForm"
"gpeLoadTemplateLaunchForm(
u_constraintCache
l_instances
)
=> t / nil"
"(ICADVM20.1 Only) Invokes the Reuse Template form, which lets you apply the existing Modgen reuse templates to the specified instances. Modgen constraints that fit the reusable template are generated.")
("gpeMove"
"gpeMove(
g_tableView
[ g_cells ]
g_fromAnchor
g_toAnchor
)
=> t / nil"
"Moves a list of cells within the Grid Pattern Editor table from one point to another.")
("gpePresetReorientResistor"
"gpePresetReorientResistor(
)
=> t / nil"
"Flips the orientations of the members of a preselected Modgen to reduce the overall connectivity wire length. The placement of the members is not altered.")
("gpeRemoveInstance"
"gpeRemoveInstance(
d_modgenID
l_instances
)
=> t / nil"
"Removes the given instances from the specified Modgen figGroup.")
("gpeSelect"
"gpeSelect(
g_tableView
[g_selectionList | g_type g_value]
)
=> t / nil"
"Select cells in the Grid Pattern Editor or Grid Pattern Mapping assistants.")
("gpeSetGridValue"
"gpeSetGridValue(
g_tableView
[ g_location ]
S_value
[ s_type ]
)
=> t / nil"
"Sets the value of the Grid Pattern Editor table view cells. If there is a single cell selected before the call, the next cell will be selected automatically.")
("gpeSetGridText"
"gpeSetGridText(
g_tableView
t_pattern
)
=> t / nil"
"Specifies a textual grid pattern for the Pattern field on the Text tab of the Grid Pattern Editor assistant.")
("gpeSetOrientText"
"gpeSetOrientText(
g_tableView
t_orientation
)
=> t / nil"
"Specifies the grid pattern orientation for the Orient field on the Text tab of the Grid Pattern Editor assistant.")
("gpeSetSize"
"gpeSetSize(
g_tableView
l_dimensions
['stable | 'nostable]
[ n_rows ]
[ n_columns ]
)
=> t / nil"
"Resizes the specified Grid Pattern Editor table. If the table dimensions are smaller or larger than the new dimensions, then rows or columns are added or removed, as needed.")
("gpeTemplateExtractLaunchForm"
"gpeTemplateExtractLaunchForm(
u_constraintCache
l_instances
)
=> t / nil"
"(ICADVM20.1 Only) Launches the Template Extract form, which lets you extract Modgen reuse templates from the given instances.")
("gpeUpdateInstanceFromSchematic"
"gpeUpdateInstanceFromSchematic(
d_modgenID
)
=> t / nil"
"Updates the given Modgen instance parameters based on the binding schematic cellview.")
("gpeAbutGridEntries"
"gpeAbutGridEntries(
u_sandbox
l_gridEntries
[ ?abutType { x_abutType | t_abutTypeName } ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Abuts the specified list of instances or indexes using the given abutment type in the given sandbox object.")
("gpeAddDummy"
"gpeAddDummy(
u_sandbox
t_direction
[ ?n x_rowsCols ]
[ ?dummyConfig l_dummyConfig ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds the specified number of dummy rows or columns in the given direction to the specified Modgen sandbox object. The dummy configuration entry, if specified, is used to configure the default entries. The master for the generated dummy entries is set to either the dummy configuration entry, which provides the master lib:cell:view specification, or the grid entries. Even if the dummy configuration entry specifies the source, the value is ignored and source is calculated based on the grid entries.")
("gpeAddDummyInEmptyCells"
"gpeAddDummyInEmptyCells(
u_sandbox
[ ?dummyConfig l_dummyConfig ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Fills the empty cells in the specified sandbox object with dummies.")
("gpeAddDummySurround"
"gpeAddDummySurround(
u_sandbox
[ ?dummyConfig l_dummyConfig ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds a ring of dummies around the specified sandbox grid.")
("gpeCancelSandbox"
"gpeCancelSandbox(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Discards the specified Modgen sandbox object. Changes made to the Modgen sandbox object are lost. This function can be run in both schematic and layout cellviews. If run from the schematic view, the associated scratch cellview is also deleted. The Modgen constraint is not transferred to the schematic view and the dummies are not backannotated.")
("gpeClearGridEntries"
"gpeClearGridEntries(
u_sandbox
[ ?row x_row ]
[ ?col x_col ]
[ ?verbose { t | nil } ]
)
=> l_gridEntries / nil"
"Unplaces the grid entries that match the given identifiers in the given sandbox object.")
("gpeCopyColAbutment"
"gpeCopyColAbutment(
u_sandbox
x_sourceCol
x_targetCol
[ ?verbose { t | nil } ]
)
=> t / nil"
"Copies abutment information from one column to another.")
("gpeCopyRowAbutment"
"gpeCopyRowAbutment(
u_sandbox
x_sourceRow
x_targetRow
[ ?verbose { t | nil } ]
)
=> t / nil"
"Copies abutment information from one row to another.")
("gpeCreateAbutEntries"
"gpeCreateAbutEntries(
[ ?rows l_rows ]
[ ?cols l_columns ]
[ ?abutType l_abutType ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> l_abutEntry / nil"
"Creates a list of abut entries that are in line with the information in the arguments.")
("gpeCreateAbutType"
"gpeCreateAbutType(
[ ?syncChains { t | nil } ]
[ ?preserveRows { t | nil } ]
[ ?permute { t | nil } ]
[ ?mirrorEquivOrients { t | nil } ]
[ ?mirror { t | nil } ]
[ ?interdigitateChains { t | nil } ]
[ ?dummyFlexBothEndNets { t | nil } ]
[ ?chainLeftNet { Source | Drain | Either } ]
[ ?chainAlignPMOS { Top | Center | Bottom } ]
[ ?chainAlignNMOS { Top | Center | Bottom } ]
[ ?allowSingleBulk { t | nil } ]
[ ?abutStrategy { sdFirst | dummyFirst } ]
[ ?verbose { t | nil } ]
) 
=> l_abutType / nil"
"Creates an abutType DPL, which can be passed to the gpeCreateAbutEntry API. The abutment then uses the chaining parameters specified in the abutType parameter. The defaults for the arguments are obtained from the Modgen environment if set. Otherwise, the defaults of lxChain are honored.")
("gpeCreateAlignment"
"gpeCreateAlignment(
[ ?direction t_direction ]
[ ?type t_type ]
[ ?reflayer g_reflayer ]
[ ?spacing f_spacing ]
[ ?verbose { t | nil } ]
)
=> l_alignment / nil"
"Creates an alignment DPL, which can be passed as an alignment argument for gpeCreateGridEntry to set the member alignment and spacing of a grid entry. Specifying a direction, although not necessary for types other than center, is highly recommended.")
("gpeCreateAlignmentAndSpacing"
"gpeCreateAlignmentAndSpacing(
u_sandbox
[?hAlignType { left | right | custom_left | custom_right | center }]
[?hSpacing f_spacing]
[?hRefLayer t_layerName]
[?hRefPurpose t_purposeName]
[?vAlignType { bottom | top | custom_bottom | custom_top | center }]
[?vSpacing f_spacing]
[?vRefLayer t_layerName]
[?vRefPurpose t_purposeName]
[?useDefaultForUnspecifiedArgs { t | nil } ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Specifies the alignment and spacing settings for all the grid entries in the given Modgen sandbox object.")
("gpeCreateDummyConfig"
"gpeCreateDummyConfig(
[ ?master t_master]
[ ?source l_source ]
[ ?connectivity l_connectivity ]
[ ?parameters l_parameters ]
[ ?template l_template ]
[ ?defaultNet t_defaultNet ]
[ ?verbose { t | nil } ]
)
=> l_dummyConfig / nil"
"Creates a dummyConfig DPL, which can be used as an argument for gpeCreateGridEntry to create a dummy grid entry. If the master is not set, the source is used to determine the master. If the source is not set, the dummy uses the neighboring instances as its source.")
("gpeCreateDummyConfigNet"
"gpeCreateDummyConfigNet(
t_termName
[ ?netName t_netName ]
[ ?verbose { t | nil } ]
)
=> l_dummyConfigNet / nil"
"Creates a dummyConfigNet DPL that can be added to a list with other dummyConfigNet DPLs and passed as the connectivity argument to gpeCreateDummyConfig to create a dummyConfig DPL.")
("gpeCreateDummyConfigParam"
"gpeCreateDummyConfigParam(
t_name
[ ?type t_type ]
[ ?value t_value ]
[ ?verbose { t | nil } ]
) 
=> l_dummyConfigParam / nil"
"Creates a dummyConfigParam DPL that can be added to a list with other dummyConfigParam DPLs and passed as the parameters argument to gpeCreateDummyConfig to create a dummyConfig DPL.")
("gpeCreateGridEntry"
"gpeCreateGridEntry(
[ ?row x_row ]
[ ?col x_col ]
[ ?name t_name ]
[ ?dummyConfig l_dummyConfig ]
[ ?orientation t_orientation ]
[ ?hAlign l_hAlign ]
[ ?vAlign l_vAlign ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> l_gridEntry / nil"
"Creates a Modgen sandbox grid entry DPL for an instance or a dummy. A grid entry can represent either an instance or a dummy.")
("gpeCreateMapEntry"
"gpeCreateMapEntry(
[ ?schematicName t_schematicName ]
[ ?symbolName t_symbolName ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> l_mapEntry / nil"
"Creates a map entry DPL that stores the schematic name of an instance, along with its symbol mapping.")
("gpeCreateSandbox"
"gpeCreateSandbox(
[ ?cv d_cellview ] 
[ ?ids l_figs ]
[ ?sync { t | nil } ]
[ ?verbose { t | nil } ]
)
=> u_sandbox / nil"
"Creates a Modgen sandbox object that includes the specified instances. This function can be used to create Modgen sandbox objects in both schematic and layout cellviews. If none of the arguments are provided, the current edit cellview and selected instances are considered.")
("gpeDeleteDummyEntries"
"gpeDeleteDummyEntries(
u_sandbox
g_includeInternal
g_unplaceOnly
g_fullRCOnly
[ ?verbose { t | nil } ]
)
=> t / nil"
"Deletes dummy entries from the given Modgen sandbox object and compresses the grid based on the specified options.")
("gpeDeleteSandbox"
"gpeDeleteSandbox(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Deletes the specified Modgen sandbox object but does not delete its associated figGroup.")
("gpeEditSandbox"
"gpeEditSandbox(
[ d_modgenID | d_figGroupID ]
[ g_sync ]
[ ?verbose { t | nil } ]
)
=> u_sandbox / nil"
"Returns a Modgen sandbox object that represents the current Modgen or figGroup. The sandbox object can be edited using SKILL APIs.")
("gpeFinishSandbox"
"gpeFinishSandbox(
u_sandbox
[ ?transfer { t | nil } ]
[ ?removeScratch { t | nil } ]
[ ?backAnnotate { t | nil } ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Deletes the specified Modgen sandbox object. If run from the schematic view, the Modgen's associated scratch cellview is also deleted. If run from the layout view, the command optionally transfers the Modgen constraint to the schematic view and backannotates any dummies. gpeFinishSandbox must be used in tandem with the functions that create sandboxes, such as gpeCreateSandbox and gpeEditSandbox. It is recommend that all Modgen sandbox objects are finished by calling this function.")
("gpeGetAbut"
"gpeGetAbut(
u_sandbox
[ ?verbose { t | nil } ]
)
=> l_abut / nil"
"Returns the Modgen abutment DPL for the specified Modgen sandbox object.")
("gpeGetAbutTypeList"
"gpeGetAbutTypeList	(
u_sandbox
[ ?verbose { t | nil } ]
)
=> l_abutTypes / nil"
"Returns a list of abutment types for the specified Modgen sandbox object.")
("gpeGetAbutTypeName"
"gpeGetAbutTypeName	(
u_sandbox
x_abutType
[ ?verbose { t | nil } ]
)
=> t_abutTypeName / nil"
"Returns the name corresponding to the given abutment type number from the specified Modgen sandbox object.")
("gpeGetConstraints"
"gpeGetConstraints(
u_sandbox
[ ?verbose { t | nil } ]
)
=> lu_constraintIDs / nil"
"Returns a list of constraint IDs that are associated with the specified Modgen sandbox object.")
("gpeGetDefaultAbutType"
"gpeGetDefaultAbutType	(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t_abutTypeName / nil"
"Returns the default abutment type name for the given Modgen sandbox object.")
("gpeGetFigGroup"
"gpeGetFigGroup(
u_sandbox
[ ?verbose { t | nil } ]
)
=> d_figGoupID / nil"
"Returns the ID of the Modgen figGroup that is associated with the specified Modgen sandbox object.")
("gpeGetGrid"
"gpeGetGrid(
u_sandbox
[ ?verbose { t | nil } ]
)
=> l_grid / nil"
"Returns the Modgen sandbox grid DPL that describes the grid placement of the specified Modgen sandbox object.")
("gpeGetGridColCount"
"gpeGetGridColCount(
u_sandbox
[ ?verbose { t | nil } ]
)
=> x_columnCount / nil"
"Returns the number of columns available in the grid of the given Modgen sandbox object.")
("gpeGetGridEntry"
"gpeGetGridEntry(
u_sandbox
[ ?ref d_refID ]
[ l_index ]
[ t_layoutName ]
[ ?verbose { t | nil } ]
)
=> l_gridEntry / nil"
"Returns a grid entry that matches the specified argument for the specified sandbox object. When calling this function, only one search argument of type reference, index, or layout name must be specified. If multiple arguments are specified, an error message is displayed.")
("gpeGetGridEntries"
"gpeGetGridEntries(
u_sandbox
[ ?row x_row ]
[ ?col x_col ]
[ ?name t_name ]
[ ?verbose { t | nil } ]
)
=> l_gridEntries / nil"
"Returns a list of grid entries from the Modgen sandbox that match the specified identifiers. If you specify multiple identifiers, then the function returns a list of instances that satisfy all requirements.")
("gpeGetGridRowCount"
"gpeGetGridRowCount(
u_sandbox
[ ?verbose { t | nil } ]
)
=> x_rowCount / nil"
"Returns the number of rows available in the grid of the specified Modgen sandbox object.")
("gpeGetGridSelection"
"gpeGetGridSelection(
u_sandbox
[ ?verbose { t | nil } ]
)
=> l_gridSelection / nil"
"Returns a list of indexes that represent the grid selection in the GPE (Grid Pattern Editor) assistant. The DPL is a list of list of indexes, for example ((0 1) (1 3) ... ), that are associated with the specified userType (UT).")
("gpeGetMap"
"gpeGetMap(
u_sandbox
[ ?verbose { t | nil } ]
)
=> l_map / nil"
"Returns the Modgen sandbox map DPL for the specified Modgen sandbox object.")
("gpeGetMapEntry"
"gpeGetMapEntry(
u_sandbox
t_name
[ ?verbose { t | nil } ]
)
=> l_mapEntry / nil"
"Returns the map entry DPL from the specified Modgen sandbox object that matches the specified schematic or symbol name. The function first looks for a matching schematic name; if not found, then looks for a matching symbol name and returns the first match.")
("gpeInsertEmptyColumns"
"gpeInsertEmptyColumns(
u_sandbox
t_direction
x_startColumn
[ ?count n_count ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Inserts empty columns in the specified Modgen sandbox object in the specified direction, starting at the specified column.")
("gpeInsertEmptyRows"
"gpeInsertEmptyRows(
u_sandbox
t_direction
x_startRow
[ ?count n_count ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Inserts empty rows in the specified Modgen sandbox object in the specified direction, starting at the specified row.")
("gpeIsSandboxSync"
"gpeIsSandboxSync(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Checks whether the specified Modgen sandbox object is in sync with its associated Modgen constraint, and returns a Boolean that indicates the status.")
("gpeIsValidAbutType"
"gpeIsValidAbutType	(
u_sandbox
{ t_abutTypeName | x_abutType }
[ ?verbose { t | nil } ]
)
=> t / nil"
"Validates the specified abutment type name or number for the specified Modgen sandbox object.")
("gpePlaceGridEntries"
"gpePlaceGridEntries	(
u_sandbox
l_gridEntries
[ ?verbose { t | nil } ]
)
=> t / nil"
"Places the specified grid entries at the specified location in the specified Modgen sandbox object.")
("gpeRemoveEmptyRowsAndColumns"
"gpeRemoveEmptyRowsAndColumns(
u_sandbox
g_includeInternal
[ ?verbose { t | nil } ]
)
=> t / nil"
"Removes empty rows and columns from the specified Modgen sandbox object.")
("gpeSboxp"
"gpeSboxp(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Checks whether the specified object is a valid Modgen sandbox object.")
("gpeSetAbut"
"gpeSetAbut(
u_sandbox
g_abut
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the abutment for the entire grid, without using individual abutment entries. The entire abutment object of the sandbox-in-place is replaced.")
("gpeSetAbutEntries"
"gpeSetAbutEntries
u_sandbox
l_abutEntries
[ ?verbose { t | nil } ]
) 
=> t / nil"
"Modifies the Modgen sandbox object by applying the abutment specified by the abutment entries. If there is any conflict between the new entry and any existing entry, the existing entry is removed and the new entry is used.")
("gpeSetGrid"
"gpeSetGrid(
u_sandbox
l_grid
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the entire grid without using individual grid entries. You can also use this function to update grid placement by providing a list of lists describing the row placement of instances.")
("gpeSetGridEntry"
"gpeSetGridEntry(
u_sandbox
l_gridEntry
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds the specified grid entry to the grid portion of the specified Modgen sandbox object. If the grid location specified in the grid entry is already occupied, the existing entry is unplaced, and the specified grid entry is set.")
("gpeSetMap"
"gpeSetMap(
u_sandbox
g_map
[ ?verbose { t | nil } ]
)
=> t / nil"
"Updates the symbol mapping without using individual map entries. When a sandbox map DPL is specified, the current mapping of instances is replaced with the mapping specified by the provided map DPL. Symbol mapping can also be updated by providing a list of lists of strings. The first string in each sub-list holds the schematic name of an instance and the second string holds its updated mapping.")
("gpeSetMapEntry"
"gpeSetMapEntry(
u_sandbox
l_mapEntry
[ ?verbose { t | nil } ]
)
=> t / nil"
"Modifies the map portion of the Modgen sandbox object by updating the symbol mapping value with the specified map entry. The key in the map is the schematic name. If the sandbox has a schematic instance with the same name as the one specified in the map entry, then the symbol mapping of that instance in the sandbox is modified.")
("gpeSetMergeLayer"
"gpeSetMergeLayer(
u_sandbox
g_mergeLayer { default | well | none | t_layerName | l_layerNames }
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the MergeLayer parameter for the specified Modgen sandbox object.")
("gpeStacksAreCompressed"
"gpeStacksAreCompressed(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether the stacks in the specified Modgen sandbox object are in the compressed state.")
("gpeStacksCompress:"
"gpeStacksCompress(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"(ICADVM20.1 Only) Compresses all stacks in the specified Modgen sandbox object.")
("gpeStacksUncompress"
"gpeStacksUncompress(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"(ICADVM20.1 Only) Uncompresses all stacks in the specified Modgen sandbox object.")
("gpeStartSandbox"
"gpeStartSandbox(
[ ?ref l_reference ] 
[ ?cv d_cellview ] 
[ ?sync { t | nil } ]
[ ?updateSchConstraint { t | nil } ]
[ ?verbose { t | nil } ]
)
=> g_sandbox / nil"
"Checks for a Modgen sandbox object that includes the specified instances. If one exists, the handle of the Modgen sandbox object is returned for editing with the GPE placement and routing APIs. If an existing object does not have the specified instances, a new Modgen sandbox object is created.")
("gpeSyncSandbox"
"gpeSyncSandbox(
u_sandbox
[ g_transferConstraint ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the specified Modgen sandbox object to sync mode, meaning that changes made to the state of the Modgen sandbox object cause an update to any associated Modgen constraint and layout placement.")
("gpeUnAbutGridEntries"
"gpeUnAbutGridEntries(
u_sandbox
l_gridEntries
[ ?verbose { t | nil } ]
)
=> t / nil"
"Unabuts the specified list of instances or indexes in the specified sandbox object.")
("gpeUnSyncSandbox"
"gpeUnSyncSandbox(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the specified Modgen sandbox object to the unsynchronized mode. In this mode, any change to the state of the Modgen sandbox object is not reflected in any associated Modgen constraint and the layout placement.")
("gpeAddMatchGroups"
"gpeAddMatchGroups(
u_sandbox
l_matchGroups
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds the specified matched groups to the specified Modgen sandbox object. A matched group is a set of topological trunks with similar properties.")
("gpeAddStrapEntries"
"gpeAddStrapEntries(
u_sandbox
l_straps
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds the specified straps to the topology (topo) section of the specified Modgen sandbox object.")
("gpeAddTrunkChains"
"gpeAddTrunkChains(
u_sandbox
l_trunkChains
[ ?verbose { t | nil } ]
)
=> t / nil"
"Adds the specified trunk chain values to the topo portion of the Modgen sandbox object.")
("gpeClearChannelWidthEntry"
"gpeClearChannelWidthEntry(
u_sandbox
x_index
t_direction
[ ?verbose { t | nil } ]
)
=> t / nil"
"Clears the channelWidth value of the specified channel in the specified sandbox.")
("gpeClearMatchGroups"
"gpeClearMatchGroups(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Removes all the matched groups from the specified Modgen sandbox object.")
("gpeClearStrapEntries"
"gpeClearStrapEntries(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Removes all straps from the specified Modgen sandbox.")
("gpeClearTopo"
"gpeClearTopo(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Removes all topologies from the specified Modgen sandbox.")
("gpeClearTrunkChains"
"gpeClearTrunkChains(
u_sandbox
[ ?verbose { t | nil } ]
)
=> t / nil"
"Removes all trunk chains from the Modgen sandbox.")
("gpeCreateChannelWidthEntry"
"gpeCreateChannelWidthEntry(
[ ?width f_width ]
[ ?reference t_reference ]
[ ?verbose { t | nil } ]
)
=> g_channelWidthEntry / nil"
"Creates a Modgen sandbox channel width entry that can be passed in gpeSetChannelWidthEntry to set the channel widths.")
("gpeCreateInstTermEntries"
"gpeCreateInstTermEntries(
[ ?deviceNames l_deviceNames ]
[ ?instTermNames l_instTermNames ]
[ ?gridEntries  l_gridEntries ]
[ ?verbose { t | nil } ]
)
=> l_instTermEntries / nil"
"Creates instTerms for all combinations of the two identifiers and returns a list of instTerms names that were created. The return value is used as an argument to twig and strap entries to define the connectivity of the topology objects.")
("gpeCreateMatchGroupEntry"
"gpeCreateMatchGroupEntry(
d_matchGroupID
[ ?twigMatchType t_twigMatchType ]
[ ?trunkMatchType t_trunkMatchType ]
[ ?verbose { t | nil } ]
)
=> t / nil"
"Creates a DPL that represents a matched group. The DPL can then be added to a Modgen sandbox object using the gpeAddMatchGroups function.")
("gpeCreateStrapEntries"
"gpeCreateStrapEntries(
[ ?netNames l_netNames ]
[ ?instTermEntries l_instTermEntries ]
[ ?direction t_direction ]
[ ?constraints l_constraints ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> l_straps / nil"
"Creates straps for the specified nets that connect the specified instance terminals.")
("gpeCreateTrunkChain"
"gpeCreateTrunkChain(
?trunks l_trunks
?anchorIndex n_anchorIndex
[ ?trunkDirection { horizontal | vertical } ]
[ ?offsetDirection { positive | negative } ]
[ ?anchorPoint t_anchorPoint ]
[ ?anchorReference t_anchorReference ]
[ ?centerInChannel { t | nil } ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> g_trunkChainObject / nil"
"Creates trunk chain entries based on the specified identifiers from the sandbox. It is recommended to use only one of the optional arguments. If none of the optional arguments is provided, all trunk chains available in the Modgen are listed. If multiple optional arguments are provided, the return value is the intersection of all the sets.")
("gpeCreateTrunkEntries"
"gpeCreateTrunkEntries(
[ ?netNames lt_netNames ]
[ ?offset f_offset ]
[ ?longOffsetSource1 t_longOffsetSource1 ]
[ ?longOffset1 f_longOffset1 ]
[ ?longOffsetSource2 t_longOffsetSource2 ]
[ ?longOffset2 f_longOffset2 ]
[ ?twigs lg_twigs ]
[ ?twigConstraints lg_twigConstraints ]
[ ?constraints lg_constraints ]
[ ?template l_template ]
[ ?matchGroup l_matchGroupID ]
[ ?verbose { t | nil } ]
)
=> l_trunkObjects / nil"
"Creates a list of trunk entries, one for each netName. The properties defined by the arguments are applied to all trunks. To define different properties for each trunk, call the function in a for loop and set the arguments, as required, for each unique trunk.")
("gpeCreateTwigEntries"
"gpeCreateTwigEntries(
[ ?instTermEntries l_instTermEntries ]
[ ?constraints l_constraints ]
[ ?template l_template ]
[ ?verbose { t | nil } ]
)
=> g_twigObject / nil"
"Creates a Modgen sandbox twig object, which specifies the instance terminals to make connections to and the constraints that define how the connections must be made. The twig objects can be added to trunk with the ?twigEntries parameter on gpeCreateTrunkEntries.")
("gpeGetChannelWidthEntry"
"gpeGetChannelWidthEntry(
u_sandbox
x_channelNumber
t_direction
[ ?verbose { t | nil } ]
)
=> g_ChannelWidthEntry / nil"
"Returns the channelWidth sandbox object that matches the specified index and direction values.")
("gpeGetStrapEntries"
"gpeGetStrapEntries(
u_sandboxObject
[ ?netNames l_netNames ]
[ ?deviceNames l_deviceNames ]
[ ?instTermNames l_instTermNames ]
[ ?verbose { t | nil } ]
)
=> l_straps / nil"
"Filters straps in the Modgen sandbox based on the specified identifiers. It is recommended to use only one of the optional arguments. If no arguments are provided, all straps in the Modgen are displayed. If multiple arguments are provided, the intersection of the sets is displayed.")
("gpeGetTrunkChains"
"gpeGetTrunkChains(
u_sandbox
[ ?anchorIndex n_anchorIndex ]
[ ?trunkDirection t_trunkDirection ]
[ ?offsetDirection t_offsetDirection ]
[ ?anchorPoint t_anchorPoint ]
[ ?verbose { t | nil } ]
)
=> l_trunksChains / nil"
"Returns a list of trunk chains based on the specified identifiers. If none of the optional arguments are provided, all trunkChains available in the Modgen are listed. If multiple optional arguments are provided, the return value is the intersection of all the sets.")
("gpeGetTwigEntries"
"gpeGetTwigEntries(
u_sandbox
[ ?trunks l_trunks ]
[ ?verbose { t | nil } ]
)
=> l_Twigs / nil"
"Returns all twigs on the specified trunks from the specified sandbox.")
("gpeSetChannelWidthEntry"
"gpeSetChannelWidthEntry(
u_sandbox
x_index
t_direction
g_channelWidth
[ ?verbose { t | nil } ]
)
=> t / nil"
"Sets the channelWidth for the specified channel.")
("gpeSetRouter"
"gpeSetRouter(
u_sandbox
t_router
[ ?verbose { t | nil } ]
)
=> t / nil"
"Specifies the router to be used to route the Modgen.")
("nclCPSaveConstraint"
"nclCPSaveConstraint(
[ d_cellViewID ]
)
=> t / nil"
"Saves a cell planner Layout Structure constraint on the cellview the cell planner was started from.")
("nclCPToolBarSelect"
"nclCPToolBarSelect(
[ s_mode ]
)
=> t / nil"
"Selects the action to perform in Cell Planning mode (one of: horizontal, vertical, merge, move). If you select horizontal, subsequent clicks create horizontal partitions in the Cell Plan. If you select vertical, subsequent clicks create vertical partitions. If you select merge, subsequent clicks on existing partitions removes those partitions. If you select move, you can move instances between rooms.")
("nclCPExit"
"nclCPExit(
)
=> t / nil"
"Exits Cell Planning mode and returns the toolbars and assistants to their original state.")
("cphUprevDesign"
"cphUprevDesign(
t_physLib
t_physCell
t_physView
t_cfgLib
t_cfgCell
t_cfgView
)
=> t / nil"
"Converts the specified design to use a physical configuration view. You must specify the name of the design to be converted and the name of the physical configuration to use.")
("cphUprevIncremental"
"cphUprevIncremental( 
t_libName
t_cellName
t_physConfigView
) 
=> t / nil"
"Modify existing physical configuration views for the library, cell and/or physical configuration names provided by cleaning up the data related to LAM physical stop list.")
("cphUprevLibrary"
"cphUprevLibrary(
t_physLib
[ t_cfgBaseName ]
)
=> t / nil"
"Converts the specified library to use physical configuration views. You must specify the name of the library to be converted. You can optionally specify a name for the configuration view that is generated (the default is physConfig).")
("cphChangeEditMode"
"cphChangeEditMode(
g_cphID
t_newMode
)
=> t / nil"
"Changes the physConfig from edit mode to the specified mode. If switching to read mode, r, and the physConfig has changed since the last edit, a prompt for saving or discarding the edits displays.")
("cphCloseConfig"
"cphCloseConfig(
g_physConfigID
)
=> t / nil"
"Closes the physical configuration view associated with the specified ID. The physical configuration view is not saved.")
("cphCloseWindow"
"cphCloseWindow(
g_physConfigID
)
=> t / nil"
"Closes the graphical user interface for the physical configuration view associated with the specified ID. The physical configuration view is not saved.")
("cphCreatePhysConfig"
"cphCreatePhysConfig(
t_cfgLib
t_cfgCell
t_cfgView
t_logLib
t_logCell
t_logView
[ ?libList t_physLibList ]
[ ?switchList t_switchList ]
[ ?stopList t_stopList ]
[ ?cstList t_cstList ]
)
=> g_physConfigID / nil"
"Creates a physical configuration view based on a specified logical view and returns the associated physical configuration ID. If the physical configuration view exists already, the system issues a warning.")
("cphFindOpenConfig"
"cphFindOpenConfig(
t_cfgLib
t_cfgCell
t_cfgView
)
=> g_physConfigID / nil"
"Returns the ID associated with the specified physical configuration view, if it exists and is already open.")
("cphGetAllOpenConfigs"
"cphGetAllOpenConfigs(
)
=> l_physConfigID / nil"
"Returns the IDs associated with all the open physical configuration views.")
("cphGetCell"
"cphGetCell(
g_physConfigID
)
=> t_cellName / nil"
"Returns the name of the cell containing the physical configuration view associated with the specified ID.")
("cphGetLayoutXLConfig"
"cphGetLayoutXLConfig(
d_physCellviewID
)
=> g_physConfigID / nil"
"Returns the ID of the physical configuration cellview associated with a specified physical cellview ID.")
("cphGetLib"
"cphGetLib(
g_physConfigID
)
=> t_libName / nil"
"Returns the name of the library containing the physical configuration view associated with the specified ID.")
("cphGetPhysicalTermName"
"cphGetPhysicalTermName(
g_physConfigID
t_path
t_logTermName
)
=> t_physTermName / nil"
"Returns the name of the corresponding physical terminal name for a specified logical terminal on a specified occurrence.")
("cphGetSelectedSet"
"cphGetSelectedSet(
g_physConfigID
)
=> l_listOfPaths / nil"
"Returns a list of paths to the selected instances in the graphical user interface of physical configuration view associated with the given ID.")
("cphGetView"
"cphGetView(
g_physConfigID
)
=> t_viewName / nil"
"Returns the view name for the physical configuration view associated with the specified ID.")
("cphGetWinConfig"
"cphGetWinConfig(
w_windowID
)
=> g_physConfigID / nil"
"Returns the ID of the physical configuration view associated with a specified Configure Physical Hierarchy window.")
("cphGetWindowId"
"cphGetWindowId(
g_physConfigID
)
=> w_windowID / nil"
"Returns the window ID of the Configure Physical Hierarchy window that contains the physical configuration view associated with the specified ID.")
("cphIsConfigModified"
"cphIsConfigModified(
g_physConfigID
)
=> t / nil"
"Returns whether or not the physical configuration view associated with the given ID has been modified since it was last saved.")
("cphIsLeaf"
"cphIsLeaf(
g_physConfigID
t_path
)
=> t / nil"
"Determines whether the specified occurrence is a leaf. An occurrence is considered a leaf if no hierarchy will be generated underneath it.")
("cphIsReadOnly"
"cphIsReadOnly(
g_cphID
)
=> t / nil"
"Checks whether the physical configuration view is read only.")
("cphIsRemoveDevice"
"cphIsRemoveDevice(
g_physConfigID
t_path
)
=> t / nil"
"Determines whether there is a Remove rule defined for the specified occurrence in the physical configuration view associated with the specified ID.")
("cphIsUnderPhysConfig"
"cphIsUnderPhysConfig(
g_physConfigID
t_path
)
=> t / nil"
"Determines whether the specified occurrence exists under a sub physConfig.")
("cphLaunchFromLayout"
"cphLaunchFromLayout(
d_physCellviewID
)
=> t / nil"
"Launches the Configure Physical Hierarchy window and loads the physical configuration view associated with the specified physical cellview ID.")
("cphOpenConfig"
"cphOpenConfig(
t_cfgLib
t_cfgCell
t_cfgView
[ t_mode { r | a } ]
)
=> g_physConfigID / nil"
"Opens the specified physical configuration view by name in either read (the default) or append mode and returns its ID.")
("cphOpenWindow"
"cphOpenWindow(
g_physConfigID
)
=> t / nil"
"Opens the graphical user interface and displays the physical configuration view associated with the specified ID.")
("cphReplaceCellName"
"cphReplaceCellName(
t_oldName
t_newName
?cfgLib t_libName
[ ?cfgCell t_cellName ]
[ ?cfgView t_viewName ]
)
=> t / nil"
"Enables update or repair of physConfig views after performing linux copy to copy the library files instead of using the Library Manager Copy Library option.")
("cphReplaceLibName"
"cphReplaceLibName(
t_oldName
t_newName
?cfgLib t_libName
[ ?cfgCell t_cellName ]
[ ?cfgView t_viewName ]
)
=> t / nil"
"Enables update or repair of physConfig views after performing linux copy to copy the library files instead of using the Library Manager Copy Library option.")
("cphReplaceViewName"
"cphReplaceViewName(
t_oldName
t_newName
?cfgLib t_libName
[ ?cfgCell t_cellName ]
[ ?cfgView t_viewName ]
)
=> t / nil"
"Enables update or repair of physConfig views after performing linux copy to copy the library files instead of using the Library Manager Copy Library option.")
("cphSaveAsConfig"
"cphSaveAsConfig(
g_physConfigID
t_cfgLib
t_cfgCell
t_cfgView
)
=> t / nil"
"Saves the physical configuration view associated with an ID under the library, cell, and view names you specify.")
("cphSaveConfig"
"cphSaveConfig(
g_physConfigID
)
=> t / nil"
"Saves the physical configuration view associated with the specified ID.")
("cphGetTopCellName"
"cphGetTopCellName
g_cphManager
)
=> t_cellName"
"Returns the cell name of the top schematic cellview in the specified physical configuration view.")
("cphGetTopLibName"
"cphGetTopLibName(
g_cphManager
)
=> t_libName"
"Returns the library name of the top schematic cellview in the specified physical configuration view.")
("cphGetTopViewName"
"cphGetTopViewName(
g_cphManager
)
=> t_viewName"
"Returns the view name of the top schematic cellview in the specified physical configuration view.")
("cphGetTopCellView"
"cphGetTopCellView(
g_physConfigID
)
=> d_logCellviewID / nil"
"Returns the database ID of the logical cellview associated with the specified physical configuration ID.")
("cphGetCstList"
"cphGetCstList(
g_physConfigID
)
=> t_cstList / nil"
"Returns the names of views containing constraint data for the physical configuration view associated with the specified ID.")
("cphGetLibList"
"cphGetLibList(
g_physConfigID
)
=> t_physLibList / nil"
"Returns the list of physical library names list for the physical configuration view associated with the specified ID. These are the libraries that are searched to find the corresponding physical cell for a given logical cell.")
("cphGetStopList"
"cphGetStopList(
g_physConfigID
[ t_path ]
)
=> t_stopList / nil"
"Returns the physical stop view list defined for the physical configuration view associated with the specified ID or, if you specify the path to an occurrence, the effective physical stop view list used by that occurrence.")
("cphGetViewList"
"cphGetViewList(
g_physConfigID
[ t_path ]
)
=> t_switchList / nil"
"Returns the logical switch view list for the physical configuration view associated with the specified ID or, if you specify the path to an occurrence, the effective logical switch view list used by that occurrence.")
("cphSetCstList"
"cphSetCstList(
g_physConfigID
t_cstList
)
=> t / nil"
"Sets the constraint view list for the physical configuration view associated with the specified ID. This list specifies the names of the views containing constraint data.")
("cphSetLibList"
"cphSetLibList(
g_physConfigID
t_physLibList
)
=> t / nil"
"Sets the physical library list for the physical configuration view associated with the specified ID. This list specifies the names of the libraries searched to find the corresponding physical cell for a given logical cell.")
("cphSetStopList"
"cphSetStopList(
g_physConfigID
t_stopList
)
=> t / nil"
"Sets the physical stop view list for the physical configuration view associated with the specified ID. The list specifies the view names that are used to determine the corresponding physical view for a given logical view. When traversing a hierarchy, Configure Physical Hierarchy uses the first view it encounters with one of the specified names.")
("cphSetViewList"
"cphSetViewList(
g_physConfigID
t_switchList
)
=> t / nil"
"Sets the logical switch view list for the physical configuration view associated with the specified ID. The list specifies the view names used to descend into a hierarchical design to find schematic views.")
("cphClearCellPhysicalBinding"
"cphClearCellPhysicalBinding(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Removes the physical binding for a logical cell in the physical configuration associated with the given ID.")
("cphClearSchCellPhysicalBinding"
"cphClearSchCellPhysicalBinding(
d_topSchCVID
t_libName
t_cellName
[ ?layCVId d_layCVId ]
)
=> t / nil"
"Removes the physical binding for the cell specified using the top-level schematic and layout cellview IDs instead of the cphManager ID. After the physical binding for the specified cell is removed, the update is also saved to the physConfig view.")
("cphClearInstPhysicalBinding"
"cphClearInstPhysicalBinding(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Removes the physical binding for a specific instance in the physical configuration associated with the given ID.")
("cphClearSchInstPhysicalBinding"
"cphClearSchInstPhysicalBinding(
d_topSchCVID
d_schInstID
g_all
[ ?layCVId d_layCVId ])
=> t / nil"
"Removes the physical binding for the instance specified using the top-level schematic and layout cellview IDs instead of the cphManager ID. After the physical binding for the specified instance is removed, the update is also saved to the physConfig view.")
("cphClearOccurPhysicalBinding"
"cphClearOccurPhysicalBinding(
g_physConfigID
t_path
)
=> t / nil"
"Removes the physical binding for a specific occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetCellForceDescend"
"cphGetCellForceDescend(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns whether or not the force descend attribute is set for a specific cell in the physical configuration associated with the given ID.")
("cphGetCellPhysicalBinding"
"cphGetCellPhysicalBinding(
g_physConfigID
t_logLib
t_logCell
)
=> t_physicalBinding / nil"
"Returns the physical library, cell, and view mapped to a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetSchCellPhysicalBinding"
"cphGetSchCellPhysicalBinding(
d_topSchCVID
t_libName
t_cellName
[ ?layCVId d_layCVId ]
)
=> t_result / nil"
"Returns the physical binding of a cell specifying the top-level schematic and layout cellview IDs instead of the cphManager ID.")
("cphGetCellPhysicalCell"
"cphGetCellPhysicalCell(
g_physConfigID
t_logLib
t_logCell
)
=> t_physCell / nil"
"Returns the name of the physical cell mapped to a specified logical cell in the physical configuration associated with the given ID.")
("cphGetCellPhysicalLib"
"cphGetCellPhysicalLib(
g_physConfigID
t_logLib
t_logCell
)
=> t_physLib / nil"
"Returns the physical library mapped to a specified logical cell in the physical configuration associated with the given ID.")
("cphGetCellPhysicalView"
"cphGetCellPhysicalView(
g_physConfigID
t_logLib
t_logCell
)
=> t_physView / nil"
"Returns the physical view mapped to a specified logical cell in the physical configuration associated with the given ID.")
("cphGetCellStopList"
"cphGetCellStopList(
g_physConfigID
t_logLib
t_logCell
)
=> t_stopList / nil"
"Returns the inherited physical stop view list for a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetCellViewBinding"
"cphGetCellViewBinding(
g_physConfigID
t_logLib
t_logCell
)
=> t_logViewToUse / nil"
"Returns the view to use for a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetCellViewList"
"cphGetCellViewList(
g_physConfigID
t_logLib
t_logCell
)
=> t_switchList / nil"
"Returns the inherited logical switch view list for a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetForceDescend"
"cphGetForceDescend(
g_physConfigID
t_path
)
=> t / nil"
"Returns whether or not an effective force descend attribute is set for a specific occurrence in the physical configuration associated with the given ID.")
("cphGetInstForceDescend"
"cphGetInstForceDescend(
g_physConfigID
t_logLib
t_logCell
t_logView
t_path
)
=> t / nil"
"Returns whether or not the force descend attribute is set for a specific instance in the physical configuration associated with the given ID.")
("cphGetSchInstForceDescend"
"cphGetSchInstForceDescend(
d_topSchCVID
d_schInstID
[ ?layCVId d_layCVId ]
)
=> t / nil"
"Returns whether an instance has a force descend, specifying the top-level schematic and layout cellview IDs instead of the cphManager ID.")
("cphGetSchInstPhysicalBinding"
"cphGetSchInstPhysicalBinding(
d_topSchCVID
d_schInstID
[ ?layCVId d_layCVId ]
)
=> t_result / nil"
"Returns the physical binding of an instance by specifying its top-level schematic and layout cellview IDs instead of specifying the cphManager ID.")
("cphGetInstPhysicalCell"
"cphGetInstPhysicalCell(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_physCell / nil"
"Returns the name of the physical cell mapped to a specified instance in the physical configuration associated with the given ID.")
("cphGetInstPhysicalLib"
"cphGetInstPhysicalLib(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_physLib / nil"
"Returns the physical library mapped to a specified instance in the physical configuration associated with the given ID.")
("cphGetInstPhysicalView"
"cphGetInstPhysicalView(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_physView / nil"
"Returns the physical view mapped to a specified instance in the physical configuration associated with the given ID.")
("cphGetInstStopList"
"cphGetInstStopList(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_stopList / nil"
"Returns the inherited stop view list for a specified instance in the physical configuration view associated with the given ID.")
("cphGetInstViewBinding"
"cphGetInstViewBinding(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_logViewToUse / nil"
"Returns the view to use for a specified logical instance in the physical configuration view associated with the given ID.")
("cphGetInstViewList"
"cphGetInstViewList(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_switchList / nil"
"Returns the inherited logical switch view list for a specified instance in the physical configuration view associated with the given ID.")
("cphGetOccurForceDescend"
"cphGetOccurForceDescend(
g_physConfigID
t_path
)
=> t / nil"
"Returns whether or not the force descend attribute is set for a specific occurrence in the physical configuration associated with the given ID.")
("cphGetOccurPhysicalCell"
"cphGetOccurPhysicalCell(
g_physConfigID
t_path
)
=> t_physCell / nil"
"Returns the physical cell binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetOccurPhysicalLib"
"cphGetOccurPhysicalLib(
g_physConfigID
t_path
)
=> t_physLib / nil"
"Returns the physical library binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetOccurPhysicalView"
"cphGetOccurPhysicalView(
g_physConfigID
t_path
)
=> t_physView / nil"
"Returns the view binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetOccurStopList"
"cphGetOccurStopList(
g_physConfigID
t_path
)
=> t_stopList / nil"
"Returns the physical stop view list set explicitly for an occurrence of an instance in the physical configuration view associated with the given ID.")
("cphGetOccurViewBinding"
"cphGetOccurViewBinding(
g_physConfigID
t_path
)
=> t_logViewToUse / nil"
"Returns the logical view to use set explicitly for an occurrence of an instance in the physical configuration view associated with the given ID.")
("cphGetOccurViewList"
"cphGetOccurViewList(
g_physConfigID
t_path
)
=> t_switchList / nil"
"Returns the inherited logical switch view list for a specific occurrence of an instance in the physical configuration view associated with the given ID.")
("cphGetPhysicalCell"
"cphGetPhysicalCell(
g_physConfigID
t_path
)
=> t_physCell / nil"
"Returns the effective physical cell binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetPhysicalLib"
"cphGetPhysicalLib(
g_physConfigID
t_path
)
=> t_physLib / nil"
"Returns the effective physical library binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetPhysicalView"
"cphGetPhysicalView(
g_physConfigID
t_path
)
=> t_physView / nil"
"Returns the effective physical view binding for an occurrence of an instance in the physical configuration associated with the given ID.")
("cphGetStopPoint"
"cphGetStopPoint(
g_physConfigID
t_path
)
=> t / nil"
"Returns whether or not the stop point attribute is set for a specific occurrence in the physical configuration associated with the given ID.")
("cphGetViewBinding"
"cphGetViewBinding(
g_physConfigID
t_path
)
=> t_logViewToUse / nil"
"Returns the effective logical view to use for a specific occurrence of an instance in the physical configuration view associated with the given ID.")
("cphSetCellForceDescend"
"cphSetCellForceDescend(
g_physConfigID
t_logLib
t_logCell
g_value
)
=> t / nil"
"Sets or unsets the force descend attribute on a specified cell in the physical configuration associated with the given ID. This forces hierarchy traversal to proceed beyond instances of the cell, even if it would normally be considered a leaf-level instance.")
("cphSetCellPhysicalBinding"
"cphSetCellPhysicalBinding(
g_physConfigID
t_logLib
t_logCell
t_physLib
t_physCell
t_physView
)
=> t / nil"
"Sets the physical binding for a specified logical cell in the physical configuration associated with the given ID.")
("cphSetSchCellPhysicalBinding"
"cphSetSchCellPhysicalBinding(
d_topSchCVID
t_libName
t_cellName
t_value
[ ?layCVId d_layCVId ]
)
=> t / nil"
"Sets the physical binding of a cell specifying top-level schematic and layout cellviews IDs instead of the cphManager ID. After the cell binding is set, the SKILL function also saves the update to the physConfig view.")
("cphSetCellStopList"
"cphSetCellStopList(
g_physConfigID
t_logLib
t_logCell
t_stopList
)
=> t / nil"
"Sets the physical stop view list for a specified logical cell in the physical configuration associated with the given ID.")
("cphSetCellViewBinding"
"cphSetCellViewBinding(
g_physConfigID
t_logLib
t_logCell
t_logViewToUse
)
=> t / nil"
"Sets the logical view to use for a specified logical cell in the physical configuration associated with the given ID.")
("cphSetCellViewList"
"cphSetCellViewList(
g_physConfigID
t_logLib
t_logCell
t_switchList
)
=> t / nil"
"Specifies the inherited logical switch view list for a specified logical cell in the physical configuration associated with the given ID.")
("cphSetInstForceDescend"
"cphSetInstForceDescend(
g_physConfigID
t_lib
t_cell
t_view
t_inst
g_boolean
)
=> t / nil"
"Sets or unsets the force descend attribute on a specified instance in the physical configuration associated with the given ID. This forces hierarchy traversal to proceed beyond the instance, even if it would normally be considered a leaf instance.")
("cphSetSchInstForceDescend"
"cphSetSchInstForceDescend(
d_topSchCVID
d_schInstID
g_value
g_all
[ ?layCVId d_layCVId ]
)
=> t / nil"
"Sets the value for force descend on the specified instance, specifying top-level schematic and layout cellview IDs instead of the cphManager ID.")
("cphSetInstPhysicalBinding"
"cphSetInstPhysicalBinding(
g_physConfigID
t_lib
t_cell
t_view
t_inst
t_physLib
t_physCell
t_physView
)
=> t / nil"
"Sets the physical binding for a specified instance in the physical configuration associated with the given ID The library and cell are empty, the system issues a warning message.")
("cphSetSchInstPhysicalBinding"
"cphSetSchInstPhysicalBinding(
d_topSchCVID
d_schInstID
t_value
g_all
[ ?layCVId d_layCVId ]
)
=> t / nil"
"Sets the physical binding of an instance specifying the top-level schematic and layout cellview IDs instead of the cphManager ID.")
("cphSetInstStopList"
"cphSetInstStopList(
g_physConfigID
t_lib
t_cell
t_view
t_inst
t_stopList
)
=> t / nil"
"Sets an inherited physical stop view list for a specified instance in the physical configuration associated with the given ID.")
("cphSetInstStopPoint"
"cphSetInstStopPoint(
g_physConfigID
t_lib
t_cell
t_view
t_inst
g_boolean
)
=> t / nil"
"Sets or unsets the stop point attribute on a specified instance in the physical configuration associated with the given ID. This means that hierarchy traversal always stops at this instance.")
("cphSetInstViewBinding"
"cphSetInstViewBinding(
g_physConfigID
t_lib
t_cell
t_view
t_inst
t_logViewToUse
)
=> t / nil"
"Sets the logical view to use for a specified instance in the physical configuration associated with the given ID.")
("cphSetInstViewList"
"cphSetInstViewList(
g_physConfigID
t_lib
t_cell
t_view
t_inst
t_switchList
)
=> t / nil"
"Sets an inherited logical switch view list for a specified instance in the physical configuration associated with the given ID.")
("cphSetOccurForceDescend"
"cphSetOccurForceDescend(
g_physConfigID
t_path
g_boolean
)
=> t / nil"
"Sets or unsets the force descend attribute on a specific occurrence of an instance in the physical configuration associated with the given ID. This forces hierarchy traversal to proceed beyond the occurrence, even if it would normally be considered a leaf instance.")
("cphSetOccurPhysicalBinding"
"cphSetOccurPhysicalBinding(
g_physConfigID
t_path
t_physLib
t_physCell
t_physView
)
=> t / nil"
"Sets the physical binding for a specific occurrence of an instance in the physical configuration associated with the given ID.")
("cphSetOccurStopList"
"cphSetOccurStopList(
g_physConfigID
t_path
t_stopList
)
=> t / nil"
"Sets an inherited physical stop view list for a specific occurrence of an instance in the physical configuration associated with the given ID.")
("cphSetOccurStopPoint"
"cphSetOccurStopPoint(
g_physConfigID
t_path
g_boolean
)
=> t / nil"
"Sets or unsets the stop point attribute on a specified occurrence of an instance in the physical configuration associated with the given ID. This means that hierarchy traversal always stops at this instance.")
("cphSetOccurViewBinding"
"cphSetOccurViewBinding(
g_physConfigID
t_path
t_logViewToUse
)
=> t / nil"
"Sets the logical view to use for a specific occurrence of an instance in the physical configuration associated with the given ID.")
("cphSetOccurViewList"
"cphSetOccurViewList(
g_physConfigID
t_path
t_switchList
)
=> t / nil"
"Sets an inherited logical switch view list for a specific occurrence of an instance in the physical configuration associated with the given ID.")
("cphDeleteCellFingerSplit"
"cphDeleteCellFingerSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Split fingered devices attribute defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellIgnoreForCheck"
"cphDeleteCellIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Ignore for check attribute defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellIgnoreForGen"
"cphDeleteCellIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Ignore for layout generation attribute defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellMFactorSplit"
"cphDeleteCellMFactorSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Split mfactored devices attribute defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellParamIgnoreForCheck"
"cphDeleteCellParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the list of parameter names to be ignored when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphDeleteCellParamIgnoreForGen"
"cphDeleteCellParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the list of parameter names to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphDeleteCellParamNameMapping"
"cphDeleteCellParamNameMapping(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the mapping specified between parameter names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphDeleteCellParamToCheck"
"cphDeleteCellParamToCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the list of parameter names to be checked when running Check Against Source for the specified logical cell in the specified physical configuration.")
("cphDeleteCellRemoveDevice"
"cphDeleteCellRemoveDevice(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Remove device rule defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellRounding"
"cphDeleteCellRounding(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Rounding rule defined for the specified logical cell in the specified physical configuration.")
("cphDeleteCellSFactorSplit"
"cphDeleteCellSFactorSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the Split sfactored devices attribute defined for the specified logical cell in the physical configuration.")
("cphDeleteCellTermIgnoreForCheck"
"cphDeleteCellTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the list of terminal names to be ignored when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphDeleteCellTermIgnoreForGen"
"cphDeleteCellTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the list of terminal names to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphDeleteCellTermNameMapping"
"cphDeleteCellTermNameMapping(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the mapping specified between terminal names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphDeleteCellVLGen"
"cphDeleteCellVLGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the VLGen property and physical binding of the specified logical cell in the physical configuration view associated with the given ID.")
("cphDeleteInstFingerSplit"
"cphDeleteInstFingerSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
)
=> t / nil"
"Deletes the Split fingered devices attribute defined for the specified instance in the specified physical configuration.")
("cphDeleteInstIgnoreForCheck"
"cphDeleteInstIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Ignore for check attribute defined for the specified instance in the specified physical configuration.")
("cphDeleteInstIgnoreForGen"
"cphDeleteInstIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Ignore for layout generation attribute defined for the specified instance in the specified physical configuration.")
("cphDeleteInstMFactorSplit"
"cphDeleteInstMFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Split mfactored devices attribute defined for the specified instance in the specified physical configuration.")
("cphDeleteInstParamIgnoreForCheck"
"cphDeleteInstParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the list of parameter names to be ignored when running Check Against Source on the specified instance in the specified physical configuration.")
("cphDeleteInstParamIgnoreForGen"
"cphDeleteInstParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the list of parameter names to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphDeleteInstParamToCheck"
"cphDeleteInstParamToCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the list of parameter names to be checked when running Check Against Source on the specified instance in the specified physical configuration.")
("cphDeleteInstRemoveDevice"
"cphDeleteInstRemoveDevice(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Remove device rule defined for the specified instance in the specified physical configuration.")
("cphDeleteInstRounding"
"cphDeleteInstRounding(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Rounding rule defined for the specified instance in the specified physical configuration.")
("cphDeleteInstSFactorSplit"
"cphDeleteInstSFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the Split sfactored devices attribute defined for the specified instance in the physical configuration.")
("cphDeleteInstTermIgnoreForCheck"
"cphDeleteInstTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the list of terminal names to be ignored when running Check Against Source on the specified instance in the specified physical configuration.")
("cphDeleteInstTermIgnoreForGen"
"cphDeleteInstTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Deletes the list of terminal names to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphDeleteOccurFingerSplit"
"cphDeleteOccurFingerSplit(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Split fingered devices attribute defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurIgnoreForCheck"
"cphDeleteOccurIgnoreForCheck(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Ignore for check attribute defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurIgnoreForGen"
"cphDeleteOccurIgnoreForGen(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Ignore for layout generation attribute defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurMFactorSplit"
"cphDeleteOccurMFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Split mfactored devices attribute defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurParamIgnoreForCheck"
"cphDeleteOccurParamIgnoreForCheck(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the list of parameter names to be ignored when running Check Against Source on the specified occurrence in the specified physical configuration.")
("cphDeleteOccurParamIgnoreForGen"
"cphDeleteOccurParamIgnoreForGen(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the list of parameter names to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurParamToCheck"
"cphDeleteOccurParamToCheck(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the list of parameter names to be checked when running Check Against Source for the specific occurrence of an instance in the physical configuration.")
("cphDeleteOccurRemoveDevice"
"cphDeleteOccurRemoveDevice(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Remove device rule defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurRounding"
"cphDeleteOccurRounding(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Rounding rule defined for the specified occurrence in the specified physical configuration.")
("cphDeleteOccurSFactorSplit"
"cphDeleteOccurSFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the Split sfactored devices attribute defined for the specific occurrence of an instance in the physical configuration.")
("cphDeleteOccurTermIgnoreForCheck"
"cphDeleteOccurTermIgnoreForCheck(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the list of terminal names to be ignored when running Check Against Source on the specified occurrence in the specified physical configuration.")
("cphDeleteOccurTermIgnoreForGen"
"cphDeleteOccurTermIgnoreForGen(
g_physConfigID
t_path
)
=> t / nil"
"Deletes the list of terminal names to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphGetCellFingerSplit"
"cphGetCellFingerSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the value of the Split fingered devices attribute for a specified logical cell in the specified physical configuration.")
("cphGetCellIgnoreForCheck"
"cphGetCellIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the value of the Ignore for check attribute for a specified logical cell in the specified physical configuration.")
("cphGetCellIgnoreForGen"
"cphGetCellIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the value of the Ignore for layout generation attribute for a specified logical cell in the specified physical configuration.")
("cphGetCellMFactorSplit"
"cphGetCellMFactorSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the value of the Split mfactored devices attribute for a specified logical cell in the specified physical configuration.")
("cphGetCellParamIgnoreForCheck"
"cphGetCellParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphGetCellParamIgnoreForGen"
"cphGetCellParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphGetCellParamNameMapping"
"cphGetCellParamNameMapping(
g_physConfigID
t_logLib
t_logCell
)
=> t_paramMapping / nil"
"Returns the mapping specified between parameter names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphGetCellParamToCheck"
"cphGetCellParamToCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be checked when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphGetCellRemoveDevice"
"cphGetCellRemoveDevice(
g_physConfigID
t_logLib
t_logCell
)
=> t_removeDevice / nil"
"Returns the value of the Remove device rule for a specified logical cell in the specified physical configuration.")
("cphGetCellRounding"
"cphGetCellRounding(
g_physConfigID
t_logLib
t_logCell
)
=> t_roundingRule / nil"
"Returns the value of the Rounding rule for a specified logical cell in the specified physical configuration.")
("cphGetCellSFactorSplit"
"cphGetCellSFactorSplit(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the value of the Split sfactored devices attribute for a specified logical cell in the specified physical configuration.")
("cphGetCellTermIgnoreForCheck"
"cphGetCellTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored when running Check Against Source for the specified logical cell in the specified physical configuration.")
("cphGetCellTermIgnoreForGen"
"cphGetCellTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphGetCellTermNameMapping"
"cphGetTermNameMapping(
g_physConfigID
t_logLib
t_logCell
)
=> t_termMapping / nil"
"Returns the mapping between terminal names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphGetCellVLGen"
"cphGetCellVLGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the VLGen property mapped to a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetFingerSplit"
"cphGetFingerSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the effective value of the Split fingered devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetIgnoreForCheck"
"cphGetIgnoreForCheck(
g_physConfigID
t_path
)
=> t / nil"
"Returns the effective value of the Ignore for check attribute for the specified occurrence in the specified physical configuration.")
("cphGetIgnoreForGen"
"cphGetIgnoreForGen(
g_physConfigID
t_path
)
=> t / nil"
"Returns the effective value of the Ignore for layout generation attribute for the specified occurrence in the specified physical configuration.")
("cphGetInstFingerSplit"
"cphGetInstFingerSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Returns the value of the Split fingered devices attribute for the specified instance in the specified physical configuration.")
("cphGetInstIgnoreForCheck"
"cphGetInstIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Returns the value of the Ignore for check attribute for the specified instance in the specified physical configuration.")
("cphGetInstIgnoreForGen"
"cphGetInstIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Returns the value of the Ignore for layout generation attribute for the specified instance in the specified physical configuration.")
("cphGetInstMFactorSplit"
"cphGetInstMFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Returns the value of the Split mfactored devices attribute for the specified instance in the specified physical configuration.")
("cphGetInstParamIgnoreForCheck"
"cphGetInstParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when running Check Against Source on the specified instance in the specified physical configuration.")
("cphGetInstParamIgnoreForGen"
"cphGetInstParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphGetInstParamToCheck"
"cphGetInstParamToCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be checked when running Check Against Source on the specified instances in the specified physical configuration.")
("cphGetInstRemoveDevice"
"cphGetInstRemoveDevice(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_removeDevice / nil"
"Returns the value of the Remove device rule for the specified instance in the specified physical configuration.")
("cphGetInstRounding"
"cphGetInstRounding(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_roundingRule / nil"
"Returns the value of the Rounding rule for the specified instance in the specified physical configuration.")
("cphGetInstSFactorSplit"
"cphGetInstSFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t / nil"
"Returns the value of the Split sfactored devices attribute for the specified instance in the specified physical configuration.")
("cphGetInstTermIgnoreForCheck"
"cphGetInstTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored by when running Check Against Source for a specified instance in the specified physical configuration.")
("cphGetInstTermIgnoreForGen"
"cphGetInstTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphGetMFactorSplit"
"cphGetMFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the effective value of the Split mfactored devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurFingerSplit"
"cphGetOccurFingerSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the value of the Split fingered devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurIgnoreForCheck"
"cphGetOccurIgnoreForCheck(
g_physConfigID
t_path
)
=> t / nil"
"Returns the value of the Ignore for check attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurIgnoreForGen"
"cphGetOccurIgnoreForGen(
g_physConfigID
t_path
)
=> t / nil"
"Returns the value of the Ignore for layout generation attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurMFactorSplit"
"cphGetOccurMFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the value of the Split mfactored devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurParamIgnoreForCheck"
"cphGetOccurParamIgnoreForCheck(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when running Check Against Source on the specified view in the specified physical configuration.")
("cphGetOccurParamIgnoreForGen"
"cphGetOccurParamIgnoreForGen(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphGetOccurParamToCheck"
"cphGetOccurParamToCheck(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the list of parameter names to be checked when running Check Against Source for the specific occurrence of an instance in the physical configuration.")
("cphGetOccurRemoveDevice"
"cphGetOccurRemoveDevice(
g_physConfigID
t_path
)
=> t_removeDevice / nil"
"Returns the Remove device rule for the specified occurrence in the specified physical configuration.")
("cphGetOccurRounding"
"cphGetOccurRounding(
g_physConfigID
t_path
)
=> t_roundingRule / nil"
"Returns the Rounding rule for the specified occurrence in the specified physical configuration.")
("cphGetOccurSFactorSplit"
"cphGetOccurSFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the value of the Split sfactored devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetOccurTermIgnoreForCheck"
"cphGetOccurTermIgnoreForCheck(
g_physConfigID
t_path
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored by when running Check Against Source for a specified occurrence in the specified physical configuration.")
("cphGetOccurTermIgnoreForGen"
"cphGetOccurTermIgnoreForGen(
g_physConfigID
t_path
)
=> t_listOfTermNames / nil"
"Returns the list of terminals to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphGetParamIgnoreForCheck"
"cphGetParamIgnoreForCheck(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the effective list of parameter names to be ignored by Check Against Source for the specified occurrence in the specified physical configuration.")
("cphGetParamIgnoreForGen"
"cphGetParamIgnoreForGen(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the effective list of parameter names to be ignored when generating a layout for the specified occurrence of an instance in the specified physical configuration.")
("cphGetParamNameMapping"
"cphGetParamNameMapping(
g_physConfigID
t_path
)
=> t_paramMapping / nil"
"Returns the effective mappings between parameter names in the schematic and layout views of the specified occurrence in the specified physical configuration.")
("cphGetParamToCheck"
"cphGetParamToCheck(
g_physConfigID
t_path
)
=> t_listOfParamNames / nil"
"Returns the effective list of parameter names to be checked by Check Against Source for the specified occurrence in the specified physical configuration.")
("cphGetRemoveDevice"
"cphGetRemoveDevice(
g_physConfigID
t_path
)
=> t_removeDevice / nil"
"Returns the effective value of the Remove device rule for the specified occurrence in the specified physical configuration.")
("cphGetRounding"
"cphGetRounding(
g_physConfigID
t_path
)
=> t_roundingRule / nil"
"Returns the effective value of the Rounding rule for the specified occurrence in the specified physical configuration.")
("cphGetSFactorSplit"
"cphGetSFactorSplit(
g_physConfigID
t_path
)
=> t / nil"
"Returns the effective value of the Split sfactored devices attribute for the specified occurrence in the specified physical configuration.")
("cphGetTermIgnoreForCheck"
"cphGetTermIgnoreForCheck(
g_physConfigID
t_path
)
=> t_listOfTermNames / nil"
"Returns the effective list of terminals to be ignored when running Check Against Source for the specified occurrence in the specified physical configuration.")
("cphGetTermIgnoreForGen"
"cphGetTermIgnoreForGen(
g_physConfigID
t_path
)
=> t_listOfTermNames / nil"
"Returns the effective list of terminals to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphGetTermNameMapping"
"cphGetTermNameMapping(
g_physConfigID
t_path
)
=> t_termMapping / nil"
"Returns the effective mappings between terminal names in the schematic and layout views of the specified occurrence in the specified physical configuration.")
("cphIsParamIgnoredForCheck"
"cphIsParamIgnoredForCheck(
g_physConfigID
t_path
t_paramName
)
=> t / nil"
"Returns whether the specified parameter on the specified occurrence is ignored for check.")
("cphIsParamIgnoredForGen"
"cphIsParamIgnoredForGen(
g_physConfigID
t_path
t_paramName
)
=> t / nil"
"Returns whether the specified parameter on the specified occurrence is ignored for generation.")
("cphIsTermIgnoredForCheck"
"cphIsTermIgnoredForCheck(
g_physConfigID
t_path
t_logTermName
)
=> t / nil"
"Returns whether the specified logical terminal on the specified occurrence is ignored for check.")
("cphIsTermIgnoredForGen"
"cphIsTermIgnoredForGen(
g_physConfigID
t_path
t_logTermName
)
=> t / nil"
"Returns whether the specified logical terminal on the specified occurrence is ignored for generation.")
("cphSetCellFingerSplit"
"cphSetCellFingerSplit(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the Split fingered devices option for the specified logical cell in the specified physical configuration.")
("cphSetCellIgnoreForCheck"
"cphSetCellIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the Ignore for check option for the specified logical cell in the specified physical configuration.")
("cphSetCellIgnoreForGen"
"cphSetCellIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
g_value
)
=> t / nil"
"Sets the Ignore for layout generation option to t or nil for the specified logical cell in the specified physical configuration.")
("cphSetCellMFactorSplit"
"cphSetCellMFactorSplit(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the Split mfactored devices option to t or nil for the specified logical cell in the specified physical configuration.")
("cphSetCellParamIgnoreForCheck"
"cphSetCellParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphSetCellParamIgnoreForGen"
"cphSetCellParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphSetCellParamNameMapping"
"cphSetCellParamNameMapping(
g_physConfigID
t_logLib
t_logCell
t_paramMapping
)
=> t / nil"
"Defines the mapping between parameter names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphSetCellParamToCheck"
"cphSetCellParamToCheck(
g_physConfigID
t_logLib
t_logCell
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be checked when running Check Against Source on the specified logical cell in the specified physical configuration.")
("cphSetCellRemoveDevice"
"cphSetCellRemoveDevice(
g_physConfigID
t_logLib
t_logCell
t_removeDevice
)
=> t / nil"
"Sets the Remove device rule for the specified logical cell in the specified physical configuration. A remove device rule causes parasitic devices to be ignored by merging nets connected to the terminals of a single instance.")
("cphSetCellRounding"
"cphSetCellRounding(
g_physConfigID
t_logLib
t_logCell
t_roundingRule
)
=> t / nil"
"Specifies how the value of a specified parameter on a logical cell is rounded when it is evaluated by Layout XL. This property is typically used in conjunction with the lxDeviceWidth parameter to prevent folded devices from becoming off-grid.")
("cphSetCellSFactorSplit"
"cphSetCellSFactorSplit(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the Split sfactored devices option to t or nil for the specified logical cell in the specified physical configuration.")
("cphSetCellTermIgnoreForCheck"
"cphSetCellTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored when running Check Against Source for the specified logical cell in the specified physical configuration.")
("cphSetCellTermIgnoreForGen"
"cphSetCellTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored when generating a layout for the specified logical cell in the specified physical configuration.")
("cphSetCellTermNameMapping"
"cphSetCellTermNameMapping(
g_physConfigID
t_logLib
t_logCell
t_termMapping
)
=> t / nil"
"Defines the mapping between terminal names in the schematic and layout views of the specified cell in the specified physical configuration.")
("cphSetCellVLGen"
"cphSetCellVLGen(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the VLGen property mapped to a specified logical cell in the physical configuration view associated with the given ID. The cell physical binding is set using the logical library name, logical cell name, and view layout. ")
("cphSetInstFingerSplit"
"cphSetInstFingerSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
g_value
)
=> t / nil"
"Sets the Split fingered devices option for the specified instance in the specified physical configuration.")
("cphSetInstIgnoreForCheck"
"cphSetInstIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
g_value
)
=> t / nil"
"Sets the Ignore for check option to t or nil for the specified instance in the specified physical configuration.")
("cphSetInstIgnoreForGen"
"cphSetInstIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
g_value
)
=> t / nil"
"Sets the Ignore for layout generation option to t or nil for the specified instance in the specified physical configuration.")
("cphSetInstMFactorSplit"
"cphSetInstMFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
g_value
)
=> t / nil"
"Sets the Split mfactored devices option to t or nil for the specified instance in the specified physical configuration.")
("cphSetInstParamIgnoreForCheck"
"cphSetInstParamIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when running Check Against Source on the specified instance in the specified physical configuration.")
("cphSetInstParamIgnoreForGen"
"cphSetInstParamIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphSetInstParamToCheck"
"cphSetInstParamToCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be checked when running Check Against Source on the specified instance in the specified physical configuration.")
("cphSetInstRemoveDevice"
"cphSetInstRemoveDevice(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_removeDevice
)
=> t / nil"
"Specifies a Remove device rule for the specified instance in the specified physical configuration. A remove device rule causes parasitic devices to be ignored by merging nets connected to the terminals of a single instance.")
("cphSetInstRounding"
"cphSetInstRounding(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_roundingRule
)
=> t / nil"
"Specifies how the value of a specified parameter on an instance is rounded when it is evaluated by Layout XL. This property is typically used in conjunction with the lxDeviceWidth parameter to prevent folded devices from becoming off-grid.")
("cphSetInstSFactorSplit"
"cphSetInstSFactorSplit(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
g_boolean
)
=> t / nil"
"Sets the Split sfactored devices option to t or nil for the specified instance in the specified physical configuration.")
("cphSetInstTermIgnoreForCheck"
"cphSetInstTermIgnoreForCheck(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored by when running Check Against Source for a specified instance in the specified physical configuration.")
("cphSetInstTermIgnoreForGen"
"cphSetInstTermIgnoreForGen(
g_physConfigID
t_logLib
t_logCell
t_logView
t_inst
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored when generating a layout for the specified instance in the specified physical configuration.")
("cphSetOccurFingerSplit"
"cphSetOccurFingerSplit(
g_physConfigID
t_path
g_value
)
=> t / nil"
"Sets the Split fingered devices option for the specified occurrence in the specified physical configuration.")
("cphSetOccurIgnoreForCheck"
"cphSetOccurIgnoreForCheck(
g_physConfigID
t_path
g_value
)
=> t / nil"
"Sets the Ignore for check option to t or nil for the specified occurrence in the specified physical configuration.")
("cphSetOccurIgnoreForGen"
"cphSetOccurIgnoreForGen(
g_physConfigID
t_path
g_value
)
=> t / nil"
"Sets the Ignore for layout generation option to t or nil for the specified occurrence in the specified physical configuration.")
("cphSetOccurMFactorSplit"
"cphSetOccurMFactorSplit(
g_physConfigID
t_path
g_value
)
=> t / nil"
"Sets the Split mfactored devices option to t or nil for the specified occurrence in the specified physical configuration.")
("cphSetOccurParamIgnoreForCheck"
"cphSetOccurParamIgnoreForCheck(
g_physConfigID
t_path
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when running Check Against Source on the specified occurrence in the specified physical configuration.")
("cphSetOccurParamIgnoreForGen"
"cphSetOccurParamIgnoreForGen(
g_physConfigID
t_path
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("cphSetOccurParamToCheck"
"cphSetOccurParamToCheck(
g_physConfigID
t_path
t_listOfParamNames
)
=> t / nil"
"Defines the list of parameter names to be checked when running Check Against Source on the specified occurrence in the specified physical configuration.")
("cphSetOccurRemoveDevice"
"cphSetOccurRemoveDevice(
g_physConfigID
t_path
t_removeDevice
)
=> t / nil"
"Specifies a Remove device rule for the specified occurrence in the specified physical configuration. A remove device rule causes parasitic devices to be ignored by merging nets connected to the terminals of a single instance.")
("cphSetOccurRounding"
"cphSetOccurRounding(
g_physConfigID
t_path
t_roundingRule
)
=> t / nil"
"Specifies how the value of a specified parameter on a specific occurrence is rounded when it is evaluated by Layout XL. This property is typically used in conjunction with the lxDeviceWidth parameter to prevent folded devices from becoming off-grid.")
("cphSetOccurSFactorSplit"
"cphSetOccurSFactorSplit(
g_physConfigID
t_path
g_boolean
)
=> t / nil"
"Sets the Split sfactored devices option to t or nil for the specified occurrence in the specified physical configuration.")
("cphSetOccurTermIgnoreForCheck"
"cphSetOccurTermIgnoreForCheck(
g_physConfigID
t_path
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored by when running Check Against Source for a specified occurrence in the specified physical configuration.")
("cphSetOccurTermIgnoreForGen"
"cphSetOccurTermIgnoreForGen(
g_physConfigID
t_path
t_listOfTermNames
)
=> t / nil"
"Defines the list of terminals to be ignored when generating a layout for the specified occurrence in the specified physical configuration.")
("ctAddCellToCompTypeGroup"
"ctAddCellToCompTypeGroup(
g_physConfigID
t_physLib
t_physCell
t_ctgName
)
=> t / nil"
"Assigns a specified physical cell to a component type group in the physical configuration associated with the given ID.")
("ctCreateCompTypeGroup"
"ctCreateCompTypeGroup(
g_physConfigID
t_ctgName
t_deviceType
t_widthParamName
t_orientationParamName
t_drainTermName
t_gateTermName
t_sourceTermName
t_bulkTermName
t_activeLayers
f_foldingThresh
t_views
)
=> t / nil"
"Creates a component type group with the specified attributes and stores it in the physical configuration associated with the given ID. If the component type group exists already, it is updated with the specified attribute values.")
("ctDeleteCellFromCompTypeGroup"
"ctDeleteCellFromCompTypeGroup(
g_physConfigID
t_physLib
t_physCell
)
=> t / nil"
"Removes a specified physical cell from its current component type group in the physical configuration associated with the given ID.")
("ctDeleteCompTypeGroup"
"ctDeleteCompTypeGroup(
g_physConfigID
t_ctgName
)
=> t / nil"
"Deletes a specified component type group from the physical configuration associated with the given ID.")
("ctGetCellCompTypeGroup"
"ctGetCellCompTypeGroup(
g_physConfigID
t_physLib
t_physCell
)
=> t_ctgName / nil"
"Returns the component type group to which a specified physical cell is assigned.")
("ctGetCellCompTypeGroups"
"ctGetCellCompTypeGroups(
g_physConfigID
t_physLib
t_physCell
)
=> l_compTypes / nil"
"Returns all the component type groups to which a specified physical cell was assigned.")
("ctGetCompTypeCells"
"ctGetCompTypeCells(
g_physConfigID
t_ctgName
)
=> l_listOfCellNames / nil"
"Returns a list of all the physical cells assigned to the specified component type.")
("ctGetCompTypeGroupAttr"
"ctGetCompTypeGroupAttr(
g_physConfigID
t_ctgName
t_attrName { deviceType | activeLayer | width | foldingThreshold 
	| views | drain | gate | source | bulk }
)
=> g_value / nil"
"Returns the value of a specified attribute in the component type group.")
("ctGetCompTypeNames"
"ctGetCompTypeNames(
g_physConfigID
)
=> l_listOfNames / nil"
"Returns a list of component type group names for the physical configuration associated with the given ID.")
("ctSetCompTypeGroupAttr"
"ctSetCompTypeGroupAttr(
g_physConfigID
t_ctgName
t_attrName { deviceType | activeLayer | width | foldingThreshold 
	| views | drain | gate | source | bulk }
g_value
)
=> t / nil"
"Sets an attribute by name in the component type.")
("cphSbAddIOPin"
"cphSbAddIOPin(
g_cphId
{ g_sbId | l_physLCV }
t_termName
t_termType
[ ?lpp txl_layerPurpose ]
[ ?width n_width ]
[ ?height n_height ]
[ ?number x_number ]
[ ?criticality x_criticality ]
[ ?sigType t_sigType ]
)
=> x_pinID / nil"
"Adds a new pin for the specified soft block and associates the pin with the specified attributes.")
("cphSbDisplayAllIOPinsInfo"
"cphSbDisplayAllIOPinsInfo(
g_cphId
{ g_sbId | l_physLCV }
)
=> t / nil"
"Displays pin information for all pins that match the specified cphID and soft block ID.")
("cphSbDefineCovObstruction"
"cphSbDefineCovObstruction(
g_cphId
g_sbId | l_physLCV
tx_layer
g_allowPGNet
)
=> t / nil"
"Creates a cover obstruction in the specified soft block (g_sbId) or physical cellView (l_physLCV). The cover obstruction restricts routing on the specified layer and all lower layers.")
("cphSbDefineIOPinLabelFlag"
"cphSbDefineIOPinLabelFlag(
g_cphId
{ g_sbId | l_PhysLCV }
g_createLabel
)
=> t / nil"
"Creates I/O pin label.")
("cphSbDefineObstruction"
"cphSbDefineObstruction(
g_cphId
{ g_sbId | l_physLCV }
t_obstructionType
[ ?topOffset  n_topOffset ]
[ ?bottomOffset n_BottomOffset ]
[ ?leftOffset n_LeftOffset ]
[ ?rightOffset  n_RightOffset ]
[ ?layerName t_layerName ]
)
=> t / nil"
"Creates placement, routing, or other obstructions based on the obstructionType argument. All conditions that are enforced for these obstructions through GUI-based flow are applicable here. For example, only one placement blockage is applied per soft block. If a second placement blockage is applied through this API, a warning is issued.")
("cphSbDefineSoftBlock"
"cphSbDefineSoftBlock(
g_cphId
t_PhysLibName
t_PhysCellName
t_PhysViewName
[ ?logLib   t_logicalLibName ]
[ ?logCell t_logicalCellName ]
[ ?logView t_logicalViewName ]
[ ?viewList t_inhViewList ]
[ ?stopList  t_inhStopViewList ]
[ ?bType t_btype ]
[ ?type t_type  ]
)
=> x_softBlockID / nil"
"Defines a soft block for a given physical and logical lib:cell:view. The initial I/O pins for the soft block are automatically generated and attributes are set as per the .cdsenv environment variables.")
("cphSbDelCovObstruction"
"cphSbDelCovObstruction(
g_cphId
{ g_sbId | l_physLCV }
)
=> t / nil"
"Deletes the cover obstruction that is available on the specified soft block (g_sbId) or physical cellView (l_physLCV). The cover obstruction is removed from the specified layer and all lower layers.")
("cphSbDelIOPin"
"cphSbDelIOPin(
g_cphId
{ g_sbId | l_physLCV }
t_termName
)
=> t / nil"
"Deletes an existing I/O pin from the specified soft block. ")
("cphSbDelIOPinById"
"cphSbDelIOPinById(
g_cphId
x_pinId
)
=> t / nil"
"Deletes an existing I/O pin with the specified unique pinId.")
("cphSbDelObstruction"
"cphSbDelObstruction(
g_cphId
{ g_sbId | l_physLCV }
t_obstructionType
[ ?topOffset  n_topOffset ]
[ ?bottomOffset n_BottomOffset ]
[ ?leftOffset n_LeftOffset ]
[ ?rightOffset n_RightOffset ]
[ ?layerName t_layerName ]
)
=> t / nil"
"Deletes the specified obstruction.")
("cphSbDisplayBoundaryInfo"
"cphSbDisplayBoundaryInfo(
g_cphId
{ g_sbId | l_physLCV }
)
=> t / nil"
"Displays boundary attributes corresponding to the specified soft block")
("cphSbDisplayCovObstructionInfo"
"cphSbDisplayCovObstructionInfo(
g_cphId
g_sbId | l_physLCV 
)
=> t / nil"
"Displays information about the cover obstruction that is available on the specified soft block (g_sbId) or physical cellView (l_physLCV).")
("cphSbDisplayIOPinInfo"
"cphSbDisplayIOPinInfo(
g_cphId
x_pinId
)
=>t / nil"
"Displays all relevant information about the pin that is associated with the specified pin ID.")
("cphSbDisplayObstruction"
"cphSbDisplayObstruction(
g_cphId
{ g_sbId | l_physLCV }
[ ?obsType t_ObstructionType ]
)
=> t / nil"
"Displays information about the specified obstruction.")
("cphSbDisplaySoftBlockAttributes"
"cphSbDisplaySoftBlockAttributes(
g_cphId
l_PhysLCV | g_sbId
)
=> t / nil"
"Displays the block type, type, inherited view list, and stop view list attributes of the specified soft block.")
("cphSbEditIOPin"
"cphSbEditIOPin(
g_cphId
{ g_sbId | l_physLCV }
t_termName
[ ?lpp txl_lpp ]	
[ ?width n_width ]
[ ?height n_height ]
[ ?number x_number ]
[ ?criticality x_criticality ]
[ ?sigType t_sigType ]
)
=> t / nil"
"Edits attributes of existing pins.")
("cphSbEditIOPinById"
"cphSbEditIOPinById(
g_cphId
x_pinId
[ ?lpp txl_lpp ]
[ ?width n_width ]
[ ?height n_height ]
[ ?number x_number ]
[ ?criticality x_criticality ]
[ ?sigType t_sigType ]
)
=> t / nil"
"Edit attributes of the pin with the specified ID.")
("cphSbEditSoftBlockAttributes"
"cphSbEditSoftBlockAttributes(
g_cphId
{ g_sbId | l_physLCV }
[ ?blockType t_blockType ]
[ ?type t_type ]
[ ?viewList t_inhViewList ]
[ ?stopList t_inhStopViewList ]
)
=> t / nil"
"Edits the attributes of the soft block with the specified ID.")
("cphSbGetAllIOPins"
"cphSbGetAllIOPins(
g_cphId
{ g_sbId | l_physLCV }
)
=> l_pinID / nil"
"Retrieves a list of pin IDs corresponding to the specified soft block.")
("cphSbGetFilteredIOPins"
"cphSbGetFilteredIOPins(
g_cphId
{ g_sbId | l_physLCV }
[ ?rexTermName  t_regExpTermName ]
[ ?termType t_termType ]
[ ?lpp    txl_layerPurpose ]
[ ?width n_width ]
[ ?height n_height ]
[ ?number  x_number ]
[ ?criticality x_criticality ]
[ ?sigType t_sigType ]
)
=> l_pinIds / nil"
"Filters pins as per the given arguments and through regular expressions, and returns a list of pin IDs of all the filtered pins.")
("cphSbGetIOPinId"
"cphSbGetIOPinId(
g_cphId
{ g_sbId | l_physLCV }
t_termName
)
=> x_pinId / nil"
"Returns the pin ID of the soft block corresponding to the specified terminal name.")
("cphSbGetIOPinName"
"cphSbGetIOPinName(
g_cphId
x_pinID
)
=> l_termNameAndsoftBlockName / nil"
"Retrieves the I/O pin name corresponding to the specified pin ID.")
("cphSbGetSoftBlockId"
"cphSbGetSoftBlockId(
g_cphId
t_PhysLibName
t_PhysCellName
t_PhysViewName
)
=> x_softBLockId / nil"
"Returns the ID of the soft block corresponding to the specified physical configuration ID and physical lib:cell:view")
("cphSbGetSoftBlocks"
"cphSbGetSoftBlocks(
g_cphId
)
=> l_softBlockID / nil"
"Returns a list of defined soft blocks corresponding to the g_cphId.")
("cphSbHasCovObstruction"
"cphSbHasCovObstruction(
g_cphId
g_sbId | l_physLCV 
)
=> t / nil"
"Checks for the presence of a cover obstruction on the specified soft block (g_sbId) or physical cellView (l_physLCV).")
("cphSbIsValidIOPin"
"cphSbIsValidIOPin(
g_cphId
x_pinId
)
=> t / nil"
"Checks if the pin with the specified pin ID exists or not.")
("cphSbLoadSoftBlocks"
"cphSbLoadSoftBlocks(
g_cphId
t_fileName
)
=> t / nil"
"Loads soft block data from the specified floorplan property file. In case of duplicate soft blocks data entries in the file, the function only considers the first data entry, and ignores subsequent duplicate entries.")
("cphSbRemoveSoftBlock"
"cphSbRemoveSoftBlock(
g_cphId
g_sbId
)
=> t / nil"
"Removes the soft block that is associated with the specified ID.")
("cphSbSaveSoftBlocks"
"cphSbSaveSoftBlocks(
g_cphId
t_fileName
[ ?mode t_fileMode ]
)
=> t / nil"
"Saves soft block data to the specified floorplan property file.")
("cphSbSetPolygonalBoundary"
"cphSbSetPolygonalBoundary(
g_cphId
{ g_sbId | l_physLCV }
l_listOfPolygonPoints
)
=> t / nil"
"Sets the boundary attributes of soft blocks that are polygonal in shape. You need to specify the boundary vertices as a list of points or x, y coordinates.")
("cphSbSetRectangularBoundary"
"cphSbSetRectangularBoundary(
g_cphId
{ g_sbId | l_physLCV }
n_width
n_height
)
=> t / nil"
"Sets the soft block rectangular boundary with the specified dimensions.")
("cphSbSetRectangularBoundaryUsingUtil"
"cphSbSetRectangularBoundaryUsingUtil(
g_cphId
l_PhysLCV | g_sbId
n_util
s_mode
[ ?width n_width ]
[ ?height n_height ]
[ ?aspRatio n_aspRatio ]
[ ?area n_area ]
[ ?areaPerGate n_areaPerGate ]
[ ?gateCount x_gateCount ]
[ ?areaEstCallback t_areaEstCallback ]
)
=> t / nil"
"Sets a rectangular boundary for the specified soft block with the specified area utilization. It is mandatory to specify any one of the three optional parameters: width, height, and aspRatio.")
("cphVisitedInstance"
"cphVisitedInstance(
g_physConfigID
)
=> d_instID / nil"
"Returns the database ID of the instance of the occurrence currently being visited.")
("cphVisitedPath"
"cphVisitedPath(
g_physConfigID
)
=> t_path / nil"
"Returns the path to the occurrence currently being visited.")
("cphVisitedSwitchMaster"
"cphVisitedSwitchMaster(
g_physConfigID
)
=> d_logCellviewID / nil"
"Returns the database ID of the switch master cellview for the occurrence currently visited.")
("cphVisitedTarget"
"cphVisitedTarget(
g_physConfigID
)
=> d_logCellviewID / nil"
"Returns the database ID of the logical cellview for the occurrence currently being visited.")
("cphVisitNextNode"
"cphVisitNextNode(
g_physConfigID
)
=> t / nil"
"Moves the visitor to the next occurrence as defined by the start mode specified in cphVisitStart. The start mode defines which nodes are visited, but not order in which they are visited.")
("cphVisitStart"
"cphVisitStart(
g_physConfigID
t_startMode { PHYSICAL_LEAF | LOGICAL_LEAF | HIERARCHY_PHYSICAL_LEAF
	| HIERARCHY_LOGICAL_LEAF }
[ t_path ]
)
=> t / nil"
"Starts a visit at the specified occurrence in the specified mode. The start mode defines which nodes are visited, but does not specify the order in which they are visited.")
("cphVisitStop"
"cphVisitStop(
g_physConfigID
)
=> t |/ nil"
"Stops the visitor currently running in the specified physical configuration.")
("cphDeleteCellVPLGen"
"cphDeleteCellVPLGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Deletes the VPLGen mapped to a specified logical cell in the physical configuration view associated with the given ID. The VPLGen property, parameters, and physical binding are deleted and the VPLGen is removed from disk.")
("cphGetCellVPLGen"
"cphGetCellVPLGen(
g_physConfigID
t_logLib
t_logCell
)
=> t / nil"
"Returns the VPLGen property mapped to a specified logical cell in the physical configuration view associated with the given ID.")
("cphGetCellVPLGenParams"
"cphGetCellVPLGenParams(
g_physConfigID
t_logLib
t_logCell
)
=> t_parameters / nil"
"Returns the VPLGen parameters mapped to a specified logical cell in the physical configuration view associated with the given ID.")
("cphSetCellVPLGen"
"cphSetCellVPLGen(
g_physConfigID
t_logLib
t_logCell
g_boolean
)
=> t / nil"
"Sets the VPLGen property mapped to a specified logical cell in the physical configuration view associated with the given ID. The cell physical binding is set using the logical library name, logical cell name, and view name layout.")
("cphSetCellVPLGenParams"
"cphSetCellVPLGenParams(
g_physConfigID
t_logLib
t_logCell
t_parameters
)
=> t / nil"
"Sets the VPLGen parameters mapped to a specified logical cell in the physical configuration view associated with the given ID.")
("dbIsVPLGen"
"dbIsVPLGen(
d_cellviewID
)
=> t / nil"
"Returns true if the design is a VPLGen.")
("dbRegVPLGenCreateCellName"
"dbRegVPLGenCreateCellName(
s_functionName
)
=> t / nil"
"Registers a SKILL function to create unique cell names for VPLGen core layouts.")
("dbUnregVPLGenCreateCellName"
"dbUnregVPLGenCreateCellName(
)
=> t / nil"
"Unregisters the SKILL function used to generate unique cell names for VPLGen core layouts. Once unregistered, Layout XL uses the default naming convention when creating new VPLGen Pcell instances in the layout view.")
("odcRegBlockage"
"odcRegBlockage( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for blockages. The application must be specified and currently only Layout-XL is supported.")
("odcRegBoundary"
"odcRegBoundary( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for boundaries. The application must be specified and currently only Layout-XL is supported.")
("odcRegCPA"
"odcRegCPA( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for a custom placement area. The application must be specified and currently only Layout-XL is supported.")
("odcRegInstance"
"odcRegInstance( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for instances. The application must be specified and currently only Layout-XL is supported.")
("odcRegisterCustomFunc"
"odcRegisterCustomFunc( 
t_odcObjType
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for the specified object type.")
("odcRegLabel"
"odcRegLabel( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for labels. The application must be specified and currently only Layout-XL is supported.")
("odcRegMarker"
"odcRegMarker( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for markers of type Tool, Short Message, and Severity information. The application must be specified and currently only Layout-XL is supported.")
("odcRegModgen"
"odcRegModgen( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for modgen. The application must be specified and currently only Layout-XL is supported.")
("odcRegPin"
"odcRegPin( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for names and net names of pins. The application must be specified and currently only Layout-XL is supported.")
("odcRegRow"
"odcRegRow( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for rows. The application must be specified and currently only Layout-XL is supported.")
("odcRegRowRegion"
"odcRegRowRegion( 
t_deAppName
t_functionText
) 
=> t / nil"
"(ICADVM20.1 Only) Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for row region in advanced node. The application must be specified. Currently only Layout-XL is supported.")
("odcRegRuler"
"odcRegRow( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for rulers. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapeCircle"
"odcRegShapeCircle( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for circles. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapeDonut"
"odcRegShapeDonut( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for donuts. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapeEllipse"
"odcRegShapeEllipse( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for donuts. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapeMPP"
"odcRegShapeMPP( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for MPPs. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapePath"
"odcRegShapePath( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for paths. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapePathSeg"
"odcRegShapePathSeg( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for pathSegs. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapePolygon"
"odcRegShapePolygon( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for polygons. The application must be specified and currently only Layout-XL is supported.")
("odcRegShapeRect"
"odcRegShapeRect( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for rectangles. The application must be specified and currently only Layout-XL is supported.")
("odcRegTextDisplay"
"odcRegTextDisplay( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for text displays. The application must be specified and currently only Layout-XL is supported.")
("odcRegVia"
"odcRegVia( 
t_deAppName
t_functionText
) 
=> t / nil"
"Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for vias. The application must be specified and currently only Layout-XL is supported.")
("odcRegVirtualFigGroup"
"odcRegVirtualFigGroup(
t_deAppName
t_functionText
)
=> t / nil"
"(ICADVM20.1 Only) Allows you to define a custom SKILL function to specify your own information to be displayed in the Info Balloon box for virtual figGroups. The application must be specified and currently only Layout-XL is supported.")
("leFinishWire"
"leFinishWire(
) 
=> t / nil"
"When the Create Wire command is active, this function uses the point-to-point router to complete the current wire or wires being edited from their current end to the nearest viable target. ")
("leFinishTrunk"
"leFinishTrunk(
) 
=> t / nil"
"When the Create Wire command is active, this function converts the current wire(s) being edited into trunks. It then uses Pin To Trunk routing to completes the connection between the converted trunk(s) and all possible pin targets that are orthogonal to the trunk(s). The default bindkey is 2.")
("leHiAddWireVia"
"leHiAddWireVia( 
[ w_windowId ] 
[ t_defaultTarget ] 
[ g_rotate ] 
) 
=> t / nil"
"When the Create - Wire command is active, this function allows you to place a via on a path or pathSeg or opens the Select Via form and select a via. If w_windowId is not specified, the current window is used.")
("leHiCancelStitch"
"leHiCancelStitch( 
[ w_windowId ]
) 
=> t / nil"
"Cancels the via that is being added in a layout and returns to an active wire editing command, such as Create Wire or Create Bus.")
("leHiCreateGeometricWire"
"leHiCreateGeometricWire( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Create - Shape - Geometric Wire command. You can press F3 to open the Create Geometric Wire form. Using this command, you can create geometric wires comprising of paths or pathSegs and vias outside of routes. If w_windowId is not specified, the current window is used.")
("leHiCreateWire"
"leHiCreateWire( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Create - Wire command in XL. You can press F3 to open the Create Wire form. The command lets you create symbolic wires comprising of pathSegs and vias in routes. If w_windowId is not specified, the current window is used.")
("leHiCreateStrandedWire"
"leHiCreateStrandedWire( 
[ w_windowId ] 
) 
=> t / nil"
"Starts the Create - Stranded Wire command. You can press F3 to open the Create Stranded Wire form. The command lets you create symbolic wires comprising of pathSegs and vias in routes.")
("leHiCreateBus"
"leHiCreateBus( 
) 
=> t / nil"
"Starts the Create - Bus command in XL. You can press F3 to open the Create Bus form. The command lets you create buses.")
("leHiP2P"
"leHiP2P( 
[ w_windowId ] 
) 
=> t / nil"
"Invokes the interactive Point to Point routing command. The Point to Point command is supported only in Layout XL and higher tiers.")
("leHiStitchToLayer"
"leHiStitchToLayer( 
t_layerName 
[ g_rotate ] 
[ w_windowId ]
) 
=> t / nil"
"Inserts a via between the current layer paths segment and the layer name provided in the parameter when the Create Wire or Create Bus command is active.")
("leWECycleControlWire"
"leWECycleControlWire( 
) 
=> t / nil"
"Allows cycling through the extreme and middle control wires in the selected bus during interactive bus editing. This functions runs successfully only when the Create Wire command is active. This function is available only in Layout XL and higher tiers.")
("leWECycleSnap"
"leWECycleSnap( 
) 
=> t / nil"
"Allows cycling of highlight during the Create Wire command through level 1 or top-level pin edges available within the Aperture distance from the cursor. The highlighted edge represents the starting point of wire creation.")
("leWENoSnap"
"leWENoSnap( 
) 
=> t / nil"
"Resets the point of starting wire creation to the current location of the cursor during the Create Wire command.")
("weGatherBusWires"
"weGatherBusWires( 
[ w_windowId ] 
) 
=> t / nil"
"This function is used when the leHiCreateBus command is running. If the gap between the bus wires does not match the minSpacing rule, then the wires are gathered at the minimum spacing. If the wires are already at minSpacing, they will be spread to use the initial gap, which is the gap before executing the weGatherBusWires function.")
("weScaleMagnifierOrIncreaseWidth"
"weScaleMagnifierOrIncreaseWidth( 
[ w_windowId ] 
) 
=> t / nil"
"If the magnifier is opened, it performs a zoom in the magnifier. Else if Create Bus, Create Wire, or Reshape command is being executed, increase the width of the current wire.")
("weScaleMagnifierOrDecreaseWidth"
"weScaleMagnifierOrDecreaseWidth( 
[ w_windowId ] 
) 
=> t / nil"
"If the magnifier is opened, it performs a zoom out in the magnifier. Else if Create Bus, Create Wire, or Reshape command is being executed, decrease the width of the current wire.")
("weGetPathSegWidth"
"weGetPathSegWidth( 
[ g_pathSegId ] 
) 
=> float"
"Automatically handles the sqrt(2) conversion for diagonal path segments when their width is being queried. Unlike dbGetPathSegWidth which returns the value stored in the OpenAccess database for the width of diagonal pathSegs, this API does the sqrt(2) conversion appropriately and return the width value as it appears in the property editor form or object inspector assistant.")
("weSetPathSegWidth"
"weSetPathSegWidth( 
[ g_pathSegId ] 
float value
) 
=> t / nil"
"Automatically handles the sqrt(2) conversion for diagonal pathseg when the width is being changed. In addition, it also supports diagonal pathseg with custom extension and appropriately updates the values when the width is being changed.")
("weCWHoldWidth"
"weCWHoldWidth( 
) 
=> t / nil"
"This function is used for the create wire command when smart snapping is active. The width that is highlighted by smart snapping is used by the next wire that is being created even if the wire is created at another position than the current one.")
("weScrollOrCycleDownWireViaAlignment"
"weScrollOrCycleDownWireViaAlignment( 
[ w_windowId ]
) 
=> t / nil"
"Lets you cycle through the wire and via alignment settings when a via is being dragged in the layout canvas. Else, the weScrollOrCycleDownWireViaAlignment SKILL API scroll down the layout canvas by pressing the Ctrl key and clicking the mouse wheel. This function works only in the Create Bus, Create Wire, and Reshape commands.")
("weScrollOrCycleUpWireViaAlignment"
"weScrollOrCycleUpWireViaAlignment( 
[ w_windowId ]
) 
=> t / nil"
"Lets you cycle through the wire and via alignment settings when a via is being dragged in the layout canvas. Else, the weScrollOrCycleUpWireViaAlignment SKILL API scrolls up the layout canvas by pressing the Ctrl key and clicking the mouse wheel. This function works only in the Create Bus, Create Wire, and Reshape commands.")
("weHiEditBus"
"weHiEditBus( 
[ w_windowId ]
) 
=> t / nil"
"Starts the Edit - Wiring - Bus command in Layout XL and higher tiers. The command lets you edit the width and spacing of bus bits. If no window ID is specified, the current window is used.")
("weHiInteractiveRouting"
"weHiInteractiveRouting(
[ w_windowId ]
) 
=> t / nil"
"Maps the function to the leHiCreateGeometricWire (paths mode) SKILL function when the technology file is one of the fabric types, package, module, or board, and the active application is Virtuoso RF. Otherwise, the function is mapped to leHiCreateWire when the technology file is of the fabric type IC or the active application is not Virtuoso RF.")
("weHiWireTo45"
"weHiWireTo45( 
[ w_windowId ]
) 
=> t / nil"
"Starts the interactive command that lets you select wire corners to create chamfering.")
("weAddCustomTransitionMenuItem"
"weAddCustomTransitionMenuItem(
t_name
t_customTransition
[ t_bindkey ]
)
=> t / nil"
"Adds a menu item to the context-sensitive menu of the Create Bus command. You can use the added menu item to call the customer SKILL API. A bindkey is also assigned to the menu item.")
("weRemoveCustomTransitionMenuItem"
"weRemoveCustomTransitionMenuItem(
t_name
)
=> t / nil"
"Removes a custom transition menu item from the Create Bus context-sensitive menu.")
("weGetCustomTransitionMenuItems"
"weGetCustomTransitionMenuItems(
)
=> t / nil"
"Returns a list of custom transitions that were added to the Create Bus context-sensitive menu.")
("weCycleCutColorVia"
"weCycleCutColorVia(
)
=> t / nil"
"(ICADVM20.1 Only) Cycles color of each cut when a via is inserted.")
("weHiCycleViaDefDown"
"weHiCycleViaDefDown(
)
=> t_viaDefName / nil"
"Returns the current via definition for the pending vias when you start either the Create Wire, Create Stranded Wire, or the Create Bus command.")
("weHiCycleViaDefUp"
"weHiCycleViaDefUp(
)
=> t_viaDefName / nil"
"Automatically cycles up the via definition for the pending vias, while using the Create Wire, Create Stranded Wire, or the Create Bus command.")
("weCyclePatternGravityLayerTransitionType"
"weCyclePatternGravityLayerTransitionType(
)
=> t_patternGravityLayerTransitionType / nil"
"In a WSP design, the wires are snapped to the layer up or down WSPs, which is the default behavior. However, if you want the wire only to snap to layer up or layer down a WSP, then you can use the patternGravityLayerTransitionType environment variable to cycle the layer for snapping. The environment variable has three values: patternGravityLayerUp, patternGravityLayerDown, and patternGravityLayerAny. The default value is patternGravityLayerAny.")
("weGetAdjustedWidthForTracks"
"weGetAdjustedWidthForTracks( 
d_cellViewId
l_layerNum
l_purposeNum
l_direction
l_dimension
l_coordinates [ x_coord y_coord ]
)
=> l_trackInfo / nil"
"Returns the Width Spacing Pattern (WSP) track information based on the inputs specified, such as layers, purposes, preferred directions, and shape dimensions, at a specific location.The purpose of the function is to check whether or not there are tracks at the given location.")
("sltSetContextSpecificationCells"
"sltSetContextSpecificationCells(
l_contextSpecificationCells
)
=> t / nil"
"Defines a list of contexts for slotting. A slotting context has a name and an associated slotting specification cell in the format library/cell/view.")
("drdAddTarget"
"drdAddTarget( 
w_winID
l_point
) 
=> t / nil"
"Sets the shape located at the specified point in the specified window as a DRD target. The function does not remove from the selection the shapes already set as DRD targets. If two or more shapes overlap at the specified point, the shape on the active layer is set as a DRD target.")
("drdBatchCheck"
"drdBatchCheck( 
d_cellViewID 
[ l_bBox ]
) 
=> t / nil"
"Runs DRD checker on the specified area of the specified cellview. The hierarchy depth and batch checking rules specified in the DRD Options form are honored. Use this function to run a DRD check on read-only cellviews to view any DRC violations as warning messages in CIW.")
("drdBatchCheckLicenseAvailable"
"drdBatchCheckLicenseAvailable( 
[ x_timeToWaitInSeconds ]
) 
=> t / nil"
"Checks whether a Layout XL license is available. If the license is available, the function returns t. If the license is unavailable, it attempts to check out the license. If the attempt is successful, it checks the license back in and returns t.")
("drdCheckedConstraintGroupItem"
"drdCheckedConstraintGroupItem( 
t_CategoryName
x_toggleValue
w_windowId
) 
=> t / nil"
"Toggles the state of a constraint category in the Constraint Category column on the Filters tab of the DRD Options form.")
("drdCheckedLayerGroupItem"
"drdCheckedLayerGroupItem( 
t_layerCategoryName
x_toggleValue
w_windowId
) 
=> t / nil"
"Toggles the state of a layer category in the Layer Category column on the Filters tab of the DRD Options form.")
("drdCompactObjects"
"drdCompactObjects( 
{ s_direction | 'target | 'anchor l_targets }
l_figs
[ 'useSameMaskSpacingOnly ]
[ 'useUserSpacingOnly ]
[ 'compact | 'compactAndSpread | 'spread ]
) 
=> t / nil"
"Compacts the specified objects in accordance with the relevant spacing rules.")
("drdCompactorOptions"
"drdCompactorOptions(
)
=> t / nil"
"Displays the DRD Compactor Options form, in which you can set the options for compacting and spreading objects.")
("drdCompactSelSet"
"drdCompactSelSet( 
{ s_direction | 'target | 'anchor l_targets }
[ w_winID ]
[ d_cellViewID ]
[ 'useSameMaskSpacingOnly ]
[ 'useUserSpacingOnly ]
[ 'compact | 'compactAndSpread | 'spread ]
) 
=> t / nil"
"Compacts objects in the selected set in accordance with the relevant spacing rules.")
("drdConstraintGroupHeaderClicked"
"drdConstraintGroupHeaderClicked( 
x_columnIndex
w_windowId
) 
=> t / nil"
"Changes the state of the check boxes for all the categories listed in the Constraint Category column on the Filters tab of the DRD Options form.")
("drdConstraintHeaderClicked"
"drdConstraintHeaderClicked( 
x_columnIndex
w_windowId
) 
=> t / nil"
"Changes the state of the check boxes for all the constraints listed in the Constraint column or sorts the constraints alphabetically, on the Filters tab of the DRD Options form.")
("drdConstraintItemClicked"
"drdConstraintItemClicked(
t_constraintName
x_columnIndex
x_stateValue
w_windowId
) 
=> t / nil"
"Toggles the state of a constraint for different checking modes, that is, Enforce, Notify, Post-Edit, and Batch, on the Filters tab of the DRD Options form.")
("drdEnablePixelThreshold"
"drdEnablePixelThreshold( 
g_enable
) 
=> t / nil"
"Enables a pixel threshold. When you move an object toward another object and you cross this pixel threshold, the object being moved is automatically snapped to the closest edge of the DRC halo or the target object, if DRD Smart Snap mode is enabled. You can disable this pixel threshold to temporarily disable smart snapping during interactive editing.")
("drdGetAllowedWidth"
"drdGetAllowedWidth(
d_objID
t_layerName
[ ?constraintGroup t_constrGroupName ]
[ ?direction { any | horizontal | vertical } ]
[ ?upperLimit f_maxValue ]
)
=> l_integers / nil"
"(ICADVM20.1 Only) Returns a list of allowed widths for the specified layer.")
("drdGetMinSpacing"
"drdGetMinSpacing(
d_techID
t_layerName
[ ?constraintGroup t_constrGroupName ]
[ ?width1 f_width1Val ]
[ ?width2 f_width2Val ]
[ ?prl f_prlVal ]
[ ?direction { any | horizontal | vertical } ]
[ ?sameMask { 0 | 1 } ]
)
=> f_minSpaceVal / nil"
"Returns the minimum spacing value defined by the minSpacing (One layer) constraint for the specified layer, based on the specified width, parallel run length (prl), direction, and mask values.")
("drdGetMinSpanLengthSpacing"
"drdGetMinSpanLengthSpacing(
d_techID
t_layerName
[ ?constraintGroup t_constrGroupName ]
[ ?span f_spanVal ]
[ ?prl f_prlVal ]
[ ?direction { any | horizontal | vertical } ]
[ ?sameMask { 0 | 1 } ]
)
=> f_minSpanSpaceVal / nil"
"Returns the minimum span length spacing value defined by the minSpanLengthSpacing constraint for the specified layer, based on the specified span, parallel run length (prl), direction, and mask values.")
("drdGetMinVoltageSpacing"
"drdGetMinVoltageSpacing(
d_techID
t_layerName
[ ?constraintGroup t_constrGroupName ]
[ ?voltage1 f_voltage1Val ]
[ ?voltage2 f_voltage2Val ]
)
=> f_minVolSpaceVal / nil"
"Returns the minimum voltage-dependent spacing value defined by the minVoltageSpacing (One layer) constraint for the specified layer based on the specified voltages. The voltage difference is calculated as the absolute difference of the two input voltages, which correspond to the voltages set on the two objects for which you want to retrieve the minimum spacing.")
("drdLayerGroupHeaderClicked"
"drdLayerGroupHeaderClicked( 
x_columnIndex
w_windowId
) 
=> t / nil"
"Changes the state of the check boxes for all the layer categories listed in the Layer Category column on the Filters tab of the DRD Options form.")
("drdLayerHeaderClicked"
"drdLayerHeaderClicked( 
x_columnIndex
w_windowId
) 
=> t / nil"
"Changes the state of the check boxes for all the layers listed in the Layer column or sorts the layers alphabetically, on the Filters tab of the DRD Options form.")
("drdLayerItemClicked"
"drdLayerItemClicked(
t_layerName
x_columnIndex
x_stateValue
w_windowId
) 
=> t / nil"
"Toggles the state of a layer on the Filters tab of the DRD Options form.")
("drdIsPixelThresholdEnabled"
"drdIsPixelThresholdEnabled(
)
=> t / nil"
"Indicates whether the pixel threshold is enabled or disabled.")
("drdListConstraintCategoryRules"
"drdListConstraintCategoryRules(
[ ?cv d_cellViewID ]
[ ?outputFile s_fileName ]
[ ?active { t | nil } ]
[ ?splitTF { t | nil } ]
[ ?csv { t | nil } ]
)
=> t / nil"
"Lists constraints supported by DRD in the version of the software that is currently running. The constraints' information can be saved in an ASCII file or listed in CIW, in a tabular format or as a comma-separated list.")
("drdOptionsSet"
"drdOptionsSet( 
t_fieldName
g_state
) 
=> t / nil"
"Sets default states for fields in the configuration file for the DRD Options form.")
("drdOptionUpdateConstraint"
"drdOptionUpdateConstraint( 
l_modeCategories
l_constraints
g_state
) 
=> t / nil"
"Sets the default state for specified constraints and modes in the configuration file for the Filters tab of the DRD Options form. DRD checks the layout against the specified constraints.")
("drdOptionUpdateLayer"
"drdOptionUpdateLayer( 
l_layers
g_state
) 
=> t / nil"
"Sets the default state for specified layers in the configuration file for the Filters tab of the DRD Options form. DRD checks the layout against the specified layers.")
("drdRemoveTarget"
"drdRemoveTarget( 
w_winID
l_point
) 
=> t / nil"
"Unsets a DRD target that exists at the specified point in the specified window. If multiple DRD targets overlap at the specified point, the DRD target on the active layer is unset.")
("drdSelectConstraintGroupItem"
"drdSelectConstraintGroupItem(
t_constraintCategoryName
x_selectIndex
w_windowId
) 
=> t / nil"
"Selects the constraint category in the Constraint Category column and displays the corresponding constraints in the Constraint column on the Filters tab of the DRD Options form.")
("drdSelectLayerGroupItem"
"drdSelectLayerGroupItem(
t_layerCategoryName
x_selectIndex
w_windowId
) 
=> t / nil"
"Selects the layer category in the Layer Category column and displays the corresponding layers in the Layer column on the Filters tab of the DRD Options form.")
("drdToggleSmartSnapMode"
"drdToggleSmartSnapMode(
) 
=> t / nil"
"Freezes DRC halos, which helps snap objects to the closest edge of the halo or the object.")
("drdToggleSmartSnapModeForDiscreteSpacing"
"drdToggleSmartSnapModeForDiscreteSpacing(
) 
=> t / nil"
"(ICADVM20.1 Only) Freezes discrete spacing markers, which helps snap objects to the closest marker.")
("drdVerifySelSet"
"drdVerifySelSet(
[ d_cellViewID ]
) 
=> ld_dbIDs / 0 / -1"
"Checks the objects selected in the specified design for rule violations and generates a marker for each rule violation found. If a design is not specified, it checks the objects selected in the design open in the current window.")
("leHiBatchChecker"
"leHiBatchChecker( 
[ w_winID ] 
) 
=> t / nil"
"Opens the Batch Checker form.")
("leToggleDrdMode"
"leToggleDrdMode(
)
=> t"
"Cycles through DRD modes: Off, Notify, Enforce, and Enforce and Notify.")
("mptActivate"
"mptActivate(
g_activate 
)
=> t / nil"
"(ICADVM20.1 Only) Specifies whether to switch the Virtuoso Multi-Patterning Technology coloring engine ON or OFF.")
("mptCheckFlow"
"mptCheckFlow(
t_flowName
)
=> t / nil"
"(ICADVM20.1 Only) Checks the flow settings by loading the check procedure of the specified flow or by comparing the current value of the related environment variables against the environment variables set by the set procedure of the flow.")
("mptCheckHierarchicalLocks"
"mptCheckHierarchicalLocks(
d_cellViewID 
)
=> t / nil"
"(ICADVM20.1 Only) Performs a check for hierarchical color lock (HCL) conflict in the cellview.")
("mptCleanClusters"
"mptCleanClusters(
d_cellViewID 
)
=> t / nil"
"(ICADVM20.1 Only) Cleans out-of-date cluster information in the cellview which can help to reduce the design size and/or improve performance.")
("mptColorRemastering"
"mptColorRemastering(
d_cellViewID 
?mode t_mode 
[ ?mappingFile t_mappingFile ]
[ ?fromView t_fromView ]
[ ?toView t_toView ]
[ ?invalidMappingWord t_invalidMappingWord ]
)
=> t / nil"
"(ICADVM20.1 Only) Remasters color-shifted abstract views to corresponding layout views or color-shifted layout views to abstract views.")
("mptDeleteClusters"
"mptDeleteClusters(
d_cellViewID 
[ ?layers l_layers ]
[ ?checkOnly g_checkOnly ]
[ ?thruHierarchy g_thruHierarchy ]
[ ?openForEdit g_openForEdit ]
)
=> t / nil"
"(ICADVM20.1 Only) Removes coloring clusters in the specified cellview.")
("mptDefineFlow"
"mptDefineFlow(
t_flowName
s_setFunction
[ s_checkFunction ]
)
=> t / nil"
"(ICADVM20.1 Only) Registers a flow by linking the flow name to a set and a check procedure. If the check procedure is not defined, the check defined in the cdsenv file is run. This function checks the environment variables defined in the set function against their current values.")
("mptDoColorChecks"
"mptDoColorChecks(
d_cellViewID 
l_layers 
l_region
g_doColorShorts
g_doUncoloredShapes
g_doUnlockedShapes
g_doColorability
)
=> t / nil"
"(ICADVM20.1 Only) Performs coloring checks in the specified cellview.")
("mptDoToolbarAction"
"mptDoToolbarAction(
g_toolbarFunc
)
=> t / nil"
"(ICADVM20.1 Only) Runs the specified Multiple Patterning toolbar function.")
("mptGetColoredPurposes"
"mptGetColoredPurposes(
d_cellViewID 
)
=> l_lpp / nil"
"(ICADVM20.1 Only) Returns a list of the colored layer purpose pairs for the cellview.")
("mptGetColorShiftingLayers"
"mptGetColorShiftingLayers(
d_cellViewID 
)
=> l_layers / nil"
"(ICADVM20.1 Only) Returns a list of valid shifting layers set by the environment variable, colorShiftingLayers.")
("mptGetDefaultColoringMethod"
"mptGetDefaultColoringMethod(
)
=> t_coloringMethod"
"(ICADVM20.1 Only) Returns the session default coloring method that was set using mptSetDefaultColoringMethod.")
("mptGetFlowNames"
"mptGetFlowNames(
)
=> l_flowName"
"(ICADVM20.1 Only) Lists all available flow names that have been defined. It includes pre-defined and custom flow names.")
("mptGetFlowSettings"
"mptGetFlowSettings(
t_flowName
)
=> t"
"(ICADVM20.1 Only) Reports, the procedure used to set a flow, in the CIW and output.")
("mptGetLayerColoringMethod"
"mptGetLayerColoringMethod(
d_cellViewID 
[ t_layerName ] 
)
=> t_coloringMethod / t_SDLcolorMethod / nil"
"(ICADVM20.1 Only) Returns either the coloring method for the given layer, or the coloring method for the session, the design, and layers with a specified coloring method.")
("mptGetLayerDefaultColor"
"mptGetLayerDefaultColor(
d_techFileID 
[ t_layerName ] 
)
=> t_color / l_layerColor / nil"
"(ICADVM20.1 Only) Returns either the default color for the given layer, or a list of layer-default color pairs.")
("mptGetLockDefaultColors"
"mptGetLockDefaultColors(
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the layer default color specified by mptSetLayerDefaultColor will be locked when assigned to a shape.")
("mptGetOutdatedDesigns"
"mptGetOutdatedDesigns(
d_cellViewID
[ t_mode ]
)
=> l_outdated / nil"
"(ICADVM20.1 Only) Returns a list of the cellviews in the design hierarchy for which the color information is outdated. The list can optionally specify the outdated layers for each cellview in the returned list.")
("mptGetTrackPatternPattern"
"mptGetTrackPatternPattern(
d_trackPatternID
)
=> l_colorPattern / nil"
"(ICADVM20.1 Only) Returns a list of the color patterns for the specified track pattern.")
("mptGetUpToDateDesigns"
"mptGetUpToDateDesigns(
d_cellViewID
)
=> l_upToDate / nil"
"(ICADVM20.1 Only) Returns a list of the cellviews in the hierarchy for which the color information is up to date.")
("mptHiStitch"
"mptHiStitch(
)
=> nil"
"(ICADVM20.1 Only) Enables stitch mode to fix odd loop color violations by breaking shapes into two overlapping (stitched) shapes. The first click in the layout selects the shape to be stitched, and the second click sets the stitch location.")
("mptHiUnStitch"
"mptHiUnStitch(
)
=> nil"
"(ICADVM20.1 Only) Enables unstitch mode to revert stitches that were created while in stitch mode (enabled by mptHiStitch). Click a stitched shape in the layout to remove the stitch.")
("mptIsMaskColorShown"
"mptIsMaskColorShown(
t_layerName 
x_maskNumber 
)
=> t / nil"
"(ICADVM20.1 Only) Checks whether the specified mask color is visible for the layer.")
("mptLPPMergeToColor"
"mptLPPMergeToColor(
d_cellviewID
g_libName
g_viewName
l_mapping
[ g_colorState ]
)
=> t / nil"
"(ICADVM20.1 Only) Converts the layout into Virtuoso multi-pattern conformance format for designs that use two or more separate layer-purpose pairs to represent multi-patterning mask information, so that Virtuoso coloring engine can perform further operations on it. You can choose to write the conversion result into a different library or/and a different view. In this case, new cells with the same cell name and the library or/and view name that you specify are used. The original cell is not changed. If you choose to write the result to the same cell, the original layer-purpose pair data is removed. This function is performed on the entire hierarchy starting from the specified cell.")
("mptLockAll"
"mptLockAll(
d_cellViewID 
[ l_layerNames ] 
)
=> t / nil"
"(ICADVM20.1 Only) Locks all the top-level shapes of the specified cellview with their current color. You can optionally lock only the shapes on specific colorable layers. Gray color shapes are not locked.")
("mptMarkersToColoredBlockages"
"mptMarkersToColoredBlockages(
l_purposes
d_cellViewID
)
=> t / nil"
"(ICADVM20.1 Only) Transforms the shapes on the specified purposes of the colored layers in the given cellview to colored blockages on the same layer. This function works hierarchically on a layout.")
("mptMarkersToMaskColors"
"mptMarkersToMaskColors(
l_purposes 
g_drawingPurpose 
d_cellViewID 
[ g_locked ]
[ g_removeMarker ]
[ g_recolorAll ]
[ g_save ]
)
=> t / nil"
"(ICADVM20.1 Only) Transforms the shapes in the given cellview to the drawing purpose and assigns color to each shape based on its original marker purpose. This function works hierarchically on a layout. By default, the assigned color is locked and the marker purpose shapes are removed.")
("mptPropagateLocks"
"mptPropagateLocks(
[ d_cellviewID ]
[ g_convertGroups ] 
)
=> t / nil"
"(ICADVM20.1 Only) Propagates all the locks visible from the top level to connected shapes through the hierarchy.")
("mptPropagateSameMaskGroups"
"mptPropagateSameMaskGroups(
d_cellViewID 
)
=> t / nil"
"(ICADVM20.1 Only) Propagates same mask groups in the given cellview through the hierarchy. This should be run following top-level editing of designs with same mask groups. This ensures that shapes in the hierarchy that are connected to same mask group shapes are included in that mask group.")
("mptPurgePcell"
"mptPurgePcell(
)
=> t / nil"
"(ICADVM20.1 Only) Removes the color of Pcell or express Pcell colored by the coloring engine. Pcells are purged and the cache of the purged express Pcell is deleted. This is performed hierarchically. Before the color is removed, the coloring engine is deactivated to prevent recoloring of Pcells.")
("mptReColor"
"mptReColor(
d_cellViewID 
[ l_layers ]
[ g_depth ] 
)
=> t / nil"
"(ICADVM20.1 Only) Rebuilds the color information for the cellview from the bottom hierarchically, according to the specified depth and layers.")
("mptReColorFromShapes"
"mptReColorFromShapes(
l_shapes 
)
=> t / nil"
"(ICADVM20.1 Only) Recolors the shapes in the list and the shapes that are connected to them. If the coloring method is colorSpacing, the color of the shapes that are within the same-mask spacing of the shapes in the list will be updated, according to the clustering algorithm described in Automatic Color Shifting in Virtuoso Multiple Patterning Technology User Guide.")
("mptReColorWsp"
"mptReColorWsp(
d_cellViewID 
[ ?layers l_layers ]
[ ?region l_bBox ]
[ ?grayShapeOnly g_grayShapeOnly ]
[ ?trackPatterns l_trackPatterns ]
[ ?shapes l_shapes ]
[ ?checkWidth g_checkWidth ]
)
=> l_coloredShapes / nil"
"(ICADVM20.1 Only) Recolors shapes based on the color of WSPs only.")
("mptReconstructStitch"
"mptReconstructStitch(
d_cellViewID 
[ t_purposeName ]
)
=> t / nil"
"(ICADVM20.1 Only) Reconstructs stitches by creating stitch pairs from overlapping shapes on the specified purpose.")
("mptReportCurrentSettings"
"mptReportCurrentSettings(
d_cellViewID 
[ t_fileName ]
g_reportDesign
)
=> t / nil"
"(ICADVM20.1 Only) Reports MPT flow settings.")
("mptSetDefaultColoringMethod"
"mptSetDefaultColoringMethod( 
t_coloringMethod 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the session default coloring method.")
("mptSetFlow"
"mptSetFlow(
t_flowName
)
=> t"
"(ICADVM20.1 Only) Applies the flow settings by loading the procedure linked to the flow name.")
("mptSetLayerColoringMethod"
"mptSetLayerColoringMethod( 
{ d_cellViewID | d_techID } 
l_layers 
t_coloringMethod 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the default coloring method for the technology database, the design, or specified layers in the design.")
("mptSetLayerDefaultColor"
"mptSetLayerDefaultColor(
d_techFileID 
t_layerName 
t_color 
)
=> t / nil"
"(ICADVM20.1 Only) Sets the default color for a layer. This color will be assigned to newly created shapes and vias on the layer, and to gray shapes and vias on the layer when recoloring the design. The color will also be used to initialize the active color for this layer in the Palette.")
("mptSetLockDefaultColors"
"mptSetLockDefaultColors(
g_lock 
)
=> t / nil"
"(ICADVM20.1 Only) Specifies whether the layer default color specified by mptSetLayerDefaultColor will be locked when assigned to a shape.")
("mptSetTrackPatternPattern"
"mptSetTrackPatternPattern(
d_trackPatternID
l_colorPattern
)
=> t / nil"
"(ICADVM20.1 Only) Specifies the color pattern for the track pattern.")
("mptSetupComplianceChecker"
"mptSetupComplianceChecker( 
dbObject 
[ x_startLevel ]
[ x_stopLevel ]
)
=> t / nil"
"(ICADVM20.1 Only) Flags any objects that are not aligned with the current MPT setup.")
("mptShowMaskColor"
"mptShowMaskColor(
t_layerName 
x_maskNumber 
g_toShow 
)
=> t / nil"
"(ICADVM20.1 Only) Shows or hides the color for the specified mask on the given layers.")
("mptUnlockAll"
"mptUnlockAll(
d_cellViewID 
[ l_layerNames ] 
)
=> t / nil"
"(ICADVM20.1 Only) Unlocks all the colored shapes that are locked at the top level of the specified cellview. You can optionally unlock only the shapes on specific colorable layers. Top-level shapes with color attribute locks (dbLocks) are unlocked with their current color. Hierarchical color locks at the current editing hierarchy level are removed.")
("mptUnpropagateLocks"
"mptUnpropagateLocks(
d_cellViewID 
[ l_layerNames ] 
)
=> t / nil"
"(ICADVM20.1 Only) Removes the system locks created by the propagate locks command.")
("mptUpdateColor"
"mptUpdateColor(
d_cellViewID 
[ l_layers ]
[ g_depth ] 
)
=> t / nil"
"(ICADVM20.1 Only) Updates the color information from the bottom hierarchically, according to the specified depth and layers. This is useful when the color engine has been switched off/on, or a third party tool has been used to modify color information, leaving color information in an out-of-date state.")
("abeBlockagesFromCellView"
"abeBlockagesFromCellView(
t_layerName
o_outLayer
g_queue
)
=> o_abeLayer / nil"
"Copies blockages from the specified layer in the current ABE session cellview, to a new ABE layer or, optionally, an existing ABE layer. Optional arguments restrict the copied blockages to the specified ABE layer. This function can be run immediately or added to the queue.")
("abeBoundariesFromCellView"
"abeBoundariesFromCellView(
o_outLayer	
g_queue	
)
=> o_abeLayer / nil"
"Copies the boundaries from the current ABE session cellview to a new ABE layer or, optionally, an existing ABE layer. Optional arguments restrict the copied boundaries to a specified layer. This function can be run immediately or added to the queue.")
("abeClearLayer"
"abeClearLayer(
o_abeLayer 
)
=> t / nil"
" Removes all the shapes on the ABE layer and frees the memory. This is useful for re-using ABE layers.")
("abeDone"
"abeDone(
)
=> t / nil"
" Closes the current ABE session and frees all the memory that was used by ABE.")
("abeElapsedTime"
"abeElapsedTime(
[ ?reset g_reset ]
)
=> g_time"
"Returns the elapsed time for the current ABE session.")
("abeInit"
"abeInit(
d_cellViewId 
[ ?doInterrupts g_interrupts ] 
[ ?depth g_depth ] 
[ ?threads g_threadCount ] 
)
=> t / nil"
"Initializes an ABE session for the specified cellview. The ABE elapsed time clock is set to zero.")
("abeIslandIterator"
"abeIslandIterator(
o_abeLayer 
[ ?noHoles g_noHoles ] 
)
=> o_islandIter / nil"
"Returns the island iterator for the rectangles and polygons on the ABE layer. Each entry is a list of points for a shape on the ABE layer.")
("abeLayerAbut"
"abeLayerAbut(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue] 
)
=> t / nil"
"Adds shapes to the ABE output layer for ABE layer1 shapes that abut with shapes on ABE layer2.")
("abeLayerAnd"
"abeLayerAnd(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes to the ABE output layer where shapes on ABE layer1 overlap shapes on ABE layer2.")
("abeLayerAndNot"
"abeLayerAndNot(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes to the ABE output layer where shapes on layer1 do not overlap shapes on layer2.")
("abeLayerAvoid"
"abeLayerAvoid(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes on the output layer for shapes on layer1 that are completely outside of, and have no abutting edges with, shapes on layer2.")
("abeLayerFromCellView"
"abeLayerFromCellView(
t_layerName 
[ ?bbox l_bbox ] 
[ ?bBox l_bBox ]
[ ?purpose t_purposeName ] 
[ ?excludePurpose l_purposeName ]
[ ?outLayer o_abeOutputLayer [ ?queue g_queue ] ]
[ ?maskColor g_maskColor ] 
[ ?startLevel g_startLevel ]
[ ?stopLevel g_stopLevel ] 
[ ?orientation g_orientation ]
)
=> o_abeLayer / nil"
"Copies the shapes from the specified layer in the current ABE session cellview to a new ABE layer or, optionally, an existing ABE layer. Optional arguments restrict the copied shapes to a specific area, purpose, mask color, or hierarchical depth. This function can be run immediately or added to the queue.")
("abeLayerFromFigSet"
"abeLayerFromFigSet(
t_figSet 
[ ?outLayer o_abeOutputLayer ] 
)
=> o_abeLayer / nil"
"Adds the shapes from a FigSet to an existing ABE layer or a new ABE layer.")
("abeLayerFromNet"
"abeLayerFromNet(
t_layerName 
t_netName
[ ?outLayer o_abeOutputLayer ] 
)
=> o_abeLayer / nil"
"Adds the shapes from a net to an existing ABE layer or a new ABE layer. Logical connectivity is not preserved and therefore cannot be restored if the shapes are written back to the ABE session cellview.")
("abeLayerFromShapes"
"abeLayerFromShapes(
l_shapeObj 
)
=> o_abeLayer / nil"
"Creates an ABE layer with shapes from the given list.")
("abeLayerGrow"
"abeLayerGrow(
o_abeInputLayer 
o_abeOutputLayer 
[ ?north g_sizeNorth ] 
[ ?south g_sizeSouth ] 
[ ?east g_sizeEast ] 
[ ?west g_sizeWest] 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes to the ABE output layer that are ABE input layer shapes that have been increased in size along one or more directions in the north, south, east, and/or west.")
("abeLayerInside"
"abeLayerInside(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds ABE layer1 shapes that are completely inside an ABE layer2 shape to the ABE output layer. Coincident edges are considered inside. Partially overlapping shapes are excluded.")
("abeLayerMergeTiles"
"abeLayerMergeTiles(
i_abeLayer
t_orientation
[ ?queue { t | nil } ] 
=> o_outputLayer / nil"
"Uses an existing ABE layer to recreate maximum tiles based on the specified orientation.")
("abeLayerOr"
"abeLayerOr(
o_abeInputLayer 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes from the input ABE layer to the ABE output layer.")
("abeLayerOrPtArray"
"abeLayerOrPtArray(
l_pointArray 
o_abeOutputLayer 
)
=> t / nil"
"Adds a polygon that is represented by a list of points to the ABE output layer.")
("abeLayerOutside"
"abeLayerOutside(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds to the ABE output layer the ABE layer1 shapes that are completely outside the ABE layer2 shapes. Coincident edges are considered outside. Partially overlapping shapes are excluded.")
("abeLayerShrink"
"abeLayerShrink(
o_abeInputLayer 
o_abeOutputLayer 
[ ?north g_sizeNorth ] 
[ ?south g_sizeSouth ] 
[ ?east g_sizeEast ] 
[ ?west g_sizeWest] 
[ ?queue g_queue ] 
)
=> t / nil"
"Decreases the size of shapes from the input ABE layer and outputs them to the ABE output layer. Shapes can be reduced by different distances in the north, south, east, and west directions.")
("abeLayerSize"
"abeLayerSize(
o_abeInputLayer 
o_abeOutputLayer 
g_size 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds shapes that have been increased or decreased in size from the ABE input layer to the ABE output layer.")
("abeLayerStraddle"
"abeLayerStraddle(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds the ABE layer1 shapes that partially overlap an ABE layer2 shape to the ABE output layer.")
("abeLayerToBlockages"
"abeLayerToBlockages(
o_abeInputLayer 
t_layerName 
[ ?maskColor g_maskColor ] 
[ ?blockageType g_blockageType ] 
[ ?tiles g_tiles 
| ?noHoles g_noHoles ] 
)
=> t / nil"
"Adds shapes as blockage objects from the ABE layer to the specified layer. Optional arguments specify a mask color and blockage type for the blockage objects, whether the shapes are copied without holes, and whether shapes are copied as tiles instead of islands.")
("abeLayerToCellView"
"abeLayerToCellView(
o_abeLayer 
t_layerName 
[ ?tiles g_tiles 
| ?noHoles g_noHoles ] 
[ ?purpose t_purposeName ] 
[ ?maskColor g_maskColor ] 
[ ?cell t_cellName ]
[ ?view t_viewName ] 
[ ?cvId d_cellviewID ] 
[ ?shapeIds { t | nil} } (2031625)
)
=> l_shapeIDs / t / nil"
"Copies shapes from the ABE layer to the specified layer in the current ABE session cellview. Optional arguments specify the layer purpose, whether the shapes are copied without holes, and whether the shapes are copied as islands instead of primitive tiles.")
("abeLayerToHilightSet"
"abeLayerToHilightSet(
o_abeInputLayer 
h_hilightSetId 
[ ?tiles g_tiles 
| ?noHoles g_noHoles ] 
)
=> t / nil"
"Adds the rectangles and polygons on the specified ABE layer to the specified highlight set. Optional arguments specify whether the shapes are copied without holes, and whether the shapes are copied as primitive tiles instead of islands.")
("abeLayerTouch"
"abeLayerTouch(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
[ ?includeCorners g_includeCorners ] 
)
=> t / nil"
"Adds the ABE layer1 shapes that touch (completely overlap, partially overlap, or abut) an ABE layer2 shape to the ABE output layer.")
("abeLayerXor"
"abeLayerXor(
o_abeLayer1 
o_abeLayer2 
o_abeOutputLayer 
[ ?queue g_queue ] 
)
=> t / nil"
"Adds rectangles and polygons to the ABE output layer where ABE layer1 shapes and ABE layer2 shapes do not overlap.")
("abeMTdebug"
"abeMTdebug(
o_abeLayer 
)
=> t / nil"
"Enables the output of additional messages to monitor progress when multithreading is used.")
("abeNewLayer"
"abeNewLayer(
)
=> o_abeLayer / nil"
"Creates a new ABE layer.")
("abeRemoveLayer"
"abeRemoveLayer(
o_abeLayer 
)
=> t / nil"
"Removes the specified ABE layer.")
("abeRunQueue"
"abeRunQueue(
)
=> t / nil"
"Runs all the ABE operations that are queued for processing.")
("abeShapesInside"
"abeShapesInside(
d_cellViewId 
l_insideShapeObj 
l_outsideShapeObj 
)
=> l_shapeObj / nil"
"Returns a list of shapes from the inside list that are completely inside a shape from the outside list. Coincident edges are considered inside. Partially overlapping shapes are excluded.")
("abeShapesOutside"
"abeShapesOutside(
d_cellViewId 
l_outsideShapeObj 
l_insideShapeObj 
)
=> l_shapeObj / nil"
"Returns a list of shapes from the outside list that are completely outside of shapes from the inside list. Coincident edges are considered outside. Partially overlapping shapes are excluded.")
("abeTileIterator"
"abeTileIterator(
o_abeInputLayer 
[ ?bbox l_bbox ] 
)
=> o_tileIter / nil"
"Returns the tile iterator for the primitive rectangles and polygons on the ABE layer. The iterator can be restricted to a region of the layer.")
("spdCalcOdSpacingWithPoly"
"spdCalcOdSpacingWithPoly(
d_lhsInst
d_rhsInst
n_minOd
n_minPoly
)
=> n_odSpacing"
"(ICADVM20.1 Only) Calculates the required oxide diffusion spacing between two adjacent instances based on minimum oxide diffusion spacing and polysilicon spacing constraints.")
("spdGetAbutName"
"spdGetAbutName(
x_strategy
[ ?libName t_libName ]
)
=> t_abutName / nil"
"(ICADVM20.1 Only) Returns the user abutment name associated with the specified abutment strategy registered using the spdGetUserAbutProc function.")
("spdGetAbutStrategy"
"spdGetAbutStrategy(
t_abutName
[ ?libName t_libName ]
)
=> x_strategy / nil"
"(ICADVM20.1 Only) Returns the abutment strategy associated with the specified user abutment name registered using the spdRegUserAbutProc function.")
("spdGetSymDeviceInfo"
"spdGetSymDeviceInfo(
d_inst
)
=> r_infoObj / nil"
"(ICADVM20.1 Only) Returns an object containing information, such as length, width, fingers, and binding related to the specified symbolic device. This information can be used to write user callback functions.")
("spdGetUserAbutProc"
"spdGetUserAbutProc(
?libName t_libName
)
=> r_infoObj / nil"
"(ICADVM20.1 Only) Returns an object containing the registered user abutment options with associated user callbacks and the description that were registered using the spdRegUserAbutProc function.")
("spdPerformAbutment"
"spdPerformAbutment(
d_lhsInst
d_rhsInst
x_keepContacts
t_abutStrategy { sdFirst | dummyFirst }
)
=> ld_chain / nil"
"(ICADVM20.1 Only) Performs abutment on two adjacent instances according to the specified arguments and the SPD P/N chain alignment setting.")
("spdRegUserAbutProc"
"spdRegUserAbutProc(
l_abutNames
t_abutProc
t_checkProc
t_restoreProc
[ ?libName t_libName ]
[ ?description t_description ]
[ ?checkOdAbut t | nil ]
)
=> t / nil"
"Registers callback to check the design for OD abutment.

(ICADVM20.1 Only) Registers a list of user-defined abutments and related callbacks to perform these abutments in the SPD Editing or SPD Preview window or when a layout generated using SPD is brought back to the SPD Editing window. You can register them globally or by name of the library. However, if the design contains instances from different libraries, SPD will load the user-defined abutments and related callbacks from only one of registered libraries.")
("spdUnregUserAbutProc"
"spdUnregUserAbutProc(
[ ?libName t_libName ] 
)
=> t / nil"
"(ICADVM20.1 Only) Unregisters the current user abutment callback for the specified library. You cannot unregister a callback during an SPD session because it is still in use.")
("spdGetUserFlowProc"
"spdGetUserFlowProc(
)
=> r_infoObj / nil"
"Returns an object containing the user flow callbacks that were registered using the spdRegUserFlowProc function.")
("spdRegUserFlowProc"
"spdRegUserFlowProc(
[ ?postGen t_postGenProc ]
[ ?preGen t_preGenProc ]
[ ?postGenLayout t_postGenLayProc ]
)
=> t / nil"
"Registers user-defined callbacks to further customize the design in specific steps of the SPD flow.")
("spdUnregUserFlowProc"
"spdUnregUserFlowProc(
)
=> t/ nil"
"Unregisters the current user flow callback. You cannot unregister a callback during an SPD session because it is still in use.")
("lobGetRegisteredAdjacentFillDefsProc"
"lobGetRegisteredAdjacentFillDefsProc(
)
=> t_functionName / nil"
"(ICADVM20.1 EXL Only) Returns the name of the function that is registered as the adjacent fill definition procedure.")
("lobGetRegisteredTransitionFillDefsProc"
"lobGetRegisteredTransitionFillDefsProc(
)
=> t_functionName / nil"
"(ICADVM20.1 EXL Only) Returns the name of the function that is registered as the transition fill definition procedure.")
("lobGetRegUserProc"
"lobGetRegUserProc(
g_userProc
)
=> l_userProcsString / nil"
"(ICADVM20.1 EXL Only) Returns a list of strings that contain the name of the specified registered user procedure.")
("lobRegisterAdjacentFillDefsProc"
"lobRegisterAdjacentFillDefsProc(
g_userProc
)
=> t / nil"
"(ICADVM20.1 EXL Only) Registers the specified user function symbol as the adjacent fill definition procedure.")
("lobRegisterTransitionFillDefsProc"
"lobRegisterTransitionFillDefsProc(
g_userProc
)
=> t / nil"
"(ICADVM20.1 EXL Only) Registers the specified user function symbol as the transition fill definition procedure.")
("lobRegUserProc"
"lobRegUserProc(
g_userFunction
)
=> t / nil"
"(ICADVM20.1 EXL Only) Registers a user-defined function for a specific purpose, as needed by layout objects. This function is currently used to register procedures to retrieve adjacent fill definitions.")
("lobUnRegisterAdjacentFillDefsProc"
"lobUnRegisterAdjacentFillDefsProc(
g_userProc
)
=> t / nil"
"(ICADVM20.1 EXL Only) Unregisters the specified user function symbol, which is currently registered as the adjacent fill definition procedure.")
("lobUnRegisterTransitionFillDefsProc"
"lobUnRegisterTransitionFillDefsProc(
g_userProc
)
=> t / nil"
"(ICADVM20.1 EXL Only) Unregisters the specified user function symbol, which is currently registered as the transition fill definition procedure.")
("lobUnRegUserProc"
"lobUnRegUserProc(
g_userFunction
)
=> t / nil"
"(ICADVM20.1 EXL Only) Accepts user functions based on keyword and unregisters them.")
("lxHiAdjustAreaBoundary"
"lxHiAdjustAreaBoundary(
)
=> t"
"(ICADVM20.1 EXL Only) Opens the Adjust Area Boundary form, which can be used to modify the area boundary of the selected virtual figGroups.")
("lxHiAdjustBoundary"
"lxHiAdjustBoundary(
)
=> t"
"(ICADVM20.1 EXL Only) Adjusts the area boundary of the selected virtual figGroups or the PR Boundary of the selected soft blocks.")
("lxHiCreateVirtGroup"
"lxHiCreateVirtGroup(
[ w_windowID ]
)
=> t / nil"
"(ICADVM20.1 EXL Only) Creates a virtual figGroup using the selected layout instances that are bound to schematic instances in the same design. Creating a virtual figGroup enables you to edit the hierarchical instances in the figGroup directly at the top level, not requiring an Edit In Place. However, if the virtual figGroup contains a clone, an Edit In Place is needed to edit the clones. A virtual figGroup that you create using lxHiCreateVirtGroup operates the same way as the virtual figGroup that you create using the Generate Layout command. Note that the SKILL function operates on the design in the specified window. If you do not specify a window, the function creates a virtual figGroup in the current window.")
("lxHiDesignPlanningOptions"
"lxHiDesignPlanningOptions(
)
=> t"
"(ICADVM20.1 EXL Only) Opens the Design Planning and Analysis Options form.")
("lxHiGenerateVirtualHierarchy"
"lxHiGenerateVirtualHierarchy(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Runs the Generate All From Source command with the Generate - Design Planning - Virtual Hierarchy option selected to generate virtual hierarchies.")
("lxHiGenerateSelectedVirtualHierarchy"
"lxHiGenerateSelectedVirtualHierarchy(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Runs the Generate Selected From Source command with the Design Planning - Virtual Hierarchy option selected to generate virtual hierarchies for the selected schematic instances.")
("lxGetVirtualFigGroupMasterName"
"lxGetVirtualFigGroupMasterName(
d_figGroupID 
)
=> s_masterName"
"(ICADVM20.1 EXL Only) Returns the schematic cellview name for the specified virtual figGroup in the format 'lib/cell/view'.")
("lxHiMakeCell"
"lxHiMakeCell(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Opens the Design Planner Make Cell form, which can be used to create a new cellview using the selected virtual hierarchy from the top-cell layout.")
("lxHiMakeVirtualHierarchy"
"lxHiMakeVirtualHierarchy(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Opens the Make Virtual Hierarchy form, which can be used to create a virtual hierarchy at the top-cell level using the selected layout instance.")
("lxHiRemaster"
"lxHiRemaster(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Opens the Remaster form, which can be used to replace the selected virtual hierarchy with an existing layout variant.")
("lxHiSnapPatternOptions"
"lxHiSnapPatternOptions(
)
=> t"
"(ICADVM20.1 EXL Only) Opens the Design Planning and Analysis Options form to create snap pattern grids and specify that horizontal and vertical tracks be created inside the PR boundary.")
("lxHiVirtHierOptions"
"lxHiVirtHierOptions(
)
=> t / nil"
"(ICADVM20.1 EXL Only) Opens the Virtual Hierarchy Options form, which can be used to specify whether the layout displays the name of the virtual hierarchy, the cell, or both. In addition, the form can be used to enable or disable symbol overlay and to specify whether the virtual hierarchy can be auto placed during editing.")
("lxIsVirtualFigGroup"
"lxIsVirtualFigGroup(
d_figID
)
=> t / nil"
"(ICADVM20.1 EXL Only) Checks if the specified figGroup is a virtual figGroup.")