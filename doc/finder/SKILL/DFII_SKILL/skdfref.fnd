;SKILL Language Functions
("geChangeCellView"
"geChangeCellView( 
[ w_windowId ] 
[ t_libName ] 
[ t_cellName ] 
[ t_viewName ] 
[ t_accessMode ] 
)
=> w_windowId"
"Opens a design in an existing window.")
("geChangeEditMode"
"geChangeEditMode( 
t_newMode 
[ w_windowId ] 
) 
=> t / nil"
"Sets the mode of a design, allowing you to edit or view the design.")
("geDiscardEdits"
"geDiscardEdits( 
[ w_windowId ] 
) 
=> t / nil"
"Discards all edits made to a design.")
("geNewWindow"
"geNewWindow( 
[ w_windowId ] 
)
=> w_windowId / nil"
"Makes a copy of a window.")
("geReturn"
"geReturn( 
[ w_windowId ] 
)
=> t / nil"
"Returns to the previous (parent) level displayed in a window before a descend, edit in place, or switch was done.")
("geReturnToLevel"
"geReturnToLevel( 
w_windowId 
)
=> nil"
"Displays a list box containing the levels to which you can return.")
("geSave"
"geSave( 
[ w_windowId ] 
)
=> t / nil"
"Saves a design.")
("geSaveAs"
"geSaveAs( 
[ w_windowId ] 
[ t_libName ] 
[ t_cellName ]
[ t_viewName ] 
)
=> t / nil"
"Saves a design under another name.")
("geSaveHier"
"geSaveHier( 
d_cellviewId 
[ x_depth ] 
[ g_askForSave ] 
)
=> t"
"Saves a design hierarchically starting from the edit cellview of the specified window to the specified depth.")
("geGetDisabledMenus"
"geGetDisabledMenus(
w_windowId
[ l_menuList ]
)
=> l_disabledMenus"
"Given a windowId, returns all the disabled submenus for all banner menus on that window. If menuList is specified, only the disabled submenus on those banner menus are returned.")
("geGetEnablePredicate"
"geGetEnablePredicate(
r_menu
t_appName
)
=> n_enablePredicate"
"Returns the enable predicate of the menu for the application named appName or nil if undefined.")
("geGetWindowStatus"
"geGetWindowStatus(
w_windowId
t_appName
)
=> n_status"
"Returns the status for the application named appName on the window windowId.")
("geSetEnablePredicate"
"geSetEnablePredicate(
r_menu
t_appName
n_enablePredicate
)"
"Sets the enable predicate of the r_menu for t_appName to n_enablePredicate.")
("geSetWindowStatus"
"geSetWindowStatus(
w_windowId
t_appName
n_status
)
=> n_previousStatus"
"Sets the status for w_windowId and t_appName to n_status.")
("geUpdateWindowMenus"
"geUpdateWindowMenus(
w_windowId
)"
"Updates the enabled status of all the menu items in the window's banner menu hierarchy and all of the window's fixed menu items.")
("geClearIgnoreProp"
"geClearIgnoreProp(
l_inst | l_net
)
=> l_obj"
"Deletes the ignoreCheck property for all objects given in the list. The name of the property is ignoreCheck* where * is a numerical value.")
("geComputeQueryBbox"
"geComputeQueryBbox(
l_point
[ w_windowID ]
)
=> queryBbox / nil"
"This function takes a point as parameter and returns a corresponding bounding box. The point that is specified is the center of the bounding box. The lower left and upper right corners of the bounding box are based on the selectionAperture.")
("geCopySelSet"
"geCopySelSet( 
[ w_windowId ] 
[ l_sourcePt ] 
[ l_destPt ] 
)
=> t / nil"
"Procedural interface to copy the selected set.")
("geDeleteSelSet"
"geDeleteSelSet( 
[ w_windowId ] 
)
=> t / nil"
"Deletes all selected objects in the specified window. If w_windowId is not specified, the current window is used.")
("geMenuForObjectsUnderPoint"
"geMenuForObjectsUnderPoint( 
w_windowId 
l_point 
)
=> t / nil"
"Creates the (De)Select Under Cursor menu for the specified window and point.")
("geSelectNextInSelSet"
"geSelectNextInSelSet( 
[ d_cellviewId ] 
)
=> t / nil"
"Selects an object from the selected set of objects in the specified cellview.")
("geSelectPreviousInSelSet"
"geSelectPreviousInSelSet( 
[ d_cellviewId ]
)
=> t / nil"
"Selects the last selected object in the specified cellview.")
("geSelectToggleObject"
"geSelectToggleObject(
[ w_windowID ]
)
=> t / nil"
"Toggles the state of the selected objects in the specified window. This means that the function deselects the selected objects and selects the remaining objects.")
("geDispWinEnvProps"
"geDispWinEnvProps( 
[ t_type ]
)
=> t / nil"
"Lists all the window environment variables that can be set using the envSetVal function, or stored inside the .cdsenv file.")
("geEditSelSet"
"geEditSelSet( 
[ d_cellview ] 
)
=> t / nil"
"Displays and edits the properties of each object in the selected set in a cellview.")
("geEditSingleObject"
"geEditSingleObject( 
d_objectId 
)
=>  t / nil"
"Displays and edits the properties of an object.")
("geEditToWindowPoint"
"geEditToWindowPoint( 
w_windowId 
l_editCellViewPoint 
)
=> l_windowCellViewPoint"
"Translates coordinate values when you are using edit in place. geWindowToEditPoint applies the top-level cellview's coordinates to the cellview being edited; geEditToWindowPoint does the reverse.")
("geEquivWindow"
"geEquivWindow( 
w_windowId 
)
=> w_windowEquiv / nil"
"Returns the ID of a window that has the same edit cellview as the specified window.")
("geEquivWindowSet"
"geEquivWindowSet( 
w_windowId 
)
=> l_windowList"
"Returns a list of all windows that have the same edit cellview as the specified window.")
("geFindPathToCellViewInst"
"geFindPathToCellViewInst( 
d_cellview 
d_masterId 
)
=> l_hierPath / nil"
"Returns a hierarchical path of one of the references to a particular master in a cellview. This function returns the closest reference with the fewest levels of hierarchy.")
("geClearNetNameDisplayFilter"
"geClearNetNameDisplayFilter(
d_cellviewID 
)
=> t / nil"
"If the specified cellview is editable, clears the net name filter setting currently saved for the cellview.")
("geGetNetNameDisplayFilter"
"geGetNetNameDisplayFilter( 
d_cellview 
[ g_fromDesign ]
)
=> l_filterSettings / nil"
"Returns the net name filtering settings currently in use for the given cellview.")
("geIsNetNameDisplayActiveOnWindow"
"geIsNetNameDisplayActiveOnWindow(
w_windowID
)
=> t / nil"
"Checks whether the Net Name Display functionality is supported for the given window ID.")
("geIsNetNameDisplayEnabled"
"geIsNetNameDisplayEnabled(
w_windowID
)
=> t / nil"
"Checks whether the Net Name Display functionality is enabled for the given window ID.")
("geGetSortedSelectByLine"
"geGetSortedSelectByLine(
[w_windowId]
[l_linePoints]
)
=> l_sortedObjects"
"Returns the sorted list of the crossed objects by the line.")
("geGetCellViewWindow"
"geGetCellViewWindow( 
d_cellview 
) 
=> w_windowId / nil"
"Returns the ID of a window in which the specified cellview is displayed.")
("geGetEditCellView"
"geGetEditCellView( 
[ w_windowId ] 
)
=> d_cellview"
"Returns the ID for the cellview being edited.")
("geGetEditCellViewWindow"
"geGetEditCellViewWindow( 
d_cellview
)
=> w_windowId / nil"
"Returns the ID of the window in which the specified cellview is the edit cellview.")
("geGetEditRep"
"geGetEditRep( 
[ w_windowId ] 
)
=> d_cellview"
"An alias for geGetEditCellView. Returns the ID for the cellview being edited.")
("geGetHierMemInst"
"geGetHierMemInst( 
[ w_windowId ] 
)
=> l_list / nil"
"Returns a list describing the hierarchy of instances that have been descended into or edited-in-place to arrive at the cellview in the window.")
("geGetInstHier"
"geGetInstHier( 
[ w_windowId ] 
)
=> t_instance-hierarchy / nil"
"Returns a string describing the hierarchy of instances that have been descended into or edited-in-place in the current window to arrive at the cellview in the window.")
("geGetInstHierPath"
"geGetInstHierPath( 
w_windowId 
)
=> l_instance-hierarchy / nil"
"Similar to geGetInstHier but returns additional information for mosaic instances. 

This function returns a list of list describing the hierarchy of instances that have been descended into or edited-in-place in the current window to arrive at the cellview in the window. The list contains the following information for each instance:

(dbinst memInst row column)")
("geGetObjectSelectedSet"
"geGetObjectSelectedSet( 
[ d_cellview ] 
) 
=> list(
	list(d_selectedObject
		list(
				list(d_instId x_memInst x_row x_column))
				list(d_instId x_memInst x_row x_column))
				...
		)
	list(d_selectedObject
		list(
				list(d_instId x_memInst x_row x_column))
				list(d_instId x_memInst x_row x_column))
				...
		)
	...
)
=> l_selectedSet"
"Returns a list of lists describing objects selected in the hierarchy of the given cellview. If the cellview is omitted, the current edit cellview of the current window is used. For each object in the selected set, the path to it consisting of the instance ID, the member instance, the row, and the column is given.")
("geGetTopLevelCellView"
"geGetTopLevelCellView( 
[ w_windowId ] 
)
=> d_cellview / nil"
"Returns the ID of the top-level cellview displayed in a window.")
("geGetTopCellViewWindow"
"geGetTopCellViewWindow( 
d_cellview
)
=> w_windowId / nil"
"Returns the ID of the window in which the specified cellview is the top cellview.")
("geGetWindowBox"
"geGetWindowBox( 
w_windowId 
)
=> l_bBox / nil"
"Returns the lower left and upper right coordinates of the current window display.")
("geGetWindowCellView"
"geGetWindowCellView( 
[ w_windowId ] 
) 
=> d_cellview / nil"
"Returns the ID of the cellview displayed in a window.")
("geGetWindowRep"
"geGetWindowRep( 
[ w_windowId ] 
) 
=> d_cellview / nil"
"An alias for geGetWindowCellView. Returns the ID of the cellview displayed in a window. 

This function returns nil if the current window is empty or if no current window is defined. The cellview being displayed in the window can be different from the cellview being edited, as returned by geGetEditCellView, if you are currently editing a cell in place.")
("geIsGraphicalWindow"
"geIsGraphicalWindow( 
[ d_windowId ] 
g_noWarn
)
=> t / nil"
"This function tests if the specified window (or by default, the current window) is a graphical window.")
("geSaveNetNameDisplayFilter"
"geSaveNetNameDisplayFilter( 
d_cellview 
)
=> t / nil"
"Saves the net name filtering settings that are currently applied on the given cellview after the geSetNetNameDisplayFilter function is called. After you call the geSaveNetNameDisplayFilter, the settings will be reloaded automatically when you open the cellview in a new Virtuoso session.")
("geSetNetNameDisplayFilter"
"geSetNetNameDisplayFilter( 
d_cellview 
t_mode
l_netNames
)
=> t / nil"
"Sets a net name filtering on the given cellview. You can control which nets are displayed or not by the net name display feature.")
("geSetTCProbeDisplayStyle"
"geSetTCProbeDisplayStyle( 
d_probeId
g_trueColorProbeVal
g_probeHighlightVal
) 
=> t / nil"
"This function sets the trueColorProbeVal and probeHighlightVal options of the specified probeId.")
("geTransparencyOptions"
"geTransparencyOptions(
)
=> t / nil"
"(ICADVM20.1) This form opens the Transparency Options form.")
("geWindowToEditPoint"
"geWindowToEditPoint( 
w_windowId 
l_windowCellViewPoint 
) 
=> l_editCellViewPoint"
"Translates coordinate values when you are using edit in place. geWindowToEditPoint applies the top-level cellview's coordinates to the cellview being edited; geEditToWindowPoint does the reverse.")
("geEnableNetNameDisplay"
"geEnableNetNameDisplay( 
w_windowId
g_state
)
=> t / nil"
"Enables the display of net name labels on shapes that are big enough to display a label.This SKILL function is supported only in Layout XL and higher tiers.")
("geNetNameDisplayOptionForm"
"geNetNameDisplayOptionForm( 
[ w_windowId ] 
)
=> t / nil"
"Opens the Net Name Display Options form. This SKILL function is supported only in Layout XL and higher tiers.")
("geRefresh"
"geRefresh( 
)
=> t / nil"
"Redraws all areas of all windows that have not been updated since the last redraw and need redrawing.")
("geRefreshCellView"
"geRefreshCellView(
d_cvId 
l_Bbox
)
=> t / nil"
"Redraws a cellview when necessary. If a bounding box is specified, only the specified area is redrawn.")
("geRefreshCellViews"
"geRefreshCellViews(
d_cvId 
)
=> t / nil"
"Displays a form that shows all cellviews from the specified cellview that have been modified by another process but not reread from disk. You can then select which ones should be refreshed. The top-level cellview is also checked for modification.")
("geRefreshWindow"
"geRefreshWindow( 
[ w_windowId ] 
[ l_bBox ] 
)
=> t / nil"
"Refreshes a window. If a bounding box is specified, only that area is refreshed.")
("geRefreshWorldView"
"geRefreshWorldView( 
w_windowId 
) 
=> t / nil"
"Refreshes the worldView window.")
("geDeleteAllAreaViewLevel"
"geDeleteAllAreaViewLevel( 
[ w_windowId ] 
)
=> t / nil"
"Removes all area view levels from a window.")
("geDeleteAllInstViewLevel"
"geDeleteAllInstViewLevel( 
w_windowId 
)
=> t / nil"
"Removes all instance-specific view levels from a window.")
("geDeleteAreaViewLevel"
"geDeleteAreaViewLevel( 
[ w_windowId ] 
l_bBox 
)
=> t / nil"
"Removes from a window all area view levels located in l_bBox.")
("geDeleteInstViewLevel"
"geDeleteInstViewLevel( 
[ w_windowId ] 
d_instId 
)
=> t / nil"
"Removes all instance-specific view levels associated with an instance ID.")
("geGetAllAreaViewLevel"
"geGetAllAreaViewLevel( 
w_windowId 
)
=> l_bBoxStartStop / nil"
"Retrieves all area view levels set for a window. The view levels are returned as a list with the start level and stop level for the areas.")
("geGetAllInstViewLevel"
"geGetAllInstViewLevel( 
w_windowId 
)
=> l_instStartStop / nil"
"Retrieves the start level and stop level assigned within a window. The start level and stop level are returned as a list of integers. If no start level and stop level are defined, then nil is returned.")
("geGetAreaViewLevel"
"geGetAreaViewLevel( 
[ w_windowId ] 
l_bBox 
)
=> l_startStop / nil"
"Retrieves an area view level overlapping a bounding box. The view level is returned as a list with the start level and stop level for that area. If more than one area overlaps the given box, the first area found is used.")
("geGetInstViewLevel"
"geGetInstViewLevel( 
w_windowId 
d_instId 
)
=> l_startStop / nil"
"Retrieves the start level and stop level of an instance. The start level and stop level are returned as a list of integers. If start level and stop level are not defined for the chosen instance, nil is returned.")
("geSetAreaViewLevel"
"geSetAreaViewLevel( 
[ w_windowId ] 
l_bBox 
[ n_start ] 
[ n_stop ]
)
=> t / nil"
"Sets display start and stop threshold levels for an area independently of the window levels.")
("geSetInstViewLevel"
"geSetInstViewLevel( 
w_windowId 
d_instId 
n_start 
n_stop 
)
=> t / nil"
"Sets display start and stop threshold levels for an instance independently of the window levels.")
("geRestoreWinView"
"geRestoreWinView( 
w_windowId 
)
=> t / nil"
"Restores the view saved with geSaveWinView.")
("geSaveWinView"
"geSaveWinView( 
[ w_windowId ] 
[ t_name ] 
)
=> t / nil"
"Saves the current view of w_windowId to t_name.")
("geEditInPlace"
"geEditInPlace( 
w_windowId 
t_accessMode 
d_instId 
x_iteration 
x_row 
x_col 
[ g_cancel ]
)
=> t / nil"
"Edits an instance in place.")
("gePush"
"gePush( 
w_windowId 
t_accessMode 
d_instId 
x_iteration
x_row 
x_col 
[ g_cancel ]
)
=> t / nil"
"Pushes into an instance.")
("geSwitch"
"geSwitch( 
w_windowId 
t_accessMode 
d_instId 
x_iteration 
x_row 
x_col 
[ g_cancel ]
)
=> w_windowId / nil"
"Switches into an instance.")
("geSwitchInContext"
"geSwitchInContext( 
w_windowId 
t_accessMode 
d_instId 
x_iteration 
x_row 
x_col 
[ verbose ]
)
=> w_windowId / nil"
"Switches into an instance by using the view name specified in the hierarchy manager configuration context. If the correct configuration context is not found, this function uses the geSwitch command to perform the switch.")
("geCenter"
"geCenter( 
[ w_windowId ] 
)
=> t / nil"
"Pans the display so that the edit cellview is centered in the window.")
("geGetScrollPercent"
"geGetScrollPercent( 
)
=> x_percent"
"Obtains the percentage used by geScroll when shifting the drawing.")
("geScroll"
"geScroll( 
[ w_windowId ] 
[ t_dir ] 
[ g_zoom ] 
)
=> t / nil"
"Scrolls a view.")
("geSetScrollPercent"
"geSetScrollPercent( 
n_percent 
)
=> n_percent"
"Controls the percentage of the drawing currently visible that is shifted when geScroll is activated.")
("geShift"
"geShift( 
[ w_windowId ] 
[ t_dir ] 
)
=> t / nil"
"Shifts w_windowId in the direction t_dir.")
("geZoomToGrid"
"geZoomToGrid( 
w_windowId 
) 
=> t / nil"
"Zooms in on a subject up to the last point at which the major grid is still visible.")
("geAdvWireSelection"
"geAdvWireSelection( 
w_windowId 
) 
=> t / nil"
"Allows the user to select route elements and the adjacent routes. Its behavior is based on the initial state of the selection and the number of consecutive calls to geAdvWireSelection().")
("geAddSelectBox"
"geAddSelectBox( 
[ w_windowId ] 
[ g_partial ] 
[ l_bBox ] 
) 
=> t / nil"
"Implements the add mode of area selection. With no arguments given, it prompts you to enter the area to be selected in the current window. Partial selection is performed only when the window environment variable partialSelect is set and the stretch command is active. Partial selection lets you select an edge, vertex, or endpoint of an object to stretch.")
("geAddSelectPoint"
"geAddSelectPoint( 
[ w_windowId ] 
[ g_partial ] 
[ l_point ] 
) 
=> t / nil"
"Implements the add mode of point selection.")
("geAdjustPoint"
"geAdjustPoint( 
l_point
[ w_windowId ] 
) 
=> l_point / nil"
"Returns the point after applying the adjustment associated to the window Id provided. Adjustment is defined using gravity, the current snap grid, and any snap mode defined in the window interface.")
("geCyclePotentialSelectNext"
"geCyclePotentialSelectNext(
[ w_windowID ]
[ l_point ]
)
=> t / nil"
"Cycles the potential selection to the next object.")
("geCycleSelectNext"
"geCycleSelectNext(
[ w_windowID ]
)
=> t / nil"
"Cycles to the next object at the current selection point.")
("geDeselectAll"
"geDeselectAll( 
[ w_windowId ] 
)
=> t / nil"
"Deselects everything in the specified window. If w_windowId is not specified, the current window is used.")
("geDeselectAllFig"
"geDeselectAllFig( 
[ d_cellview ] 
)
=> t / nil"
"Deselects all objects in a cellview. 

Does not use the selection filter, so all objects are deselected.")
("geDeselectAllObject"
"geDeselectAllObject( 
[ d_cellview ] 
)
=> t / nil "
"Deselects everything in the specified cellview.")
("geDeselectArea"
"geDeselectArea( 
[ w_windowId ] 
[ l_bBox ] 
)
=> t / nil "
"Calls geSubSelectBox to deselect objects within the specified bounding box in the specified window. ")
("geDeselectFig"
"geDeselectFig( 
d_figId 
)
=> t / nil"
"Removes an object from the selected set if the object passes the selection filter.")
("geDeselectFigs"
"geDeselectFigs( 
l_figList
)
=> l_list / nil"
"Deselects figures from a specified list of figures.")
("geDeselectFigNoFilter"
"geDeselectFigNoFilter( 
d_figId 
)
=> t / nil "
"Deselects the specified figure.")
("geDeselectFigPoint"
"geDeselectFigPoint( 
d_figId 
l_vertex 
)
=> t / nil"
"Removes vertices from the selected set if they pass the selection filter.")
("geDeselectObject"
"geDeselectObject( 
d_figId 
[ l_path ] 
)
=> t / nil "
"Deselects the specified object at the specified hierarchical path, if it passes the selection filter. ")
("geDeselectObjectNoFilter"
"geDeselectObjectNoFilter( 
d_figId 
[ l_path ] 
)
=> t / nil "
"Deselects the specified object at the specified hierarchical path.")
("geDeselectObjectPoint"
"geDeselectObjectPoint( 
d_figId 
l_path 
l_points 
)
=> t / nil "
"Deselect the specified vertices of the specified figure if it passes the selection filter. ")
("geDeselectPoint"
"geDeselectPoint( 
[ w_windowId ] 
[ l_point ] 
)
=> t / nil "
"Calls geSubSelectPoint to deselect the figure at the specified point in the specified window. This might deselect just a vertex or edge, or the whole figure, depending on the state of the partialSelect window environment variable. Use the F4 key to toggle this variable. You can see the state of partialSelect in the window banner.")
("geDeselectProtected"
"geDeselectProtected( 
[ d_cellview ]
)
=> t / nil "
"Deselects all the objects that are marked protected in the specified cellview.")
("geGetPotentialSelection"
"geGetPotentialSelection( 
[ w_windowId ]
[ g_ignoreSelect] 
[ l_point]
)
=> ((d_figId l_path) g_isAllSelected [l_selArray]) / nil "
"Returns the figure ID of the object which can be selected, hierarchical path of the figure, and indicates if the figure is fully or partially selected.")
("geGetSelSet"
"geGetSelSet( 
[ w_windowId ]
[ d_cellview ] 
)
=> l_selectedSet / nil "
"Returns a list of the currently selected objects in a window or cellview.")
("geGetSelectedSet"
"geGetSelectedSet( 
[ d_cellview ] 
)
=> l_figs / nil"
"Returns a list of selected objects in a cellview.")
("geGetSelSetCount"
"geGetSelSetCount( 
[ d_cellview ] 
)
=> n_count / 0"
"Counts selected objects in a cellview.")
("geGetSelectedInstancesCount"
"geGetSelectedInstancesCount( 
[ d_cellviewId ] 
)
=> n_count"
"Counts selected instances in a cellview.")
("geGetSelProtectedObjects"
"geGetSelProtectedObjects( 
[ d_cellview ]
)
=> l_results / nil "
"Returns a list of all the objects that are marked protected in the specified cellview.")
("geGetSelSetFigPoint"
"geGetSelSetFigPoint( 
d_figId 
)
=> l_selPoints / nil"
"Returns a list indicating whether points are selected for an object.")
("geGetWindowSelProtectionHighlight"
"geGetWindowSelProtectionHighlight( 
[ w_window ]
)
=> t / nil "
"Returns whether or not the protected objects in the specified window are highlighted.")
("geGetWindowSelProtectionSelectability"
"geGetWindowSelProtectionSelectability( 
[ w_window ]
)
=> t / nil "
"Returns whether or not the protected objects in the specified window can be selected.")
("geHiDragFig"
"geHiDragFig(
w_windowID 
r_form
t_srcPrompt
t_dstPrompt
t_cmdName
t_SelSet
g_useMultiWindow
[ l_firstPoint ]
)"
"Used in conjunction with other SKILL functions to implement the dragging of selected database figures.")
("geHiDisplaySelectionForm"
"geHiDisplaySelectionForm( 
) 
=> t / nil"
"Opens a form that allows you to manage selection options.")
("geHighlightProtected"
"geHighlightProtected( 
[ w_window ]
)
=> t / nil "
"Displays a halo around objects that are protected from being selected in the specified cellview.")
("geHiSetSelProtectionEF"
"geHiSetSelProtectionEF( 
)
=> t / nil "
"Starts an enter function to set selection protection.")
("geHiUnsetSelProtectionEF"
"geHiUnsetSelProtectionEF( 
)
=> t / nil "
"Starts an enter function to remove selection protection.")
("geIsFigAllSelected"
"geIsFigAllSelected( 
d_figId 
) 
=> t / nil"
"Checks whether an object is completely selected.")
("geIsFigPartiallySelected"
"geIsFigPartiallySelected( 
d_figId 
) 
=> t / nil"
"Checks whether an object is partially, but not completely, selected.")
("geIsFigSelected"
"geIsFigSelected( 
d_figId 
) 
=> t / nil"
"Checks whether an object is at least partially selected.")
("geIsObjectAllSelected"
"geIsObjectAllSelected( 
d_figId 
[ l_path ] 
)
=> t / nil "
"Tests if the specified figure is fully selected.")
("geIsObjectPartiallySelected"
"geIsObjectPartiallySelected( 
d_figId 
[ l_path ] 
)
=> t / nil "
"Tests if the specified figure is partially selected.")
("geIsObjectSelected"
"geIsObjectSelected( 
d_figId 
[ l_path ] 
)
=> t / nil "
"Tests if the specified figure is partially or fully selected.")
("geIsSelProtection"
"geIsSelProtection( 
w_window
d_figId
l_figId
)
=> l_results"
"Returns whether the specified object in the specified window is protected from being selected.")
("gePointQuery"
"gePointQuery( 
w_windowId 
l_point 
t_filterProc 
)
=> d_figId / nil"
"Returns the ID of the object found at the point l_point.")
("gePointToFig"
"gePointToFig( 
[ w_windowId ] 
[ g_ignoreSelect ] 
[ l_list ] 
)
=> d_figure / nil"
"Returns the ID of the object located at the coordinates given in l_list.")
("geSelectAll"
"geSelectAll( 
[ w_windowId ] 
) 
=> t / nil"
"Selects all objects in the specified window.")
("geSelectAllFig"
"geSelectAllFig( 
[ d_cellview ] 
) 
=> t / nil"
"Selects all objects in a cellview that pass the selection filter.")
("geSelectArea"
"geSelectArea( 
[ w_windowId ] 
[ l_points ] 
[ t_areaShapeType ] 
)
=> t / nil "
"Adds the objects within the area defined by t_areaShapeType to the selection.")
("geSelectByline"
"geSelectByLine( 
)
=> t / nil "
"Enables you to select objects by drawing a line. Press Shift and draw a line to overlap the additional objects to be selected. Press Ctrl and draw a line to overlap the objects to be removed from the selected set. Double-click to end the line.")
("geSelectBy2PointsLine"
"geSelectBy2PointsLine( 
[ w_windowId ] 
) 
=> t / nil"
"Selects objects by drawing a line. Press Shift and draw a line to overlap the additional objects to be selected. Press Ctrl and draw a line to overlap the objects to be removed from the selected set. The selection is done when the second point is entered.")
("geSelectFig"
"geSelectFig( 
d_figId 
) 
=> t / nil"
"Selects an object in the layout.")
("geSelectFigs"
"geSelectFigs( 
l_figList
)
=> l_list / nil"
"Selects figures from a specified list of figures.")
("geSelectFigNoFilter"
"geSelectFigNoFilter( 
d_figId 
)
=> t / nil "
"Selects the specified figure regardless of the selection filter.")
("geSelectFigPoint"
"geSelectFigPoint( 
d_figId 
l_vertex 
) 
=> t / nil"
"Adds vertices of an object to the selected set if they pass the selection filter.")
("geSelectObject"
"geSelectObject( 
d_figId 
[ l_path ] 
)
=> t / nil"
"Selects the specified figure at the specified hierarchical path, if it passes the selection criteria.")
("geSelectObjectNoFilter"
"geSelectObjectNoFilter(
d_figId 
[ l_path ]
)
=> t / nil"
"Selects the specified figure at the specified hierarchical path.")
("geSelectPoint"
"geSelectPoint( 
[ w_windowId ] 
[ l_point ] 
)
=> t / nil "
"Uses the given point to select the object. If there is no object at that location, no object is selected and nil is returned.")
("geSelectProtected"
"geSelectProtected( 
[ d_cellview ]
)
=> t / nil "
"Selects the objects that are protected from being selected in the specified cellview.")
("geSelectViaPile"
"geSelectViaPile( 
[ d_cellview ] 
)
=> t / nil "
"Extends the selection set by adding via pile for each via selected. If the selection set does not contain vias, nil is returned.")
("geSetEnterFunctionSelectionMode"
"geSetEnterFunctionSelectionMode(
w_windowId
x_mode
)
=> t / nil"
"Sets the selection mode for the enter function associated with the specified window.")
("geSelObjectsPartiallySelected"
"geSelObjectsPartiallySelected(
[ w_windowId ]
)
=> t / nil"
"Fully selects the objects that are partially selected in the specified window. If all objects are already fully selected, geSelObjectsPartiallySelected extends the selection according to the current selection granularity.")
("geSetSelProtection"
"geSetSelProtection( 
[ d_cellview ] | [ d_figId ] | [ l_figId ]
)
=> l_results / nil "
"Sets the specified object as protected, which prevents it from being selected. If no figId is specified, the selected objects in the specified or in the current cellview are set as protected.")
("geSetSelProtectionAllObjects"
"geSetSelProtectionAllObjects( 
[ d_cellview ]
)
=> t / nil "
"Sets all the objects in the specified cellview as protected, which prevents them from being selected.")
("geSetSelProtectionHighlightOptionForm"
"geSetSelProtectionHighlightOptionForm( 
)
=> t / nil "
"Opens the Selection Protection Highlight Options form where you can configure the settings for highlighting protected objects.")
("geSetSelProtectionHighlightOptions"
"geSetSelProtectionHighlightOptions( 
w_window
d_cellview
[ l_options ]
)
=> t / nil "
"Sets the highlight options for objects that are marked protected.")
("geSingleSelectBox"
"geSingleSelectBox( 
[ w_windowId ] 
[ g_partial ] 
[ l_point ] 
) 
=> t / nil"
"Implements the single mode of area selection.")
("geSingleSelectPoint"
"geSingleSelectPoint( 
[ w_windowId ] 
[ g_partial ] 
[ l_point ] 
) 
=> t / nil"
"Implements the single mode of point selection.")
("geSubSelectBox"
"geSubSelectBox( 
[ w_windowId ] 
[ g_partial ] 
[ l_bBox ] 
) 
=> t / nil"
"Implements the sub mode of area selection.")
("geSubSelectPoint"
"geSubSelectPoint( 
[ w_windowId ] 
[ g_partial ] 
[ l_point ] 
) 
=> t / nil"
"Implements the sub mode of point selection.")
("geToggleAreaSelectOption"
"geToggleAreaSelectOption( 
)
=> enclosed_crossed / enclosed / edgeOnly / vertexAndEdge"
"Toggles area selection mode.")
("geToggleDisplayResolution"
"geToggleDisplayResolution( )"
"Rotates the value of the graphic environment variable displayResolution between the values Very High, High, Medium, and Low. This function is bound to the F9 bindkey in the default layout editor bindkeys.")
("geToggleFilterSize"
"geToggleFilterSize( )"
"Rotates the value of the graphic environment variable filterSize between the values 0.0, 3.0, 10.0, 25.0, and 50.0. This function is bound to the F9 bindkey in the default layout editor bindkeys.")
("geTogglePartialSelect"
"geTogglePartialSelect( 
)
=> t / nil"
"Toggles partial selection off and on.")
("geToggleWindowSelProtectionHighlight"
"geToggleWindowSelProtectionHighlight( 
[ w_window ]
)
=> t"
"Toggles the highlight state of protected objects in the specified window.")
("geToggleWindowSelProtectionSelectability"
"geToggleWindowSelProtectionSelectability( 
[ w_window ]
)
=> t"
"Toggles the selectability state of protected objects in the specified window.")
("geUnhighlightProtected"
"geUnhighlightProtected( 
[ w_window ]
)
=> t / nil "
"Removes the halo from the objects marked as protected in the specified cellview.")
("geUnsetAllSelProtection"
"geUnsetAllSelProtection( 
[ d_cellview ]
)
=> t / nil "
"Removes the selection protection from all the protected objects in the specified cellview.")
("geUnsetSelProtection"
"geUnsetSelProtection( 
[ d_cellview ] | [ d_figId ] | [ l_figId ]
)
=> l_results / nil "
"Removes the selection protection from the specified protected objects. If no figId is specified, protection of the selected objects in the specified or in the current cellview is removed.")
("geDSAFreeze"
"geDSAFreeze(
w_windowId
l_point
)
=> t / nil"
"Toggles between the freeze and unfreeze states of the Dynamic Selection Assistant (DSA).")
("geDeleteStoredSelectionSet"
"geDeleteStoredSelectionSet( 
t_setName
[ d_cellviewId ]
)
=> t / nil"
"Removes the specified stored selection set from the manual store selection set of the given cellview.")
("geDeselectStoredSelectionSet"
"geDeselectStoredSelectionSet( 
t_setName
[ d_cellviewId ]
)
=> t / nil"
"Removes the elements of the specified selection set from the current selection set of the given cellview.")
("geGetStoredSelectionSets"
"geGetStoredSelectionSets( 
d_cellviewId 
)
=> t_nameList / nil"
"Returns the list of names for the stored selection sets in the given cellview.")
("geHiStoreSelectionForm"
"geHiStoreSelectionForm( 
)
=> t / nil"
"Opens the Save/Restore Selection Set form.")
("geIsAutoStoreSelectionOn"
"geIsAutoStoreSelectionOn( 
[ d_cellviewId ]
)
=> t / nil"
"Returns true if the auto store selection set feature is enable.")
("geSelectNextAutoStoreSet"
"geSelectNextAutoStoreSet( 
[ d_cellviewId ]
)
=> t / nil"
"Sets the next stored auto selection set as the current selection set. This function ends on the last stored selection set.")
("geSelectPreviousAutoStoreSet"
"geSelectPreviousAutoStoreSet( 
[ d_cellviewId ]
)
=> t / nil"
"Restores the previous stored auto selection set. This function ends on the first stored selection set.")
("geSelectStoredSelectionSet"
"geSelectStoredSelectionSet(
t_setName
[ d_cellviewId]
)
=> t / nil"
"Adds the elements of the specified selection set into the current selection set of the given cellview.")
("geSetAutoStoreSelection"
"geSetAutoStoreSelection(
g_autoStore 
[ d_cellviewId ]
)
=> t / nil"
"Enables the auto store selection set feature on a cellview. Stored selection sets are remembered as long as the cellview is open. Once the cellview is closed, the recorded information is lost.")
("geStoreSelectionSet"
"geStoreSelectionSet(
t_setName 
[ d_cellviewId ]
)
=> t / nil"
"Records the current selection set into the cellview manual store selection set list.")
("geAddHilightArc"
"geAddHilightArc( 
g_hlSetId 
l_ellipsebBox 
l_arcbBox 
)
=> g_hlObjectId / nil"
"Adds an arc to a highlight set.")
("geAddHilightBlockage"
"geAddHilightBlockage( 
g_hlSetId 
d_blockageId
)
=> g_hlObjectId / nil"
"Adds a blockage to a highlight set.")
("geAddHilightCircle"
"geAddHilightCircle( 
g_hlSetId 
l_center 
n_radius 
)
=> g_hlObjectId / nil"
"Adds a circle to a highlight set.")
("geAddHilightCurvedPath"
"geAddHilightCurvedPath( 
g_hlSetId 
l_points 
n_width 
)
=> g_hlObjectId / nil"
"(ICADVM20.1 Only) Adds a curved path to a highlight set.")
("geAddHilightCurvedPolygon"
"geAddHilightPolygon( 
g_hlSetId 
l_points 
)
=> g_hlObjectId / nil"
"(ICADVM20.1 Only) Adds a curved polygon to a highlight set.")
("geAddHilightDistance"
"geAddHilightDistance(
h_hlSetId
l_points [l_points]
)
=> h_hlObjectId"
"Adds a distance (like ruler) to the given hilight Set or Group.")
("geAddHilightDonut"
"geAddHilightDonut( 
g_hlSetId 
l_center 
n_outR 
n_holeR 
)
=> g_hlObjectId / nil"
"Adds a donut to a highlight set.")
("geAddHilightDot"
"geAddHilightDot( 
g_hlSetId 
l_point 
n_width 
n_height 
)
=> g_hlObjectId / nil"
"Adds a dot to a highlight set.")
("geAddHilightEllipse"
"geAddHilightEllipse( 
g_hlSetId 
l_bBox 
)
=> g_hlObjectId / nil"
"Adds an ellipse to a highlight set.")
("geAddHilightFig"
"geAddHilightFig( 
g_hlSetId 
d_figId 
[ g_drawAll ] 
[ l_hierPath ]
[ l_vertex ]
)
=> g_hlObjectId / nil"
"Adds a figure to a highlight set.")
("geAddHilightLabel"
"geAddHilightLabel( 
g_hlSetId 
l_origin 
t_label 
t_just
t_orient 
t_font 
n_height 
g_draftingP 
[ g_overBar ] 
)
=> g_hlObjectId / nil"
"Adds a label to a highlight set.")
("geAddHilightLine"
"geAddHilightLine( 
g_hlSetId 
l_points 
)
=> g_hlObjectId / nil"
"Adds a line to a highlight set.")
("geAddHilightPath"
"geAddHilightPath( 
g_hlSetId 
l_points 
n_width 
)
=> g_hlObjectId / nil"
"Adds a path to a highlight set.")
("geAddHilightPathSeg"
"geAddHilightPathSeg( 
g_hlSetId 
l_beginPt
l_endPt
n_width
t_beginStyle
t_endStyle
[ l_extValue ] 
=> g_hlObjectId / nil"
"Adds a pathSeg to a highlight set.")
("geAddHilightPolygon"
"geAddHilightPolygon( 
g_hlSetId 
l_points 
)
=> g_hlObjectId / nil"
"Adds a polygon to a highlight set.")
("geAddHilightRow"
"geAddHilightRow( 
g_hlSetId 
d_siteDef
l_point
x_numSites
[ t_siteOrient ]
[ t_rowOrient ]
=> g_hlObjectId / nil"
"Adds a row to a highlight set.")
("geAddHilightRuler"
"geAddHilightRuler( 
g_hlSetId 
l_points
=> g_hlObjectId / nil"
"Adds a ruler to a highlight set.")
("geAddHilightSlicedCircle"
"geAddHilightSlicedCircle( 
g_hlSetId 
l_center 
n_radius 
f_startAngle
f_StopAngle
)
=> g_hlObjectId / nil"
"Adds a sliced circle to a highlight set.")
("geAddHilightSlicedDonut"
"geAddHilightSlicedDonut( 
g_hlSetId 
l_center 
n_radius 
f_startAngle
f_StopAngle
)
=> g_hlObjectId / nil"
"Adds a sliced donut to a highlight set.")
("geAddHilightTrackPattern"
"geAddHilightTrackPattern( 
g_hlSetId 
d_trackPatternId
)
=> g_hlObjectId / nil"
"Adds a track pattern to a highlight set.")
("geAddHilightRectangle"
"geAddHilightRectangle( 
g_hlSetId 
l_bBox 
)
=> g_hlObjectId / nil"
"Adds a rectangle to a highlight set.")
("geChangeHilightPacketName"
"geChangeHilightPacketName( 
h_hlSetId 
g_packetName
)
=> t / nil"
"Changes the packet on which the given highlight set is drawn.")
("geCreateHilightGroup"
"geCreateHilightGroup( 
h_hlSetId 
[ l_hlObjects ]
)
=> hlGroupId / nil"
"Creates a group container in the given highlight set.")
("geCreateHilightSet"
"geCreateHilightSet( 
d_cellview 
l_layerPurposePair 
[ g_notGlobal ] 
)
=> g_hlSetId / nil"
"Creates a highlight set.")
("geCreateWindowHilightSet"
"geCreateWindowHilightSet( 
w_windowId 
l_layerPurposePair | t_packetName
[ g_notGlobal ]
)
=> h_hilightSetId / nil"
"Creates an highlight set on a window.")
("geDeleteAllHilightSet"
"geDeleteAllHilightSet( 
d_cellview 
)
=> t / nil"
"Deletes all highlight sets from the specified window.")
("geDeleteAllWindowHilightSet"
"geDeleteAllWindowHilightSet( 
w_windowId 
)
=> t / nil"
"Deletes all the window highlight sets registered on the given window.")
("geDeleteHilightGroup"
"geDeleteHilightGroup( 
hl_groupId
[ g_deleteAll ]
)
=> t / nil"
"Deletes the specified highlight group.")
("geDeleteHilightObject"
"geDeleteHilightObject( 
g_hlObjectId 
)
=> t / nil"
"Deletes the highlight object from the highlight set.")
("geDeleteHilightSet"
"geDeleteHilightSet( 
g_hlSetId 
)
=> t / nil"
"Deletes a highlight set.")
("geDeleteHilightSetInWindows"
"geDeleteHilightSetInWindows( 
hl_groupId
[ l_windowList ]
)
=> t / nil"
"Deletes the given window highlight set in all windows where it is referenced, or in the given windows specified in the list.")
("geDrawHilightSet"
"geDrawHilightSet( 
[ w_windowId ]
[ g_hlSetId ]
)
=> t / nil"
"Redraws a highlight set from a specified window ID.")
("geGetCurrentHilightSet"
"geGetCurrentHilightSet( 
d_cellview 
)
=> g_hlSetId / nil"
"Retrieves the current highlight set.")
("geGetCurrentWindowHilightSet"
"geGetCurrentWindowHilightSet( 
w_windowId
)
=> d_hlSetId / nil"
"Returns the window highlight set which is at the top of the window highlight stack.")
("geGetFigHilightObjectId"
"geGetFigHilightObjectId( 
g_hlSetId 
d_figId 
)
=> g_hlObjectId / nil"
"Returns the highlight object ID of the object d_figId in the highlight set g_hlSetId.")
("geGetHilightObjectFigId"
"geGetHilightObjectFigId( 
h_hlObjectId 
)
=> d_figId / nil"
"Returns the figure ID of the highlighted object.")
("geInsertHilightObjectsInGroup"
"geInsertHilightObjectsInGroup( 
h_hlGroupId
[ l_hlObjectId ] 
)
=> t / nil"
"Groups all given highlight objects together.")
("geIsValidHilightGroup"
"geIsValidHilightGroup( 
h_hlGroupId 
)
=> t / nil"
"Determines whether the highlighted group is valid.")
("geIsValidHilightId"
"geIsValidHilightId( 
h_hlId 
)
=> t / nil"
"This function determines whether a highlight ID is valid.")
("geIsValidHilightObject"
"geIsValidHilightObject( 
h_hlObjectId 
)
=> t / nil"
"Determines whether the highlighted object is valid.")
("geIsValidHilightSet"
"geIsValidHilightSet( 
h_hlSetId 
)
=> t / nil"
"Determines whether a highlight set is valid.")
("gePopHilightStack"
"gePopHilightStack( 
d_cellview 
)
=> nil"
"Pops the current highlight set out of the highlight stack.")
("gePopWindowHilightStack"
"gePopWindowHilightStack( 
w_windowId 
)
=> t / nil"
"Pops the current window highlight set out of the window highlight stack.")
("gePushHilightStack"
"gePushHilightStack( 
g_hlSetId 
)
=> t / nil"
"Pushes a highlight set into the highlight stack of the cellview to which the highlight belongs.")
("geResetHilightSetAlphaBlendingParameters"
"geResetHilightSetAlphaBlendingParameters( 
g_hSetId
) 
=> t / nil"
"Resets the alpha blending values to maximum values (1000) for the given highlight set.")
("geResetHilightSetHaloParameters"
"geResetHilightSetHaloParameters(
h_hlSetId 
)
=> t / nil"
"Resets the halo parameters set on a highlight set.")
("geSetHilightSetAlphaBlendingParameters"
"geSetHilightSetAlphaBlendingParameters( 
g_hSetId
g_halo
g_fill
g_outLine
) 
=> t / nil"
"This function sets the alpha blending values for the specified highlight set.")
("geSetHilightSetHaloParameters"
"geSetHilightSetHaloParameters(
h_hlSetId
g_haloPosition
g_haloType
g_haloThickNess
g_haloTransparency
[ g_drawStroke ]
)
=> t / nil"
"Sets the halos parameters on the given highlight set in order to draw the set with halos.")
("geShareWindowHilightSet"
"geShareWindowHilightSet(
h_hlSetId 
l_windowList
)
=> t / nil"
"Shares the given window highlight set with other windows.")
("geBackgroundCellView"
"geBackgroundCellView( 
)
=> t / nil"
"Opens the Background CellView form which is used to superimposed cellviews in the same window.")
("geDisableBackgroundCellView"
"geDisableBackgroundCellView( 
[ w_windowId ]
)
=> t / nil"
"Disables the display of the background cellview for the given window (current window by default).")
("geEnableBackgroundCellView"
"geEnableBackgroundCellView( 
w_windowId
[ g_dimmed ]
)
=> t / nil"
"Enables the display of the background cellview in the specified window. The current window is used by default. If the dimmed parameter is set to t, the background cellview is displayed dimmed.")
("geGetBackgroundCellView"
"geGetBackgroundCellView( 
[ w_windowId ] 
)
=> l_cellViewId / l_transform"
"Returns the cellview used for the background cellview.")
("geResetBackgroundCellView"
"geResetBackgroundCellView( 
[ w_windowId ]
)
=> t / nil"
"Resets the background cellview on the given window.")
("geSetBackgroundCellView"
"geSetBackgroundCellView( 
w_windowId 
d_cellViewId | l_libName, cellName, viewName
[ l_transform ]
)
=> t / nil"
"Sets a background cellview on specified window. A cellview ID or a list of libName, cellName, and viewName can be given.")
("geZoomToBackgroundAndEditCV  "
"geZoomToBackgroundAndEditCV ( 
[ w_windowId ]
)
=> t / nil"
"When a background cellview is set on the window, zooms to fit the background cellview and the current edit cellview. If a background cellview is not set on the window, zooms to fit the current edit cellview.")
("geZoomToBackgroundCV  "
"geZoomToBackgroundCV ( 
[ w_windowId ] 
)
=> t / nil"
"When a background cellview is set on the window, zooms to fit the background cellview.")
("geCreateMarker"
"geCreateMarker( 
d_dbobjectId 
t_severity 
t_owner 
t_reason 
t_displayText 
)
=> d_shapeId / nil"
"Creates a box-shaped marker whose size and position are determined by the software.")
("geCreateMarkerByBBox"
"geCreateMarkerByBBox( 
d_cellview 
t_type 
t_owner 
t_reason 
t_displayText 
l_bBox 
)
=> d_shapeId / nil"
"Creates a rectangular marker whose size you define with l_bBox.")
("geCreateMarkerByPoints"
"geCreateMarkerByPoints( 
d_cellview 
t_type 
t_owner 
t_reason 
t_displayText 
l_points 
)
=> d_shapeId / nil"
"Creates a polygon-shaped marker.")
("geDeleteAllMarker"
"geDeleteAllMarker( 
d_cellview 
[ l_owner ] 
[ l_severity ]
[ g_traverse ]
) 
=> t / nil"
"Deletes all markers in d_cellview that have owner l_owner and severity l_severity. If l_owner is specified, l_severity must be specified. All markers in the specified traversal hierarchy are deleted, unless g_traverse argument is specified as nil.")
("geGetMarkerDisplayText"
"geGetMarkerDisplayText( 
d_figId 
)
=> t_string / nil"
"Displays the text associated with a marker.")
("geGetMarkerOwner"
"geGetMarkerOwner( 
d_figId 
)
=> t_string / nil"
"Displays the owner of a marker.")
("geGetMarkerReason"
"geGetMarkerReason( 
d_dbobjectId 
)
=> t_reason / nil"
"Displays the reason for a marker.")
("geGetMarkerType"
"geGetMarkerType( 
d_figId 
)
=> t_type / nil"
"Displays the type of a marker.")
("geHasMarker"
"geHasMarker( 
d_cellview 
[ l_owner ] 
[ l_type ]
)
=> t / nil"
"Queries whether the cellview contains any markers with owner l_owner and type l_type.")
("geHiCommonFindMarker"
"geHiCommonFindMarker( 
)
=> t / nil"
"Opens the Find Marker form and highlights the current marker in the current window.")
("geHiDeleteAllMarker"
"geHiDeleteAllMarker( 
) 
=> t / nil"
"Displays a form that prompts you to select the markers to be deleted from the current cellview.")
("geHiDeleteMarker"
"geHiDeleteMarker( 
)
=> t / nil"
"Deletes the current marker in the current window.")
("geHiExplainMarker"
"geHiExplainMarker( 
)
=> t / nil"
"Explains the current marker in the current cellview.")
("geHiFindMarker"
"geHiFindMarker( 
)
=> t / nil"
"Highlights the current marker in the current window.")
("geIsMarkerShape"
"geIsMarkerShape( 
d_dbobjectId 
)
=> t / nil"
"Checks whether a shape was created as a marker.")
("geAddInstProbe"
"geAddInstProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
)
=> o_probe"
"Adds an instance probe to a window.")
("geEnterAddInstProbe"
"geEnterAddInstProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
[ g_repeatCmd ] 
)
=> o_probe / l_probes"
"Adds an instance probe to a window. The instance probe is displayed using the attributes of layer-purpose pair l_lpp.")
("geGetAdjustedPath"
"geGetAdjustedPath( 
w_winId 
t_pathList 
[ d_cellview ] 
[ t_viewnameList ] 
)
=> t_adjustedPathList"
"Reduces the given hierarchical net path to the shortest hierarchical name that is equivalent to this net.")
("geAddNetProbe"
"geAddNetProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
)
=> o_probe"
"Adds a net probe to a window.")
("geEnterAddNetProbe"
"geEnterAddNetProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
[ g_repeatCmd ] 
)
=> o_probe"
"Adds a net probe to a window.")
("geAddPathProbe"
"geAddPathProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec1 ]
[ lt_probeSpec2 ] 
)
=> o_probe"
"Adds a path probe to a window.")
("geAddTermProbe"
"geAddTermProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
)
=> o_probe"
"Adds a terminal probe to a window.")
("geEnterAddTermProbe"
"geEnterAddTermProbe( 
[ w_windowId ] 
[ l_lpp ] 
[ lt_probeSpec ] 
[ g_repeatCmd ] 
)
=> o_probe"
"Adds a terminal probe to a window.")
("geDeleteAllProbe"
"geDeleteAllProbe( 
[ w_windowId ] 
[ g_crossProbeFlag ] 
)
=> t / nil"
"Removes all the probes from a window.")
("geDeleteInstProbe"
"geDeleteInstProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Deletes an instance probe from a window.")
("geEnterDeleteInstProbe"
"geEnterDeleteInstProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
[ g_repeatCmd ] 
)
=> t / nil"
"Deletes an instance probe from a window.")
("geDeleteNetProbe"
"geDeleteNetProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Deletes a net probe from a window.")
("geEnterDeleteNetProbe"
"geEnterDeleteNetProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
[ g_repeatCmd ] 
)
=> t / nil"
"Deletes a net probe from a window.")
("geDeletePathProbe"
"geDeletePathProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Deletes a path probe from a window.")
("geDeleteProbe"
"geDeleteProbe( 
w_windowId 
o_userType 
[ g_crossProbeFlag ] 
)
=> t / nil"
"Removes a probe from a set of probes in a window.")
("geDeleteTermProbe"
"geDeleteTermProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Deletes a terminal probe from a window.")
("geEnterDeleteTermProbe"
"geDeleteTermProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Deletes a terminal probe from a window.")
("geExplainProbe"
"geExplainProbe( 
[ w_windowId ] 
[ lt_probeSpec ] 
)
=> t / nil"
"Explains the probes in a window.")
("geGetAllProbe"
"geGetAllProbe( 
[ w_windowId ] 
)
=> l_probes / nil"
"Gets a list of all the probes in a window.")
("geSetMaxCreatedProbe"
"geSetMaxCreatedProbe( 
x_maxCreateProbe 
)
=> t / nil"
"Sets the maximum number of created probes.")
("geGetCrossProbeValue"
"geGetCrossProbeValue( 
t_viewTypeName 
)
=> g_value / nil"
"Queries the view type to see if it is set.")
("geGetProbeNetStopLevel"
"geGetProbeNetStopLevel( 
) 
=> x_netDisplayStopLevel"
"Gets the display stop level of net probes.")
("geGetProbeUserLPP"
"geGetProbeUserLPP( 
)
=> l_lpp / nil"
"Gets the layer-purpose pair to be used by the geAdd*Probe functions if no layer-purpose pair is passed into these functions.")
("geAddNetProbeFromTo"
"geAddNetProbeFromTo( 
[ w_windowId ] 
[ l_lpp ] 
)
=> t / nil"
"Adds a probe between two points where there is a connection between two different nets, such as nets separated by feedthrough or nets on different hierarchy but physically connected by pins.")
("geSetLimitedProbe"
"geSetLimitedProbe( 
o_probeObject 
t_dir 
)
=> t / nil"
"Sets the specified probe as a directed probe.")
("geSetProbeDirection"
"geSetProbeDirection( 
o_probeObject 
t_dir 
)
=> t / nil"
"Sets the specified probe as a directed probe.")
("geClearProbeNetFilter"
"geClearProbeNetFilter ( 
d_cellview 
)
=> t / nil"
"If the specified cellview is editable, clears the probe net filtering settings currently saved for the cellview.")
("geGetProbeNetFilter"
"geGetProbeNetFilter( 
d_cellview 
[ g_fromDesign ]
)
=> l_filterSettings / nil"
"Returns the net filtering settings of the Highlight Options form currently in use for the given cellview.")
("geSaveProbeNetFilter"
"geSaveProbeNetFilter ( 
d_cellview 
)
=> t / nil"
"Saves the probe net filtering settings that are currently applied on the given cellview after the geSetProbeNetFilter function is called. After you call the geSaveProbeNetFilter, the settings are reloaded automatically when you open the cellview in a new Virtuoso session.")
("geSetProbeNetFilter"
"geSetProbeNetFilter( 
d_cellview 
t_mode
l_netNames
)
=> t / nil"
"Sets a net filtering for probe on the given cellview.")
("geLoadNextProbe"
"geLoadNextProbe( 
[ w_window ] 
[ p_port ] 
[ s_prop ] 
[ s_cond ]
[ g_value ] 
[ s_loadCount ] 
)
=> t / nil"
"Loads a probe into a window. Identical to geLoadProbe except that s_loadCount is a symbol containing the index of the probe to be loaded.")
("geLoadProbe"
"geLoadProbe( 
[ w_windowId ] 
[ p_port ] 
[ s_prop ] 
[ s_cond ] 
[ g_value ] 
)
=> t / nil"
"Loads probes into a window.")
("geMakeProbeWithColor"
"geMakeProbeWithColor( 
[ ?window w_windowId ]
[ ?name t_name ]
[ ?object g_object ]
[ ?otherObject g_otherObject ]
[ ?color g_color ]
[ ?probeType t_probeType ]
[ ?displayStyle t_displayStyle ] 
[ ?viewTypeList l_viewTypesToCrossProbe ] 
[ ?message t_messageString ] 
)
=> o_probeObject"
"Creates a probe of the specified type and gives it the specified color.")
("geMakeProbeWithoutColor"
"geMakeProbeWithoutColor( 
[ ?window w_windowId ]
[ ?name t_name ]
[ ?object g_object ]
[ ?otherObject g_otherObject ]
[ ?probeType t_probeType ]
[ ?viewTypeList l_viewTypesToCrossProbe ]
[ ?message t_messageString ]
)
=> o_probeObject"
"Creates a probe of the specified type without specifying any colors. The object is highlighted when it is found by specifying the color defined in the geProbeOptionForm. This form can accessed from Option - Probe.")
("geMakeProbeWithLabel"
"geMakeProbeWithLabel( 
[ ?window w_windowId ]
[ ?name t_name ] 
[ ?object g_object ] 
[ ?otherObject g_otherObject ]
[ ?label g_label ]
[ ?probeType t_probeType ]
[ ?displayStyle t_displayStyle ]
[ ?viewTypeList l_viewTypesToCrossProbe ]
[ ?message t_messageString ]
[ ?labelName t_labelName ]
[ ?labelColor l_labelColor ]
[ ?labelOffset l_labelOffset ]
[ ?labelFont t_labelFont ]
[ ?labelFontSize f_labelFontSize ]
[ ?labelJust t_labelJust ]
[ ?labelOrient t_labelOrient ]
) 
=> o_probeObjectId"
"Creates a probe and gives it the specified label.")
("geMakeProbeWithOnColor"
"geMakeProbeWithOnColor( 
[ ?window w_windowId ]
[ ?name t_name ]
[ ?object g_object ]
[ ?otherObject g_otherObject ]
[ ?onColor g_onColor ]
[ ?probeType t_probeType ]
[ ?displayStyle t_displayStyle ]
[ ?viewTypeList g_viewTypesToCrossProbe ]
[ ?message t_messageString ]
)
=> o_probeObjectId"
"Creates an instance probe and gives it the specified color.")
("gePrintAllProbe"
"gePrintAllProbe( 
[ w_windowId ] 
[ p_port ] 
)
=> t / nil"
"Prints a list of the probes in a window.")
("geProbeP"
"geProbeP( 
o_probe 
)
=> t / nil"
"Checks if the value passed in is a probe.")
("geRegCrossProbeTrigger"
"geRegCrossProbeTrigger(
g_ilFunc
x_priority
t_name
)
=> t / nil"
"Registers a trigger function for cross probing.")
("geSaveProbe"
"geSaveProbe( 
[ w_windowId ] 
[ p_port ] 
)
=> t / nil"
"Saves probes to a port.")
("geSetCrossProbeValue"
"geSetCrossProbeValue( 
t_viewTypeName 
[ g_value ] 
)
=> t / nil"
"Sets the view types to cross-probe.")
("geSetProbeNetStopLevel"
"geSetProbeNetStopLevel( 
x_netDisplayStopLevel 
)
=> t / nil"
"Sets the display stop level of net probes.")
("geSetProbeUserLPP"
"geSetProbeUserLPP( 
l_lpp 
)
=> t / nil"
"Sets the layer-purpose pair to be used by the geAdd*Probe functions if no layer-purpose pair is passed in to these functions.")
("geiLoadProbe"
"geiLoadProbe( 
[ w_windowId ] 
)
=> t"
"Displays the Load Probes form.")
("geiSaveProbe"
"geiSaveProbe( 
[ w_windowId ] 
)
=> t"
"Displays the Save Probes form.")
("geCellViewToDlist"
"geCellViewToDlist( 
d_cellview 
)
=> l_dlist / nil"
"Returns a display list of all the objects in a cellview.")
("geLoadIcon"
"geLoadIcon( 
[ t_iconName ] 
[ t_fileName ] 
[ x_width ] 
[ x_height ] 
[ x_bgColor ] 
)
=> t / nil"
"Creates an icon from a SKILL file.")
("geSaveIcon"
"geSaveIcon( 
[ w_windowId ] 
[ t_iconName ] 
[ t_fileName ] 
)
=> t / nil"
"Saves a cellview as a SKILL icon file.")
("geUnRegCrossProbeTrigger"
"geUnRegCrossProbeTrigger(
s_ilFunc
)
=> t / nil"
"Removes the cross probe trigger, if one is registered.")
("geAskOverwriteMode"
"geAskOverwriteMode( 
d_cellviewId 
)
=> t / nil"
"Prompts the user to determine whether or not to overwrite the already open cellview.")
("geClosePolygon"
"geClosePolygon( 
d_cellview 
l_points 
t_snapMode 
)
=> l_pointsPolygon / nil"
"Returns a list of points that describe a closed polygon if a polygon could be made from the specified points. Otherwise, returns nil.")
("geCompressPointArray"
"geCompressPointArray( 
d_cellview 
l_points 
g_closedList 
)
=> l_pointList / nil"
"Searches a point list in a cellview for collinear points and deletes the intermediate collinear points.")
("geCoordp"
"geCoordp( 
coord 
)
=> t / nil"
"Determines whether the data supplied bycoord is a point coordinate.")
("geCreatePacket"
"geCreatePacket( 
w_window
t_name
t_stippleName
t_lineStyleName
t_fillColorName
t_outlineColorName
[ d_lineThickness ]
[ g_reuse ]
[ t_fillStyleName ]
)
=> t / nil"
"Creates or updates a DFII display packet. The reuse flag indicates whether to use an existing display packet with the given name or to update it with given parameters.")
("geGetInstTransform"
"geGetInstTransform( 
d_InstId 
) 
=> list( list( xOffset yOffset ) rotation magnification )"
"Evaluates a path to an instance returned by dbGetTrueOverlaps and concatenates the overall offset, transform, and magnification of the instance placed within the design hierarchy. The value returned by geGetInstTransform is a three member list containing the values of the three variables mentioned above. This transform list can be passed to the functions dbCopyFig or dbMoveFig as their third argument to copy or move the shape to the cellView passed to dbGetTrueOverlaps as its first argument.")
("geGetLockInfo"
"geGetLockInfo( 
t_libName
t_cellName
t_viewName
)
=> t_userHostInfo / no data on lock available"
"Returns the user and host from a .cdslck file.")
("geInstIdToFileSpec"
"geInstIdToFileSpec( 
d_instId 
t_mode 
)
=> l_fileSpec"
"Creates a fileSpec (disassociated property list) from the data in an instance and the given mode.")
("geIsPathReentrant"
"geIsPathReentrant( 
d_cellview 
l_points 
n_width 
[ t_style ] 
[ n_beginExt ] 
[ n_endExt ] 
)
=> t / nil"
"Determines whether a path is self-intersecting.")
("geIsPolygonReentrant"
"geIsPolygonReentrant( 
d_cellview 
l_points 
)
=> t / nil"
"Determines whether a polygon is self-intersecting.")
("geOpen"
"geOpen( 
[ ?window w_windowId ]
[ ?lib t_lib ]
[ ?cell t_cell ]
[ ?view t_view ]
[ ?viewType t_viewType ]
[ ?mode t_mode ]
)
=> w_windowId / nil"
"Opens a design in a new window.")
("geQuerySelSet"
"geQuerySelSet( 
[ w_windowId ] 
)
=> t / nil"
"Displays the properties of each object in the selected set.")
("geRegSaveAllTrigger"
"geRegSaveAllTrigger( 
trigName 
)
=> t / nil"
"Registers a trigger name for the Save All form.")
("geResetCellView"
"geResetCellView( 
d_cellview 
)
=> t / nil"
"Re-displays the last saved version of a cellview.")
("geTransformUserBBox"
"geTransformUserBBox( 
l_bbox 
l_transform 
)
=> l_bBox_new"
"Transforms the specified bounding box by a list describing the offset, orientation, and magnification.")
("geTransformUserPoint"
"geTransformUserPoint( 
l_point 
l_list 
)
=> l_point / nil"
"Transforms a coordinate pair by the displacement and rotation passed in.")
("geValidateWindow"
"geValidateWindow( 
[ w_windowId ] 
)
=> w_windowId / nil"
"Verifies the database ID of a window.")
("geWriteCellView"
"geWriteCellView( 
d_cellview 
t_libName 
t_cellName
t_viewName 
[ t_version ] 
[ d_contextId ] 
)
=> t / nil"
"Creates a copy of a cellview.")
("geCreateBend"
"geCreateBend( 
d_cellview 
txl_layerPurpose 
l_points 
f_width1 
f_width2 
t_bendStyle 
f_bendFac 
f_radFac 
f_chamFac 
x_nPtsToPI 
)
=> d_bendId / nil"
"Creates a transmission line bend in a cellview.")
("geCreateTaper"
"geCreateTaper( 
d_cellview 
txl_layerPurpose 
l_points 
f_width1 
f_width2 
t_taperStyle 
x_nPtsToTaper 
)
=> d_taperId / nil"
"Creates a tapered transmission line in a cellview.")
("geCreateTrl"
"geCreateTrl( 
d_cellview 
txl_layerPurpose 
l_points 
f_width 
t_bendStyle 
f_bendFac 
f_radFac 
f_chamFac 
x_nPtsToPI 
) 
=> d_trlId / nil"
"Creates a transmission line in a cellview.")
("mouseAddPt"
"mouseAddPt( )"
"Adds the point at the location where you clicked the mouse button to the enter function in the current window.")
("mouseAddSelectPt"
"mouseAddSelectPt( )"
"Performs an add mode point selection at the point you click in the current window.")
("mouseFinishPt"
"mouseFinishPt( )"
"Adds the point at the location where you clicked the mouse button to the enter function in the current window and completes the enter function, if possible.")
("mousePopUp"
"mousePopUp( )"
"Displays the popup menu associated with the given windowId, which must be a valid data structure returned by a call to hiOpenWindow or hiCreateWindow.")
("mouseSingleSelectPt"
"mouseSingleSelectPt( )"
"Performs a single mode point selection at the point you click in the current window.")
("mouseSubSelectPt"
"mouseSubSelectPt( )"
"Performs a sub-mode point selection at the point you click in the specified window.")
("mouseUndoPt"
"mouseUndoPt( )"
"Deletes the point at the location where you clicked the mouse button to the enter function and cancels the enter function in the current window.")
("dbGetDatabaseType"
"dbGetDatabaseType(
)
=> CDBA / OpenAccess"
"Returns CDBA when called from a regular CDB executable, and OpenAccess when called from an OpenAccess executable.")
("dbIsId"
"dbIsId( 
d_id 
) 
=> t / nil"
"Returns t if the argument is a valid database object ID, otherwise, it returns nil.")
("dbValidP"
"dbValidP( 
d_id
) 
=> t / nil"
"Determines if the argument is a valid database object ID.")
("dbobjectp"
"dbobjectp( 
d_id
)
=> t / nil"
"Determines if its argument is a database object.")
("dbCreateSigNetExpr"
"dbCreateSigNetExpr( 
d_sigId 
t_netExpression 
)
=> t / nil"
"Given an inherited net expression in t_netExpression and a signal id in d_sigId, this function attaches the inherited net expression to the given signal and adds the signal to the set of signals having inherited net expressions.")
("dbCreateTermNetExpr"
"dbCreateTermNetExpr( 
d_termId 
t_netExpression 
) 
=> t / nil"
"Given an inherited net expression in t_netExpression and a term ID, in d_termId, this function attaches the inherited net expression to the given terminal and adds the terminal to the set of terminals having inherited net expressions.")
("dbCVHasInheritedSig"
"dbCVHasInheritedSig( 
d_cellViewid 
)
=> t / nil"
"Checks if there is any inherited signal in the given cellview.")
("dbCVHasInheritedTerm"
"dbCVHasInheritedTerm( 
d_cellViewId 
)
=> t / nil"
"Checks whether there is any inherited terminal in the given cellview.")
("dbCVHasNetSetProp"
"dbCVHasNetSetProp( 
d_cellviewId
) 
=> t / nil"
"Determines if the netSet property is set on a cellview.")
("dbDeleteSigNetExpr"
"dbDeleteSigNetExpr( 
d_sigId 
)
=> t / nil"
"Given a signal IDin d_sigId, this function deletes any existing inherited net expression associated with this signal and removes it from the set of inherited signals.")
("dbDeleteTermNetExpr"
"dbDeleteTermNetExpr( 
d_termId 
)
=> t / nil"
"Given d_termId, this function deletes any existing inherited net expression associated with this terminal and removes it from the set of inherited terminals.")
("dbFix"
"dbFix( 
d_cellViewId
[ ?reBind g_reBind ]
)
=> t / nil"
"Fixes data corruption in inherited connectivity, rectangle, and instance header. This is a no-op function.")
("dbGetCellViewInheritedSig"
"dbGetCellViewInheritedSig( 
d_cellViewId 
)
=> l_sigId / nil"
"Retrieves from the given cellview all signals to which inherited net expressions are attached.")
("dbGetCellViewInheritedTerm"
"dbGetCellViewInheritedTerm( 
d_cellViewId 
)
=> l_termId / nil"
"Retrieves from the given cellview all terminals to which inherited net expressions are attached.")
("dbGetSigNetExpr"
"dbGetSigNetExpr( 
d_sigId 
)
=> t_netExpression / nil"
"Retrieves any inherited net expression found attached to the signal.")
("dbGetTermNetExpr"
"dbGetTermNetExpr( 
d_termId 
)
=> t_netExpression / nil"
"Retrieves any inherited net expression found attached to the terminal.")
("dbIsValidSigNetExpr"
"dbIsValidSigNetExpr( 
t_netExpression 
)
=> t / nil"
"Given an inherited net expression in the t_netExpression associated with a signal, this function checks whether its syntax is valid. This function does as much local checking as possible, but it does not detect whether the given default net name is global, nor whether the evaluation of the property results in a valid net name.")
("dbIsValidTermNetExpr"
"dbIsValidTermNetExpr( 
t_netExpression 
)
=> t / nil"
"Given an inherited net expression in t_netExpression associated with a terminal, this function checks whether its syntax is valid. This function does as much local checking as possible, but it does not detect whether the given default net name is global nor whether the evaluation of the property results in a valid net name.")
("dbIsSigInherited"
"dbIsSigInherited( 
d_sigId 
) 
=> t / nil"
"Given a signal id in sigId, this function checks if there is an inherited net expression attached to it.")
("dbIsTermInherited"
"dbIsTermInherited( 
d_termId 
)
=> t / nil"
"Checks whether there is an inherited net expression attached to the given terminal.")
("dbParseSigNetExpr"
"dbParseSigNetExpr( 
t_netExpression 
)
=> t_searchScope
   t_propName 
   t_formatString 
   t_defaultNetName / nil"
"Parses the expression and returns the individual components of the expression that include the search scope, the property name to be used in searching, the format string, and the default net name.")
("dbParseTermNetExpr"
"dbParseTermNetExpr( 
t_netExpression 
) 
=> t_searchScope
	t_propName 
	t_formatString 
	t_defaultNetName / nil"
"Parses the expression and returns the individual components of the expression that include the search scope, the property name to be used in searching, the format string, and the default net name.")
("dbReplaceSigNetExpr"
"dbReplaceSigNetExpr( 
d_sigId 
t_netExpression 
)
=> t / nil"
"Replaces any existing inherited net expression already associated with the signal. If none exists, t_netExpression is attached to the given signal and adds the signal to the set of signals having inherited net expressions.")
("dbReplaceTermNetExpr"
"dbReplaceTermNetExpr( 
d_termId 
t_netExpression 
)
=> t / nil"
"Replaces any existing inherited net expression already associated with the terminal. If none exists, t_netExpression is attached to the given terminal and adds the terminal to the set of terminals having inherited net expressions.")
("dbSetUndoHandle"
"dbSetUndoHandle(
t_handleName 
[ g_moveHandle ]
)
=> t / nil"
"Sets an undo handle with the specified name on the current undo checkpoint. If there already exists a handle with the same name, you can optionally specify that the existing handle is moved from its current position in the undo stack and associated with the current undo checkpoint.")
("dbUndoToHandle"
"dbUndoToHandle(
[ t_handleName ]
)
=> t / nil"
"Invokes undo back to the given handle. If no handle name is given, rolls back to the last labeled checkpoint.")
("dbGetUndoHandles"
"dbGetUndoHandles(
)
=> l_handlelist"
"Returns a list of handles in the undo stack.")
("dbGetRedoHandles"
"dbGetRedoHandles(
)
=> l_handlelist"
"Returns a list of handles in the redo stack.")
("dbRedoToHandle"
"dbRedoToHandle(
[ t_handleName ]
)
=> t / nil"
"Invokes redo up to the given handle. If no handle name is given, it rolls forward to the next labeled checkpoint.")
("dbEnableUndo"
"dbEnableUndo(
)
=> t / nil"
"Enables undo and redo operations in a Virtuoso session.")
("dbFreeze"
"dbFreeze( 
d_topCellViewId
t_regLibName
t_pcellLibName
[ g_cleanUp ]
)
=> d_figGroupId / nil"
"Freezes a pcell design hierarchy into a non-pcell design hierarchy by converting a pcell instance into a static instance and converting a pcell customVia into a static customVia. If t_regLibName and t_pcellLibName are different, regular and pcell frozen instances will be put into two different libraries.")
("dbGetFluidShapeByName"
"dbGetFluidShapeByName(
d_cellViewId
t_shapeName
) 
=> d_fluidShapeId"
"Returns the database ID for a specified fluid shape name in a given cellview.")
("dbGetFluidShapeName"
"dbGetFluidShapeName(
d_shapeId
)
=> t_FluidName / nil"
"Returns the fluid name of the specified shape if it is a fluid shape.")
("dbGetFluidShapes"
"dbGetFluidShapes(
d_cvId
)
=> l_fluidShapes"
"Returns all fluid shapes on the specified cellviewdbGetFluidShapes.")
("dbIsFluidPcell"
"dbIsFluidPcell(
d_cellViewId
)
=> t / nil"
"Checks if submaster belongs to a Fluid Pcell supermaster.")
("dbIsFluidShape"
"dbIsFluidShape(
d_shapeId
)
=> t / nil"
"Checks if the specified shape is marked as a Fluid shape.")
("dbSetFluidShape"
"dbSetFluidShape(
d_shapeId 
t_fluidName
)
=> t / nil"
"Sets the given name for the specified shape to mark it as a fluid shape. This function can be used only in a sub-master layout view, for example, during Pcell generation.")
("dbAbutIsInteractive"
"dbAbutIsInteractive(
)
=> t / nil"
"This function is used by user-defined abutment functions. It indicates if the call to the abutment function was triggered by an interactive action.")
("dbAbutIsReAbutGroup"
"dbAbutIsReAbutGroup(
d_groupID
)
=> t / nil"
"When called during abutment event 3 (un-abutment), the SKILL function indicates if re-abutment of Pcell instances will be triggered immediately after un-abutment. If the SKILL function returns true, the PDK SKILL function can store relevant information, if needed, from the current abutment group.")
("dbSetFigAbutName"
"dbSetFigAbutName(
d_figId
t_abutName
)
=> t / nil"
"Assigns a unique abutment name to the figure associated with the given ID (d_figId). If you set the name to an empty string, Virtuoso clears any existing abutment names specified for the figure ID.")
("dbSetFigAbutRefName"
"dbSetFigAbutRefName(
d_figId
t_abutRefName
)
=> t / nil"
"Assigns an abutment reference name to the specified figure associated with the given ID (d_figId). If you set the name to an empty string, Virtuoso clears any existing abutment reference names specified for the figure ID.")
("dbGetFigAbutName"
"dbGetFigAbutName(
d_figId

=> t_abutName / nil"
"Retrieves the abutment name assigned to the figure associated with the given ID (d_figId).")
("dbGetFigAbutRefName"
"dbGetFigAbutRefName(
d_figId
)
=> t_abutname / nil"
"Retrieves the abutment reference name assigned to the figure associated with the given ID (d_figId).")
("dbHasFigAbutName"
"dbHasFigAbutName(
d_figId
)
=> t / nil"
"Returns a Boolean value indicating whether an abutment name was assigned to the figure associated with the given ID (d_figId)")
("dbHasFigAbutRefName"
"dbHasFigAbutRefName(
d_figId
)
=> t / nil"
"Returns a Boolean value indicating whether an abutment reference name was assigned to the figure associated with the given ID (d_figId)")
("dbFindAbutFig"
"dbFindAbutFig(
d_cvId
t_abutName
)
=> d_figId / nil"
"Searches for the figure with the specified abutment name in the given subMaster cellview and returns the ID of the searched figure.")
("dbUnabutGroup"
"dbUnabutGroup(
d_groupID
)
=> t / nil"
"Unabuts members of an abutment group.")
("dbCopyShape"
"dbCopyShape(
d_shapeId
d_cellviewId
[ l_transform ] 
)
=> d_newShapeId / nil"
"Copies a shape to the specified cellview with the given transformation.")
("dbCreateLine"
"dbCreateLine( 
d_cellView 
txl_layerPurpose
l_points 
) 
=> d_line / nil"
"Creates a line.")
("dbCreatePath"
"dbCreatePath( 
d_cellView 
txl_layerPurpose
l_points 
n_width 
[ t_pathStyle ] 
) 
=> d_path / nil"
"Creates a path.")
("dbCreatePolygon"
"dbCreatePolygon( 
d_cellView 
txl_layerPurpose
l_points 
) 
=> d_polygon / nil"
"Creates a polygon.")
("dbCreateRect"
"dbCreateRect( 
d_cellView 
txl_layerPurpose
l_bBox 
) 
=> d_rect / nil"
"Creates a rectangle.")
("dbCreateEllipse"
"dbCreateEllipse( 
d_cellView 
txl_layerPurpose
l_bBox 
) 
=> d_ellipse / nil"
"Creates an ellipse.")
("dbCreateArc"
"dbCreateArc( 
d_cellView 
txl_layerPurpose
l_ellipse_bBox 
l_arc_bBox 
) 
=> d_arc / nil"
"Creates an arc.")
("dbCreateDonut"
"dbCreateDonut( 
d_cellView 
txl_layerPurpose 
l_point 
x_outR 
x_holeR 
) 
=> d_donut / nil"
"Creates a donut (two concentric circles).")
("dbCreateDot"
"dbCreateDot( 
d_cellView 
txl_layerPurpose 
l_point 
) 
=> d_dot / nil"
"Creates a dot.")
("dbCreateLabel"
"dbCreateLabel( 
d_cellView 
txl_layerPurpose
l_point 
t_label 
t_just 
t_orient 
t_font 
x_height 
) 
=> d_label / nil"
"Creates a graphic text-string label.")
("dbCreateTextDisplay"
"dbCreateTextDisplay( 
d_associateId 
d_ownerId 
txl_layerPurpose
l_displayFlags 
l_point 
t_just 
t_orient 
t_font 
x_height 
[ g_isDrafted [ g_isOverbar [ g_isVisible [ g_isNameVisible [ g_isValueVisible [ t_attrOrParamName [ g_isParamAssoc ] ] ] ] ] ] ] 
) 
=> d_textDisplay / nil"
"Creates a text display object.")
("dbHasShape"
"dbHasShape( 
d_cellviewId 
) 
=> t / nil"
"Checks whether the specified cellview contains any shapes.")
("dbMoveShape"
"dbMoveShape( 
shapeId 
cellviewId
[l_transform] 
)
=> d_shapeId / nil"
"Moves a shape to given cellview with given transformation.")
("dbSetTextDisplayNameValueVisible"
"dbSetTextDisplayNameValueVisible( 
d_tdId
g_isNameVisible
g_isValueVisible
)
=> t / nil"
"Sets the isNameVisible and the isValueVisible flags. The isNameVisible flag sets the text display name visibility. When this flag is set to true, the name of the text display will be visible. The isValueVisible flag sets the text display value visibility. When this flag is set to true, the value of the text display will be visible.")
("dbConvertArcToLine"
"dbConvertArcToLine( 
d_arc 
x_nSides 
) 
=> d_line / nil"
"Converts an arc to a line. A line is defined as a number of connecting segments.")
("dbConvertDonutToPolygon"
"dbConvertDonutToPolygon( 
d_donut 
x_nSides 
) 
=> d_polygon / nil"
"Converts a donut to a polygon.")
("dbConvertEllipseToPolygon"
"dbConvertEllipseToPolygon( 
d_ellipse 
x_nSides 
) 
=> d_polygon / nil"
"Converts an ellipse to a polygon.")
("dbConvertPathToPolygon"
"dbConvertPathToPolygon( 
d_path 
) 
=> d_polygon / nil"
"Converts a path to a polygon with the same number of points as the path.")
("dbConvertPathSegToPolygon"
"dbConvertPathSegToPolygon( 
d_pathSeg 
) 
=> d_polygon / nil"
"Converts a pathseg to a polygon based on the boundary list.")
("dbConvertLineToPath"
"dbConvertLineToPath( 
d_line 
x_width 
[ t_pathStyle ] 
) 
=> d_path / nil"
"Converts a line to a path.")
("dbConvertRectToPolygon"
"dbConvertRectToPolygon(
d_rect
)
=> d_polygon / nil"
"Converts a rectangle into a polygon.")
("dbCompressPointArray"
"dbCompressPointArray( 
l_pointArray 
x_isClosed 
[ f_DBUPerUU ] 
) 
=> l_newPointArray"
"Compresses collinear points in a list of points.")
("dbCreateParamSimpleMosaic"
"dbCreateParamSimpleMosaic( 
d_cellView 
d_masterCellView 
t_name 
l_origin 
l_orient 
x_rows 
x_cols 
n_rowSpacing 
n_colSpacing 
l_params 

) 
=> d_mosaic / nil"
"Creates a parameterized simple mosaic (from the master d_masterCellView) in d_cellView, with an origin and orientation specified by l_origin and l_orient.")
("dbCreateParamSimpleMosaicByMasterName"
"dbCreateParamSimpleMosaicByMasterName( 
d_cellView 
t_libName
t_cellName 
t_viewName 
t_name 
l_origin 
l_orient 
x_rows 
x_cols 
n_rowSpacing 
n_colSpacing 
l_params 

) 
=> d_mosaic / nil"
"Creates a parameterized simple mosaic (from the master t_libName/t_cellName/t_viewName) in d_cellView, with an origin and orientation specified by l_origin and l_orient.")
("dbCreateSimpleMosaic"
"dbCreateSimpleMosaic( 
d_cellView 
d_masterCellView 
t_name 
l_point 
t_orient 
x_rows 
x_cols 
n_rowSpacing 
n_colSpacing 
) 
=> d_mosaic / nil"
"Creates a simple mosaic in the cellview from the master d_masterCellView.")
("dbFindMosaicByName"
"dbFindMosaicByName(
d_cellViewId 
t_name
) 
=> d_mosaicId / nil"
"Returns a mosaic ID if a mosaic with the given name is found in the cellview specified.")
("dbCreateProp"
"dbCreateProp( 
g_object 
t_name 
t_propType 
g_value 
) 
=> d_prop / nil"
"Creates a scalar property for an object. If a property named t_name already exists on the specified object, it returns nil.")
("dbCreateRangeProp"
"dbCreateRangeProp( 
g_object 
t_name 
t_propType 
g_value 
g_lBound 
g_uBound 
) 
=> d_prop / nil"
"Creates a range property for an object.")
("dbCreateEnumProp"
"dbCreateEnumProp( 
g_object 
t_name 
t_value 
l_string 
) 
=> d_prop / nil"
"Creates an enumerated property for an object.")
("dbCreateHierProp"
"dbCreateHierProp( 
g_object 
t_name 
) 
=> d_prop / nil"
"Creates a hierarchical property for an object.")
("dbFindProp"
"dbFindProp( 
d_object 
t_name 
) 
=> d_propId / nil"
"If a property of the given name is found on the object specified, d_propId of the property is returned; otherwise, nil is returned. This function has the same functionality as dbGetPropByName.")
("dbGetPropByName"
"dbGetPropByName(
d_object 
t_name
) 
=> d_propId / nil"
"If a property of the given name is found on the object specified, d_propId of the property is returned; otherwise, nil is returned.")
("dbReplaceProp"
"dbReplaceProp( 
g_object 
t_name 
t_propType 
g_value 
) 
=> d_prop / nil"
"Replaces a scalar property for an object. Calls to dbReplaceProp for abutment groups must be made before calls to dbReplaceProp for pcell properties.")
("dbReplaceRangeProp"
"dbReplaceRangeProp( 
g_object 
t_name 
t_propType 
g_value 
g_lBound 
g_uBound 
) 
=> d_prop / nil"
"Replaces a range property for an object.")
("dbReplaceEnumProp"
"dbReplaceEnumProp( 
g_object 
t_name 
t_value 
l_string 
) 
=> d_prop / nil"
"Replaces an enumerated property for an object.")
("dbReplaceHierProp"
"dbReplaceHierProp( 
g_object 
t_name 
) 
=> d_prop / nil"
"Replaces a hierarchical property for an object.")
("dbCopyProp"
"dbCopyProp( 
g_object1 
g_object2 
) 
=> t / nil"
"Copies all the properties of one database object to another database object.")
("dbCopyPropList"
"dbCopyPropList( 
d_dbId1
d_dbId2
)
=> t / nil"
"Copies all the properties from the database object given in the first argument to the database object given in the second argument in a single, atomic, copy operation. Properties with the same name in the destination object are overwritten. If the given database objects are pcell instances, then pcell evaluation happens once after all the properties are copied.")
("dbResetPropList"
"dbResetPropList(
d_object 
l_props 
)
=> t / nil"
"Resets a list of properties on a given object with the specified list of properties.")
("dbDeletePropByName"
"dbDeletePropByName( 
g_object 
t_name 
) 
=> t / nil"
"Deletes a property from an object.")
("dbCopySingleProp"
"dbCopySingleProp( 
d_srcPropId 
g_dstObjId 
) 
=> d_dstPropId"
"Copies a single property to a destination object.")
("dbMergeSingleProp"
"dbMergeSingleProp( 
d_srcPropId 
g_dstObjId 
) 
=> d_dstPropId"
"Merges a property with a destination object without overwriting the property if it already exists.")
("dbReplacePropList"
"dbReplacePropList( 
g_object 
l_params 
) 
=> t / nil"
"Replaces the specified list of properties (l_params) in the given object. dbReplacePropList will trigger Pcell evaluation once as an atomic operation.")
("dbSearchPropByName"
"dbSearchPropByName( 
d_object 
t_name 
) 
=> d_propId / nil"
"Searches for the specified property.")
("dbDeleteObject"
"dbDeleteObject(
d_object
)
=> t / nil"
"Deletes one of the following objects: shapes, nets, terminals, instance terminals, pins, instance pins, mosaics, instances, mosaic instances, properties, groups, and group members. Any other object type produces an error.")
("dbAddObjectToGroup"
"dbAddObjectToGroup( 
d_group 
d_object 
) 
=> d_groupMem / nil"
"Adds a database object to a group.")
("dbChangeGroupType"
"dbChangeGroupType( 
d_groupId
l_groupType
) 
=> t / nil"
"Changes the type of a group.")
("dbCreateGroup"
"dbCreateGroup( 
d_cellViewID 
t_groupName 
l_groupType 
[ t_groupDefName ]
) 
=> d_group / nil"
"Creates a group of the specified group definition in the specified cellview. If a group definition is not specified, a traditional, unrestricted group is created, which allows all types of objects and all types of groups as members and can exist in any database.")
("dbDeleteGroupByName"
"dbDeleteGroupByName( 
d_cellView 
t_name 
) 
=> t / nil"
"Deletes a group and its members from a cellview.")
("dbDeleteObjectFromGroup"
"dbDeleteObjectFromGroup( 
d_group 
d_object 
) 
=> t / nil"
"Deletes an object from a group.")
("dbGetGroupByName"
"dbGetGroupByName( 
d_cellviewId
t_groupName 
)
=> d_groupId / nil"
"Returns the database ID of the group specifed by name.")
("dbGetGroupsWithDef"
"dbGetGroupsWithDef( 
d_cellViewID 
t_groupDefName
) 
=> d_group / nil"
"Returns a list of groups in the specified cellview and of the specified group definition name.")
("dbMoveGroupMember"
"dbMoveGroupMember( 
d_groupMem1 
[ d_groupMem2 ] 
) 
=> t / nil"
"Moves group member d_groupMem1 immediately after group member d_groupMem2.")
("dbDeleteGroupMemberFromGroup"
"dbDeleteGroupMemberFromGroup(
d_groupMemId 
) 
=> t / nil"
"Deletes a particular group member from the group to which it belongs.")
("dbTransformCellView"
"dbTransformCellView( 
d_cellViewId 
f_mag 
f_angle
) 
=> t / nil"
"Scales (magnifies) and/or rotates all shapes in a cellview.")
("dbTransformPoint"
"dbTransformPoint( 
l_point 
l_list 
) 
=> l_point / nil"
"Transforms a coordinate pair.")
("dbTransformPointList"
"dbTransformPointList( 
l_points
l_transform
) 
=> l_points / nil"
"Transforms all points in an array in the same way as dbTransformPoint does with a single point. This function does not modify the original array, and returns the transformed array.")
("dbTransformBBox"
"dbTransformBBox( 
l_bBox 
l_list 
) 
=> l_bBox_new"
"Transforms a bounding box.")
("dbConcatTransform"
"dbConcatTransform( 
l_transform1 
l_transform2 
) 
=> l_transform_new"
"Merges two individual transformations into a single new transformation. 

For example, the call(dbMoveFig F cv (dbConcatTransform T1 T2)) results in figure F being moved to the same position and orientation as two successive calls to dbMoveFig in the following order: 
      (dbMoveFig F cv T1)
      (dbMoveFig F cv T2)")
("dbCanonicalizeAnyAngleTransform"
"dbCanonicalizeAnyAngleTransform(
g_anyAngleTransform...
) 
=> list(t_orient f_acuteAngleDeg)"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Canonicalizes composition of the given transformations into a pair of orientation angles and a non-negative acute angle. Transformations are either numbers representing counter-clockwise rotation in degrees or strings representing orientation. The effect of transformation by the composition of the transformations in the return value is the same as effect of transformation by the composition of all input transformations.")
("dbConvertAnyAngleTransformFromDbToMY"
"dbConvertAnyAngleTransformFromDbToMY(
t_orient 
f_angleDeg
) 
=> list(f_angleDeg g_MY)"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Converts orientation-based representation of an orthogonal transformation into an MY-based representation. Orientation-based representation is a pair of DB orientation and any-angle rotation with the rotation applied first. The MY-based representation is a pair of any-angle rotation and an optional reflection over a Y-axis with the reflection applied first.")
("lowerLeft"
"lowerLeft( 
l_bBox
)
=> l_list"
"Returns the lower left point of the given bounding box. The bounding box is not validated and assumed to be correct.")
("upperRight"
"upperRight( 
l_bBox
)
=> l_list"
"Returns the upper right point of the given bounding box. The bounding box is not validated and is assumed to be correct.")
("leftEdge"
"leftEdge( 
d_object 
)
=> g_coordinate / nil"
"Returns the lower left point's X coordinate of the figure's bounding box.")
("rightEdge"
"rightEdge( 
d_object 
)
=> g_coordinate / nil"
"Returns the upper right point's X coordinate of the figure's bounding box.")
("bottomEdge"
"bottomEdge( 
d_object 
)
=> g_coordinate / nil"
"Returns the lower left point's Y coordinate of the figure's bounding box.")
("topEdge"
"topEdge( 
d_object 
)
=> g_coordinate / nil"
"Returns the upper right point's Y coordinate of the figure's bounding box.")
("centerBox"
"centerBox( 
l_bBox 
)
=> l_point / nil"
"Returns the center point of the given bounding box. The bounding box is not validated and is assumed to be correct.")
("isLocation"
"isLocation( 
l_point 
)
=> t / nil"
"Validates that the given point is properly defined.")
("isBBox"
"isBBox( 
l_bBox 
)
=> t / nil"
"Validates that the given bounding box is properly defined.")
("dbOpenBag"
"dbOpenBag( 
g_ddObject 
t_mode 
) 
=> g_bagId / nil"
"Opens the library, cell, or view property bag in the given mode.")
("dbReOpenBag"
"dbReOpenBag( 
g_bagId 
t_mode 
) 
=> t / nil"
"Reopens the given g_bagId for the given mode.")
("dbGetBag"
"dbGetBag( 
g_ddObject 
) 
=> g_bagId / nil"
"Opens the property bag in read mode for the given ddId object.")
("dbGetBagOwner"
"dbGetBagOwner( 
g_bagId 
) 
=> g_ddId / nil"
"Returns the owner of the specified property bag. The owner could be a library, cell, or view.")
("dbCloseBag"
"dbCloseBag( 
g_bagId 
[t_mode] 
) 
=> t / nil"
"Closes the property bag in the given mode.")
("dbPurgeBag"
"dbPurgeBag( 
g_bagId 
) 
=> t / nil"
"Forces a property bag to close and removes it from virtual memory.")
("dbRefreshBag"
"dbRefreshBag( 
g_bagId 
) 
=> t / nil"
"Refreshes the virtual memory image of the property bag by the one from the disk. If the disk file does not exist and the bag is in edit mode, then the virtual memory is truncated.")
("dbMakeBagCurrent"
"dbMakeBagCurrent( 
g_bagId 
) 
=> t / nil"
"Refreshes the given property bag if it is out of date relative to the one on disk.")
("dbSaveBag"
"dbSaveBag( 
g_bagId 
) 
=> t / nil"
"Writes the virtual memory image of the property bag to disk.")
("dbIsBagReadable"
"dbIsBagReadable( 
g_ddObject 
) 
=> t / nil"
"Checks if the property bag exists on disk for the given ddId object and if the user has read access for that property bag file.")
("dbIsBagWritable"
"dbIsBagWritable( 
g_ddObject 
) 
=> t / nil"
"Returns the UNIX file permission of the file that contains the property information. For example, basic is a system owned library, dbIsBagWritable will always return nil on its property. If you own a library, and its prop.xx has write permission, even if the bag is opened in r mode, dbIsBagWritable will still return t. A new property bag that exists only in VM is not considered writable.")
("dbGetBagTimeStamp"
"dbGetBagTimeStamp( 
g_bagId 
) 
=> t_time / nil"
"Returns the last time that the bag was modified.")
("dbFindOpenBag"
"dbFindOpenBag( 
d_ddId 
) 
=> g_bagId / nil"
"Finds an opened bag in virtual memory for the specified d_ddId.")
("dbGetBagDdId"
"dbGetBagDdId( 
g_bagId 
) 
=> d_ddId / nil"
"Returns the ddId associated with the specified bagId.")
("dbGetOpenBags"
"dbGetOpenBags( 
) 
=> d_bags / nil"
"Returns a list of the currently open property bags.")
("dbIsBagId"
"dbIsBagId( 
g_bagId 
) 
=> t / nil"
"Returns t if the specified ID is a valid bagId, otherwise, it returns nil.")
("dbLayerAnd"
"dbLayerAnd( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2 
[ x_numVertices ]
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of objects derived from the overlap of objects on the input lists. This function generates the areas common to both input lists. The resulting objects are created in the specified layer and cellview.")
("dbLayerAndNot"
"dbLayerAndNot( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2 
[ x_numVertices ]
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects derived from areas of the first input list that do not overlap any area of the second input list and creates the resulting objects in the specified layer and cellview.")
("dbLayerOr"
"dbLayerOr( 
d_cellViewId
t_layerName
l_dbIdList1
[ l_dbIdList2 ]
[ x_numVertices ]
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects that encompass all areas on input lists and creates the resulting objects in the specified layer and cellview.")
("dbLayerXor"
"dbLayerXor( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2
[ x_numVertices ]
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects derived from those portions of either input list that do not overlap the other list and creates the resulting objects in the specified layer and cellview.")
("dbLayerSize"
"dbLayerSize( 
d_cellViewId
t_layerName
l_dbIdList1
n_value
[ x_numVertices ]
[ g_mfgGrid ]
[ x_conicSides ] 
) 
=> l_dbIdList"
"Performs an oversizing or undersizing operation on the object specified in the input list.")
("dbLayerTile"
"dbLayerTile( 
d_cellViewId
t_layerName
l_dbIdList1
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Fractures edges of the specified object on the input list into vertical trapezoids.")
("dbLayerStraddle"
"dbLayerStraddle( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects from those shapes on the first layer that straddle shapes on the second layer. A shape is straddling, if part of its area is covered by part of the shape on the second layer and part is not. The return list also includes copies of shapes that are touching these straddling shapes.
Butting and coincident edges do not affect this function.")
("dbLayerNoHoles"
"dbLayerNoHoles( 
d_cellViewId
t_layerName
l_dbIdList1
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects from those areas consisting of all the original shapes of the input list without holes. A hole is an area created when the perimeter of a polygon touches itself, enclosing an area that is not the polygon.")
("dbLayerHoles"
"dbLayerHoles( 
d_cellViewId
t_layerName
l_dbIdList1
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of new objects from those areas consisting of all the holes in shapes of the input list. A hole is an area created when the perimeter of a polygon touches itself, enclosing an area that is not the polygon.")
("dbLayerInside"
"dbLayerInside( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Creates a new merged object for each overlapping object on dbIdList1 that is completely enclosed by an object on dbIdList2 and returns a list of the new object/objects created. A shape on dbIdList1 is considered inside if its entire area is enclosed by the area of a shape on dbIdList2. Coincident shapes are considered inside in this check. If both shapes are coincident on all sides, then each shape can be defined as being inside the other.")
("dbLayerOutside"
"dbLayerOutside( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Creates a new object for each object on dbIdList1 that is not enclosed by any object on dbIdList2 and returns a list of the new object created. A shape on dbIdList1 is considered outside if none of its area is enclosed by the area of a shape on dbIdList2. Coincident shapes are considered inside in this check. Butting edges are considered outside.")
("dbLayerEnclose"
"dbLayerEnclose( 
d_cellViewId
t_layerName
l_dbIdList1
l_dbIdList2
[ g_mfgGrid ]
) 
=> l_dbIdList"
"Returns a list of shapes on the first list that enclose shapes on the second list. A shape is enclosing the other if the entire area of a second shape is covered by first shape.")
("dbPointArrayAnd"
"dbPointArrayAnd( 
d_cellViewId
l_pointList1
l_pointList2 
[ x_maxPoints ]
) 
=> l_pointList / nil"
"Returns a list of point lists derived from the overlap of shapes in the two input point lists. This function generates the areas common to both the input lists. The resulting point list is created in the specified cellview.")
("dbPointArrayAndNot"
"dbPointArrayAndNot( 
d_cellViewId
l_pointList1
l_pointList2
[ x_maxPoints ]
) 
=> l_pointList / nil"
"Returns a list of point lists derived from the area of the first input point list that does not overlap any area of the second input point list. The resulting point list is created in the specified cellview.")
("dbPointArrayOr"
"dbPointArrayOr( 
d_cellViewId
l_pointList1
[ l_pointList2 ]
[ x_maxPoints ]
) 
=> l_pointList / nil"
"Returns a list of point lists derived from the union of shapes in the two input point lists. The resulting point list is created in the specified cellview. If the second input point list is not specified, the first input point list is returned.")
("dbPointArraySize"
"dbPointArraySize( 
d_cellViewId
l_pointList
n_value
[ x_maxPoints ]
) 
=> l_pointList / nil"
"Returns a list of point lists derived after performing an over size or under size operation on the shapes specified in the input list. The resulting point list is created in the specified cellview.")
("dbPointArrayXor"
"dbPointArrayXor( 
d_cellViewId
l_pointList1
l_pointList2
[ x_maxPoints ]
) 
=> l_pointList / nil"
"Returns a list of point lists derived from portions of both the inputs lists that do not overlap the points in the other input list.")
("dbSetTermSoftConnect"
"dbSetTermSoftConnect ( 
d_termId 
b_value 
) 
=> t / nil"
"Sets the softConnect attribute of the specified terminal to the given value.")
("dbGetSoftConnectTermConnectToLayer"
"dbGetSoftConnectTermConnectToLayer ( 
d_termId 
) 
=> x_layer"
"Returns the connectToLayer of the softConnect terminal as a layer number. If the connectToLayer is not set for this terminal, an error is reported and nil is returned.")
("dbGetSoftConnectTermPinlessLayer"
"dbGetSoftConnectTermPinlessLayer ( 
d_termId 
) 
=> tx_layer"
"Returns the pinlessTerminalLayer of the softConnect terminal as a layer name or number. If the pinlessTerminalLayer is not set for this terminal, an error is reported and nil is returned.")
("dbIsTermSoftConnect"
"dbIsTermSoftConnect ( 
d_termId 
) 
=> t / nil"
"Checks the softConnect attribute value of the specified terminal. Since the softConnect attribute can only be set on explicit, single-bit terminals, using this query on an implicit or multi-bit terminal always returns nil.")
("dbSetSoftConnectTermConnectToLayer"
"dbSetSoftConnectTermConnectToLayer ( 
d_termId 
tx_layer 
) 
=> t / nil"
"Sets the connectToLayer attribute of the specified softConnect terminal.")
("dbSetSoftConnectTermPinlessLayer"
"dbSetSoftConnectTermPinlessLayer ( 
d_termId 
tx_layer 
) 
=> t / nil"
"Sets the pinlessTerminalLayer attribute of the specified softConnect terminal. You can specify both the layer name or layer number of the terminal.")
("dbSoftConnectTermHasConnectToLayer"
"dbSoftConnectTermHasConnectToLayer ( 
d_termId 
) 
=> t / nil"
"Checks if the given terminal has the softConnect connectToLayer attribute set.")
("dbSoftConnectTermHasPinlessLayer"
"dbSoftConnectTermHasPinlessLayer ( 
d_termId 
) 
=> t / nil"
"Checks if the given terminal has the softConnect pinlessTerminalLayer attribute set.")
("dbDebugStats2"
"dbDebugStats2( 
[ d_cellViewId ]
[ x_segNum ] 
[ g_objName ] 
[ g_outputFileName ]
) 
=> t / nil"
"Lists memory used by every cellview in virtual memory, memory used by a specified cellview, content of a specified segment of the cellview, and number of objName objects in the specified segment or cellview.")
("dbGetBuildInfo"
"dbGetBuildInfo(
)
=> t_dbBuildInfo"
"Returns the OpenAccess release number, the tarkit revision number, and the date and machine on which the database was built.")
("dbGetFileDatabaseType"
"dbGetFileDatabaseType(  
t_libName 
t_cellName 
t_viewName 
) 
=> t_dbFileDatabaseType"
"Returns the t_libName, t_cellName, and t_viewName database type.")
("dbGetVersion"
"dbGetVersion(
)
=> t_dbVersion"
"Returns the OpenAccess database version number.")
("dbSetNIMsgMode"
"dbSetNIMsgMode( 
g_arg
)
=> t / nil"
"Turns on/off the not implemented message.")
("dbCreateAreaBlockage  "
"dbCreateAreaBlockage(
d_cellviewId
l_points
[ d_owner ]
)
=> d_areaBlockageId / nil"
"Creates an area blockage object of the type placement in the given cellview. Area blockages are used to prevent instances from being placed within a specific area.")
("dbCreateAreaHalo  "
"dbCreateAreaHalo(
d_ownerId
n_topOffset
n_bottomOffset
n_leftOffset
n_rightOffset
)
=> d_areaHaloId / nil"
"Creates an areaHalo blockage object of type placement. An area halo is associated with an instance or a prBoundary to represent an extended area around the master's prBoundary.")
("dbCreateLayerBlockage  "
"dbCreateLayerBlockage(
d_cellviewId
tx_layer
t_type
l_points
[ d_owner ]
)
=> d_layerBlockageId / nil"
"Creates a layer blockage object of the specified type in the given cellview.")
("dbCreateLayerHalo"
"dbCreateLayerHalo( 
d_ownerId 
tx_layer
t_type
n_top
n_bottom
n_left
n_right
)
=> d_layerHalo / nil"
"Creates a layer halo blockage object of the specified type.")
("dbCreateAreaBoundary"
"dbCreateAreaBoundary(
d_cellviewId
l_points
[ t_name = nil] 
[ lt_edgeNames = nil]
)
=> d_areaBoundaryId / nil"
"Creates an area boundary object in the specified cellview.")
("dbCreateClusterBoundary"
"dbCreateClusterBoundary(
d_clusterId
t_name
l_points
[ lt_edgeNames ]
)
=> d_boundaryId / nil"
"Creates a cluster boundary object in the cellview of the given cluster. The cluster boundary is associated with a cluster (grouping of objects) and defines the area of the cluster objects.")
("dbCreateCoverObstruction"
"dbCreateCoverObstruction(
d_prBoundaryId
x_topLayerMaskNumber
[ g_allowPGNet ]
)
=> d_coverObstructionId / nil"
"Creates a cover obstruction object associated with the specified prBoundary object.")
("dbCreatePRBoundary"
"dbCreatePRBoundary(
d_cellViewId
l_points
[ lt_edgeNames ]
)
=> d_boundaryId / nil"
"Creates a prBoundary object in the specified cellview for place-and-route purpose. A cellview can only have one prBoundary.")
("dbCreateSnapBoundary"
"dbCreateSnapBoundary(
d_cellViewId
l_points
[ lt_edgeNames ]
)
=> d_boundaryId / nil"
"Creates a snap boundary in the specified cellview.")
("dbFindAreaBoundaryByName "
"dbFindAreaBoundaryByName(
d_cellviewId
t_name
)
=> d_areaBoundaryId / nil"
"Finds the area boundary specified by name and cellview ID.")
("dbFindClusterBoundaryByName "
"dbFindClusterBoundaryByName(
d_clusterId
t_name
)
=> d_boundaryId / nil"
"Finds the cluster boundary specified by name.")
("dbSetBoundaryEdge"
"dbSetBoundaryEdge(
d_boundaryId
l_points
[ lt_edgeNames ]
)
=> t / nil"
"Sets the points (edges) and edge names for the specified boundary.")
("dbCreateBusNetDef"
"dbCreateBusNetDef(
d_cellviewId
t_baseName
t_bitOrder
)
=> d_busNetDefId / nil"
"Creates a bus net definition with specified bit order and base name in the given cellview. ")
("dbCreateBusTermDef"
"dbCreateBusTermDef(
d_cellviewId
t_baseName
t_bitOrder
)
=> d_busTermDefId / nil"
"Creates a bus terminal definition with specified bit order and base name in the given cellview.")
("dbCreateVectorInstDef"
"dbCreateVectorInstDef(
d_cellviewId
t_baseName
t_bitOrder
)
=> d_vectorInstDefId / nil"
"Creates a vector instance definition with specified bit order and base name in the given cellview.")
("dbFindBusNetDefByName"
"dbFindBusNetDefByName(
d_cellviewId
t_baseName
)
=> d_busNetDefId / nil"
"Searches for a bus net definition with specified base name in the given cellview. ")
("dbFindBusTermDefByName"
"dbFindBusTermDefByName(
d_cellviewId
t_baseName
)
=> d_busTermDefId / nil"
"Searches for a bus term definition with specified base name in the given cellview. ")
("dbFindVectorInstDefByName"
"dbFindVectorInstDefByName(
d_cellviewId
t_baseName
)
=> d_vectorInstDefId / nil"
"Searches for a vector instance definition with specified base name in the given cellview. ")
("dbCreateCluster"
"dbCreateCluster(
d_cellViewId
t_clusterName
t_clusterType
)
=> d_clusterId / nil"
"Creates a cluster in the specified cellview.")
("dbFindClusterByName"
"dbFindClusterByName(
d_cellViewId
t_clusterName
)
=> d_clusterId / nil"
"Searches for a cluster in the specified cellview with the specified name.")
("dbDisableCellViewCounter"
"dbDisableCellViewCounter( 
d_cellViewId
) 
=> t / nil"
"Disables updates to the modifiedCounter attribute of the cellview.")
("dbEnableCellViewCounter"
"dbEnableCellViewCounter( 
d_cellViewId
) 
=> t / nil"
"Enables updating of the cellview's timestamp counter.")
("dbGetCellViewCounter"
"dbGetCellViewCounter( 
d_cellViewId
) 
=> x_counter / nil"
"Gets the value of the cellview's timestamp counter.")
("dbGetFileTimeStamp"
"dbGetFileTimeStamp( 
d_cellViewId
) 
=> t_time / nil"
"Gets the last saved time for the cellview's file.")
("dbIsConnCurrent"
"dbIsConnCurrent( 
d_cellViewId
) 
=> t / nil"
"Tests whether the value of the connectivity current property is equal to the cellview's timestamp counter value.")
("dbSetConnCurrent"
"dbSetConnCurrent( 
d_cellViewId 
)
=> t / nil"
"Sets the value of the connectivity current property to the cellview's timestamp counter value.")
("dbSetInstHeadersCounter"
"dbSetInstHeadersCounter( 
d_cellViewId 
)
=> t / nil"
"Sets the value of the instance header change count property on each instance header to the instance master cellview's timestamp counter value.")
("dbCreateGuide"
"dbCreateGuide(
d_cellviewId
l_startPoint
l_endPoint
[ t_startLayerName ]
[t_endLayerName ] 
)
=> d_guideId / nil"
"Creates a guide based on the specified parameters.")
("dbCreatePathSeg"
"dbCreatePathSeg(
d_cellviewId
txl_layerPurpose
l_beginPt
l_endPt
n_width
t_beginStyle
t_endStyle
[list(
	n_beginExt
	n_endExt
	[ l_extValue ]
	)]
)
=> d_pathSegId / nil"
"Creates a path segment based on the specified parameters. The argument l_extValue is an optional list that contains six entries.")
("dbCreateRoute"
"dbCreateRoute(
d_cellviewId
[ d_netId ] 
[ g_isGlobal ] 
[ t_routeStatus ] 
)
=> d_routeId / nil"
"Creates a route based on the specified parameters.")
("dbCreateVia"
"dbCreateVia(
d_cellviewId
d_viaDefId
l_point
t_orient
[ l_paramList ] ]
)
=> d_viaId / nil"
"Creates a custom or standard via according to the specified viaDef type and the optional parameter list")
("dbCreateCustomViaVariant"
"dbCreateCustomViaVariant(
d_cellViewId
t_viaVariantName
t_viaDefName
l_viaParams
)
=> d_viaVariantId / nil"
"Creates a custom viaVariant in cellview.")
("dbCreateStdViaVariant"
"dbCreateStdViaVariant(
d_cellViewId t_viaVariantName t_viaDefName
(t_cutLayerName f_cutLayerWidth f_cutLayerHeight)
(n_cutRows n_cutCol  (f_cutSpaceX f_cutSpaceY))
(f_layer1EncX f_layer1EncY)
(f_layer2EncX f_layer2EncY)
(f_layer1OffsetX f_layer1OffsetY)
(f_layer2OffsetX f_layer2OffsetY)
(f_origOffsetX f_origOffsetY)
(f_implant1EncX f_implant1EncY)
(f_implant2EncX f_implant2EncY)
(cut_pattern) 
) 
=> nil / d_viaVariantId"
"Creates a standard via variant with the specified attributes.")
("dbFindViaVariantByName"
"dbFindViaVariantByName( 
d_cellViewId 
t_viaVariantName 
) 
=> d_viaVariantId / nil"
"Finds the viaVariant in a cellview.")
("dbGetViaLayer"
"dbGetViaLayer(
d_viaId
t_viaLayerType
)
=> t_layerName / nil"
"Returns the layer name of the specified layer of the given via.")
("dbIsCellViewStdViaMaster"
"dbIsCellViewStdViaMaster( 
d_cellViewId
) 
=> t / nil"
"Returns a boolean value indicating whether the specified cellview is a standard via master.")
("dbSetPathSegPoints"
"dbSetPathSegPoints(
d_pathSegId
l_beginPt
l_endPt 
)
=> t / nil"
"Specifies the beginning and ending points for the given path segment.")
("dbSetViaParamDefault"
"dbSetViaParamDefault(
d_viaId
t_paramName
)
=> t / nil"
"Sets the value of a parameter of a specified via to use its default value by a parameter name.")
("dbSetViaShapePurpose"
"dbSetViaShapePurpose(
d_customViaId
tx_purpose
)
=> t / nil"
"Sets the purposes of all shapes in the cdsVia to the specified purpose. The updated parameters include primaryShapePurpose, cutShapePurpose, and otherShapePurpose. To set all purposes to their original values (defined in the cdsViaDevice definition), use an empty string as the new purpose value.")
("dbGetRouteAuthor"
"dbGetRouteAuthor(
d_routeId
)
=> t_authorType"
"Returns the author type of the specified route.")
("dbSetRouteAuthor"
"dbSetRouteAuthor (
d_routeId,
t_authorType
)
 => t / nil"
"Sets the author type for the specified route.")
("xdvReplaceInstWithVias"
"xdvReplaceInstWithVias(
t_libName
t_cellName
t_viewName
)
=> t / nil"
"Detects and replaces the via-like instances with standard vias in the existing design across the hierarchy of the given library, cell, and view. The function overwrites the existing design and saves it. New via definitions can be created if the technology file is writable.")
("dbGetAllTrimFillShapes"
"dbGetAllTrimFillShapes(
d_cellviewId 
) 
=> l_shapeID / nil"
"(ICADVM20.1 Only) Returns a list of database IDs of all shapes present in the specified cellview with a valid trim fill type.")
("dbGetShapeTrimFillType"
"dbGetShapeTrimFillType (
d_shapeId
) 
=> t_trimFillType / nil"
"(ICADVM20.1 Only) Returns the trim fill type for the specified trim shape.")
("dbGetPatchType"
"dbGetPatchType(
d_pathSegId
)
=> t_patchType / nil"
"(ICADVM20.1 Only) Returns the patch type for the specified path segment.")
("dbSetBeginPatch"
"dbSetBeginPatch(
d_pathSegId
g_value
)
=> t / nil"
"(ICADVM20.1 Only) Adds or removes the beginStyle patch type for the specified path segment depending on the argument g_value.")
("dbSetEndPatch"
"dbSetEndPatch(
d_pathSegId
g_value
)
=> t / nil"
"(ICADVM20.1 Only) Adds or removes the endStyle patch type for the specified path segment depending on the argument g_value.")
("dbSetFullPatch"
"dbSetFullPatch(
d_pathSegId
g_value
)
=> t / nil"
"(ICADVM20.1 Only) Adds or removes the full style patch type for the specified path segment depending on the argument g_value. Path segment needs to have at least one property among beginStyle or endStyle or both to set the full style patch type.")
("dbSetPatchType"
"dbSetPatchType(
d_pathSegId
t_patchType
)
=> t / nil"
"(ICADVM20.1 Only) Sets the patch type for the specified path segment.")
("dbCreateMarker"
"dbCreateMarker(
d_cellviewId
t_msg
t_tool
l_points
[ ld_objects ]
[ g_isVisible ]
[ g_isClosed ]
[ t_severity ]
[ t_shortMsg ]
[ t_deleteWhen ]
)
=> d_markerId / nil"
"Creates a marker object in the specified cellview.")
("dbAddObjectsToMarker"
"dbAddObjectsToMarker(
d_markerId
ld_objectId
)
=> t / nil"
"Adds a list of objects to a specified marker.")
("dbRemoveObjectsFromMarker"
"dbRemoveObjectsFromMarker(
d_markerId
ld_objectId
)
=> t / nil"
"Removes a list of objects from a specified marker.")
("dbGetMarkerName"
"dbGetMarkerName(
d_markerId 
)
=> t_markerName / nil"
"Retrieves the name assigned to the marker associated with the given marker ID.")
("dbSetMarkerName"
"dbSetMarkerName(
d_markerId
t_markerName
)
=> t / nil"
"Assigns the specified name to the marker associated with the given marker ID. The name can be an empty string.")
("dbCreateRuler"
"dbCreateRuler(
d_cellviewId
l_points
)
=> d_rulerId / nil"
"Creates a dbRuler object in the design.")
("dbBoundaryQuery"
"dbBoundaryQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_boundary / nil"
"Returns a list of all the boundaries in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbFigGroupQuery"
"dbFigGroupQuery( 
d_cellView
l_bBox
[ x_startLevel ]
[ x_stopLevel ] 
[ n_filterSize ]
[ l_transform ]
)
=> l_figGroupId / nil"
"Returns a list of all the figGroups in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbGuideQuery"
"dbGuideQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_guide / nil"
"Returns a list of all the guides in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbInstQuery"
"dbInstQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_inst / nil"
"Returns a list of all the instances in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbLayerBlockageQuery"
"dbLayerBlockageQuery(
d_cellviewId
tx_layer
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_layerBlockage / nil"
"Returns a list of all the layer blockages in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbMarkerQuery"
"dbMarkerQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_marker / nil"
"Returns a list of all the markers in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbPlacementBlockageQuery"
"dbPlacementBlockageQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_via / nil"
"Returns a list of all the placement blockages in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbRowQuery"
"dbRowQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_row / nil"
"Returns a list of all the rows in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbShapeQuery"
"dbShapeQuery(
d_cellviewId
l_layerPurposePair
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> l_occShapes / nil"
"Returns a list of all the shapes in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbSteinerQuery"
"dbSteinerQuery(
d_cellviewId
tx_layer
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> ld_steiner / nil"
"Returns a list of all the steiners in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbViaQuery"
"dbViaQuery(
d_cellviewId
l_bBox
[ x_startLevel ] 
[ x_stopLevel ]
[ n_filterSize ] 
[ l_transform ] 
)
=> l_hiervia / nil"
"Returns a list of all the vias in a cellview whose bounding boxes overlap the region specified by l_bBox.")
("dbCreateRow"
"dbCreateRow(
d_cellViewId
d_siteDef
t_name
l_point
x_numSites
[ t_siteOrient ]
[ t_rowOrient ]
)
=> d_rowId / nil"
"Creates a row in the specified cellview.")
("dbFindRowByName"
"dbFindRowByName(
d_cellViewId
t_name
)
=> d_rowId / nil"
"Finds the specified row.")
("dbFindRowHeader"
"dbFindRowHeader(
d_cellViewId
t_siteDefName
)
=> d_rowHeaderId / nil"
"Finds the specified row header.")
("dbCreateSteiner"
"dbCreateSteiner(
d_cellViewId
l_bBox 
[ tx_layer ] 
)
=> d_steinerId / nil"
"Creates a Steiner object in the given cellview.")
("dbCreateTapSteiner"
"dbCreateTapSteiner(
d_cellViewId
l_bBox 
[ tx_layer ] 
)
=> d_steiner / nil"
"Creates a tap steiner object with the specified bounding box in the given cellview.")
("dbIsTapSteiner"
"dbIsTapSteiner(
d_object
)
=> t / nil"
"Checks whether the specified ID is a tap steiner ID.")
("dbGetTermGroundSensitivity"
"dbGetTermGroundSensitivity(
d_termId
)
=> d_groundTermId / nil"
"Returns the terminal ground sensitivity attributes for the given terminal ID.")
("dbGetTermSupplySensitivity"
"dbGetTermSupplySensitivity(
d_termId
)
=> d_supplyTermId / nil"
"Returns the terminal supply sensitivity attributes for the given terminal ID.")
("dbSetTermGroundSensitivity"
"dbSetTermGroundSensitivity(
d_termId
d_groundTermId
)
=> t / nil"
"Specifies the terminal ground sensitivity attributes for the given terminal ID.")
("dbSetTermSupplySensitivity"
"dbSetTermSupplySensitivity(
d_termId
d_supplyTermId
)
=> t / nil"
"Specifies the terminal supply sensitivity attributes for the given terminal ID.")
("dbCreateInstTermByPosition"
"dbCreateInstTermByPosition(
d_netId
d_instId
x_position
)
=> d_instTermId / nil"
"Creates an instTerm connecting to a terminal at the given position and to the specified master instance.")
("dbFindTermByPosition"
"dbFindTermByPosition(
d_cellviewId
x_position
)
=> d_termId / nil"
"Finds the terminal assigned to specific position.")
("dbDeleteAllTerminalAntennaRules"
"dbDeleteAllTerminalAntennaRules( 
d_termId 
t_modelName 
)
=> t / nil"
"Deletes all antenna rules from the specified terminal.")
("dbDeleteTerminalAntennaRuleOnLayer"
"dbDeleteTerminalAntennaRuleOnLayer( 
d_termId 
t_modelName
t_dataName
tx_layer
)
=> t / nil"
"Deletes the antenna rule of the terminal according to the specified antenna model name, antenna data name, and layer.")
("dbDeleteTerminalAntennaRules"
"dbDeleteTerminalAntennaRules( 
d_termId 
t_modelName 
t_dataName
l_antennaValueLayerPairs
)
=> t / nil"
"Delete the antenna rules of a terminal according to the model name, data name, and value layer pairs.")
("dbGetTerminalAntennaRuleOnLayer"
"dbGetTerminalAntennaRuleOnLayer( 
d_termId 
t_modelName
t_dataName
tx_layer
)
=> g_value / nil"
"Returns an antenna rule of the terminal according to the model name, data name, and layer.")
("dbGetTerminalAntennaRules"
"dbGetTerminalAntennaRules( 
d_termId 
t_modelName
t_dataName
)
=> l_antennaValueLayerPairs / nil"
"Returns a list of value layer pairs for an antenna rule of the specified terminal according to model name and data name.")
("dbSetTerminalAntennaRuleOnLayer"
"dbSetTerminalAntennaRuleOnLayer( 
d_termId 
t_modelName
t_dataName
g_value
tx_layer
)
=> t / nil"
"Sets an antenna rule to a specified terminal according to model name, data name, and value layer pair.")
("dbSetTerminalAntennaRules"
"dbSetTerminalAntennaRules( 
d_termId 
t_modelName
t_dataName
l_antennaValueLayerPairs

)
=> t / nil"
"Sets an antenna value layer pair list to a terminal according to model name and data name.")
("dbCreateTrackPattern"
"dbCreateTrackPattern(
d_cellviewId
g_isHorizontal
n_startCoord
x_numTracks
n_trackSpace
[ tx_layer ]
)
=> d_trackPatternId / nil"
"Creates a track pattern in the specified cellview.

(ICADVM20.1 Only) To color the track pattern, use dbSetTrackPatternFirstTrackColor or dbSetTrackPatternColorAlternating.")
("dbCreateGCellPattern"
"dbCreateGCellPattern(
d_cellviewId
g_isHorizontal
n_startCoord
x_count
n_spacing
[ tx_layer ]
)
=> d_GCellPatternId / nil"
"Creates a GCell pattern in the specified cellview.")
("dbCreateGenViaVariant"
"dbCreateGenViaVariant(
d_cellviewId 
t_name 
t_viaDefName
l_paramList
) 
=> viaVariantId / nil"
"Creates a genViaVariant object in the specified cellview according to the specified viaDef and parameter list.")
("dbIsCellViewGenViaMaster"
"dbIsCellViewGenViaMaster(
d_cellviewId
)
=> t / nil"
"Checks whether the specified cellview ID is of a genViaMaster object.")
("dbIsGenVia"
"dbIsGenVia(
d_objId
)
=> t / nil"
"Checks whether the specified database object is a genVia object.")
("dbIsGenViaHeader"
"dbIsGenViaHeader(
d_objId
)
=> t / nil"
"Checks whether the specified database object is a genViaHeader object.")
("dbIsGenViaVariant"
"dbIsGenViaVariant(
d_objId
)
=> t / nil"
"Checks whether the specified database object is a genViaVariant object.")
("dbSetGenViaParamDefault"
"dbSetGenViaParamDefault(
d_viaID
t_name
) 
=> t / nil"
"Sets the specified parameter to its default value based on the given genVia ID and parameter name.")
("dbFindViaHeaderByName"
"dbFindViaHeaderByName(  
d_cellviewId
t_viaDefName 
) 
=> d_viaHeaderId / nil"
"Takes a viaDef name and returns a viaHeader that references that viaDef. The returned viaHeader is always the superHeader. The only exception is for a custom viaDef whose master is not parameterized.")
("dbCellViewHasOpticalData"
"dbCellViewHasOpticalData(
d_cellviewId
)
=> t / nil"
"Checks whether the specified cellview has optical data.")
("dbIsNetOptical"
"dbIsNetOptical(
d_netId
)
=> t / nil"
"Checks whether the specified net or signal has optical data.")
("dbListTypes"
"dbListTypes(
t_typeName
)
=> l_enumValues / nil"
"Lists the enumerated values for a specified database enumerated type.")
("dbAllCellViews"
"dbAllCellViews( 
g_lib 
t_cellName 
[ d_contextCellView ] 
) 
=> l_viewName / nil"
"Lists all the view names of a cell.")
("dbCellViewHasVirtHier"
"dbCellViewHasVirtHier(
cellviewID
)
=> t / nil"
"Determines whether the specified cellview contains virtual hierarchy data.")
("dbCheckRecursion"
"dbCheckRecursion( 
d_cellViewId 
) 
=> t / nil"
"Checks for occurrence of the given top cellview in the hierarchy of the instHeader masters or any other recursion inside the instHeader master's hierarchy.")
("dbClose"
"dbClose( 
d_cellViewId 
) 
=> t / nil"
"Closes a cellview.")
("dbComputeBBox"
"dbComputeBBox( 
d_cellViewId 
) 
=> t / nil"
"Recomputes the given cellview's bounding box.")
("dbComputeBBoxNoNLP"
"dbComputeBBoxNoNLP( 
d_cellViewId 
) 
=> l_bBox / nil"
"Computes the given cellview's bounding box, but excludes all the bounding boxes of the nlp labels in the given cellview itself and its reference cellviews.")
("dbCopyCellView"
"dbCopyCellView( 
d_srcCVId 
t_libName 
t_cellName 
t_viewName 
[ t_version 
[ g_contextId 
[ g_overwrite ] ] ] 
) 
=> d_cellViewId / nil"
"Copies a cellview to a destination cellview.")
("dbCreateLib"
"dbCreateLib( 
t_libName 
[ t_libPath ] 
) 
=> ddId_libId / nil"
"Creates a library named t_libName.")
("dbDefineProc"
"dbDefineProc( 
d_cellView 
t_fileName 
) 
= t / nil"
"Changes the cellview specified by the d_cellView to be a parameterized cell. The specified file name should be the name of a file containing un-encrypted SKILL code defining procedure pcGenCell. The cellview should have a hierarchical property named parameters, which should be a hierarchical property list containing the default values for the parameters.")
("dbFeaturePrintInfo"
"dbFeaturePrintInfo( 
d_cellView
[ g_incompatibleOnly ]
)
=> t / nil"
"Lists information about the features that are being used in the specified cellview.")
("dbFindOpenCellView"
"dbFindOpenCellView( 
g_libId 
t_cellName 
t_viewName 
[ t_version ] 
) 
=> d_cellViewId / nil"
"Finds an opened cellview.")
("dbFlattenInst"
"dbFlattenInst(
d_instId
x_levels
[ g_flattenPCells ]
[ g_preservePins ]
[ g_preserveRODobjs ]
[ g_delDetachedBlockages ] 
[ g_preservePinFigs ] 
[ g_preserveTermName ]
[ g_flattenVias ]
) 
=> t / nil"
"Flattens instance d_instId up through x_levels of hierarchy. The dbFlattenInst function flattens mosaics as well as normal instances. To flatten a mosaic, pass the mosaicId to dbFlattenInst.")
("dbFlattenInst2"
"dbFlattenInst2(
d_instId
x_levels
[ g_options ]
)
=> t / nil"
"Flattens an instance up through x_levels of hierarchy along with an optional set of flatten options. dbFlattenInst2 flattens mosaics as well as normal instances.")
("dbFullLibPath"
"dbFullLibPath( 
t_libName
) 
=> t_fullLibPath / nil"
"Returns the full library path of the specified library.")
("dbFullPath"
"dbFullPath( 
d_cellView 
) 
=> t_fullPath / nil"
"Returns the full path of a cellview.")
("dbGetAnyInstSwitchMaster"
"dbGetAnyInstSwitchMaster( 
d_anyInst 
t_viewList 
) 
=> d_cellView / nil"
"Switches into a different view of a master cell instance and opens the corresponding cellview.")
("dbGetCellViewDdId"
"dbGetCellViewDdId( 
d_dbCellViewId 
) 
=> ddId_cellViewId / nil"
"Returns a ddId associated with the cellViewId. This ddId contains the path to the library, cell, view, and file name.")
("dbGetLibDataCompressionLevel"
"dbGetLibDataCompressionLevel(
dd_libId
)
=> value/ nil"
"Returns the data compression level set on the specified library ID.")
("dbGetOpenCellViews"
"dbGetOpenCellViews(
)
=> (d_cv d_cv d_cv ...) / nil"
"Returns all opened cellviews in virtual memory.")
("dbHasAutoSavedFile"
"dbHasAutoSavedFile(
t_libName
t_cellName
t_viewName
)
=> t / nil"
"Determines whether the specified cellview has an auto-saved file.")
("dbHasPanicFile"
"dbHasPanicFile(
t_libName
t_cellName
t_viewName
)
=> t / nil"
"Determines whether the specified cellview has a panic file.")
("dbIsNonSKILLPcell"
"dbIsNonSKILLPcell(
d_cellviewId
)
=> t / nil"
"Checks whether a pcell is not a SKILL pcell.")
("dbOpenAutoSavedCellView"
"dbOpenAutoSavedCellView( 
t_libName 
t_cellName 
lt_viewName 
[ t_version ] 
) 
=> d_cellView / nil"
"Reads the auto-saved file.")
("dbOpenCellViewByType"
"dbOpenCellViewByType( 
{ gt_lib | nil }
t_cellName 
lt_viewName 
[ t_viewTypeName 
[ t_mode 
[ d_contextCellView ] ] ] 
) 
=> d_cellView / nil"
"Opens a cellview.")
("dbOpenHier"
"dbOpenHier( 
d_cellView 
x_numLevels 
) 
=> t"
"Opens and binds masters of instances that constitute a design hierarchy.")
("dbOpenPanicCellView"
"dbOpenPanicCellView( 
gt_lib 
t_cellName 
t_viewName 
[ t_version 
[ t_mode 
[ d_contextCellView ] ] ]
) 
=> d_cellView / nil"
"Opens a saved panic cellview from a physical panic file with extension .oa-. The cellview .oa- opens in read mode only. You can then use the dbSave() function to save it to a new cellview, or call the dbReopen() function to reopen it in the append mode and then call the dbSave() function to save the cellview back to disk.")
("dbOpenParamCellView"
"dbOpenParamCellView(
t_libName 
t_cellName 
t_viewName 
[ l_params ]
)
=> d_cellView / nil"
"Opens submaster cellview of the Pcell supermaster specified by the library, cell, and view names and the parameter values.")
("dbProduceMemName"
"dbProduceMemName( 
t_name 
) 
=> list( <memName> ... <memName> ) / nil"
"Returns a list of the member names for the given name.")
("dbPurge"
"dbPurge( 
d_cellView 
) 
=> t / nil"
"Forces a cellview to close and removes from virtual memory.")
("dbRefreshCellView"
"dbRefreshCellView( 
d_cellViewId
) 
=> t / nil"
"Refreshes the cellview in virtual memory with the most current copy from disk. If there were any changes to the cellview, this function purges the cellview from virtual memory and reopens the cellview.")
("dbRefreshLibDataCompressionLevel"
"dbRefreshLibDataCompressionLevel(
dd_libId
)
=> t / nil"
"Refreshes the data compression level for the specified library ID from the disk.")
("dbRegPostSaveAsTrigger"
"dbRegPostSaveAsTrigger( 
S_triggerFunc 
[ x_priority ] 
) 
=> t / nil"
"Allows users to register a trigger function that is called after a postSaveAs or Save Copy operation.")
("dbRegPostSaveTrigger"
"dbRegPostSaveTrigger( 
S_triggerFunc 
[ x_priority ] 
) 
=> t / nil"
"Allows users to register a trigger function that is to be called after dbSave. If dbSave fails, this trigger will not be launched. This trigger will be called only after saving the db cellviews. The post save trigger will be called with the db cellview ID.")
("dbRegPurgeTrigger"
"dbRegPurgeTrigger( 
S_triggerFunc 
[ x_priority ] 
) 
=> t / nil"
"Registers a user-defined trigger function.")
("dbRegSaveTrigger"
"dbRegSaveTrigger( 
S_triggerFunc 
[ x_priority ]
)
=> t / nil"
"Registers a SKILL preSave trigger. The trigger function does not need to exist at the time of register, a warning will be issued though. If the function is bound, it is called before the cellview is saved.")
("dbReopen"
"dbReopen( 
d_cellViewId 
t_mode 
) 
=> t / nil"
"Changes the mode of the specified cellview to the given mode.")
("dbRestoreAndOpenAutoSavedFile"
"dbRestoreAndOpenAutoSavedFile(
t_libName
t_cellName
t_viewName
)
=> d_cellviewID / nil"
"Restores and opens the auto-saved file for the specified cellview.")
("dbRestoreAndOpenPanicFile"
"dbRestoreAndOpenPanicFile(
t_libName
t_cellName
t_viewName
)
=> d_cellviewID / nil"
"Restores and opens the panic file for the specified cellview.")
("dbSave"
"dbSave(
d_cellview
[ d_destCellView | t_libName t_cellName t_viewName ]
)
=> t / nil"
"Saves the changes made to a specified cellview opened in write or append mode. By default the cellview is saved to the same database ID; however, you can optionally specify a different destination cellview ID or create a new cellview in a different library. A cellview opened in read mode can only be saved as a new cellview with the different name.")
("dbSearchCDF"
"dbSearchCDF( 
g_status
) 
=> t"
"Sets and un-sets a flag that will cause CDF to be searched for parameter values.")
("dbSetAutoSave"
"dbSetAutoSave( 
g_isAutoSaveSet 
[ u_saveInterval ] 
) 
=> t / nil"
"Enables or disables the automatic save feature.")
("dbSetAutoSaveCallback"
"dbSetAutoSaveCallback(
t_callback
)
=> 't / nil"
"Enables a user-defined callback function to control the frequency at which large designs are auto-saved. When set, the user-defined callback function is called just before the design is about to be auto-saved.")
("dbSetLibDataCompressionLevel"
"dbSetLibDataCompressionLevel(
dd_libId
[ n_compressionLevel ]
)
=> t/ nil"
"Sets the data compression level for designs that are saved to the specified library ID.")
("dbUndefineProc"
"dbUndefineProc( 
d_cellView 
) 
= t / nil"
"Changes the parameterized cell specified by the d_cellView to be a regular cellview.")
("dbUnregPostSaveAsTrigger"
"dbUnregPostSaveAsTrigger( 
S_triggerFunc
) 
=> t / nil"
"Allows users to unregister the trigger function called after a postSaveAs operation")
("dbUnregPostSaveTrigger"
"dbUnregPostSaveTrigger( 
s_triggerFunc 
) 
=> t / nil"
"Un-registers the post save trigger function from dbSave.")
("dbUnregPurgeTrigger"
"dbUnregPurgeTrigger( 
s_triggerFunc 
) 
=> t / nil"
"Unregisters a user-defined trigger function.")
("dbUnregSaveTrigger"
"dbUnregSaveTrigger( 
S_triggerFunc 
)
=> t / nil"
"This function unregisters the SKILL preSave trigger function specified by the given name.")
("dbUnsetLibDataCompressionLevel"
"dbUnsetLibDataCompressionLevel(
dd_libId
)
=> t/ nil"
"Removes the data compression level of the specified library.")
("dbWriteSkill"
"dbWriteSkill( 
d_cellViewId 
t_fileName 
t_mode 
t_release 
[ g_conn ] db
[ g_ref ] 
[ g_lppString ] 
) 
=> t / nil"
"Creates a file that contains all the SKILL commands needed to recreate a cellview, so that the design can be recreated in the current or previous release by loading the file in the current or previous release, respectively.")
("dbWriteSkillWithLib"
"dbWriteSkillWithLib( 
d_cellviewId 
t_fileName 
t_mode 
t_release 
[ g_conn ] 
[ g_ref ] 
)
=> t / nil"
"Creates a file that contains all the SKILL commands needed to recreate a cellview.")
("dbCreateInst"
"dbCreateInst( 
d_cellView 
d_master 
t_name 
l_point 
t_orient 
[ x_stopIndex ] 
[ g_physOnly]
) 
=> d_inst / nil"
"Creates an instance (of cellview d_master) in the cellview d_cellView with an origin and orientation specified by l_point and t_orient.")
("dbCreateParamInst"
"dbCreateParamInst( 
d_cellView 
d_master 
t_name 
l_point 
t_orient 
[ x_numInst 
[ l_params 
[ g_physOnly ] ] ]
) 
=> d_inst / nil"
"Creates a parameterized cell instance (of cellview d_master) in the cellview d_cellView with an origin and orientation specified by l_point and t_orient.")
("dbCreateExtParamInst"
"dbCreateExtParamInst(
d_cellView
d_master
t_name
l_point
t_orient
[ x_numInst
[ l_params
[ g_physOnly ] ] ]
)
=> d_inst / nil"
"Creates a parameterized cell instance (of cellview d_master) in the cellview d_cellView with an origin and orientation specified by l_point and t_orient. The parameters in the l_params list may be CDF parameters whose values match the CDF parameter defaults.")
("dbCreateExtParamInstByMasterName"
"dbCreateExtParamInstByMasterName(
d_cellView
t_libName
t_cellName
t_viewName
t_name
l_origin
t_orient
[ x_numInst
[ l_params
[ g_physOnly ] ] ]
)
=> d_inst / nil"
"Creates an instance of the specified Pcell master in the specified cellview. The parameters in the parameter list may be CDF parameters. In this case, for each parameter the function creates an explicit local user property on the instance, even if its value is the same as the default on the master.")
("dbCreateXformPCell"
"dbCreateXformPCell( 
d_cellViewId 
t_libName 
) 
=> d_cellViewId / nil"
"Creates a new Pcell supermaster with the additional parameters: mag and angle. The new Pcell is used in emulating magnification and any-angle rotation of instances. If the source cellview is maskLayout, the Pcell cell name is same as that of the source cellview, with _xform appended to it, otherwise, the viewName is similarly renamed.
This Pcell creates an instance of the source cellview, flattens it, and then transforms all the resultant shapes by adding the parameters mag and angle.
If the Pcell supermaster already exists, it is opened as read-only, and the cellview ID is returned.")
("dbDumpPcDefinePcell"
"dbDumpPcDefinePcell(
d_cellViewId 
t_pCellFile
)
=> t / nil"
"Writes out three lists to the file specified: The first list is a list of library names, cell names, and view names of the given cellview ID; the second list is of the parameter value; the last list is the SKILL procedure attached to the given cellview ID.")
("dbCheckParamCell"
"dbCheckParamCell( 
d_cellViewId
) 
=> t / nil"
"Checks if the specified cellview is a valid parameterized cell. If there was an error during the reading, binding, or evaluation of the specified cellview, a description of the error is returned.")
("dbEvalParamCell"
"dbEvalParamCell( 
d_cellViewId
) 
=> t / nil"
"Evaluates the supermaster; the parameters on all the instance headers are fixed, and the submasters are evaluated.")
("dbFixParamCell"
"dbFixParamCell( 
d_cellViewId
t_fileName
) 
=> t / nil"
"Fixes the parameterized cell for which the reading, binding, or evaluation has failed, by re-defining it with a different SKILL procedure defined in t_fileName.")
("dbHasInstance"
"dbHasInstance( 
d_cellViewId
) 
=> t / nil"
"Checks whether the specified cellview contains any instances.")
("dbIsCellViewModified"
"dbIsCellViewModified( 
d_cellViewId
) 
=> t / nil"
"Checks whether the specified cellview has been modified since the last open or last save.")
("dbReplaceParam"
"dbReplaceParam( 
d_cellViewId
t_name
t_type
g_value
) 
=> d_prop / nil"
"Add or modifies a cellview parameter if the cellview is a pcell super master. If the cellview is not a super master, dbReplaceParam gives a warning stating that it cannot define a parameter for a non super master, and quits.
This function is only used on pcell super master cellviews.")
("dbReplaceInstParamList"
"dbReplaceInstParamList( 
d_instId
l_paramList
) 
=> t / nil"
"Atomically replaces all the Pcell instance parameters with the given parameter list. The resulting Pcell subMaster is evaluated only once.")
("dbFindAnyInstByName"
"dbFindAnyInstByName( 
d_cellView 
t_name 
) 
=> d_inst / nil"
"Retrieves an instance or mosaic.")
("dbFindMemInstByName"
"dbFindMemInstByName( 
d_cellView 
t_name 
) 
=> ( d_inst x_index ) / nil"
"Retrieves an instance or mosaic and returns its member index.")
("dbGetHierPathTransform"
"dbGetHierPathTransform( 
l_dbInstId 
) 
=> x_InstTransform"
"Returns the concatenated transform of all instance or mosaic IDs present in the nested list passed as the parameter. The nested list represents the path to an object, such as the lists returned by dbGetTrueOverlaps or dbGetOverlaps.")
("dbGetInstByName"
"dbGetInstByName( 
d_cellView 
t_name 
) 
=> d_inst / nil"
"Retrieves an instance or mosaic.

dbGetInstByName is maintained only for backward compatibility; you should now use dbFindAnyInstByName.")
("dbGetInstanceByName"
"dbGetInstanceByName( 
d_cellView 
t_name 
) 
=> d_inst / nil"
"Retrieves an instance or mosaic.

dbGetInstanceByName is maintained only for backward compatibility; you should now use dbFindAnyInstByName.")
("dbGetInstNameNumInst"
"dbGetInstNameNumInst( 
t_name 
) 
=> x_numInst / nil"
"Retrieves the number of instances of an instance or mosaic")
("dbGetInstTransform"
"dbGetInstTransform( 
l_dbInstId
) 
=> x_InstTransform"
"Returns the concatenated transform of all instance or mosaic IDs present in the nested list passed as the parameter. The nested list represents the path to an object, such as the lists returned by dbGetTrueOverlaps or dbGetOverlaps.")
("dbIsAnyInstBaseNameUsed"
"dbIsAnyInstBaseNameUsed( 
d_cellView 
t_name 
) 
=> t / nil"
"Check if the name is used as instance basename in the cellview.")
("dbCreateInstByMasterName"
"dbCreateInstByMasterName( 
d_cellView 
t_libName 
t_cellName 
t_viewName 
t_instName 
l_origin 
t_orient 
[ x_numInst ] 
[ g_physOnly ] 
) 
=> d_inst / nil"
"Creates an instance (of cellview-t_libName/t_cellName/t_viewName) in d_cellView with an origin and orientation specified by l_point and t_orient.")
("dbCreateParamInstByMasterName"
"dbCreateParamInstByMasterName( 
d_cellView 
t_libName 
t_cellName 
t_viewName 
t_name 
l_origin 
l_orient 
[ x_numInst 
[ l_params 
[ g_physOnly ] ] ]
) 
=> d_inst / nil"
"Creates an instance of the specified Pcell master in the specified cellview. The parameters in the parameter list may be CDF parameters. In this case, when you create a Pcell instance and pass a parameter, with the same value as the default value, dbCreateParamInstByMasterName() does not create an explicit local user property on the instance because the value is the same as the default. If the value is different from the default, the function stores the value as a local property on the instance.")
("dbDumpPcell"
"dbDumpPcell( 
d_cvId 
t_outputFile
t_pCellFile 
) 
=> t / nil"
"The dbDumpPcell function is used in the implementation of the keepPcell option, during streamIn and streamOut. Pcells are preserved by writing the pcells to SKILL files (during StreamOut) which are loaded back into CDB/Virtuoso (during StreamIn).")
("dbDumpPcellWithLib"
"dbDumpPcellWithLib( 
d_cvId 
t_outputFile
t_pCellFile 
) 
=> t / nil"
"Same functionality as dbDumpPcell, which preserves pcells through StreamIn and StreamOut by writing the pcells to SKILL files. dbDumbPcellWithLib does not directly write the library name in the SKILL code, instead writes a SKILL variable, dbD_NewLibNameForDump whose value can be set to the name of the target library before loading the SKILL file.")
("dbCreateViaShapeArray"
"dbCreateViaShapeArray( 
d_techCVId 
g_viaLayer 
[ d_netId ] 
f_x 
f_y 
f_xPitch 
f_yPitch 
f_w 
f_length 
x_row 
x_column 
) 
=> l_xy / nil"
"Creates an array of via shapes (rectangles) on the given layer in the technology cellview and adds all the shapes to the given net.")
("dbSetInstHeaderMasterName"
"dbSetInstHeaderMasterName( 
d_instHeader 
t_libName 
t_cellName 
t_viewName 
) 
=> t / nil"
"Sets the master of individual instance on the instHeader to the new master. All the instances are removed from the old instHeader and move to the new instHeader, which may exist or not. When an instHeader is empty, meaning it does not have any instance on this instHeader, the instHeader is removed and the ID is no longer valid.")
("dbIsSameMaster"
"dbIsSameMaster( 
d_anyInst1 
d_anyInst2 
) 
=> t / nil"
"Determines if two instances or mosaics are instantiated from the same cellview master.")
("dbIsObjectBound"
"dbIsObjectBound( 
g_object
) 
=> t / nil"
"Determines whether or not an object is bound. If the master cellview of the object is opened, the object is bound. Otherwise it is not bound.")
("dbGetCellViewSymmetry"
"dbGetCellViewSymmetry( 
d_cellView 
)
=> t_symmetry / nil"
"Returns the symmetry of the specified cellview.")
("dbSetCellViewSymmetry"
"dbSetCellViewSymmetry( 
d_cellViewID 
t_symmetry
)
=> t / nil"
"Sets the symmetry (or orientation) on a cellview (for which the ID is specified). The symmetry of the cellview can be set to a string value, such as X, Y, XY, any, or none, where X mirrors the cellview about the x axis and Y mirrors the cellview about the y axis.")
("dbGetCellViewEEQMaster"
"dbGetCellViewEEQMaster( 
d_cellView 
)
=> t_EEQMaster / nil"
"Returns the value of the EEQmaster attribute of the cellview.")
("dbSetCellViewEEQMaster"
"dbSetCellViewEEQMaster( 
d_cellView 
t_EEQMaster 
)
=> t / nil"
"Sets the value of the EEQmaster attribute of the specified cellview.")
("dbIsInstTransparent"
"dbIsInstTransparent(
d_instanceId
)
=> t / nil"
"Checks if the specified instance ID is set to be transparent to the Layout XL binder.")
("dbSetInstTransparent"
"dbSetInstTransparent
d_instanceId
g_transparent
)
=> t / nil"
"Sets an instance as transparent to the Layout XL binder.")
("dbCreateNet"
"dbCreateNet( 
d_cellView 
t_name 
[ d_parentNet ] 
) 
=> d_net / nil"
"Creates a new net in a cellview. If the net already exists, returns nil.")
("dbCreateNamedSubNet"
"dbCreateNamedSubNet(
d_parentNet
t_subNetName
)
=> t_subnetId / nil"
"Creates a subnet with the specified name. The behavior is different from dbCreateNet because when a root net ID is specified. dbCreateNameSubNet creates an explicitly named scalar net with the specified subnet name.")
("dbMakeNet"
"dbMakeNet( 
d_cellView 
t_name 
[ d_parentNet ] 
) 
=> d_net / nil"
"Creates a new net in a cellview. If the net already exists, it returns the dbObject of the net.")
("dbMergeNet"
"dbMergeNet( 
d_netId1 
d_netId2 
) 
=> dnetId1 / nil"
"Merges one netId2 into netId1. The pins, terminals, connections, figures, properties, and signals of the merging net (netId2) are merged into the surviving net (netId1), and member nets of netId2's signals become members of netId1's signals. Both of the nets may already be attached to a terminal; both nets must have the same number of bits. If the two nets are in the same net hierarchy, netId1 must not be a descendant of netId2. If the merge is successful, netId1 is returned; otherwise, nil is returned.")
("dbCreateUniqueNamedNet"
"dbCreateUniqueNamedNet( 
d_cellView 
t_prefix 
x_numBits 
) 
=> d_net / nil"
"Creates a new net with a unique name.")
("dbSetNetNameDescend"
"dbSetNetNameDescend( 
d_cellView 
g_mode 
) 
=> t / nil"
"Sets a mode, descending or ascending, which determines the direction of the net name vector expression.")
("dbIsNetNameDescend"
"dbIsNetNameDescend( 
d_cellView 
) 
=> t / nil"
"Checks if the net name descend mode is set or not.")
("dbNetIsSig"
"dbNetIsSig( 
d_netId
) 
=> t / nil"
"Tests whether the specified net ID is also a signal.")
("dbDeleteAllNet"
"dbDeleteAllNet( 
d_cellView 
) 
=> t / nil"
"Deletes all nets from a cellview.")
("dbCreateTerm"
"dbCreateTerm( 
d_net 
t_name 
t_direction 
[ x_unused ]
[ g_physOnly ]
) 
=> d_term / nil"
"Creates a terminal for a net.")
("dbCreateInstTerm"
"dbCreateInstTerm( 
d_net 
d_inst 
d_term 
) 
=> d_instTerm / nil"
"Creates an instance terminal on the instance d_inst for the master terminal d_term.")
("dbHasShortedTerminals"
"dbHasShortedTerminals( 
d_cellViewId
)
=> t / nil"
"Checks whether the specified cellview contains nets that are connected to multiple terminals.")
("dbCreatePin"
"dbCreatePin( 
d_netId 
d_figId | nil
[ t_pinName | nil ] 
[ d_termId | nil] 

) 
=> d_pin / nil"
"Creates a pin.")
("dbCreateConn"
"dbCreateConn( 
d_net 
d_inst 
d_term 
) 
=> d_instTerm / nil"
"Identical to dbCreateInstTerm, except the net d_net defines a valid net to be connected to the instance terminal of a master terminal d_term.")
("dbCreateConnByName"
"dbCreateConnByName( 
d_net 
d_inst 
t_name 
) 
=> d_instTerm / nil"
"Similar to dbCreateConn, except the master terminal is defined by t_name instead of being specified by the master terminal's dbObject.")
("dbCreateConnByNewName"
"dbCreateConnByNewName( 
d_net 
d_inst 
t_name 
) 
=> d_instTerm / nil"
"Similar to dbCreateConnByName, except t_name can refer to a master terminal to be created in the master cellview of instance d_inst.")
("dbSubFigFromNet"
"dbSubFigFromNet(
d_figId
) 
=> t / nil"
"Removes the given figure object from the net object with which it is already associated.")
("dbAddFigToNet"
"dbAddFigToNet(
d_figId
d_netId
) 
=> t / nil"
"Assigns the given figure object to a specified net object. If the figure is already associated with a different net, the figure will be detached from that net before being assigned to the given net object.")
("dbGetNetVoltageRange"
"dbGetNetVoltageRange(
d_netId 
)
=> l_voltages / nil"
"Returns the minimum and maximum voltages on a net.")
("dbSetNetVoltageRange"
"dbSetNetVoltageRange(
d_netId 
n_minVoltage
n_maxVoltage
)
=> t / nil"
"Sets the minimum and maximum voltages on the specified net.")
("dbUnsetNetVoltageRange"
"dbUnsetNetVoltageRange(
d_netId
)
=> t / nil"
"Resets the minimum and maximum voltages on a net to their default values.")
("dbGetNetVoltageRangeSource"
"dbGetNetVoltageRangeSource(
d_netId 
)
=> t_source / nil"
"Returns the voltage range source of the specified net ID.")
("dbSetNetVoltageRangeSource"
"dbSetNetVoltageRangeSource(
d_netId 
t_source
)
=> t / nil"
"Sets the voltage range source on the specified net ID.")
("dbUnsetNetVoltageRangeSource"
"dbUnsetNetVoltageRangeSource(
d_netId
)
=> t / nil"
"Resets the voltage range source of the specified net ID to its default value.")
("dbGetCellViewNetVoltageRange"
"dbGetCellViewNetVoltageRange(
d_cvId 
)
=> l_voltages / nil"
"Returns the default minimum and maximum net voltages on the specified cellview ID.")
("dbSetCellViewNetVoltageRange"
"dbSetCellViewNetVoltageRange(
d_cvId 
n_minVoltage
n_maxVoltage
)
=> t / nil"
"Sets the default minimum and maximum net voltages on a cellview ID.")
("dbIsCellViewNetVoltageRangeSet"
"dbIsCellViewNetVoltageRangeSet( 
d_cvId
)
=> t / nil"
"Ensures that the voltage range is set on a cellview.")
("dbIsNetVoltageRangeSet "
"dbIsNetVoltageRangeSet( 
d_netId
)
=> t / nil"
"Ensures that the voltage range is set on a net.")
("dbUnsetCellViewNetVoltageRange"
"dbUnsetCellViewNetVoltageRange( 
d_cvId
)
=> t / nil"
"Resets the voltage range on a cellview to its default value.")
("dbGetNetPowerDomain"
"dbGetNetPowerDomain(
dd_netId 
)
=> l_list / nil"
"Returns the power domain associated with the specified net. A power domain can be a single string or a list of strings.")
("dbSetNetPowerDomain"
"dbSetNetPowerDomain(
dd_netId 
l_list
)
=> t / nil"
"Sets the power domain for the specified net.")
("dbGetPowerDomainClusters"
"dbGetPowerDomainClusters(
d_cellViewId
)
=> l_cluster / nil"
"Retrieves SKILL list of clusters in the specified cellView. Only clusters with clusterBoundary having power domain attribute are returned. Each entry contains the cluster name, cluster boundary name and voltage value.")
("dbRenameNet"
"dbRenameNet(
d_netId
t_newNetName
)
=> t / nil"
"This function changes the name of the net pointed by netId to the newNetName.")
("dbIsCellViewPhysicalOnly"
"dbIsCellViewPhysicalOnly(
d_cvId
)
=> t / nil"
"Checks whether the connectivity detail of a cellveiw is visible only to the block domain or to both the block domain and the OpenAccess module domain.")
("dbUnsetCellViewPhysicalOnly"
"dbUnsetCellViewPhysicalOnly(
d_cvId
)
=> t / nil"
"Unsets the physical-only attribute of the specified cellview, allowing connectivity to be visible in the OpenAccess module domain.")
("dbCellViewHasEquivalentConnectivityTime"
"dbCellViewHasEquivalentConnectivityTime(
d_cvId
)
=> t / nil"
"Checks whether the equivalent connectivity time is set on the specified cellview.")
("dbGetCellViewEquivalentConnectivityTime"
"dbGetCellViewEquivalentConnectivityTime
d_cvId
)
t_timeString / nil"
"Retrieves the equivalent connectivity time that is set on the specified cellview.")
("dbSetCellViewEquivalentConnectivityTime"
"dbSetCellViewEquivalentConnectivityTime
d_cvId
t_timestring
)
=> t / nil"
"Sets the equivalent connectivity time on the specified cellview.")
("dbUnsetCellViewEquivalentConnectivityTime"
"dbUnsetCellViewEquivalentConnectivityTime(
d_cvId
)
=> t / nil"
"Removes equivalent connectivity time information from the specified cellview.")
("dbDeleteEmptyNet"
"dbDeleteEmptyNet( 
d_netId 
)
=> t / nil"
"Deletes a net that is not associated with other objects.")
("dbFindNetByName"
"dbFindNetByName( 
d_cellView 
t_name 
) 
=> d_net / nil"
"Retrieves a net in a cellview.")
("dbFindTermByName"
"dbFindTermByName( 
d_cellView 
t_name 
) 
=> d_term / nil"
"Finds a terminal in a cellview.")
("dbFindSigByName"
"dbFindSigByName( 
d_cellView 
t_name 
) 
=> d_sig / nil"
"Finds a signal in a cellview.")
("dbFindSigByAlias"
"dbFindSigByAlias( 
d_cellView 
t_name 
) 
=> d_sig / nil"
"Finds a signal in a cellview by an alias.")
("dbGetMemNetSig"
"dbGetMemNetSig
dbGetMemNetSig( ( d_net x_index ) ) 
	=> d_sig / nil 

dbGetMemNetSig( d_net x_index ) 
	=> d_sig / nil"
"Retrieves the signal carried by bit number x_index of net d_net.")
("dbGetMemNetSigName"
"dbGetMemNetSigName
dbGetMemNetSigName( d_net x_index ) 
	=> t_name / nil 

dbGetMemNetSigName( ( d_net x_index ) ) 
	=> t_name / nil"
"Similar to dbGetMemNetSig, except it returns the name of the signal instead of the signal object.")
("dbGetNetTerms"
"dbGetNetTerms( 
d_net
) 
=> d_term / nil"
"Returns the IDs of the terminals attached to the specified net.")
("dbGetSigNameMemNets"
"dbGetSigNameMemNets( 
d_cellView 
t_sigName 
) 
=> ( (t_netName x_index) ...) / nil"
"Lists the member nets within the cellview that contain the signal.")
("dbIsSigNameGlobal"
"dbIsSigNameGlobal( 
d_cellView 
t_name 
) 
=> t / nil"
"Tests if the signal t_name is a global signal.")
("dbGetMemName"
"dbGetMemName( 
t_name 
x_index 
) 
=> t_memName"
"Retrieves the name of the x_index member from t_name.")
("dbExpandToMemNameExpr"
"dbExpandToMemNameExpr( 
t_bundleName 
) 
=> l_memNameExpr"
"Expands a bundle name to a list of member-name-expression strings.")
("dbGetMaxNumBit"
"dbGetMaxNumBit( 
) 
=> x_numbit"
"Returns the maximum width allowed for a net.")
("dbGetNameNumBit"
"dbGetNameNumBit( 
t_name 
) 
=> x_numBit"
"Parses a string and returns the number of bits in the net, terminal, or instance named.")
("dbMergeSignal"
"dbMergeSignal( 
d_sig1Id 
d_sig2Id 
)
=> d_sig1Id / nil"
"Merges two signals into one signal.")
("dbMoveChildNet"
"dbMoveChildNet( 
d_childId 
d_parentId 
)
=> t / nil"
"Moves a net to be the child of given parent net, both should be on same terminal.")
("dbMovePinToNet"
"dbMovePinToNet( 
d_pinId 
d_netId 
)
=> t / nil"
"Moves a pin to the specified net.")
("dbCreateStrongGroup"
"dbCreateStrongGroup(
l_pinList
[ s_groupConnection ]
)
=> t / nil"
"This function is obsolete in this release. Strong connections are defined exclusively by the geometry on the pin. All the pinFigs on the same pin are strongly connected to one another.")
("dbExternallyConnectPins"
"dbExternallyConnectPins(
l_pinList
)
=> t / nil"
"This function is obsolete in this release. External connections are modeled by pinFigs on Pins on Terms in the same MustJoin set. See dbSetTermMustJoin.")
("dbGetPinConnection"
"dbGetPinConnection(
d_pin1
d_pin2
)
=> dbcExternallyConnected / dbcWeaklyConnected /
	dbcStronglyConnected / nil"
"Given two pins, it returns a symbol representing the connectivity between two pins.")
("dbGetStrongGroups"
"dbGetStrongGroups(
d_object
)
=> ~>name"
"This function is obsolete in this release. Strong connections are modeled by multiple pinFigs on the same pin.")
("dbHasExternalConnections"
"dbHasExternalConnections(
d_connectivityObject
)
=> t / nil"
"Reports if the given net or terminal has one or more pins that are externally connected. dbHasExternalConnections(connectivityObject) is equivalent to dbHasMustConnections(connectivityObject).")
("dbHasMustConnections"
"dbHasMustConnections(
anObject
)
=> t"
"Reports if the given net or terminal has one or more pins that are must connected. dbHasMustConnections(anObject) is equivalent to dbHasExternalConnections(connectivityObject).")
("dbMergeStrongGroups"
"dbMergeStrongGroups(
l_pinList
)
=> t / nil"
"This function is obsolete in this release. Strong connections are modeled by multiple pinFigs on the same pin.")
("dbMustConnectPins"
"dbMustConnectPins(
l_pinList
)
=> t / nil"
"This function is obsolete in this release. External Pin connections are modeled by collections of MustJoin Terms. See dbSetTermMustJoin.")
("dbStronglyConnectPins"
"dbStronglyConnectPins(
l_pinList
)
=> t / nil"
"This function is obsolete in this release. Strong connections are modeled by multiple pinFigs on the same pin.")
("dbTransformAccessDirection"
"dbTransformAccessDirection( 
x_dirCode 
t_orient 
)
=> x_dirCode / nil"
"Transforms the given direction by the specified orientation and returns the corresponding access direction.")
("dbWeaklyConnectPins"
"dbWeaklyConnectPins(
l_pinList
)
=> t / nil"
"This function is obsolete in this release. Weak pin connections are modeled by pinFigs on different pins on the same terminal.")
("dbAddFigsToPin"
"dbAddFigsToPin(
d_pinId
ld_figId
)
=> t / nil"
"Adds a list of figures to the given pin. ")
("dbAddFigToPin"
"dbAddFigToPin(
d_pinId
d_figId
)
=> t / nil"
"Adds the specified figure to the given pin. ")
("dbGetPinFigAccessDirection"
"dbGetPinFigAccessDirection(
d_figId
)
=> t_pinFigAccessDir / nil"
"Returns the access direction for the specified pin figure.")
("dbGetPinFigName"
"dbGetPinFigName(
d_figId
)
=> t_pinFigName / nil"
"Returns the name of the figure specified by the pin figure ID. ")
("dbGetPinFigPlacementStatus"
"dbGetPinFigPlacementStatus(
d_figId
)
=> t_pinFigPlacement / nil"
"Returns the placement status for the specified pin figure.")
("dbSetPinFigAccessDirection"
"dbSetPinFigAccessDirection(
d_pinFigId
lt_accessDir
)
=> t / nil"
"Specifies the access direction for the given pin figure.")
("dbSetPinFigName"
"dbSetPinFigName(
d_pinId
t_pinName
)
=> t / nil"
"Specifies the name for the given pin figure. ")
("dbSetPinFigPlacementStatus"
"dbSetPinFigPlacementStatus(
d_figId
g_placementStat
)
=> t / nil"
"Specifies the placement status for the given pin figure.")
("dbSetTermMustJoin"
"dbSetTermMustJoin(
d_termId
d_mustJoinTermId
)
=> t / nil"
"Sets the connection status of the terminals specified by the terminal IDs to mustJoin. ")
("dbSubFigFromPin"
"dbSubFigFromPin(
d_pinId
d_figId
)
=> t / nil"
"Removes the specified figure from the given pin. ")
("dbSubFigsFromPin"
"dbSubFigsFromPin(
d_pinId
ld_figId
)
=> t / nil"
"Removes the specified list of figures from the given pin. ")
("dbUnsetTermMustJoin"
"dbUnsetTermMustJoin(
d_termId
)
=> t / nil"
"Removes the mustJoin pin connection status from the given terminal. ")
("dbSetTermMustConnectAllPins"
"dbSetTermMustConnectAllPins(
d_termId
g_value { t / nil }
)
=> t / nil"
"Indicates whether to set the mustConnectAllPins attribute on the specified terminal. The terminal must be a single-bit terminal.")
("dbTermHasMustConnectAllPins"
"dbTermHasMustConnectAllPins(
d_termId
)
=> t / nil"
"Checks whether the mustConnectAllPins attribute value is set on the specified single-bit terminal.")
("dbCreateAreaPinGroupGuide"
"dbCreateAreaPinGroupGuide(
d_cellViewId
t_name
)
=> d_pinGroupGuideId / nil"
"Creates an area pin group guide with the specified name in the given cellview.")
("dbCreateEdgePinGroupGuide"
"dbCreateEdgePinGroupGuide(
d_cellViewId
t_name
)
=> d_edgePinGroupGuideId / nil"
"Creates an edge pin group guide with the specified name in the given cellview.")
("dbFindPinGroupGuideByName"
"dbFindPinGroupGuideByName(
d_cellViewId
t_name
)
=> d_pinGroupGuideId / nil"
"Searches for the pin group guide with the specified name in the given cellview.")
("dbGetAreaBoundaryPinGroupGuide"
"dbGetAreaBoundaryPinGroupGuide(
d_areaBoundaryId
)
=> d_pinGroupGuideId / nil"
"Returns the pin group guide associated with the specified area boundary.")
("dbGetAreaPinGroupGuideAreas"
"dbGetAreaPinGroupGuideAreas(
d_areaPinGroupGuideId
)
=> l_areaBoundaryIds / nil"
"Returns the list of area boundaries associated with the specified area pin group guide.")
("dbGetFigPinGroupGuide"
"dbGetFigPinGroupGuide(
d_figId
)
=> d_pinGroupGuideId / nil"
"Returns the pin group guide associated with the specified figure.")
("dbGetPRBoundaryPinGroupGuides"
"dbGetPRBoundaryPinGroupGuides(
d_prBoundaryId
)
=> l_pinGroupGuideIds / nil"
"Returns the list of pin group guides associated with the specified prBoundary.")
("dbGetPinGroupGuideEdgeBoundary"
"dbGetPinGroupGuideEdgeBoundary(
d_edgePinGroupGuide
)
=> d_prBoundary / nil"
"Returns the prBoundary associated with the specified edge pin group guide.")
("dbGetPinGroupGuideEdgeName"
"dbGetPinGroupGuideEdgeName(
d_edgePinGroupGuide
)
=> t_name / nil"
"Returns the edge name of the specified edge pin group guide.")
("dbGetPinGroupGuideEdgeStartOffset"
"dbGetPinGroupGuideEdgeStartOffset(
d_edgePinGroupGuide
)
=> n_offset / nil"
"Returns the start offset of the edge for the specified edge pin group guide.")
("dbGetPinGroupGuideEdgeStopOffset"
"dbGetPinGroupGuideEdgeStopOffset(
d_edgePinGroupGuide
)
=> n_offset / nil"
"Returns the stop offset of the edge for the specified edge pin group guide.")
("dbGetPinGroupGuides"
"dbGetPinGroupGuides(
d_cellViewId
)
=> l_pinGroupGuides / nil"
"Returns the list of pin group guides associated with the specified cellview.")
("dbGetPinPinGroupGuides"
"dbGetPinPinGroupGuides(
d_pinId
)
=> l_pinGroupGuideIds / nil"
"Returns the list of pin group guides associated with the specified pin.")
("dbAddAreaToPinGroupGuide"
"dbAddAreaToPinGroupGuide(
d_areaPinGroupGuideId
d_areaBoundaryId
)
=> t / nil"
"Adds an area boundary to the specified area pin group guide.")
("dbAddFigToPinGroupGuide"
"dbAddFigToPinGroupGuide(
d_pinGroupGuideId
d_figId
)
=> t / nil"
"This function adds a via or a non-text shape to the specified pin group guide.")
("dbAddPinToPinGroupGuide"
"dbAddPinToPinGroupGuide(
d_pinGroupGuideId
d_pinId
)
=> t / nil"
"This function adds a pin to the specified pin group guide.")
("dbSubAreaFromPinGroupGuide"
"dbSubAreaFromPinGroupGuide(
d_areaPinGroupGuideId
d_areaBoundaryId
)
=> t / nil"
"This function removes an area boundary from the specified area pin group guide.")
("dbSubFigFromPinGroupGuide"
"dbSubFigFromPinGroupGuide(
d_pinGroupGuideId
d_figId
)
=> t / nil"
"This function removes a via or a non-text shape from the specified pin group guide.")
("dbSubPinFromPinGroupGuide"
"dbSubPinFromPinGroupGuide(
d_pinGroupGuideId
d_pinId
)
=> t / nil"
"This function removes a pin from the specified pin group guide.")
("dbRemovePinGroupGuideEdge"
"dbRemovePinGroupGuideEdge(
d_edgePinGroupGuide
)
=> t / nil"
"This function removes the prBoundary and edge name specification from the specified edge pin group guide.")
("dbSetPinGroupGuideEdge"
"dbSetPinGroupGuideEdge(
d_edgePinGroupGuide
d_prBoundary
t_name
)
=> t / nil"
"This function specifies new or updates existing prBoundary edge information for the edge pin group guide.")
("dbSetPinGroupGuideEdgeStartOffset"
"dbSetPinGroupGuideEdgeStartOffset(
d_edgePinGroupGuide
n_offset
)
=> t / nil"
"This function sets the start offset of the edge on the edge pin group guide.")
("dbSetPinGroupGuideEdgeStopOffset"
"dbSetPinGroupGuideEdgeStopOffset(
d_edgePinGroupGuide
n_offset
)
=> t / nil"
"This function sets the stop offset of the edge on the edge pin group guide.")
("dbGetAreaBoundaryValidRoutingLayers"
"dbGetAreaBoundaryValidRoutingLayers(
d_areaBoundaryId
)
=> l_layers / nil"
"This function returns the value of the validRoutingLayers constraint on the given area boundary.")
("dbAreaBoundaryHasLayerPriorityOrder"
"dbAreaBoundaryHasLayerPriorityOrder(
d_areaBoundaryId
)
=> t / nil"
"This function returns a boolean value indicating that the layerPriorityOrder constraints set on the specified area boundary.")
("dbAreaBoundaryHasValidRoutingLayers"
"dbAreaBoundaryHasValidRoutingLayers(
d_areaBoundaryId
)
=> t / nil"
"This function returns a boolean value indicating that the validRoutingLayers constraint is set on the specified area boundary.")
("dbGetAreaBoundaryLayerPriorityOrder"
"dbGetAreaBoundaryLayerPriorityOrder(
d_areaBoundaryId
)
=> t / nil"
"This function returns the value of the layerPriorityOrder constraint that is set on the specified area boundary.")
("dbGetPinGroupGuideKeepoutSpacing"
"dbGetPinGroupGuideKeepoutSpacing(
d_pinGroupGuide
tx_layer
)
=> n_value / nil"
"This function returns the value of the keepoutSpacing constraint set on the specified pin group guide.")
("dbGetPinGroupGuideLayerPriorityOrder"
"dbGetPinGroupGuideLayerPriorityOrder(
d_areaPinGroupGuide
)
=> t / nil"
"This function returns the value of the layerPriorityOrder constraint set on the specified area pin group guide.")
("dbGetPinGroupGuideMinPinSpacing"
"dbGetPinGroupGuideMinPinSpacing(
d_pinGroupGuide
tx_layer
)
=> n_value / nil"
"This function returns the value of the minSpacing constraint set on the specified pin group guide.")
("dbGetPinGroupGuideMinPinWidth"
"dbGetPinGroupGuideMinPinWidth(
d_pinGroupGuide
tx_layer
)
=> n_value / nil"
"This function returns the value of the minWidth constraint set on the specified pin group guide.")
("dbGetPinGroupGuideValidRoutingLayers"
"dbGetPinGroupGuideValidRoutingLayers(
d_areaPinGroupGuide
)
=> l_layers / nil"
"This function returns the value of the validRoutingLayers constraint set on the specified area pin group guide.")
("dbGetPinMinPinSpacing"
"dbGetPinMinPinSpacing(
d_pinId
tx_layer
)
=> n_value / nil"
"This function returns the value of the minSpacing constraint set on the specified pin.")
("dbGetPinMinPinWidth"
"dbGetPinMinPinWidth(
d_pinId
tx_layer
)
=> n_value / nil"
"This function returns the value of the minWidth constraint set on the specified pin.")
("dbPinGroupGuideHasKeepoutSpacing"
"dbPinGroupGuideHasKeepoutSpacing(
d_pinGroupGuide
tx_layer
)
=> t / nil"
"This function returns a boolean value indicating that the keepoutSpacing constraint is set on the specified pin group guide.")
("dbPinGroupGuideHasLayerPriorityOrder"
"dbPinGroupGuideHasLayerPriorityOrder(
d_areaPinGroupGuide
)
=> t / nil"
"This function returns a boolean value indicating that the layerPriorityOrder constraint is set on the specified area pin group guide.")
("dbPinGroupGuideHasMinPinSpacing"
"dbPinGroupGuideHasMinPinSpacing(
d_PinGroupGuide
tx_layer
)
=> t / nil"
"This function returns a boolean value indicating whether the minSpacing constraint is set on the specified pin group guide.")
("dbPinGroupGuideHasMinPinWidth"
"dbPinGroupGuideHasMinPinWidth(
d_PinGroupGuide
tx_layer
)
=> t / nil"
"This function returns a boolean value indicating whether the minWidth constraint is set on the specified pin group guide.")
("dbPinGroupGuideHasValidRoutingLayers"
"dbPinGroupGuideHasValidRoutingLayers(
d_areaPinGroupGuide
)
=> t / nil"
"This function returns a boolean value indicating whether the validRoutingLayers constraint is set on the specified area pin group guide.")
("dbPinHasMinPinSpacing"
"dbPinHasMinPinSpacing(
d_PinId
tx_layer
)
=> t / nil"
"This function returns a boolean value indicating whether the minSpacing constraint is set on the specified pin.")
("dbPinHasMinPinWidth"
"dbPinHasMinPinWidth(
d_pinId
tx_layer
)
=> t / nil"
"This function returns a boolean value indicating whether the minWidth constraint has been applied to the specified pin.")
("dbSetAreaBoundaryLayerPriorityOrder"
"dbSetAreaBoundaryLayerPriorityOrder(
d_areaBoundaryId
g_value
)
=> t / nil"
"This function sets the value of the layerPriorityOrder constraint on the given area boundary.")
("dbSetAreaBoundaryValidRoutingLayers"
"dbSetAreaBoundaryValidRoutingLayers(
d_areaBoundaryId
l_layers
)
=> t / nil"
"This function sets the value of the validRoutingLayers constraint on the given area boundary.")
("dbSetPinGroupGuideKeepoutSpacing"
"dbSetPinGroupGuideKeepoutSpacing(
d_pinGroupGuide
tx_layer
n_value
)
=> t / nil"
"This function sets the value of the keepoutSpacing constraint on the given pin group guide.")
("dbSetPinGroupGuideLayerPriorityOrder"
"dbSetPinGroupGuideLayerPriorityOrder(
d_areaPinGroupGuide
g_value
)
=> t / nil"
"This function sets the value of the layerPriorityOrder constraint on the given area pin group guide.")
("dbSetPinGroupGuideMinPinSpacing"
"dbSetPinGroupGuideMinPinSpacing(
d_pinGroupGuide
tx_layer
n_value
)
=> t / nil"
"This function sets the value of the minSpacing constraint on the given pin group guide.")
("dbSetPinGroupGuideMinPinWidth"
"dbSetPinGroupGuideMinPinSpacing(
d_pinGroupGuide
tx_layer
n_value
)
=> t / nil"
"This function sets the value of the minWidth constraint on the given pin group guide.")
("dbSetPinGroupGuideValidRoutingLayers"
"dbSetPinGroupGuideValidRoutingLayers(
d_areapinGroupGuide
l_layers
)
=> t / nil"
"This function sets the value of the validRoutingLayers constraint on the given area pin group guide.")
("dbSetPinMinPinSpacing"
"dbSetPinMinPinSpacing(
d_pinID
tx_layer
n_value
)
=> t / nil"
"This function sets the value of the minSpacing constraint on the given pin.")
("dbSetPinMinPinWidth"
"dbSetPinMinPinWidth(
d_pinID
tx_layer
n_value
)
=> t / nil"
"This function sets the value of the minWidth constraint on the given pin.")
("dbUnsetAreaBoundaryLayerPriorityOrder"
"dbUnsetAreaBoundaryLayerPriorityOrder(
d_areaBoundaryId
)
=> t / nil"
"This function deletes the layerPriorityOrder constraint on the given area boundary.")
("dbUnsetAreaBoundaryValidRoutingLayers"
"dbUnsetAreaBoundaryValidRoutingLayers(
d_areaBoundaryId
)
=> t / nil"
"This function deletes the validRoutingLayers constraint on the given area boundary.")
("dbUnsetPinGroupGuideKeepoutSpacing"
"dbUnsetPinGroupGuideKeepoutSpacing(
d_pinGroupGuide
tx_layer
)
=> t / nil"
"This function deletes the keepoutSpacing constraint on the given pin group guide.")
("dbUnsetPinGroupGuideLayerPriorityOrder"
"dbUnsetPinGroupGuideLayerPriorityOrder(
d_areaPinGroupGuide
)
=> t / nil"
"This function deletes layerPriorityOrder constraint on the given area pin group guide.")
("dbUnsetPinGroupGuideMinPinSpacing"
"dbUnsetPinGroupGuideMinPinSpacing(
d_pinGroupGuide
tx_layer
)
=> t / nil"
"This function deletes the minSpacing constraint on the given pin group guide.")
("dbUnsetPinGroupGuideMinPinWidth"
"dbUnsetPinGroupGuideMinPinSpacing(
d_pinGroupGuide
tx_layer
)
=> t / nil"
"This function deletes the minWidth constraint on the given pin group guide.")
("dbUnsetPinGroupGuideValidRoutingLayers"
"dbUnsetPinGroupGuideValidRoutingLayers(
d_areapinGroupGuide
)
=> t / nil"
"This function deletes the validRoutingLayers constraint on the given area pin group guide.")
("dbUnsetPinMinPinSpacing"
"dbUnsetPinMinPinSpacing(
d_pinID
tx_layer
)
=> t / nil"
"This function deletes the minSpacing constraint on the given pin.")
("dbUnsetPinMinPinWidth"
"dbUnsetPinMinPinWidth(
d_pinID
tx_layer
)
=> t / nil"
"This function deletes the minWidth constraint on the given pin.")
("dbCreateBackgroundDef"
"dbCreateBackgroundDef(
d_cvId
t_name
l_lpp
t_netName
g_leftEnc
g_rightEnc
g_topEnc
g_bottomEnc
) 
=> d_backgroundDefId / nil"
"Creates a backgroundDef based on the specified attributes. The layer-purpose pair must exist to create a backgroundDef.")
("dbCreateBackgroundDefByAttr"
"dbCreateBackgroundDefByAttr(
d_cvId
t_name
g_dpl
)
=> d_bgDefId / nil"
" Creates a backgroundDef based on the SKILL DPL specification of the object. Contents of the SKILL DPL specification are checked before the backgroundDef is created.")
("dbGetBackgroundDefAttr"
"dbGetBackgroundDefAttr(
d_bgDefId
)
=> l_attr / nil"
"Returns the attributes of the specified backgroundDef.")
("dbGetCellViewBackgroundDef"
"dbGetCellViewBackgroundDef(
d_cellviewId
) 
=> l_bgDefId / nil"
" Returns list of backgroundDefs in the given cellview.")
("dbCreateCompTypeSetDef"
"dbCreateCompTypeSetDef( 
d_cellViewId 
t_compTypeSetName 
t_rowReference
t_componentReference
l_allowedOrientations
l_componentTypes
[ g_componentOffset ]
[ g_pitch ]
)
=> d_compTypeSetDef / nil"
"This function creates a container of component types that use the same placement attributes.")
("dbCreateCompTypeSetDefByAttr"
"dbCreateCompTypeSetDefByAttr(
d_cvId
t_name
l_attr_dpl
)
=> d_compTypeSetDefId/nil"
" Creates a compTypeSetDef in the given cellview based on the specified attributes list.")
("dbGetCellViewCompTypeSetDef"
"dbGetCellViewCompTypeSetDef( 
d_cellViewId 
)
=> d_compTypeSetDef / nil"
"This function returns a list of compTypeSetDef objects defined in the specified cellview.")
("dbGetCompTypeSetDefAttr"
"dbGetCompTypeSetDefAttr(
d_compDefId
)
=> l_attr / nil"
" Returns the attributes of the specified dbCompTypeSetDef.")
("dbGetCompTypeSetDefCompFilters"
"dbGetCompTypeSetDefCompFilters(
d_compDefId
)
=> l_compFilters / nil"
" Returns the component filters in the specified compTypeSetDef.")
("dbSetCompTypeSetDefCompFilters"
"dbSetCompTypeSetDefCompFilters(
d_compDefId 
l_compFilters
) 
=> t/nil"
" Sets the component filters in the specified compTypeSetDef.")
("dbUnsetCompTypeSetDefCompFilters"
"dbUnsetCompTypeSetDefCompFilters(
d_compDefId
) 
=> t / nil"
" Removes the component filters from the specified compTypeSetDef.")
("dbCreateRailDef"
"dbCreateRailDef( 
d_cellViewId 
t_raildDefName
t_netName
l_lpp
t_rowReference
t_railReference
g_width
[ g_offset ]
[ g_beginOffset ]
[ g_endOffset ]
)
=> d_railDef / nil"
"This function creates a container of attributes to define a row rail. The definition can be referenced in more than one row or placeArea. If a physical attribute is modifed in the object, it is instantly reflected in all row/placeArea that reference the railDef.")
("dbCreateRailDefByAttr"
"dbCreateRailDefByAttr(
d_cvId
t_name
l_attr_dpl
) 
=> d_railDefId / nil"
"Creates railDef based on the SKILL DPL of the railDef object specification. Contents of the SKILL DPL specification are checked before railDef is created.")
("dbGetCellViewRailDef"
"dbGetCellViewRailDef( 
d_cellViewId 
)
=> l_railDefObjects / nil"
"Returns a list of railDef objects defined in the specified cellview.")
("dbGetRailDefAttr"
"dbGetRailDefAttr(
d_railDefId
)
=> l_attr / nil"
"Returns the rail attributes of the specified railDef.")
("dbGetRailDefFigType"
"dbGetRailDefFigType(
d_railDefId
) 
=> t_figType / nil"
"Returns the figType specified in the given railDef.")
("dbSetRailDefFigType"
"dbSetRailDefFigType(
d_railDefId
t_railFigType
) 
=> t / nil"
"Sets the railFigType for the specified railDef.")
("dbAddPlaceAreaBackgroundDef"
"dbAddPlaceAreaBackgroundDef(
d_plcAreaId 
d_bgDefId
) 
=> t / nil"
"Adds a reference to the specified placeArea object in the given backgroundDef. A warning message is displayed if the objects are not of the correct type.")
("dbAddPlaceAreaCompTypeSetDef"
"dbAddPlaceAreaCompTypeSetDef( 
d_placeAreaId
d_compTypeSetDefId
)
=> t / nil"
"Adds a reference in the specified placeArea to the specified compTypeSetDefs. A warning message is displayed if the objects are not of the correct type.")
("dbAddPlaceAreaRailDef"
"dbAddPlaceAreaRailDef( 
d_placeAreaId
d_railDefId
)
=> t / nil"
"Adds a reference in the specified placeArea to the specified railDef. A warning message is displayed if the objects specified are not of the correct type.")
("dbCreatePlaceArea"
"dbCreatePlaceArea( 
d_cellViewId 
t_name 
g_width
g_height
l_origin
t_orientation
[ f_utilization ] 
)
=> d_IdOfCustomPlacementArea / nil"
"Creates a custom placeArea in the specified cellview. A custom placeArea is a row structure used for placing device-level instances.")
("dbGetCellViewPlaceArea"
"dbGetCellViewPlaceArea(
d_cellviewId 
)
=> l_customPlacementAreas / nil"
"Returns a list of custom placeAreas in the specified cellview.")
("dbGetPlaceAreaBackgroundDef"
"dbGetPlaceAreaBackgroundDef(
d_plcAreaId
) 
=> l_bgDefId / nil"
"Returns a list of database IDs of the backgroundDefs in the specified placeArea.")
("dbGetPlaceAreaCompTypeSetDef"
"dbGetPlaceAreaCompTypeSetDef(
d_customPlacementArea 
)
=> l_dbCompTypeSetDefs / nil"
"Returns a list of dbCompTypeSetDefs referenced in the specified placeArea.")
("dbGetPlaceAreaOrient"
"dbGetPlaceAreaOrient(
d_customPlacementArea 
)
=> s_orientation / nil"
"Returns the orientation of the specified custom placeArea.")
("dbGetPlaceAreaRailDef"
"dbGetPlaceAreaRailDef(
d_customPlacementArea 
)
=> l_dbRailDefs / nil"
"Returns a list of dbRailDefs referenced in the specified custom placeArea.")
("dbGetPlaceAreaUtilization"
"dbGetPlaceAreaUtilization(
d_customPlacementArea 
)
=> f_utilizationValue / nil"
"Returns the assigned placement utilization for the specified custom placeArea.")
("dbGetPlacementGrid"
"dbGetPlacementGrid(
d_cellviewId 
)
=> l_placementGridInfo / nil"
"Returns the placement grid information for the specified cellview.")
("dbRemovePlaceAreaBackgroundDef"
"dbRemovePlaceAreaBackgroundDef(
d_plcAreaId 
d_bgDefId
)
=> t / nil"
"Removes the association between the specified placeArea and backgroundDef. The background shape on the placeArea is also removed.")
("dbRemovePlaceAreaCompTypeSetDef"
"dbRemovePlaceAreaCompTypeSetDef( 
d_placeAreaId
d_compTypeSetDefId 
)
=> t / nil"
"Removes a reference to the specified compTypeSetDef in the specified placeArea. A warning message is displayed if the objects are not of the correct type.")
("dbRemovePlaceAreaRailDef"
"dbRemovePlaceAreaRailDef( 
d_placeAreaId
d_railDefId 
)
=> t / nil"
"Removes a reference to the specified railDef in the specified placeArea. The rail geometry is also deleted. A warning message is displayed if the objects are not of the correct type.")
("dbSetPlaceAreaOrient"
"dbSetPlaceAreaOrient(
d_customPlacementArea
s_orientation
)
=> t / nil"
"Sets the orientation of the specified custom placeArea.")
("dbSetPlaceAreaUtilization"
"dbSetPlaceAreaUtilization(
d_customPlacementArea
f_utilizationValue
)
=> t / nil"
"Sets the assigned placement utilization for the specified custom placeArea.")
("dbSetPlacementGrid"
"dbSetPlacementGrid(
d_cellviewId
l_origin 
f_pitchX
f_pitchY
)
=> t / nil"
"Sets the placement grid information. The origin of the placement grid, and the X pitch and Y values are set for the specified cellview.")
("dbAddRowBackgroundDef"
"dbAddRowBackgroundDef(
d_rowId
d_bgDefId
)
=> t / nil"
"Adds a reference to the specified row object in the given backgroundDef. A warning message is displayed if the objects are not of the correct type.")
("dbAddRowCompTypeSetDef"
"dbAddRowCompTypeSetDef( 
d_rowId 
d_compTypeSetDefId 
)
=> t / nil"
"Adds a reference in the specified compTypeSetDef to the specified row object. A warning message is displayed if the objects are not of the correct type.")
("dbGetRowBackgroundDef"
"dbGetRowBackgroundDef(
d_rowId
) 
=> l_bgDefId / nil"
"Returns a list of backgroundDefs in the specified custom row.")
("dbGetRowCompTypeSetDef"
"dbGetRowCompTypeSetDef(
d_rowId
)
=> l_compTypeSetDefs / nil"
"Returns a list of dbCompTypeSetDefs referenced in the specified row.")
("dbAddRowRailDef"
"dbAddRowRailDef( 
d_rowId 
d_railDefId 
)
=> t / nil"
"Adds a reference in the specified railDef to the specified row object. A warning message is displayed if the objects are not of the correct type.")
("dbGetRowRailDef"
"dbGetRowRailDef(
d_rowId
)
=> l_dbRailDefs / nil"
"Returns a list of dbRailDefs referenced in the specified row.")
("dbRemoveRowCompTypeSetDef"
"dbRemoveRowCompTypeSetDef( 
d_rowId 
d_compTypeSetDefId 
)
=> t / nil"
"Removes a reference to the specified compTypeSetDef in the specified row. A warning message is displayed if the objects are not of the correct type.")
("dbRemoveRowBackgroundDef"
"dbRemoveRowBackgroundDef(
d_rowId 
d_bgDefId
) => t / nil"
"Removes the given backgroundDef from the specified custom row. Removing a backgroundDef also removes the background shape associated with the backgroundDef from the custom row.")
("dbRemoveRowRailDef"
"dbRemoveRowRailDef( 
d_rowId 
d_railDefId
)
=> t / nil"
"Removes a reference to the specified railDef in the specified row. The rail geometry is also deleted. A warning message is displayed if the objects are not of the correct type.")
("dbCreateRowRegionSpec"
"dbCreateRowRegionSpec(
d_cvId
t_name
{ n_height | d_siteDef }
l_rowAttrs
[ l_refGridNames ]
[ l_refGridOffsets ]
[ t_relSnapPatternName ]
[ t_type ]
)
=> d_specId / nil"
"(ICADVM20.1 Only) Creates rowRegionSpec in the specified cellview.")
("dbFindRowRegionSpec"
"dbFindRowRegionSpec(
d_cvId 
t_name
) 
=> d_specId / nil"
"(ICADVM20.1 Only) Searches for a rowRegionSpec with the specified name in the given cellview.")
("dbGetCellViewRowRegionSpecs"
"dbGetCellViewRowRegionSpecs(
d_cellviewId
)
=> l_rowRegionSpecs / nil"
"Returns a list of rowRegionSpecs in the specified cellview.")
("dbAttachRowRegionToPRBoundary"
"dbAttachRowRegionToPRBoundary(
d_rowRegionId
)
=> t / nil"
"(ICADVM20.1 Only) Associates the given rowRegion with the PRBoundary in the same block. If the PRBoundary is assigned to another rowRegion, it is first detached from that region before being assigned to the specified rowRegion.")
("dbCreateRowRegion"
"dbCreateRowRegion(
d_cvId
t_name
t_specName
l_points
) 
=> d_rowRegionId/nil"
"(ICADVM20.1 Only) Creates a rowRegion in the specified cellview. The contents of the rowRegion are created based on the template defined in the rowRegionSpec.")
("dbDetachPRBoundaryFromRowRegion"
"dbDetachPRBoundaryFromRowRegion(
d_PRBoundaryId
) 
=> t / nil"
"(ICADVM20.1 Only) Detaches the PRBoundary from any associated rowRegion.")
("dbFindRowRegion"
"dbFindRowRegion(
d_cvId
t_name
) 
=> d_rowRegionId / nil"
"(ICADVM20.1 Only) Searches for a rowRegion by the specified name in the given cellview.")
("dbFlattenRowRegion"
"dbFlattenRowRegion(
d_rowRegionId
)
=> t / nil"
"(ICADVM20.1 Only) Flattens the rowRegion by removing information related to the associated figGroup and areaBoundary, and retaining information related to rows and other shapes.")
("dbGetCellViewRowRegions"
"dbGetCellViewRowRegions(
d_cellviewId
)
=> l_rowRegionSpecs / nil"
"(ICADVM20.1 Only) Returns a list of rowRegions in the specified cellview.")
("dbGetRowRegionAttachedToPRBoundary"
"dbGetRowRegionAttachedToPRBoundary(
d_prBoundaryId
) 
=> d_rowRegionId / nil"
"(ICADVM20.1 Only) Returns the database ID of the rowRegion attached to the given PRBoundary.")
("dbGetRowRegionPlaceRows"
"dbGetRowRegionPlaceRows(
d_rowRegionId)
=> l_placeRowId / nil"
"(ICADVM20.1 Only) Returns a list of all placement rows scoped to the given rowRegion. Placement rows can be a standard row or a custom placeArea object.")
("dbGetRowRegionPoints"
"dbGetRowRegionPoints(
d_rowRegionId
) 
=> l_points / nil"
"(ICADVM20.1 Only) Returns a list of rectilinear points that define the rowRegion boundary.")
("dbGetRowRegionRowRegionSpec"
"dbGetRowRegionRowRegionSpec(
d_rowRegionId
) 
=> d_rowRegionSpecId / nil"
"(ICADVM20.1 Only) Returns the rowRegionSpec from which the specified rowRegion was generated.")
("dbGetRowRegionSpecRowRegions"
"dbGetRowRegionSpecRowRegions(
d_rowRegionSpecId
) 
=> l_rowRegions / nil"
"(ICADVM20.1 Only) Returns a list of rowRegions built on the basis of the given rowRegionSpec.")
("dbGetRowRegionUsesPartialRowSpec"
"dbGetRowRegionUsesPartialRowSpec(
d_rowRegionID
) 
=> t / nil"
"(ICADVM20.1 Only) Confirms whether the fill space of rowRegion should be populated with partial specialization of rowRegionSpec.")
("dbIsRowRegion"
"dbIsRowRegion(
d_Id
) 
=> t / nil"
"(ICADVM20.1 Only) Checks if the specified database object is a rowRegion.")
("dbIsRowRegionAttachedToPRBoundary"
"dbIsRowRegionAttachedToPRBoundary(
d_rowRegionId
) 
=> t / nil"
"(ICADVM20.1 Only) Checks whether the specified rowRegion is associated with the PRBoundary of the block that contains the rowRegion.")
("dbRowRegionPointsCutOut"
"dbRowRegionPointsCutOut(
d_rowRegionId 
l_box
) 
=> t / nil"
"(ICADVM20.1 Only) Changes the rectilinear specification of the specified rowRegion by cutting out the portion of it defined by the specified box. The box cannot fully cover the current rowRegion and it cannot split it into two or more fully independent rowRegions.")
("dbRebuildRowRegion"
"dbRebuildRowRegion(
d_rowRegionId
) 
=> t / nil"
"(ICADVM20.1 Only) Removes contents of the specified rowRegion and then regenerates it based on the rowRegionSpec associated with it.")
("dbRowRegionMatchesSpec"
"dbRowRegionMatchesSpec(
d_rowRegionId
) 
=> t / nil"
"(ICADVM20.1 Only) Checks whether the rowRegion matches its rowRegionSpec.")
("dbSetRowRegionPoints"
"dbSetRowRegionPoints(
d_rowRegionId
l_points
)
=> t / nil"
"(ICADVM20.1 Only) Changes the rectilinear specification of the given rowRegion.")
("dbSetRowRegionRowRegionSpec"
"dbSetRowRegionRowRegionSpec(
d_rowRegionId 
d_rowRegionSpecId
) 
=> t / nil"
"(ICADVM20.1 Only) Sets the given rowRegionSpec as the template for the specified rowRegion.")
("dbSetRowRegionUsesPartialRowSpec"
"dbSetRowRegionUsesPartialRowSpec(
d_rowRegionId 
g_value
) 
=> t / nil"
"(ICADVM20.1 Only) A Boolean indicating whether the population of rowRegion is set to fill the space with partial specialization of rowRegionSpec.")
("dbGetPlaceRowVersion"
"dbGetPlaceRowVersion(
[d_cvId]
) 
=> n_version / nil"
"(ICADVM20.1 Only) Returns the version of the placement row infrastructure in the given design, or returns the software version if the cellview is not specified.")
("dbGetRowRegionVersion"
"dbGetRowRegionVersion(
[d_cvId]
) 
=> n_version / nil"
"(ICADVM20.1 Only) Returns the version of the rowRegion infrastructure used in the given design, or returns the software version if the cellview is not specified.")
("dbIsImplicit"
"dbIsImplicit(
d_objectId
) 
=> t / nil"
"(ICADVM20.1 Only) Verifies whether the object represented by the specified database ID is implicit. Supported objects: dbRailDef, dbBackgroundDef and dbCompTypeSetDef.")
("dbIsInRowRegion"
"dbIsInRowRegion(
d_FigId
) 
=> t / nil"
"(ICADVM20.1 Only) Checks if a figure with the given figure database ID belongs to a rowRegion.")
("dbCreateTopology"
"dbCreateTopology(
t_name 
d_netId
)
=> d_topologyId / nil"
"Creates a topology on the specified net with the given name. The net must be a single-bit net.")
("dbDeleteTopology"
"dbDeleteTopology(
d_topologyId 
)
=> t / nil"
"Deletes the specified topology, which includes removing the association it has with the net, and deleting the associated trunk, trunk connect pattern, and strap pattern.")
("dbGetCellViewTopologies"
"dbGetCellViewTopologies(
d_cellViewId 
)
=> l_topologyIds / nil"
"Returns a list of topologies in the specified cellview.")
("dbGetNetTopologies"
"dbGetNetTopologies(
d_netId 
)
=> l_topologyIds / nil"
"Returns a list of topologies associated with the specified net.")
("dbGetTopologyName"
"dbGetTopologyName(
d_topologyId 
)
=> t_name / nil"
"Returns the name of the topology associated with the specified topology ID.")
("dbGetTopologyNet"
"dbGetTopologyNet(
d_topologyId 
)
=> t_name / nil"
"Returns the net associated with the specified topology ID.")
("dbGetTopologyObjects"
"dbGetTopologyObjects(
d_topologyId 
)
=> l_patterns / nil"
"Returns the list of trunks, trunk connects, and straps owned by the specified topology.")
("dbGetTopologyPatternType"
"dbGetTopologyPatternType(
d_patternId 
)
=> t_tpGroupType / nil"
"Returns the type of the specified topology pattern ID. The valid types are topology, trunkConnect, trunk, twig, strap, and generic.")
("dbSetTopologyName"
"dbSetTopologyName(
d_topologyId 
t_name
)
=> t / nil"
"Sets the name of the specified topology ID.")
("dbSetTopologyNet"
"dbSetTopologyNet(
d_topologyId 
d_netId
)
=> t / nil"
"Changes the net associated with the specified topology. The net must be a single-bit net.")
("dbCreateTrunk"
"dbCreateTrunk(
t_name
d_topologyId 
t_direction 
)
=> d_trunkId / nil"
"Creates a trunk pattern on the specified topology with the given name and direction.")
("dbDeleteTrunk"
"dbDeleteTrunk(
d_trunkId 
)
=> t / nil"
"Deletes the specified trunk pattern and objects associated with that pattern, such as trunk connects and twigs.")
("dbGetTrunkAnchor"
"dbGetTrunkAnchor(
d_trunkId 
)
=> d_anchorId / nil"
"Returns the anchor of the specified trunk pattern. The anchor may be an instance or another trunk.")
("dbGetTrunkDirection"
"dbGetTrunkDirection(
d_trunkId 
)
=> t_direction / nil"
"Returns the direction of the specified trunk pattern ID.")
("dbGetTrunkLongOffset1"
"dbGetTrunkLongOffset1(
d_trunkId 
)
=> f_longitudinalOffset1 / nil"
"Returns the longitudinal offset1 value of the specified trunk pattern ID.")
("dbGetTrunkLongOffset2"
"dbGetTrunkLongOffset2(
d_trunkId 
)
=> f_longitudinalOffset2 / nil"
"Returns the longitudinal offset2 value of the specified trunk pattern ID.")
("dbGetTrunkLongOffsetSource"
"dbGetTrunkLongOffsetSource(
d_trunkId 
)
=> t_source / nil"
"Returns the longitudinal offset source value of the specified trunk pattern ID.")
("dbGetTrunkLongOffsetSource1"
"dbGetTrunkLongOffsetSource1(
d_trunkId 
)
=> t_source / nil"
"Returns the first longitudinal offset source value of the specified trunk pattern ID. Valid source values are unknown, twigExtents, figGroupExtents, instanceExtents, guardRing, and connExtents.")
("dbGetTrunkLongOffsetSource2"
"dbGetTrunkLongOffsetSource2(
d_trunkId 
)
=> t_source / nil"
"Returns the second longitudinal offset source value of the specified trunk pattern ID. Valid source values are unknown, twigExtents, figGroupExtents, instanceExtents, guardRing, and connExtents.")
("dbGetTrunkName"
"dbGetTrunkName(
d_trunkId 
)
=> t_name / nil"
"Returns the name of the trunk specified by the trunk pattern ID.")
("dbGetTrunkOrthoOffset"
"dbGetTrunkOrthoOffset(
d_trunkId 
)
=> n_offset / nil"
"Returns the orthogonal offset of the specified trunk pattern ID. The value returned is in userUnits. An orthogonal offset is meaningful only when there is an anchor set for the trunk pattern.")
("dbGetTrunkSide"
"dbGetTrunkSide(
d_trunkId 
)
=> t_side / nil"
"Returns the side of the trunk specified by the trunk pattern ID.")
("dbGetTrunkTopology"
"dbGetTrunkTopology(
d_trunkId 
)
=> d_topologyId / nil"
"Returns the topology pattern that owns the specified trunk pattern ID.")
("dbGetTrunkTwigs"
"dbGetTrunkTwigs(
d_trunkId 
)
=> l_twigs / nil"
"Returns the list of twigs associated with the specified trunk pattern ID.")
("dbSetTrunkAnchor"
"dbSetTrunkAnchor(
d_trunkId 
d_anchorId
)
=> t / nil"
"Sets the anchor for the specified trunk pattern. The anchor may be an instance or another trunk.")
("dbSetTrunkLongOffset1"
"dbSetTrunkLongOffset1(
d_trunkId 
f_longitudinalOffset1 
)
=> t / nil"
"Sets the longitudinal offset1 value for the specified trunk pattern.")
("dbSetTrunkLongOffset2"
"dbSetTrunkLongOffset2(
d_trunkId 
f_longitudinalOffset2 
)
=> t / nil"
"Sets the longitudinal offset2 value for the specified trunk pattern ID.")
("dbSetTrunkLongOffsetSource"
"dbSetTrunkLongOffsetSource(
d_trunkId 
t_source
)
=> t / nil"
"Sets the longitudinal offset source value of the specified trunk pattern ID. Valid source values are twigExtents, figGroupExtents, twigExtentsTermOnly, guardRing.")
("dbSetTrunkLongOffsetSource1"
"dbSetTrunkLongOffsetSource1(
d_trunkId 
t_source
)
=> t / nil"
"Sets the first longitudinal offset source value of the specified trunk pattern ID. Valid source values are twigExtents, figGroupExtents, instanceExtents, guardRing, and connExtents.")
("dbSetTrunkLongOffsetSource2"
"dbSetTrunkLongOffsetSource2(
d_trunkId 
t_source
)
=> t / nil"
"Sets the second longitudinal offset source value of the specified trunk pattern ID. Valid source values are twigExtents, figGroupExtents, instanceExtents, guardRing, and connExtents.")
("dbSetTrunkName"
"dbSetTrunkName(
d_trunkId 
t_name
)
=> t / nil"
"Sets the name of the trunk specified by the trunk pattern ID.")
("dbSetTrunkDirection"
"dbSetTrunkName(
d_trunkId 
t_direction
)
=> t / nil"
"Specifies whether the given trunk is running in the horizontal or vertical direction.")
("dbSetTrunkOrthoOffset"
"dbSetTrunkOrthoOffset(
d_trunkId 
n_offset
)
=> t / nil"
"Sets the orthogonal offset value for the specified trunk pattern ID. The specified value must be in userUnits. An orthogonal offset is only meaningful when there is an anchor set for the trunk pattern.")
("dbSetTrunkSide"
"dbSetTrunkSide(
d_trunkId 
t_side
)
=> t / nil"
"Sets the side value for the specified trunk pattern ID. The valid side values are bottom, top, left, and right.")
("dbCreateTwig"
"dbCreateTwig(
t_name 
d_trunkId
)
=> d_twigId / nil"
"Creates a twig pattern on the specified trunk.")
("dbDeleteTwig"
"dbDeleteTwig(
d_twigId 
)
=> t / nil"
"Deletes the twig pattern.")
("dbGetTwigName"
"dbGetTwigName(
d_twigId 
)
=> t_name / nil"
"Returns the name of the specified twig pattern ID.")
("dbGetTwigObject"
"dbGetTwigObject(
d_twigId 
)
=> d_dbId / nil"
"Returns the database object set for the specified twig ID. A twig can have only one object and that is one of the following: InstTerm, Via, MPPShape, or a Strap.")
("dbGetTwigPinName"
"dbGetTwigPinName(
d_twigId 
)
=> t_pinName / nil"
"Returns the pin name set on the specified twig pattern ID. If there is no pin name for the twig pattern ID, an empty string is returned.")
("dbGetShapeTwigs"
"dbGetShapeTwigs(
d_shapeId 
)
=> l_twigs / nil"
"Returns a list of twigs associated with the given shape ID.")
("dbGetInstTermTwigs"
"dbGetInstTermTwigs(
d_instTermId 
)
=> l_twigs / nil"
"Returns a list of twigs associated with the given instTerm ID.")
("dbGetViaTwigs"
"dbGetViaTwigs(
d_viaId 
)
=> l_twigs / nil"
"Returns a list of twigs associated with the given via.")
("dbGetTwigTrunk"
"dbGetTwigTrunk(
d_twigId 
)
=> d_trunkId / nil"
"Returns the trunk that owns the specified twig pattern ID.")
("dbSetTwigName"
"dbSetTwigName(
d_twigId 
t_name
)
=> t / nil"
"Sets the name of the specified twig pattern ID.")
("dbSetTwigObject"
"dbSetTwigObject(
d_twigId 
d_dbId
)
=> t / nil"
"Sets the database object for the specified twig ID. A twig can have only one object and that is one of the following: InstTerm, Via, MPPShape, or a Strap.")
("dbSetTwigPinName"
"dbSetTwigPinName(
d_twigId 
t_pinName
)
=> t / nil"
"Sets the pin name set for the specified twig.")
("dbCreateTrunkConnect"
"dbCreateTrunkConnect(
t_name 
d_topologyId 
d_startTrunkId 
d_endTrunkId 
)
=> d_trunkConnectId / nil"
"Creates a trunk connect pattern on the specified topology with the specified start and end trunks.")
("dbDeleteTrunkConnect"
"dbDeleteTrunkConnect(
d_trunkConnectId 
)
=> t / nil"
"Deletes the specified trunk connect pattern, which includes removing the association the pattern has with the topology, and deleting associated trunks.")
("dbGetTrunkConnectName"
"dbGetTrunkConnectName(
d_trunkConnectId 
)
=> t_name / nil"
"Returns the name of the specified trunk connect pattern ID.")
("dbGetTrunkConnectTopology"
"dbGetTrunkConnectTopology(
d_trunkConnectId 
)
=> d_topologyId / nil"
"Returns the owner topology of the specified trunk connect pattern ID.")
("dbGetTrunkConnectTrunks"
"dbGetTrunkConnectTrunks(
d_trunkConnectId 
)
=> l_trunkIds / nil"
"Returns the list of trunks associated with the specified trunk connect ID. The returned list includes the start and end trunks.")
("dbSetTrunkConnectName"
"dbSetTrunkConnectName(
d_trunkConnectId 
t_name
)
=> t / nil"
"Sets the name of the specified trunk connect pattern.")
("dbSetTrunkConnectTrunks"
"dbSetTrunkConnectTrunks(
d_trunkConnectId 
d_startTrunkId 
d_endTrunkId 
)
=> t / nil"
"Sets the start and end trunks for the specified trunk connect ID.")
("dbCreateStrap"
"dbCreateStrap(
t_name 
d_topologyId 
)
=> d_strapId / nil"
"Creates a strap pattern with the given name on the specified topology.")
("dbDeleteStrap"
"dbDeleteStrap(
d_strapId 
)
=> t / nil"
"Deletes the specified strap pattern.")
("dbGetStrapName"
"dbGetStrapName(
d_strapId 
)
=> t_name / nil"
"Returns the name of the specified strap pattern ID.")
("dbGetStrapObjects"
"dbGetStrapObjects(
d_strapId 
)
=> l_objects / nil"
"Returns a list of database objects associated with the specified strap pattern ID.")
("dbGetStrapTopology"
"dbGetStrapTopology(
d_strapId 
)
=> d_topologyId / nil"
"Returns the topology pattern ID that owns the specified strap pattern.")
("dbGetStrapTwig"
"dbGetStrapTwig(
d_strapId 
)
=> t_name / nil"
"Returns the twig associated with the specified strap pattern ID.")
("dbGetInstTermStraps"
"dbGetInstTermStraps(
d_instTermId 
)
=> l_straps / nil"
"Returns a list of straps associated with the given instTerm ID.")
("dbGetViaStraps"
"dbGetViaStraps(
d_viaId 
)
=> l_straps / nil"
"Returns a list of straps associated with the given via ID.")
("dbGetShapeStraps"
"dbGetShapeStraps(
d_shapeId 
)
=> l_straps / nil"
"Returns a list of straps associated with the given shape ID.")
("dbAddStrapObject"
"dbAddStrapObject(
d_strapId 
d_dbId 
)
=> t / nil"
"Adds a database object to a specified strap pattern. The object must be of the type InstTerm, Via, or Shape. The object must be in the same database as the strap.")
("dbRemoveStrapObject"
"dbRemoveStrapObject(
d_strapId 
d_dbId 
)
=> t / nil"
"Removes the database object from the specified strap pattern.")
("dbSetStrapName"
"dbSetStrapName(
d_strapId 
t_name
)
=> t / nil"
"Sets the name of the specified strap pattern ID.")
("dbSetStrapTwig"
"dbSetStrapTwig(
d_strapId 
t_name
)
=> t / nil"
"Changes the twig associated with the specified strap pattern.")
("dbIsTopologyPatternId"
"dbIsTopologyPatternId(
d_objectId 
)
=> t / nil"
"Returns a Boolean indicating whether the specified object ID is a dbTopologyPattern.")
("dbNetHasTopology"
"dbNetHasTopology(
d_netId 
)
=> t / nil"
"Returns a Boolean indicating whether the specified net has a topology.")
("dbStartGenAnyInstToInstTerm"
"dbStartGenAnyInstToInstTerm(
d_instId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all instance terminals for the specified instance.")
("dbStartGenInstHeader"
"dbStartGenInstHeader(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all instance headers of the specified cellview.")
("dbStartGenInstHeaderToAnyInst"
"dbStartGenInstHeaderToAnyInst(
d_instHeaderId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all instances of the specified instance header.")
("dbStartGenLPPHeaderToShape"
"dbStartGenLPPHeaderToShape(
d_LPPHeaderId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all shapes of the specified cellview and layer-purpose pair (LPP) header.")
("dbStartGenLPToShape"
"dbStartGenLPToShape(
d_cellViewId
l_layerPurpose
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all shapes of the specified cellview and layer-purpose pair (LPP).")
("dbStartGenMarker"
"dbStartGenMarker(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all markers of the specified cellview.")
("dbStartGenNet"
"dbStartGenNet(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all nets of the specified cellview.")
("dbStartGenNetToInstTerm"
"dbStartGenNetToInstTerm(
d_netId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all instance terminals of the specified net.")
("dbStartGenNetToRoute"
"dbStartGenNetToRoute(
d_netId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all routes of the specified net.")
("dbStartGenRoute"
"dbStartGenRoute(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all routes of the specified cellview.")
("dbStartGenShape"
"dbStartGenShape(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all shapes of the specified cellview.")
("dbStartGenTerm"
"dbStartGenTerm(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all terms of the specified cellview.")
("dbStartGenViaHeader"
"dbStartGenViaHeader(
d_cellViewId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all via headers of the specified cellview.")
("dbStartGenViaHeaderToVia"
"dbStartGenViaHeaderToVia(
d_viaHeaderId
)
=> I_genId"
"Returns a dbGenerator object that can be used to iterate over all via of the specified via header.")
("dbStopGen"
"dbStopGen(
I_genId
)
=> t / nil"
"Forces a dbGenerator object reference to close and removes it from virtual memory.")
("dbCreateInPlaceCoverObstruction"
"dbCreateInPlaceCoverObstruction(
d_InstHeaderId
l_intRange
) 
=> t/nil"
"Creates an InPlaceCoverObstruction object on the specified instance header.")
("dbDestroyInPlaceCoverObstruction"
"dbDestroyInPlaceCoverObstruction(
d_InstHeaderId
)
=> t / nil"
"Destroys an InPlaceCoverObstruction object on the given instance header.")
("dbGetInPlaceCoverObstructionAbstractFileName"
"dbGetInPlaceCoverObstructionAbstractFileName(
d_InstHeaderId
) 
=> t_fileName / nil"
"Returns value of the InPlaceCoverObstruction AbstractFileName attribute for the specified instance header.")
("dbGetInPlaceCoverObstructionAbstractFilePath"
"dbGetInPlaceCoverObstructionAbstractFilePath(
d_InstHeaderId
) 
=> t_filePath / nil"
"Returns the value of the InPlaceCoverObstruction AbstractFilePath attribute for the specified instance header.")
("dbGetInPlaceCoverObstructionAbstractViewName"
"dbGetInPlaceCoverObstructionAbstractViewName(
d_InstHeaderId
) 
=> t_viewName / nil"
"Returns value of the InPlaceCoverObstruction AbstractViewName attribute for the specified instance header.")
("dbGetInPlaceCoverObstructionBloat"
"dbGetInPlaceCoverObstructionBloat(
d_InstHeaderId
t_layerName
) 
=> x_bloat"
"Returns value of the InPlaceCoverObstruction Bloat attribute from the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionBlockageAttributeValue"
"dbGetInPlaceCoverObstructionBlockageAttributeValue(
d_InstHeaderId
t_layerName
) 
=> f_blockageAttributeValue"
"Returns value of the InPlaceCoverObstruction BlockageAttributeValue attribute from the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionBlockageModel"
"dbGetInPlaceCoverObstructionBlockageModel(
d_InstHeaderId
t_layerName
) 
=> t_blockageModelName/nil"
"Returns value of the InPlaceCoverObstruction BlockageModel attribute from the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionDoughnutHalo"
"dbGetInPlaceCoverObstructionDoughnutHalo(
d_InstHeaderId
t_layerName
) 
=> x_doughnutHalo"
"Returns value of the InPlaceCoverObstruction DoughnutHalo attribute from the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionLayers"
"dbGetInPlaceCoverObstructionLayers(
d_InstHeaderId
) 
=> l_layerNames / nil"
"Returns a list of physical layer names in the technology database, with mask value lying between the minMask and maxMask values.")
("dbGetInPlaceCoverObstructionMaxMask"
"dbGetInPlaceCoverObstructionMaxMask(
d_InstHeaderId
) 
=> x_maxMask"
"Returns value of the InPlaceCoverObstruction MaxMask attribute from the specified instance header.")
("dbGetInPlaceCoverObstructionMergeDistance"
"dbGetInPlaceCoverObstructionMergeDistance(
d_InstHeaderId
t_layerName
) 
=> f_mergeDistanceValue"
"Returns value of the InPlaceCoverObstruction MergeDistance attribute for the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionMinMask"
"dbGetInPlaceCoverObstructionMinMask(
d_InstHeaderId
) 
=> x_minMask"
"Returns value of the InPlaceCoverObstruction MinMask attribute from the specifed instance header.")
("dbGetInPlaceCoverObstructionNeedsRemodeling"
"dbGetInPlaceCoverObstructionNeedsRemodeling(
d_InstHeaderId
) 
=> 
t / nil"
"Returns value of the InPlaceCoverObstruction NeedsRemodeling attribute from the specified instance header.")
("dbGetInPlaceCoverObstructionPinCutOut"
"dbGetInPlaceCoverObstructionPinCutOut(
d_InstHeaderId
t_layerName
) 
=> t / nil"
"Returns value of the InPlaceCoverObstruction PinCutOut attribute for the specified instance header on the given layer.")
("dbGetInPlaceCoverObstructionPinRemodeling"
"dbGetInPlaceCoverObstructionPinRemodeling(
d_InstHeaderId
) 
=> t_remodelingName/nil"
"Returns value of the InPlaceCoverObstruction PinRemodeling attribute from the specified instance header.")
("dbGetInPlaceCoverObstructionSpacingModel"
"dbGetInPlaceCoverObstructionSpacingModel(
d_InstHeaderId
t_layerName
) 
=> t_spacingModelName / nil"
"Returns value of the InPlaceCoverObstruction SpacingModel attribute from the specified instance header on the given layer.")
("dbInPlaceCoverObstructionExists"
"dbInPlaceCoverObstructionExists(
d_InstHeaderId
) 
=> t / nil"
"Checks whether an InPlaceCoverObstruction object is present on the specified instance header.")
("dbSetInPlaceCoverObstructionAbstractFileName"
"dbSetInPlaceCoverObstructionAbstractFileName(
d_InstHeaderId
t_fileName
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction AbstractFileName attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionAbstractFilePath"
"dbSetInPlaceCoverObstructionAbstractFilePath(
d_InstHeaderId
t_filePath
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction AbstractFilePath attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionAbstractViewName"
"dbSetInPlaceCoverObstructionAbstractViewName(
d_InstHeaderId
t_viewName
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction AbstractViewName attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionBloat"
"dbSetInPlaceCoverObstructionBloat(
d_InstHeaderId
t_layerName
n_value
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction Bloat attribute on the specified instance header on the given layer.")
("dbSetInPlaceCoverObstructionBlockageAttributeValue"
"dbSetInPlaceCoverObstructionBlockageAttributeValue(
d_InstHeaderId
t_layerName
n_value
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction BlockageAttributeValue attribute on the specified instance header on the given layer.")
("dbSetInPlaceCoverObstructionBlockageModel"
"dbSetInPlaceCoverObstructionBlockageModel(
d_InstHeaderId
t_layerName
t_blockageModelName
) 
=> t/nil"
"Sets value of the InPlaceCoverObstruction BlockageModel attribute on the specified instance header on the specified layer.")
("dbSetInPlaceCoverObstructionDoughnutHalo"
"dbSetInPlaceCoverObstructionDoughnutHalo(
d_InstHeaderId
t_layerName
n_value
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction DoughnutHalo attribute on the specified instance header on the given layer.")
("dbSetInPlaceCoverObstructionMergeDistance"
"dbSetInPlaceCoverObstructionMergeDistance(
d_InstHeaderId 
t_layerName 
n_value
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction MergeDistance attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionNeedsRemodeling"
"dbSetInPlaceCoverObstructionNeedsRemodeling(
d_InstHeaderId
g_value
) 
=> t/nil"
"Sets value of the InPlaceCoverObstruction NeedsRemodeling attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionPinCutOut"
"dbSetInPlaceCoverObstructionPinCutOut(
d_InstHeaderId
t_layerName
g_value
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction PinCutOut attribute on the specified instance header on the given layer.")
("dbSetInPlaceCoverObstructionPinRemodeling"
"dbSetInPlaceCoverObstructionPinRemodeling(
d_InstHeaderId
t_remodelingName
) 
=> t / nil"
"Sets value of the InPlaceCoverObstruction PinRemodeling attribute on the specified instance header.")
("dbSetInPlaceCoverObstructionSpacingModel"
"dbSetInPlaceCoverObstructionSpacingModel(
d_InstHeaderId
t_layerName
t_spacingModelName
)
=> t / nil"
"Sets value of the InPlaceCoverObstruction SpacingModel attribute on the specified instance header on the given layer.")
("dbCreateFigGroup"
"dbCreateFigGroup( 
d_cellView
t_name
g_ordered
l_origin
t_orient
)
=> d_figGroup / nil"
"Creates a figGroup object in the specified cellview.")
("dbAddFigToFigGroup"
"dbAddFigToFigGroup( 
d_figGroupId
d_figId
)
=> t / nil"
"Adds a figure to the specified figGroup.")
("dbRemoveFigFromFigGroup"
"dbRemoveFigFromFigGroup( 
d_figGroupId
d_figId
)
=> t / nil"
"Removes a figure from a figGroup object.")
("dbGetFigGroupByName"
"dbGetFigGroupByName( 
d_cellView
t_name
)
=> d_figGroupId / nil"
"Retrieves a figGroup by name.")
("dbCopyFig"
"dbCopyFig( 
d_fig 
d_cellView 
[ l_transform ] 
) 
=> d_fig / nil"
"Copies and transforms a figure, and places it in a cellview.")
("dbMoveFig"
"dbMoveFig( 
d_fig 
d_cellView 
[ l_transform ] 
) 
=> d_fig / nil"
"Moves and transforms a figure, and places it in a cellview.")
("dbGetOverlaps"
"dbGetOverlaps
dbGetOverlaps( 
d_cellView 
l_bBox 
[ tx_layer ] 
[ lx_level ] 
[ g_doRowCol ]
) 
=> ld_fig 

dbGetOverlaps( 
d_cellView 
l_bBox 
[ l_layerPurposePair ]
[ lx_level ] 
[ g_doRowCol ]
) 
=> ld_fig"
"Returns a list of all the objects (such as, shapes, instances, and mosaics) in a cellview that overlaps the area specified by l_bBox. 
If the object comes from a lower level in the hierarchy, instead of from the specified cellview, the object is represented by a list (potentially a nested list, if it comes from more than one level down). Each level of the list has the ID of the instance in the corresponding level in the hierarchy. 
For example, if there is a rectangle in a master cellview two levels down, for this rectangle, in the top cellview, dbGetOverlaps will return a nested list. The output of this function is same as dbGetTrueOverlaps.")
("dbGetTrueOverlaps"
"dbGetTrueOverlaps(
d_cellView
l_bBox
[ l_layerPurposePair | tx_layer | g_value {t | nil} ]
[ lx_level ]
[ g_doRowCol ]
)
=> ld_fig / nil"
"Returns a list of all the objects (such as, shapes, instances, and mosaics) in a cellview that overlap the area specified by l_bBox. 
If the object comes from a lower level in the hierarchy, instead of from the specified cellview, the object is represented by a list (potentially a nested list, if it comes from more than one level down). Each level of the list has the ID of the instance in the corresponding level in the hierarchy. 
For example, if there is a rectangle in a master cellview two levels down, for this rectangle, in the top cellview, the function will return a nested list. The output of this function is same as dbGetOverlaps.
You can switch the output syntax of dbGetTrueOverlaps between the new and legacy format by setting the noDetailedRow .cdsenv environment variable.")
("dbGetNeighbor"
"dbGetNeighbor(
d_cellViewId 
l_bBox 
t_direction 
[ ( t_layer [ t_purpose ] ) ] 
[ x_depth ] 
) 
=> ld_closestNeighbor / nil"
"Returns a list containing information about the closest neighboring shape in the specified direction of the given layer-purpose pair.")
("dbGetNeighborList"
"dbGetNeighborList( 
d_cellView 
l_area 
t_direction 
[ ( t_layer [ t_purpose ] ) ] 
[ lx_depth ] 
) 
=> l_closestNeighbor"
"Lists neighboring shapes in the specified direction of the given layer-purpose pair.")
("dbGetMaxHierDepth"
"dbGetMaxHierDepth(
) 
=> x_maxHierDepth"
"Returns the dbcMaxHierDepth constant in SKILL.")
("dbGetPathSegStyle"
"dbGetPathSegStyle(
d_pathSeg
)
=> l_pathSegStyle"
"Returns the path segment end styles for the supplied pathSeg database object.")
("dbSetPathSegStyle"
"dbSetPathSegStyle(
d_pathSeg
n_width t_beginStyle t_endStyle 	[ n_beginExt n_endExt 
    [ n_beginLeftDiagExt n_beginRightDiagExt n_beginRightHalfWidth     n_endLeftDiagExt n_endRightDiagExt n_endRightHalfWidth ]	]
)
=> t / nil"
"Sets the path segment style of a given path seg database object.")
("dbGetPathBoundary"
"dbGetPathBoundary(
d_path
)
=> l_points / nil"
"Returns the polygon boundary for the specified path.")
("dbProduceOverlap"
"dbProduceOverlap( 
d_cellView 
l_bBox 
[ lx_level 
[ l_layerPurposePair ] ] 
) 
=> ld_shape / nil"
"Returns a list of all the shapes in a cellview whose bounding boxes overlap the area specified by l_bBox. This function interface is simpler than dbGetOverlaps if you are only interested in finding the overlapping shapes.")
("dbProduceOverlapInst"
"dbProduceOverlapInst( 
d_cellView 
l_bBox 
[ lx_level ] 
) 
=> ld_inst / nil"
"Returns a list of all the instances in a cellview that overlap the area specified by l_bBox. This function interface is simpler than dbGetOverlaps if you are only interested in finding instances.")
("txCreateFigSet"
"txCreateFigSet(
d_cellView
[ t_name ]
)
=> T_figSet / nil"
"Creates an empty FigSet with the specified name in the given cellview. If the name is not specified, it will be generated automatically. If a FigSet with the specified name already exists, an error message is issued.")
("txGetFigSetData"
"txGetFigSetData(
T_figSet
n_entry
)
=> g_object / nil"
"Returns the nth object from the specified FigSet. This object is either a dbObject (CDB figure) or txObject (a FigSet or a transient shape).")
("txAppendObjectToFigSet"
"txAppendObjectToFigSet(
T_figSet
g_figObject
)
=> t / nil"
"Appends an object to the end of the specified FigSet. The object can be a figure or a FigSet.")
("txClearFigSet"
"txClearFigSet(
T_figSet
)
=> t / nil"
"Clears the contents of the specified FigSet.")
("txCloneFigSet"
"txCloneFigSet(
T_figSet1
T_figSet2
)
=> t / nil"
"Makes FigSet1 a clone of FigSet2 by replacing the contents of FigSet1with equivalent entries from FigSet2. It creates references to the objects; it does not make copies of the objects. The name of FigSet1 is preserved.")
("txConcatFigSet"
"txConcatFigSet(
T_figSet1
T_figSet2
)
=> t / nil"
"Appends the contents of FigSet2 to the end of FigSet1.")
("txCopyFigSet"
"txCopyFigSet(
T_srcFigSet
l_transform
)
=> T_newFigSet / nil"
"Copies each figure from the source FigSet and applies to it the specified transform to create a new FigSet with an automatically generated name.")
("txFindFigSet"
"txFindFigSet(
d_cellView
t_name
)
=> T_figSet / nil"
"Searches for a FigSet with the given name in the specified cellview. This function also searches for a FigSetGroup with the same name and automatically resurrects the corresponding FigSet from it, if required.")
("txDeleteFigSet"
"txDeleteFigSet(
T_figSet
[ g_deep = nil ]
)
=> t / nil"
"Deletes the specified FigSet. If the optional argument g_deep is set to true, then the FigSets referenced by the specified FigSet will also be recursively deleted.")
("txGetCellViewFigSets"
"txGetCellViewFigSets(
d_cellView
)
=> l_figSets / nil"
"Returns the list of FigSets in the specified cellview.")
("txGetFigSetBBox"
"txGetFigSetBBox(
T_figSet @key
(onlyTheseLayers l_onlyTheseLayers)
(onlyTheseLPPs l_onlyTheseLPPs)
(notTheseLayers l_notTheseLayers)
(notTheseLPPs l_notTheseLPPs)
(onlyTheseTypes l_onlyTheseTypes)
(notTheseTypes l_notTheseTypes)
)
=> l_bBox / nil"
"Calculates the bounding box for the objects in the specified FigSet. The caller can optionally specify included and excluded layers, included and excluded layer-purpose pairs (LPPs), and included and excluded object types. The bounding box values are returned in user units.")
("txIsFigSet"
"txIsFigSet(
g_object
)
=> t / nil"
"Determines whether the specified object is a FigSet object.")
("txMakeFigSet"
"txMakeFigSet(
d_cellView
d_figSetGroup
)
=> T_figSet / nil"
"Creates a FigSet from the given FigSetGroup in the specified cellview.")
("txMoveFigSet"
"txMoveFigSet(
T_figSet
l_transform
)
=> t / nil"
"Moves each figure in the given FigSet using the specified transform.")
("txPrependObjectToFigSet"
"txPrependObjectToFigSet(
T_figSet
g_figObject
)
=> t / nil"
"Inserts an object in the beginning of the specified FigSet. The object may be a figure or a FigSet.")
("txRemoveFigSetData"
"txRemoveFigSetData(
T_figSet
n_entry
)
=> t / nil"
"Removes the nth object from the specified FigSet.")
("txRemoveObjectFromFigSet"
"txRemoveObjectFromFigSet(
T_figSet
g_object
)
=> t / nil"
"Removes the specified object from the given FigSet, if the object is a member of this FigSet. This object can be a figure or a FigSet.")
("dbMakeFigSetGroup"
"dbMakeFigSetGroup(
d_cellView
T_figSet
)
=> d_figSetGroup / nil"
"Creates a FigSetGroup in the specified cellview and populates it with the contents of the specified FigSet.")
("dbFindFigSetGroup"
"dbFindFigSetGroup(
d_cellView
T_figSet
)
=> d_figSetGroup / nil"
"Searches the specified cellview for a FigSetGroup that has the same name as the specified FigSet.")
("dbFindFigSetGroupByName"
"dbFindFigSetGroupByName(
d_cellView
t_name
)
=>d_figSetGroup / nil"
"Searches for the specified FigSetGroup name in the given cellview.")
("dbGetFigSetGroupName"
"dbGetFigSetGroupName(
d_figSetGroup
)
=> t_name / nil"
"Returns the name of the specified FigSetGroup object.")
("dbGetCellViewFigSetGroups"
"dbGetCellViewFigSetGroups(
d_cellView
)
=> l_figSetGroups / nil"
"Returns a list of FigSetGroups in the specified cellview.")
("dbIsFigSetGroup"
"dbIsFigSetGroup(
d_object
)
=> t / nil"
"Determines whether the specified object is a FigSetGroup.")
("dbDeleteFigSetGroup"
"dbDeleteFigSetGroup(
d_figSetGroup
)
=> t / nil"
"Deletes the specified FigSetGroup, including the hierarchy of FigSetGroups that may exist in this FigSetGroup.")
("dbCellViewAreLayerShiftsValid"
"dbCellViewAreLayerShiftsValid(
d_cellviewId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean depending on whether the layer shift information on the instances in the specified cellview is synchronized with the layers and color information in the bound tech. This function is currently intended only for the advanced nodes release.")
("dbCellViewClearLayerShifts"
"dbCellViewClearLayerShifts(
d_cellviewID
)
=> t / nil"
"(ICADVM20.1 Only) Clears the layer shift information from all instances in the specified cellview. Any cached layer shift specification for the tech bound to the cellview is left intact.")
("dbCellViewHasLayerShifts"
"dbCellViewHasLayerShifts(
d_cellviewID
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean indicating whether there is layer shift information on any instance in the specified cellview.")
("dbCellViewUpdateLayerShifts"
"dbCellViewUpdateLayerShifts(
d_cellviewID
)
=> t / nil"
"(ICADVM20.1 Only) Creates or rebuilds the layer shift specification cache with the layers that are in the tech bound to the specified cellview. As a result, the per-layer shift information on the instances in the cellview is removed.")
("dbCellViewInitForLayerShifting"
"dbCellViewInitForLayerShifting(
d_cellviewID
)
=> t / nil"
"(ICADVM20.1 Only) Initializes the layer shift data for the given cell.")
("dbClearUnusedOccShapeColorData"
"dbClearUnusedOccShapeColorData(
d_cellView
[ ?dryRun { t | nil } ]
[ ?ignoreUnboundRefs { t | nil } ]
)
=> x_numClearedObjects / nil"
"(ICADVM20.1 Only) Opens hierarchy below the given cellview and removes all occShape coloring data that does not have any effect on the display of coloring data in the opened hierarchy. By default, if some instances or vias in the hierarchy cannot be bound, the function prints a warning message and returns nil, but cleanup can be forced with the ignoreUnboundRefs argument.")
("dbInstGetLayerShifts2"
"dbInstGetLayerShifts2(
d_instId
)
=> l_layerShifts / nil"
"(ICADVM20.1 Only) Returns a list of shifts that are applied to the layers in the master of the specified instance.")
("dbInstHasLayerShifts"
"dbInstHasLayerShifts(
d_instId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean value indicating whether per-layer color shifts are specified on the instance.")
("dbInstSetLayerShifts2"
"dbInstSetLayerShifts2(
d_instId
l_layerShifts
)
=> t / nil"
"(ICADVM20.1 Only) Sets the given l_layerShifts on the specified instance.")
("dbInstClearLayerShifts"
"dbInstClearLayerShifts(
d_instId
)
=> t / nil"
"(ICADVM20.1 Only) Removes all per-layer color shifting information from the specified instance.")
("dbIsShapeColoringAllowed"
"dbIsShapeColoringAllowed(
d_shapeID
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the specified shape is of a type that can be colored or not. Only the following shapes can be colored: arcs, lines, donuts, ellipses, pathSegs, paths, rects, and polygons.")
("dbIsShapeColored"
"dbIsShapeColored(
d_shapeID
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the specified shape is colored in a color other than grayColor.")
("dbGetShapeColor"
"dbGetShapeColor(
d_shapeId
)
=> t_maskColor / nil"
"(ICADVM20.1 Only) Returns the assigned color of the specified shape. By default, all newly created shapes are of the grayColor color type, which represents the currently assigned color of the shape.")
("dbSetShapeColor"
"dbSetShapeColor(
d_shapeId
t_maskColor
)
=> t / nil"
"(ICADVM20.1 Only) Assigns the specified color to the given shape if the color state is unlocked.")
("dbIsShapeColorLocked"
"dbIsShapeColorLocked(
d_shapeID
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the coloring for the specified shape is locked.")
("dbSetShapeColorLocked"
"dbSetShapeColorLocked(
d_shapeId
g_setLocked
)
=> t / nil"
"(ICADVM20.1 Only) Changes the color state of the shape.")
("dbIsBlockageColored"
"dbIsBlockageColored(
d_blockageId
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the specified blockage is colored in a color other than grayColor.")
("dbIsBlockageColoringAllowed"
"dbIsBlockageColoringAllowed(
d_blockageId
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the specified blockage is of a blockage type that can be colored. Only layer blockages can be colored.")
("dbGetBlockageColor"
"dbGetBlockageColor(
d_blockageId
)
=> t_maskColor / nil"
"(ICADVM20.1 Only) Returns the color assigned to the given blockage. The default color type is grayColor.")
("dbSetBlockageColor"
"dbSetBlockageColor(
d_blockageID
t_maskColor
)
=> t / nil"
"(ICADVM20.1 Only) Assigns color to the specified blockage.")
("dbIsViaColorStateLocked"
"dbIsViaColorStateLocked(
d_viaId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean indicating whether the coloring on the via is locked. The default value is nil.")
("dbSetViaColorStateLocked"
"dbSetViaColorStateLocked(
d_viaId
g_locked
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color state for the specified via.")
("dbIsViaColorStateLayerLocked"
"dbIsViaColorStateLayerLocked(
d_dbViaId
t_dbViaLayerType
)
=> t / nil"
"(ICADVM20.1 Only) Indicates whether the coloring for the specified individual layer in a via is locked.")
("dbSetViaColorStateLayerLocked"
"dbSetViaColorStateLayerLocked(
d_dbViaId
t_dbViaLayerType
g_setLocked
)
=> t / nil"
"(ICADVM20.1 Only) Locks and unlocks the color state for individual layers in a via.")
("dbGetViaLayerNumColorMasks"
"dbGetViaLayerNumColorMasks(
d_viaId
t_viaLayerType
)
=> t_layerName / nil"
"(ICADVM20.1 Only) Returns the number of supported color masks for specified layer of the given via.")
("dbGetViaLayer1Control"
"dbGetViaLayer1Control(
d_viaId
)
=> t_colorControl / nil"
"(ICADVM20.1 Only) Returns the color control assigned to layer1 of the via. Default value for color control is noShift.")
("dbGetViaLayer2Control"
"dbGetViaLayer2Control(
d_viaId
)
=> t_colorControl / nil"
"(ICADVM20.1 Only) Returns the color control assigned to layer 2 of the via. Default value for color control is noShift.")
("dbGetViaCutLayerControl"
"dbGetViaCutLayerControl(
d_viaId
)
=> t_colorControl / nil"
"(ICADVM20.1 Only) Returns the color control assigned to the cut layer of the via. Default color control is noShift.")
("dbGetViaLayerControl"
"dbGetViaLayerControl(
d_dbViaId
t_dbViaLayerType
)
=> t_colorControl / nil"
"(ICADVM20.1 Only) Returns the color control assigned to the specified layer in the given via.")
("dbSetViaLayer1Control"
"dbSetViaLayer1Control(
d_viaId
t_colorControl
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color control for layer1 shapes of the via master.")
("dbSetViaLayer2Control"
"dbSetViaLayer2Control(
d_viaId
t_colorControl
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color control for layer2 shapes of the via master.")
("dbSetViaCutLayerControl"
"dbSetViaCutLayerControl(
d_viaId
t_colorControl
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color control for the cut layer shapes of the via master.")
("dbSetViaLayerControl"
"dbSetViaLayerControl(
d_dbViaId
t_dbViaLayerType
t_colorControl
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color control for the specified layer in the given via.")
("dbSetViaColorInfo"
"dbSetViaColorInfo(
d_dbViaId
l_layer1ControlInfo 
l_layer2ControlInfo 
l_cutLayerControlInfo 
)
=> t / nil"
"(ICADVM20.1 Only) Updates the color control and color state for the three via layers (via layer1, via layer2, and cut layer) of the given via.")
("dbIsTrackPatternColored"
"dbIsTrackPatternColored(
d_trackPatternId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean value that indicates whether the first track of the specified track pattern is colored in a color other than gray.")
("dbIsTrackPatternColorAlternating"
"dbIsTrackPatternColorAlternating(
d_trackPatternId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean value indicating whether the coloring for the specified track pattern is alternating.")
("dbIsTrackPatternColoringAllowed"
"dbIsTrackPatternColoringAllowed(
d_trackPatternId
)
=> t / nil"
"(ICADVM20.1 Only) Returns a Boolean indicating whether the specified track pattern can be colored. Only track patterns with specified track layer can be colored.")
("dbGetTrackPatternFirstTrackColor"
"dbGetTrackPatternFirstTrackColor(
d_trackPatternId
)
=> t_maskColor / nil"
"(ICADVM20.1 Only) Returns the color assigned to the first track of the specified track pattern. Default color type is grayColor.")
("dbSetTrackPatternFirstTrackColor"
"dbSetTrackPatternFirstTrackColor(
d_trackPatternId
t_maskColor
)
=> t / nil"
"(ICADVM20.1 Only) Assigns a color to the first track of the specified track pattern.")
("dbSetTrackPatternColorAlternating"
"dbSetTrackPatternColorAlternating(
d_trackPatternId
g_isAlternating
)
=> t / nil"
"(ICADVM20.1 Only) Sets the coloring type of the track pattern.")
("dbCreateSameMaskGroup"
"dbCreateSameMaskGroup(
d_cellView
t_groupName
)
=> d_group / nil"
"(ICADVM20.1 Only) Creates a same-mask, color shape group (d_group) in the specified cellview with the given name. The name must be unique amongst all same-mask groups in the cellview. You can only add shapes to the resulting group.")
("dbCreateDiffMaskGroup"
"dbCreateDiffMaskGroup(
d_cellView
t_groupName
d_sameMaskGroup1
d_sameMaskGroup2
)
=> d_group / nil"
"(ICADVM20.1 Only) Creates a diff-mask, color shape group (d_group) in the specified cellview with a pair of same-mask color shape groups and with the given name. The name must be unique amongst all diff-mask groups in the cellview.")
("dbGetSameMaskDiffMaskGroups"
"dbGetSameMaskDiffMaskGroups(
d_sameMaskGroupId
)
=> l_listofGroups / nil"
"(ICADVM20.1 Only) Accepts an object with the same mask color group as a parameter and returns a list of all groups of type 'diffMaskColor'.")
("dbGetShapeSameMaskGroups"
"dbGetShapeSameMaskGroups(
d_shapeId
)
=> l_listofGroups / nil"
"(ICADVM20.1 Only) Accepts the object of the shape for which you want to retrieve a list of all groups of type 'sameMaskColor'.")
("dbColorShapeQuery"
"dbColorShapeQuery( 
d_cellViewId
l_layerPurposePair
l_bBox
[ x_startLevel ]
[ x_stopLevel ]
[ n_filterSize ]
[ l_transform ]
)
=> l_shapeColorPairs / nil"
"(ICADVM20.1 Only) Returns a list of all shapes and their effective color, where the bounding boxes of the shapes overlap the region specified by l_bBox.")
("dbGetIntegrationColorModel"
"dbGetIntegrationColorModel(
d_cellViewId
)
=> t_integType / nil"
"(ICADVM20.1 Only) Returns a string value of the integration color model constraint for the specified cellview. Possible values are any or locked.")
("dbGetColorModel"
"dbGetColorModel(
d_cellViewId
)
=> t_type / nil"
"(ICADVM20.1 Only) Returns a string value of the color model constraint for the specified cellview. Possible values are any, layerBased, or locked.")
("dbSetIntegrationColorModel"
"dbSetIntegrationColorModel(
d_cellViewId
t_integType
)
=> t / nil"
"(ICADVM20.1 Only) Sets the value of the integration color model constraint for the specified cellview. Possible values are any or locked.")
("dbSetColorModel"
"dbSetColorModel(
d_cellViewId
t_type
)
=> t / nil"
"(ICADVM20.1 Only) Sets the value of the color model constraint for the specified cellview. It specifies how you want the contents of the block to be color-shifted. Possible values are any, layerBased, or locked.")
("dbRemoveLayerColorData"
"dbRemoveLayerColorData(
d_cellViewId
t_layerName
g_locked
[ g_via g_hcl g_instColorShift g_blockage g_trackPattern ]
)
=> t / nil"
"(ICADVM20.1 Only) Removes the color data from the specified layer in the given cellview. By default, all color data is removed. You can optionally preserve the via color data, hierarchical color locks, layer shift information, blockage color data, and track pattern color data.")
("dbColorShapeQuery2"
"dbColorShapeQuery2( 
d_cellViewId
l_layerPurposePair
l_bBox
[ x_startLevel ]
[ x_stopLevel ]
[ n_filterSize ]
[ l_transform ]
)
=> l_occShapesWithColorAndState / nil"
"(ICADVM20.1 Only) Returns a list of shapes and occurrence shapes within a given region, and the coloring information for each shape. The coloring information includes the color, whether the color is locked, and whether the coloring is due to the color attribute or hierarchical color locking on the shape.")
("dbGetColoredOccShapes"
"dbGetColoredOccShapes( 
d_refId 
[ b_lockedOnly ] 
)
=> l_occShapesWithColorAndState / nil"
"(ICADVM20.1 Only) Generates a list of all the occurrence shapes, associated with the specified instance or via, that were colored due to hierarchical color locking. If the optional argument b_lockedOnly is t, only the locked colored occurrence shapes are included.")
("dbGetShapeEffectiveColor"
"dbGetShapeEffectiveColor( 
l_occShape 
)
=> l_colorAndColorState / nil"
"(ICADVM20.1 Only) Implements a query for individual colored shapes. This function takes an occurrence shape (a list consisting of the absolute hierarchical path and the master shape) as an argument. It returns the color of the shape and two Boolean values that indicate whether the color state is locked and whether it was colored by hierarchical color locking.")
("dbSetOccShapeColor"
"dbSetOccShapeColor( 
l_occShape
t_color
)
=> t / nil"
"(ICADVM20.1 Only) Assigns the specified color to the given occurrence shape. You can set the color for occurrence shapes with types Path, PathSeg, Polygon, and Rect.")
("dbSetOccShapeColorLocked"
"dbSetOccShapeColorLocked( 
l_occShape
g_setLocked
)
=> t / nil"
"(ICADVM20.1 Only) Changes the color state of the specified occurrence shape. You can set the color state for occurrence shapes with types Path, PathSeg, Polygon, and Rect.")
("dbGetHierColorOverride"
"dbGetHierColorOverride( 
l_occShape 
)
=> l_occShapeHCL / nil"
"(ICADVM20.1 Only) Returns the occurrence shape with the topmost hierarchical color lock that defines the effective color of the given occurrence shape. nil is returned if the effective color of the given occurrence shape is not defined by a hierarchical color lock.")
("dbGetShapeColorLockType"
"dbGetShapeColorLockType(
d_shapeId
) 
=> t_lockType / nil"
"(ICADVM20.1 Only) Returns the color lock type assigned to the specified shape. If the shape is not locked, nil is returned.")
("dbSetShapeColorLockType"
"dbSetShapeColorLockType(
d_shapeId
g_lockType
) 
=> t / nil"
"(ICADVM20.1 Only) Sets the color lock type for the specified shape.")
("dbGetViaLayerColorLockType"
"dbGetViaLayerColorLockType(
d_viaId 
t_viaLayerType
) 
=> t_lockType / nil"
"(ICADVM20.1 Only) Returns the color lock type assigned to the specified via layer.")
("dbSetViaLayerColorLockType"
"dbSetViaLayerColorLockType(
d_viaId
t_viaLayer
g_lockType
)
=> t / nil"
"(ICADVM20.1 Only) Sets the color lock type for the specified via layer.")
("dbCellViewHasUnknownColorLockChanges"
"dbCellViewHasUnknownColorLockChanges( 
d_cellViewId 
[ g_shapes g_vias g_HCLs ] 
) 
=> t / nil"
"(ICADVM20.1 Only) Checks whether any edits were done to the specified type of objects in the older versions of Virtuoso after color lock type information was set for some of them.")
("dbGetShapeEffectiveColorLockType"
"dbGetShapeEffectiveColorLockType( 
l_occShape 
) 
=> t_colorLockType / nil"
"(ICADVM20.1 Only) Returns the effective color lock type of the specified occurrence shape. It is either the color lock type of the topmost HCL, returned by dbGetHierColorOverride or the color lock type of the shape itself.")
("dbCellViewResetAllColorLockTypes"
"dbCellViewResetAllColorLockTypes( 
d_cellViewId
t_value 
[g_shapes g_vias g_HCLs]
) 
=> t / nil"
"(ICADVM20.1 Only) Changes color lock type for all color-locked objects of the specified object types to the given value.")
("dbSetOccShapeColorLockType"
"dbSetOccShapeColorLockType( 
l_occShape
g_colorLockType
) 
=> t / nil"
"(ICADVM20.1 Only) Changes the color lock type of the specified occurrence shape. You can set the color state only for occurrence shapes with the following types: Path, PathSeg, Polygon, and Rect.")
("dbCreateWidthSpacingPattern"
"dbCreateWidthSpacingPattern( 
d_cellView
t_name
l_patternSpecs
[ n_offset ]
[ g_repeatOffset ]
[ g_shiftColor ]
[ t_allowedRepeatMode ]
[ t_defaultRepeatMode ]
)
=> d_widthSpacingPattern / nil"
"(ICADVM20.1 Only) Creates a width spacing pattern in the specified cellview.")
("dbCreateWidthSpacingPatternWithColor"
"dbCreateWidthSpacingPatternWithColor(
d_cellView
t_name
l_patternSpecs
t_startingColor
[ n_offset ]
[ g_repeatOffset ]
[ t_allowedRepeatMode ]
[ t_defaultRepeatMode ]
)
=> d_widthSpacingPattern / nil"
"(ICADVM20.1 Only) Creates a width spacing pattern in the specified cellview. This function requires you to specify the color for only the first track, referred to as the starting color. All other tracks are colored automatically by shifting colors.")
("dbFindWidthSpacingPattern"
"dbFindWidthSpacingPattern(
d_cellView
t_name
)
=> d_widthSpacingPattern / nil"
"(ICADVM20.1 Only) Searches for the width spacing pattern with the given name in the specified cellview and technology library.")
("dbGetWidthSpacingPatternAllowedRepeatMode"
"dbGetWidthSpacingPatternAllowedRepeatMode(
d_wspId
)
=> t_allowedRepeatMode / nil"
"(ICADVM20.1 Only) Returns the allowed repeat mode for the specified width spacing pattern.")
("dbGetWidthSpacingPatternDefaultRepeatMode"
"dbGetWidthSpacingPatternDefaultRepeatMode(
d_wspId
)
=> t_defaultRepeatMode / nil"
"(ICADVM20.1 Only) Returns the default repeat mode of the specified width spacing pattern.")
("dbGetWidthSpacingPatterns"
"dbGetWidthSpacingPatterns(
d_cellView
)
=> l_widthSpacingPatterns / nil"
"(ICADVM20.1 Only) Returns a list of all width spacing pattern IDs in the specified cellview.")
("dbSetWidthSpacingPatternRepeatMode"
"dbSetWidthSpacingPatternRepeatMode(
d_wspId
t_allowedRepeatMode
t_defaultRepeatMode
)
=> t / nil"
"(ICADVM20.1 Only) Sets a valid combination of allowed and default repeat modes for the specified width spacing pattern.")
("dbCreateWidthSpacingPatternGroup"
"dbCreateWidthSpacingPatternGroup(
d_cellView
t_name
l_patternNames
)
=> d_widthSpacingPatternGroup / nil"
"(ICADVM20.1 Only) Creates a group of width spacing patterns in the specified cellview.")
("dbGetWidthSpacingPatternGroups"
"dbGetWidthSpacingPatternGroups(
d_cellView
)
=> l_widthSpacingPatternGroups / nil"
"(ICADVM20.1 Only) Returns a list of all width spacing pattern group IDs from the specified cellview.")
("dbFindWidthSpacingPatternGroup"
"dbFindWidthSpacingPatternGroup(
d_cellView
t_name
)
=> d_widthSpacingPatternGroup / nil"
"(ICADVM20.1 Only) Searches for the width spacing pattern group with the specified name in the given cellview and technology library.")
("dbCreateWidthSpacingSnapPatternDef"
"dbCreateWidthSpacingSnapPatternDef( 
d_cellViewId 
t_name
(tx_layer [tx_purpose])
t_direction
n_period
t_defaultActivePattern
[ l_snappingLayers ]
[ n_offset ]
[ l_patternNames ]
[ l_patternGroupNames ]
[ g_gridType ]
)
=> widthSpacingSnapPatternDefId / nil"
"(ICADVM20.1 Only) Creates a widthSpacingSnapPatternDef object in the specified cellview.")
("dbFindWidthSpacingSnapPatternDefByName"
"dbFindWidthSpacingSnapPatternDefByName( 
d_cellViewId 
t_name
)
=> d_widthSpacingSnapPatternDefId / nil"
"(ICADVM20.1 Only) Searches for the given widthSpacingSnapPatternDef object in the specified cellview.")
("dbDeleteWidthSpacingSnapPatternDef"
"dbDeleteWidthSpacingSnapPatternDef( 
d_dbWidthSpacingSnapPatternDefId
)
=> t / nil"
"(ICADVM20.1 Only) Deletes the specified widthSpacingSnapPatternDef object.")
("dbGetWidthSpacingSnapPatternDefsByLP"
"dbGetWidthSpacingSnapPatternDefsByLP(
d_cellViewId
l_LP
)
=> l_widthSpacingSnapPatternDefIDList / nil"
"(ICADVM20.1 Only) Returns all the widthSpacingSnapPatternDefs on a layer-purpose pair.")
("dbCreateRelatedSnapPatterns"
"dbCreateRelatedSnapPatterns(
d_cellView
t_name
l_relatedSnapPatterns
[l_rowRegionSpecNames]
[l_extraLPP]   
[f_regionSnapPitchHorizontal]    
[f_regionSnapPitchVertical]
)
=> d_relatedSnapPatterns / nil"
"(ICADVM20.1 Only) Creates a group of related snap patterns in the specified cellview.")
("dbGetRelatedSnapPatterns"
"dbGetRelatedSnapPatterns(
d_cellView
)
=> l_relatedSnapPatterns / nil"
"(ICADVM20.1 Only) Returns a list of related snap pattern IDs from the specified cellview.")
("dbFindRelatedSnapPatterns"
"dbFindRelatedSnapPatterns(
d_cellView
t_name
)
=> d_relatedSnapPatterns / nil"
"(ICADVM20.1 Only) Searches for the group of related snap patterns with the specified name in the given cellview and technology library.")
("dbGetPatternRegionActivePattern"
"dbGetPatternRegionActivePattern(
d_shapeId
)
=> t_patternName / nil"
"(ICADVM20.1 Only) Returns the name of the currently set active pattern for the specified shape.")
("dbSetPatternRegionActivePattern"
"dbSetPatternRegionActivePattern(
d_shapeId
t_patternName
)
=> t / nil"
"(ICADVM20.1 Only) Sets the given active pattern for the specified shape.")
("dbHasPatternRegionActivePattern"
"dbHasPatternRegionActivePattern(
d_shapeId
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether the specified shape has an associated active pattern.")
("dbGetPatternRegionAllowedPatterns"
"dbGetPatternRegionAllowedPatterns(
d_shapeId
)
=> l_patternNameList / nil"
"(ICADVM20.1 Only) Returns a list of allowed pattern names for the specified shape.")
("dbSetPatternRegionAllowedPatterns"
"dbSetPatternRegionAllowedPatterns(
d_shapeId
l_patternNameList
)
=> t / nil"
"(ICADVM20.1 Only) Sets the given allowed patterns for the specified shape.")
("dbGetPatternRegionAllowedPatternGroups"
"dbGetPatternRegionAllowedPatternGroups(
d_shapeId
)
=> l_groupNameList / nil"
"(ICADVM20.1 Only) Returns a list of allowed pattern groups for the specified shape.")
("dbSetPatternRegionAllowedPatternGroups"
"dbSetPatternRegionAllowedPatternGroups(
d_shapeId
l_groupNameList
)
=> t / nil"
"(ICADVM20.1 Only) Sets the given allowed pattern groups for the specified shape.")
("dbGetPatternRegionCommittedPatterns"
"dbGetPatternRegionCommittedPatterns(
d_shapeId
)
=> l_patternNameList / nil"
"(ICADVM20.1 Only) Returns a list of committed pattern names for the specified shape.")
("dbGetPatternRegionCommittedPatternShiftColor"
"dbGetPatternRegionCommittedPatternShiftColor(
d_shapeId
t_patternName
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether a specific committed pattern was committed with or without a color shift.")
("dbGetPatternRegionCreateType"
"dbGetPatternRegionCreateType(
d_shapeId
)
=> t_createType / nil"
"(ICADVM20.1 Only) Returns the create type of the specified shape. Possible values of create type are systemCreated and userCreated.")
("dbGetPatternRegionShiftColor"
"dbGetPatternRegionShiftColor(
d_shapeId
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether shift color is enabled for the specified shape.")
("dbSetPatternRegionShiftColor"
"dbSetPatternRegionShiftColor(
d_shapeId
g_shiftColor
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether shift color is enabled for the specified shape.")
("dbHasPatternRegionInfo"
"dbHasPatternRegionInfo(
d_shapeId
)
=> t / nil"
"(ICADVM20.1 Only) Determines whether the specified shape contains pattern region information.")
("dbGetPatternRegionName"
"dbGetPatternRegionName(
d_shapeId
)
=> t_name / nil"
"(ICADVM20.1 Only) Returns the name of the pattern region set for the specified shape.")
("dbSetPatternRegionName"
"dbSetPatternRegionName(
d_shapeId
t_name
)
=> t / nil"
"(ICADVM20.1 Only) Sets the specified pattern region for the specified shape.")
("dbGetPatternRegionWidthSpacingSnapPatternDefName"
"dbGetPatternRegionWidthSpacingSnapPatternDefName(
d_dbShapeId
)
=> t_defName / nil"
"(ICADVM20.1 Only) Returns the widthSpacingSnapPatternDef name from the specified pattern region.")
("dbSetPatternRegionWidthSpacingSnapPatternDefName"
"dbSetPatternRegionWidthSpacingSnapPatternDefName(
d_dbShapeId
t_defName
)
=> t / nil"
"(ICADVM20.1 Only) Sets the widthSpacingSnapPatternDef name on the specified pattern region. The widthSpacingSnapPatternDef must already exist.")
("dbGetPatternRegionDefaultRepeatMode"
"dbGetPatternRegionDefaultRepeatMode(
d_patternRegion
)
=> t_repeatMode / nil"
"(ICADVM20.1 Only) Returns the default repeat mode for the specified pattern region.")
("dbSetPatternRegionDefaultRepeatMode"
"dbSetPatternRegionDefaultRepeatMode(
d_patternRegion
t_repeatMode
) 
=> t / nil"
"(ICADVM20.1 Only) Sets default repeat mode on the specified pattern region.")
("dbGetPatternRegionRepeatMode"
"dbGetPatternRegionRepeatMode(
d_patternRegion
t_patternName
) 
=> t_repeatMode / nil"
"(ICADVM20.1 Only) Returns the repeat mode for the specified pattern region.")
("dbSetPatternRegionRepeatMode"
"dbSetPatternRegionRepeatMode(
d_patternRegion
t_patternName
t_repeatMode
) 
=> t / nil"
"(ICADVM20.1 Only) Sets the specified repeat mode on the pattern region for the specified width spacing pattern.")
("dbGetCellViewActiveWireTypes"
"dbGetCellViewActiveWireTypes(
d_dbCellViewId
)
=> l_activeWireTypeNames / nil"
"(ICADVM20.1 Only) Returns the active wire types on the specified cellview.")
("dbSetCellViewActiveWireTypes"
"dbSetCellViewActiveWireTypes(
d_dbCellViewId
l_activeWireTypeNames
)
=> t / nil"
"(ICADVM20.1 Only) Sets the active wire types on the specified cellview.")
("dbClearAllActiveWireTypes"
"dbClearAllActiveWireTypes (
d_dbCellViewId
) 
=> t / nil"
"(ICADVM20.1 Only) Clears all the active wire type specifications on the design and for the widthSpacingSnapPatternDef. Additionally, clears all the region-specific active wire types.")
("dbGetCellViewActiveWireTypesForWidthSpacingSnapPatternDef"
"dbGetCellViewActiveWireTypesForWidthSpacingSnapPatternDef (
d_dbCellViewId
t_widthSpacingSnapPatternDefName
) 
=> t / nil"
"(ICADVM20.1 Only) Returns the active wire types on the specified cellview for a given widthSpacingSnapPatternDef.")
("dbSetCellViewActiveWireTypesForWidthSpacingSnapPatternDef"
"dbSetCellViewActiveWireTypesForWidthSpacingSnapPatternDef(
d_dbCellViewId
t_widthSpacingSnapPatternDefName
l_activeWireTypeNames
)
=> t / nil"
"(ICADVM20.1 Only) Sets the active wire types on the specified cellview for a given widthSpacingSnapPatternDef.")
("dbGetPatternRegionActiveWireTypes"
"dbGetPatternRegionActiveWireTypes (
d_PatternRegion
) 
=> l_activeWireTypeNames / nil"
"(ICADVM20.1 Only) Returns the active wire types set on the specified pattern region.")
("dbSetPatternRegionActiveWireTypes"
"dbSetPatternRegionActiveWireTypes(
d_PatternRegion
l_activeWireTypeNames
)
=> t / nil"
"(ICADVM20.1 Only) Sets the active wire types on the specified pattern region.")
("dbSetPatternRegionNoActiveWireTypes"
"dbSetPatternRegionNoActiveWireTypes (
d_PatternRegion
) 
=> t / nil"
"(ICADVM20.1 Only) Sets no active wire types on the specified pattern region.")
("dbHasPatternRegionNoActiveWireTypes"
"dbHasPatternRegionNoActiveWireTypes (
d_PatternRegion
) 
=> t / nil"
"(ICADVM20.1 Only) Returns true if no active wire types is set on the specified pattern region.")
("dbSetGlobalGridOffsetReferenceType"
"dbSetGlobalGridOffsetReferenceType (
d_dbCellViewId
t_referenceType
)
=> t / nil"
"(ICADVM20.1 Only) Sets the global grid offset reference type on a cellview for the snapPatternDef and widthSpacingSnapPatternDef global grids. The global grid offset reference type can be boundary or origin.")
("dbGetGlobalGridOffsetReferenceType"
"dbGetGlobalGridOffsetReferenceType(
d_dbCellViewId
) 
=> t_referenceType"
"(ICADVM20.1 Only) Returns the global grid offset reference. The value returned can either be origin or boundary.")
("dbGetGlobalGridDefaultRepeatMode"
"dbGetGlobalGridDefaultRepeatMode(
d_cellViewId
t_wsspDefName
)
=> t_repeatMode / nil"
"(ICADVM20.1 Only) Returns the default repeat mode for the specified widthSpacingSnapPatternDef global grid in the specified cellview.")
("dbSetGlobalGridDefaultRepeatMode"
"dbSetGlobalGridDefaultRepeatMode(
d_cellViewId
t_wsspDefName
t_repeatMode
)
=> t / nil"
"(ICADVM20.1 Only) Sets the specified repeat mode as the default on a cellview for the specified widthSpacingSnapPatternDef global grid.")
("dbGetGlobalGridRepeatMode"
"dbGetGlobalGridRepeatMode(
d_cellViewId
t_wsspDefName
t_patternName
)
=> t_repeatMode / nil"
"(ICADVM20.1 Only) Returns the repeat mode for the specified widthSpacingSnapPatternDef global grid in the specified cellview for the given width spacing pattern.")
("dbSetGlobalGridRepeatMode"
"dbSetGlobalGridRepeatMode(
d_cellViewId
t_wsspDefName
t_patternName
t_repeatMode
)
=> t / nil"
"(ICADVM20.1 Only) Sets the specified repeat mode for the widthSpacingSnapPatternDef global grid in the specified cellview for the given width spacing pattern.")
("hdbAddConfigToBag"
"hdbAddConfigToBag ( 
h_configBagId 
h_configId
) 
=> t / nil"
"Adds a configuration handle to a configuration bag.")
("hdbBind"
"hdbBind(
h_pathVector
t_masterLibName
t_masterCellName
t_masterViewName
t_instName
g_fixedLib
g_fixedCell
g_fixedView
[ g_wantSignature ]
[ g_wantWhy ]
) 
=> ( t_boundLibId t_boundCellId t_boundView h_bindSignature h_bindWhy )"
"Binds an instance to a master.")
("hdbCloseConfigsInBag"
"hdbCloseConfigsInBag( 
h_configBagId 
)
=> t / nil"
"Closes all of the configurations held in a configuration bag.")
("hdbCreateConfigBag"
"hdbCreateConfigBag( 
)
=> h_configBagId / nil"
"Creates a configuration bag to hold configurations.")
("hdbCreatePathVectorStack"
"hdbCreatePathVectorStack(
)
=> h_pathVectorStackId / nil"
"Creates a stack to hold path vectors when traversing into sub-configurations.")
("hdbExplainBinding"
"hdbExplainBinding(
t_indentation
t_masterLibName
t_masterCellName
t_masterViewName
t_instName
g_fixedLib
g_fixedCell
g_fixedView
t_boundLib
t_boundCell
t_boundView
h_bindSignatureId
h_bindWhyId
) 
=> t_string"
"Explains why a hdbBind binding was made the way it was.")
("hdbExplainSignature"
"hdbExplainSignature(
t_indentation
h_bindSignatureId
) 
=> t_string"
"Explains the contents of a binding signature.")
("hdbExplainStop"
"hdbExplainStop(
t_indentation
h_pathVectorId
) 
=> t_string"
"Explains why a stop was declared.")
("hdbGetPathStackStr"
"hdbGetPathStackStr(
h_pathVectorStackId
) 
=> t_string"
"Creates a string listing all the path vectors. Creates something similar to a fully rooted path for a design binding that contains sub-configurations.")
("hdbGetPathStr"
"hdbGetPathStr(
h_pathVectorId
) 
=> t_string"
"Creates a string representation of a path vector.")
("hdbGetPathVectorStackTop"
"hdbGetPathVectorStackTop(
h_pathVectorStackId
) 
=> h_pathVectorId"
"Gets the top of a path vector stack.")
("hdbIsAtStopPoint"
"hdbIsAtStopPoint(
h_pathVectorId
)
=> t / nil"
"Checks if the point just pushed into with hdbPushCell is a stop point.")
("hdbIsConfig"
"hdbIsConfig(
t_libName 
t_cellName 
t_viewName
)
=> t / nil"
"Checks if a given library/cell/view is a configuration.")
("hdbIsOpenConfig"
"hdbIsOpenConfig(
h_configID
)
=> t / nil"
"Checks if the configuration ID you specify is valid. The configuration ID is valid if the configuration is still open.")
("hdbReOpenNewConfig"
"hdbReOpenNewConfig(
h_configID
)
=> t / nil"
"Increments the reference count of an in-memory only configuration (that is, a new configuration that has not yet been written to disk) and returns t. If the configuration does not exist in memory or if it already exists on disk, this function returns nil and the reference count is not incremented.")
("hdbPopPathVect"
"hdbPopPathVect(
h_pathVectorStackId
)
=> h_pathVectorId / nil"
"Pops a path vector off the top of a path vector stack.")
("hdbPushPathVect"
"hdbPushPathVect(
h_pathVectorStackId 
h_pathVectorId
)
=> t / nil"
"Adds a path vector on to the top of a path vector stack.")
("hdbSaveACopy"
"hdbSaveACopy(
h_configId 
t_libName 
t_cellName 
t_viewName
)
=> t / nil"
"Makes a copy of a configuration and saves it to a library/cell/view. Unlike hdbSaveAs, this function does not modify the location of the configuration associated with the specified configId.")
("hdbSaveAs"
"hdbSaveAs(
h_configId 
t_libName 
t_cellName 
t_viewName
)
=> t / nil"
"Saves a configuration to a library/cell/view.")
("hdbSave"
"hdbSave(
h_configId
)
=> t / nil"
"Saves a configuration opened with hdbOpen.")
("hdbClose"
"hdbClose(
h_configId
) 
=> t / nil"
"Closes a configuration. In all cases where you are using the hdb interface to traverse (bind, elaborate) a design use hdbCloseConfigsInBag to close open configurations instead of this function.")
("hdbOpen"
"hdbOpen(
t_libName 
t_cellName 
t_viewName 
t_mode 
[ t_nameSpace ]
) 
=> h_configId / nil"
"Opens a configuration for read or edit.")
("hdbCreatePathVector"
"hdbCreatePathVector(
h_configId
) 
=> h_pathVectorId / nil"
"Creates a path vector to use while traversing (elaborating) a design hierarchy.")
("hdbDestroyPathVector"
"hdbDestroyPathVector(
h_pathVectorId
) 
=> t / nil"
"Destroys a path vector.")
("hdbGetCellName"
"hdbGetCellName(
h_configId
) 
=> t_cellName / nil"
"Gets the cell name of a configuration specified by h_configId.")
("hdbGetLibName"
"hdbGetLibName(
h_configId
) 
=> libName / nil"
"Gets the library name of a configuration specified by h_configId.")
("hdbGetTopCellName"
"hdbGetTopCellName(
h_configId
)
=> t_topCellName / nil"
"Gets the name of the top cell of a configuration specified by h_configId.")
("hdbGetTopLibName"
"hdbGetTopLibName(
h_configId
)
=> t_topLibName / nil"
"Gets the name of the top library of a configuration specified by h_configId.")
("hdbGetTopViewName"
"hdbGetTopViewName(
h_configId
)
=> t_topViewName / nil"
"Gets the name of the top view pointed to by h_hdbConfig.")
("hdbGetViewName"
"hdbGetViewName(
h_configId
)
=> t_viewName / nil"
"Gets the view name of a configuration specified by h_configId.")
("hdbPopCell"
"hdbPopCell(
h_pathVectorId
)
=> t / nil"
"Pops an entry off a path vector.")
("hdbPushCell"
"hdbPushCell(
h_pathVectorId 
t_instanceName 
t_libName 
t_cellName 
t_viewName
)
=> t / nil"
"Push a cell onto a path vector.")
("hdbSetObjBindRule"
"hdbSetObjBindRule(
h_configId
g_specifier
g_rule
)
=> t / nil"
"Sets or deletes a binding rule on a cell, instance, or occurrence (path). You can set the following binding rules: library list, view list, binding, or stop point.")
("hdbSetDefaultLibListString"
"hdbSetDefaultLibListString(
h_configID
t_liblist
)
=> t / nil"
"Sets the global library list in the configuration specified by the h_configId")
("hdbSetDefaultViewListString"
"hdbSetDefaultViewListString(
h_configID
t_viewList
)
=> t / nil"
"Sets the global view list in the configuration specified by h_configId")
("hdbSetDefaultStopListString"
"hdbSetDefaultStopListString(
h_configID
t_stopList
)
=> t / nil"
"Sets the global stop view list in the configuration specified by h_configId")
("hdbSetTopCellViewName"
"hdbSetTopCellViewName(
h_configID
t_libName
t_cellName
t_viewName
)
=> t / nil"
"Sets the top of the design hierarchy to library.cell:view in the configuration specified by h_configId")
("hdbBindBit"
"hdbBindBit(
h_pathVector
t_masterLibName
t_masterCellName
t_masterViewName
t_baseInstName
x_bit
x_leftRangeIndex
x_rightRangeIndex
g_fixedLib
g_fixedCell
g_fixedView
[ g_wantSignature ]
[ g_wantWhy ]
)
=> ( t_boundLib t_boundCell t_boundView h_bindSignatureId h_bindWhyId )"
"Binds a single bit of an iterated instance.")
("hdbBitHasRules"
"hdbBitHasRules(
h_hdbPathVector
t_baseInstName
x_bit
)
=> t / nil"
"Determines whether a bit-specific configuration rule applies to the specified iterated instance bit.")
("hdbHasIterInstBitRules"
"hdbHasIterInstBitRules(
h_configId
)
=> t /nil"
"Determines whether a configuration contains rules that apply to iterated instance bits.")
("hdbIsIterInst"
"hdbIsIterInst(
t_instName 
[ t_nameSpace ]
)
=> (t_baseInstName t_leftIndex t_rightIndex) / nil"
"Determines whether an instance name is of an iterated instance. If it is of an iterated instance, the base instance name and range indexes are returned.")
("hdbIterInstHasBitRules"
"hdbIterInstHasBitRules(
h_pathVectorId
t_baseInstName
x_leftRangeIndex
x_rightRangeIndex
)
=> t / nil"
"Determines whether an iterated instance has bit-specific configuration rules. If it does, you might want to check whether the binding for individual bits of the iterated instance are different from the iterated instance binding.")
("hdbPushBitCell"
"hdbPushBitCell(
h_pathVectorId
t_baseInstName
x_bit 
x_leftRangeIndex
x_rightRangeIndex
t_libName
t_cellName
t_viewName
[ h_bindWhy ]
)
=> t / nil"
"Pushes the cell of an iterated instance bit on to a path vector.")
("occpClose"
"occpClose(
o_occpHandle 
)
=> t / nil"
"Closes a properties file without saving unsaved changes.")
("occpCreateProp"
"occpCreateProp(
t_name 
g_value @key (nonInheritable nil) (noEval nil)
)
=> r_occpProp / nil"
"Creates an occurrence property structure. It is returned from the occpGet<Type>Prop family of functions and provided as an argument to the occpSet<Type>Prop family of functions. ")
("occpGetBestProp"
"occpGetBestProp(
o_occpHandle 
h_pathVectorId 
t_propName
)
=> r_occpProp / nil"
"Gets the property information with the highest precedence for the specified occurrence path. The information is based on the occurrence path, the iterated instance, the instance, the cell, and the default properties with the specified name.")
("occpGetBitInstProp"
"occpGetBitInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_baseInstName 
x_bit 
t_propName
)
=> r_occpProp / nil"
"Gets the property information for an iterated instance. ")
("occpGetCellProp"
"occpGetCellProp(
o_occpHandle 
t_libName | nil 
t_cellName 
t_propName
)
=> r_occpProp / nil"
"Gets the property information for a cell. ")
("occpGetDefaultProp"
"occpGetDefaultProp(
o_occpHandle 
t_propName
)
=> r_occpProp / nil"
"Gets default property information from the specified properties file. ")
("occpGetInstProp"
"occpGetInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_instName 
t_propName
)
=> r_occpProp / nil"
"Gets the property information for an instance. ")
("occpGetPathProp"
"occpGetPathProp(
o_occpHandle 
h_pathVectorId 
t_propName
)
=> r_occpProp / nil"
"Gets property information for the specified occurrence path. ")
("occpOpen"
"occpOpen(
t_libName 
t_cellName
t_viewName 
t_mode [t_nameSpace [x_iterInstSupport]]
)
=> o_occpHandle / nil"
"Opens a properties file in the specified configuration view for read or edit. When editing a properties file, include the hdbOpen call before occpOpen and close the properties file before closing the HDB handle. ")
("occpRmBitInstProp"
"occpRmBitInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_baseInstName 
x_bit 
t_propName
)
=> t / nil"
"Removes a property for an iterated instance. ")
("occpRmCellProp"
"occpRmCellProp(
o_occpHandle 
t_libName | nil 
t_cellName 
t_propName
)
=> t / nil"
"Removes a cell property. ")
("occpRmDefaultProp"
"occpRmDefaultProp(
o_occpHandle 
t_propName
)
=> t / nil"
"Removes a default property. ")
("occpRmPathProp"
"occpRmPathProp(
o_occpHandle 
h_pathVectorId 
t_propName
)
=> t / nil"
"Removes an occurrence path property. ")
("occpRmInstProp"
"occpRmInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_instName 
t_propName
)
=> t / nil"
"Removes an instance property. ")
("occpSave"
"occpSave(
o_occpHandle 
)
=> t / nil"
"Saves a properties file opened with occpOpen and keeps it open. Only saved updates are reflected when other tools access the file.")
("occpSetBitInstProp"
"occpSetBitInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_baseInstName 
x_bit 
r_occpProp
)
=> t / nil"
"Sets the property information for an iterated instance. The new setting overwrites any existing property setting for the iterated instance.")
("occpSetCellProp"
"occpSetCellProp(
o_occpHandle 
t_libName | nil 
t_cellName 
r_occpProp
)
=> t / nil"
"Sets the property information for a cell. The new setting overwrites any existing property setting for the cell.")
("occpSetDefaultProp"
"occpSetDefaultProp(
o_occpHandle 
r_occpProp
)
=> t / nil"
"Sets the default property information. The new setting overwrites any existing default property setting.")
("occpSetInstProp"
"occpSetInstProp(
o_occpHandle 
t_libName | nil 
t_cellName | nil 
t_viewName | nil 
t_instName 
r_occpProp
)
=> t / nil"
"Sets the property information for an instance. The new setting overwrites any existing property setting for the instance.")
("occpSetPathProp"
"occpSetPathProp(
o_occpHandle 
h_pathVectorId
r_occpProp
)
=> t / nil"
"Sets the occurrence path property information. The new setting overwrites any existing occurrence path property setting.")
("pcdbClose"
"pcdbClose(
h_pcdbHandle
)
=> t / nil"
"Closes a pcdb handle opened with pcdbOpen.")
("pcdbGetInstGen"
"pcdbGetInstGen(
h_master
)
=> h_instGen / nil"
"Creates an instance generator that can be used to get the instances for a given master.")
("pcdbGetInstMasterGen"
"pcdbGetInstMasterGen(
h_pcdbHandle
)
=> h_masterGen / nil"
"Creates a generator that can be used to get the masters of a view.")
("pcdbGetIgnoredInstMasterGen"
"pcdbGetIgnoredInstMasterGen(
h_pcdbHandle
)
=> h_masterGen / nil"
"Creates a generator that can be used to get a list of ignored instance masters.
An ignored instance master is one that is not a sub-design.")
("pcdbInstMasterCell"
"pcdbInstMasterCell(
h_master
)
=> t_cellName / nil"
"Gets the cell name for a master.")
("pcdbInstMasterCellFixed"
"pcdbInstMasterCellFixed(
h_master
)
=> t / nil"
"Gets whether a master's cell name is fixed.")
("pcdbInstMasterLib"
"pcdbInstMasterLib(
h_master
)
=> t_libName / nil"
"Gets the library name for a master.")
("pcdbInstMasterLibFixed"
"pcdbInstMasterLibFixed(
h_master
)
=> t / nil"
"Gets whether a master's library name is fixed.")
("pcdbInstMasterView"
"pcdbInstMasterView(
h_master
)
=> t_viewName / nil"
"Gets the view name for a master.")
("pcdbInstMasterViewFixed"
"pcdbInstMasterViewFixed(
h_master
)
=> t / nil"
"Gets whether a master's view name is fixed.")
("pcdbInstName"
"pcdbInstName(
h_instance
)
=> t_instName / nil"
"Gets the instance name for an instance.")
("pcdbInstWidth"
"pcdbInstWidth(
h_instance
)
=> x_width / nil"
"Gets the instance width for an instance.")
("pcdbNextInst"
"pcdbNextInst(
h_instGen
)
=> h_instance / nil"
"Gets the next instance from an instance generator.")
("pcdbNextInstMaster"
"pcdbNextInstMaster(
h_masterGen
)
=> h_master / nil"
"Gets the next master from a master generator.")
("pcdbOpen"
"pcdbOpen(
t_libName 
t_cellName 
t_viewName 
t_mode
[ ?nameSpace t_nameSpace ]
[ ?dontOpenNextLevel g_dontOpenNextLevel ]
)
=> h_pcdbHandle / nil"
"Opens a configuration and gets a handle that will allow access to the parent/child data for a view.")
("pcdbViewHasPcdbInfo"
"pcdbViewHasPcdbInfo(
t_libName 
t_cellName 
t_viewname 
[ t_nameSpace ] 
)
=> t / nil"
"Determines whether the specified view has pcdb information.
If t_nameSpace is not provided, t_libName, t_cellName, and t_viewName are assumed to be in the name space.")
("pcdbSave"
"pcdbSave(
h_pcdbHandle
)
=> t / nil"
"Save a pcdb handle opened with pcdbOpen. This function is currently not useful. It would require other functions that would modify a pcdb handle that do not currently exist.")
("dbIsMultiTechEnabled"
"dbIsMultiTechEnabled(
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Confirms whether the Virtuoso Multi Tech Framework functionality is enabled in the current session.")
("dbIsVRFEnabled"
"dbIsVRFEnabled(
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Confirms whether the VRF-related functionality is enabled in the current session.")
("dbIsVRFInfraEnabled"
"dbIsVRFInfraEnabled(
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Confirms whether the VRF infrastructure sub-system is enabled in the current session. This includes the basic database SKILL functions required to work with the curved shapes, Allegro translators, and other related features.")
("dbCreateCurvedAreaBoundary"
"dbCreateCurvedAreaBoundary(
d_cellViewId
l_complexCurvedPoints
)
=> d_curvedAreaId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a curved area boundary in the specified cellview, using the specified points.")
("dbCreateCurvedPath"
"dbCreateCurvedPath(
d_cellViewId 
txl_layerPurpose 
l_curvedPoints 
x_width
)
=> d_curvedPathId"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a curved path that has a straight centerline and round edges at all segments.")
("dbCreateCurvedPolygon"
"dbCreateCurvedPolygon(
d_CellViewId 
txl_layerPurpose 
l_curvedPoints
)
=> d_curvedPolygonId"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a curved polygon.")
("dbCreateMultipleCurvedPolygons"
"dbCreateMultipleCurvedPolygons(
d_cellViewId 
txl_layerPurpose 
l_curvedPoints)
=> list(d_curvedPolygonIds) / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates multiple curved polygons in the specified cellview on the specified layer or layer-purpose pair using the specified points.")
("dbIsCurved"
"dbIsCurved(
d_shapeId
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Checks whether the specified shape is a curved shape.")
("dbGetCurvedAreaBoundaryPoints"
"dbGetCurvedAreaBoundaryPoints(
d_curvedAreaBoundaryId
)
=> l_complexCurvedPoints / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns curved area boundary points for the specified curved area boundary object.")
("dbGetCurvedPolygonPoints"
"dbGetCurvedPolygonPoints(
d_curvedPolygonId
) 
=> l_curvedPoints"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Retrieves the curved point list for the specified curved polygon.")
("dbSetCurvedAreaBoundaryPoints"
"dbSetCurvedAreaBoundaryPoints
d_curvedAreaBoundaryId
l_complexCurvedPoints
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Sets curved points for the specified curved area boundary object.")
("dbSetCurvedPolygonPoints"
"dbSetCurvedPolygonPoints(
d_polygonId
l_curvedPoints
) 
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Sets the given curved point list for the specified polygon. If the polygon is not curved, it is converted to curved and the points are set.")
("dbCreateRegionBoundary"
"dbCreateRegionBoundary( 
d_cellViewId 
l_curvedPoints 
t_regionName 
[ t_layerType ]
)
=> d_regionBoundaryId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a region boundary.")
("dbGetRegionBoundaryLayer"
"dbGetRegionBoundaryLayer( 
d_regionBoundaryID
)
=> tx_regionLayer / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns the layer name or number of the specified region boundary.")
("dbGetRegionBoundaryLayerType"
"dbGetRegionBoundaryLayerType( 
d_regionBoundaryId 
)
=> t_regionLayerType / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns the region boundary layer type.")
("dbGetRegionBoundaryName"
"dbGetRegionBoundaryName( 
d_regionBoundaryId 
)
=> t_regionName / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns region boundary name.")
("dbIsRegionBoundary"
"dbIsRegionBoundary( 
d_areaBoundaryId 
)
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Confirms if the specified area boundary is a region boundary.")
("pkxAddFuncDefPin"
"pkxAddFuncDefPin(
pkx_compDefPinId
pkx_funcDefPinId
) 
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Adds the specified funcDefPin object to the specified compDefPin object.")
("pkxCreateCompDef"
"pkxCreateCompDef(
d_bagId
t_deviceType
t_class
t_package
) 
=> pkx_compDefId | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a compDef object in the specified database and returns its ID.")
("pkxCreateCompDefPin"
"pkxCreateCompDefPin(
pkx_compDefId
t_number
) 
=> pkx_compDefPinId | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a compDefPin object and returns its ID.")
("pkxCreateFuncDef"
"pkxCreateFuncDef(
pkx_compDefId
t_slot
t_type
) 
=> pkx_funcDefId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a funcDef object in the specified compDef and returns its ID.")
("pkxCreateFuncDefPin"
"pkxCreateFuncDefPin(
pkx_funcDefId
t_number
t_use
x_swapCode
) 
=> pkx_funcDefPinId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Creates a funcDefPin object in the specified funcDef object and returns its ID.")
("pkxDeleteCompDef"
"pkxDeleteCompDef(
pkx_compDefId
) 
=> t / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Deletes the specified compDef object.")
("pkxFindCompDef"
"pkxFindCompDef(
d_bagId
t_deviceType
) 
=> pkx_compDefId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Searches for a compDef object in the specified database with the specified device type and returns its ID if it exists.")
("pkxFindCompDefPin"
"pkxFindCompDefPin(
pkx_compDefId
t_number
) 
=> pkx_compDefPinId | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Searches for a compDefPin object in the specified compDef with the specified attributes, and returns its ID if it exists.")
("pkxFindFuncDef"
"pkxFindFuncDef(
pkx_compDefId
t_slot
t_type
) 
=> pkx_funcDefId / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Searches for a funcDef object in the specified compDef with the specified attributes, and returns its ID if it exists.")
("pkxFindFuncDefPin"
"pkxFindFuncDefPin(
pkx_funcDefId | pkx_compDefPinId
t_name
t_use
s_swapCode
) 
=> pkx_funcDefPinId | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Searches for a funcDefPin object with the specified attributes, either in a funcDef or in a compDefPin, and returns its ID if it exists.")
("pkxGetCompDefPins"
"pkxGetCompDefPins(
d_bagId
) 
=> list(pkx_compDefPinId) | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns a list of compDefPin object IDs in the specified database.")
("pkxGetCompDefs"
"pkxGetCompDefs(
d_bagId
) 
=> list(pkx_compDefId) / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns a list of compDef object IDs in the specified database.")
("pkxGetFuncDefPins"
"pkxGetFuncDefPins(
d_bagId
) 
=> list(pkx_funcDefPinId) | nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns a list of funcDefPin object IDs in the specified database.")
("pkxGetFuncDefs"
"pkxGetFuncDefs(
d_bagId
) 
=> list(pkx_funcDefId) / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns a list of funcDef object IDs in the specified database.")
("pkxGetProp"
"pkxGetProp(
pkx_Obj
t_propName
) 
=> pkx_Prop / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns the property of the specified package object and name.")
("pkxGetProps"
"pkxGetProps(
pkx_Obj
t_propName
) 
=> list(pkx_properties) / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Returns a list of properties for the specified package object.")
("pkxSetProp"
"pkxSetProp(
pkx_Obj
t_propName
S_propType
g_propValue
) 
=> pkx_property / nil"
"(ICADVM20.1 Virtuoso MultiTech Framework Only) Sets the specified properties on the specified package object.")
("dbCellViewHasPhotonicPinFig"
"dbCellViewHasPhotonicPinFig(
d_cvId
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks whether the specified cellview has a photonic pinFig.")
("dbGetPhotonicPinFigAngle"
"dbGetPhotonicPinFigAngle(
d_pinFigId
)
=> n_angle / nil"
"(ICADVM20.1 Photonics Only) Returns the attribute value of the angle for the specified photonics pinFig.")
("dbGetPhotonicPinFigRadius"
"dbGetPhotonicPinFigRadius(
d_pinFigId
)
=> n_radius / nil"
"(ICADVM20.1 Photonics Only) Returns the attribute value of the radius for the specified photonics pinFig.")
("dbGetPhotonicPinFigWidth"
"dbGetPhotonicPinFigWidth(
d_pinFigId
)
=> n_width / nil"
"(ICADVM20.1 Photonics Only) Returns the attribute value of the width for the specified photonics pinFig.")
("dbIsPhotonicsEnabled"
"dbIsPhotonicsEnabled(
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Confirms whether the photonics-related functionality is enabled.")
("dbSetPhotonicPinFigAngle"
"dbSetPhotonicPinFigAngle(
d_pinFigId
n_value
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Sets the given attribute value as the angle of the specified photonic pinFig.")
("dbSetPhotonicPinFigRadius"
"dbSetPhotonicPinFigRadius(
d_pinFigId
n_value
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Sets the given attribute value as the radius of the specified photonic pinFig.")
("dbSetPhotonicPinFigWidth"
"dbSetPhotonicPinFigWidth(
d_pinFigId
n_value
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Sets the given attribute value as the width of the specified photonic pinFig.")
("dbUnsetPhotonicPinFigAngle"
"dbUnsetPhotonicPinFigAngle(
pinFigId
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Resets the attribute value of the angle for the specified photonics pinFig.")
("dbUnsetPhotonicPinFigRadius"
"dbUnsetPhotonicPinFigRadius(
pinFigId
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Resets the attribute value of the radius for the specified photonics pinFig.")
("dbUnsetPhotonicPinFigWidth"
"dbUnsetPhotonicPinFigWidth(
pinFigId
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Resets the attribute value of the width for the specified photonics pinFig.")
("ccIsEnabled"
"ccIsEnabled(
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks if the CurvyCore engine is enabled.")
("ccCreateCurve"
"ccCreateCurve(
t_x
t_y
l_interval
) 
=> o_curve / nil"
"(ICADVM20.1 Photonics Only) Creates a ccCurve object using the specified parametric functions and interval.")
("ccCreateFacet"
"ccCreateFacet(
l_origin
[ ?angle n_angle ]
[ ?radius n_radius ]
[ ?offsets l_offsets ]
[ ?name t_name ]
)
=> o_facet / nil"
"(ICADVM20.1 Photonics Only) Creates a ccFacet object. A facet is a special type of straight segment that is specified by the origin point, offsets, curvature, and rotation angle. It can be used to implement a smooth stitching between two ccShape objects.")
("ccCreateLineSegment"
"ccCreateLineSegment(
l_pt1
l_pt2
) => o_curve / nil"
"(ICADVM20.1 Photonics Only) Creates a ccCurve object that represents a straight line segment connecting two specified points.")
("ccCreatePolyCurve"
"ccCreatePolyCurve(
l_segments
[ ?close { t | nil } ]
[ ?smoothness S_smoothness ]
) 
=> o_polyCurve / nil"
"(ICADVM20.1 Photonics Only) Creates a ccPolyCurve object from a list of specified polyCurve segments.")
("ccCreateLine"
"ccCreateLine(
d_cellViewId
l_lpp
g_polyCurveSegments
)
=> o_line / nil"
"(ICADVM20.1 Photonics Only) Creates a ccLine object at the specified layer-purpose pair of the given cellview from either a ccPolyCurve object or a list of polyCurve segments forming a polyCurve. When list of polyCurve segments is specified  the resulting polyCurve should be of class G2, otherwise, the function terminates with an error.")
("ccCreatePath"
"ccCreatePath(
d_cellviewId
l_lpp
l_segments
[?defaultWidth g_defWidth] 
[?smoothness   S_smoothness]
) 
=> o_path / nil"
"(ICADVM20.1 Photonics Only) Creates a ccPath object on the specified layer-purpose pair from one or a list of path segments.")
("ccCreatePie"
"ccCreatePie(
d_cellviewId
l_lpp 
[ ?angle n_angle ] 
[ ?startRadius n_startRadius ]
[ ?length n_length ]
[ ?endWidth n_endWidth ]
[ ?endLength n_endLength ]
[ ?offset l_offset ]
[ ?rotation n_rotation ]
[ ?genFigs { t | nil } ]
) 
=> o_surface / nil"
"(ICADVM20.1 Photonics Only) Creates a pie slice figure bounded by outer circle and optionally by an inner circle, two radiuses at given angles, and optionally by an outer capping of given length. The function generates different figures based on the input as follows: 

     When the startRadius is nil, the pie shape that is generated is a true pie shape, with the      length being the radius. 

     When the startRadius is larger than 0.0, a donut shape is generated, with the inner part      radius determined by the value, while the length is used to represent the thickness of the      donut. 

     When endWidth is specified, a termination is generated, caping the coupler by a shape      that is conceptually the union of a rectangle and the last pie shape, with the inner-curved      radius as specified. In this case, endWidth must be smaller than the arc defined by sum      of radius and length and larger than the arc from radius. 

If rotation or offset is specified, the resulting the object undergoes corresponding transformation.")
("ccCreatePolygon"
"ccCreatePolygon(
d_cellview
l_lpp
l_points
?offset l_offset  
?rotation n_rotation
?genFigs g_genFigs
) 
=> o_surface | nil"
"(ICADVM20.1 Photonics Only) Creates a polygon with the specified vertices as the ccSurface in the specified cellview and on the specified layer-purpose pair. The polygon is transformed according to the specified offset and rotation. Optionally, OpenAccess figures (polygons) are created.")
("ccCreateRect"
"ccCreateRect(
d_cellview
l_lpp
l_llPoint
l_urPoint
?offset l_offset  
?rotation n_rotation
?genFigs g_genFigs
) 
=> o_surface | nil"
"(ICADVM20.1 Photonics Only) Creates a rectangle with the specified coordinates as a ccSurface object on the specified cellview and layer-purpose pair. The rectangle is then transformed according to the specified offset and rotation. Optionally, OpenAccess figures (polygons) are created.")
("ccCreateSurface"
"ccCreateSurface(
d_cellViewId
l_lpp
o_boundary
[ l_holes ] 
) 
=> o_surface / nil"
"(ICADVM20.1 Photonics Only) Creates a ccSurface object on the specified layer-purpose pair from the specified boundary, which is ccPolyCurve with positive area and a list of holes, which are ccPolyCurve objects with negative areas.")
("ccCreateSurfaceFromPath"
"ccCreateSurfaceFromPath(
o_path
[ ?facetNames l_facetNames  ]
) 
=> o_surface | nil"
"(ICADVM20.1 Photonics Only) Creates a ccSurface object from the boundary of the given ccPath. Begin and end facets of the ccPath object in the resulting ccSurface boundary are renamed according to the value of facetNames, or are not renamed if facetNames is nil.")
("ccCopyFig"
"ccCopyFig(
o_shape
[ ?cv d_cellViewID ]
[ ?lpp g_lpp ]         
[ ?transform l_transform ]   
) 
=> o_shape2 / nil"
"(ICADVM20.1 Photonics Only) Copies the specified ccShape object to the specified cellview and layer-purpose pair (LPP) by using the specified transform. The copied cellview and LPP default to the ones of the source ccShape.")
("ccConvertIntoCurvy"
"ccConvertIntoCurvy(
d_fig
)
=> o_owner / nil"
"(ICADVM20.1 Photonics Only) Returns a new ccShape to which the specified database figure is attached.")
("ccGenFigs"
"ccGenFigs(
o_shape
[ ?attach { t | nil } ]
[ ?snapToMFG { t | nil } ] 
[ ?accuracy { n_accuracy | nil } ]
)
=> l_figs / nil"
"(ICADVM20.1 Photonics Only) Generates geometry for the specified ccShape and optionally attaches it to the originating ccShape.")
("ccGenOffsetFig"
"ccGenOffsetFig(
o_path
g_lpp
?side t_side
[ ?inner n_value | ?outer n_value | ?inner n_value | ?outer n_value ]
)
=> o_shape / nil"
"(ICADVM20.1 Photonics Only) Creates a new ccShape in the same cellview as the specified path on the specified layer-purpose pair. This shape is constructed by connecting two offsets of the edge of the specified path by using the inner and outer values, respectively, with two facets. The origins of these facets are the same as the origins of the facets of the specified path.")
("ccGetFromFig"
"ccGetFromFig(
d_fig
)
=> o_owner / nil"
"(ICADVM20.1 Photonics Only) Returns the ccShape object attached to the given database figure.")
("ccMoveFig"
"ccMoveFig(
o_shape
[ ?cv d_cellViewId ]
[ ?lpp g_lpp ]
[ ?transform l_transform ]
) 
=> o_shape2 / nil"
"(ICADVM20.1 Photonics Only) Moves the specified ccShape to the specified cellview and layer-purpose pair (LPP) using the specified transform. The cellview and LPP default to the ones of the source ccShape.")
("ccRemoveFigs"
"ccRemoveFigs(
o_shape
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Removes the database figures attached to the given ccShape.")
("ccOffsetPolyCurve"
"ccOffsetPolyCurve(
o_polyCurve           
n_value
[ ?key g_key ]
) 
=> o_polyCurve2"
"(ICADVM20.1 Photonics Only) Returns a copy of the specified polyCurve that is expanded by the specified offset value.")
("ccRenameFacet"
"ccRenameFacet(
o_facet
t_name
)
=> o_facet2 / nil"
"(ICADVM20.1 Photonics Only) Returns a copy of the specified facet with a different name.")
("ccCubicSplineConnector"
"ccCubicSplineConnector(
l_points
[ ?d1 n_d1 ]
[ ?d2 n_d2 ]
) 
=> o_polyCurve / nil"
"(ICADVM20.1 Photonics Only) Returns a polyCurve representing a cubic spline function in the form where y is a function of x through the given list of points (x,y) with strictly increasing coordinates x.")
("ccGetCurvePoint"
"ccGetCurvePoint(
g_curve
n_t
) 
=> l_xy"
"(ICADVM20.1 Photonics Only) Returns a point on a curve or a polyCurve segment at the specified value of the curve function parameter.")
("ccGetCurveDerivative"
"ccGetCurveDerivative(
g_curve
n_t
[ x_order ]
) 
=> l_xy"
"(ICADVM20.1 Photonics Only) Returns a derivative of a curve or a polyCurve segment at the specified value of the curve function parameter.")
("ccGetPolyCurveMinRadius"
"ccGetPolyCurveMinRadius(
o_polyCurve
)
=> n_minRadius"
"(ICADVM20.1 Photonics Only) Returns the minimum curvature radius of a polyCurve, ignoring any tangent discontinuity points.")
("ccIsLinearCurve"
"ccIsLinearCurve(
o_curve
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks if the given ccCurve is linear.")
("ccGetAll"
"ccGetAll(
d_cellViewId
)
=> l_shapes / nil"
"(ICADVM20.1 Photonics Only) Returns all persistent ccShapes in the specified cellview.")
("ccGetPathBoundary"
"ccGetPathBoundary(
o_path
)
=> o_boundary / nil"
"(ICADVM20.1 Photonics Only) Returns the ccBoundary object of the specified ccPath.")
("ccGetPathCenterLine"
"ccGetPathCenterLine(
o_path
)
=> o_centerLine / nil"
"(ICADVM20.1 Photonics Only) Returns the center line of the path as an open ccPolyCurve.")
("ccGetPathEdge"
"ccGetPathEdge(
o_path
S_side 
)
=> o_edge / nil"
"(ICADVM20.1 Photonics Only) Creates a new ccPolyCurve that is either the left or the right edge of the boundary of the specified path.")
("ccFindSurfaceFacet"
"ccFindSurfaceFacet(
o_surface
t_name
) 
=> o_facet / nil"
"(ICADVM20.1 Photonics Only) Searches for a facet with the specified name on the specified surface.")
("ccLayerAnd"
"ccLayerAnd(
g_shapes1
g_shapes2
[ ?cellView d_cellViewId ]
[ ?lpp l_lpp ]
) 
=> l_surface / nil"
"(ICADVM20.1 Photonics Only) Returns a list of new surface shapes derived from the areas of shapes of the first input argument g_shapes1 that overlap areas of shapes of the second input argument g_shapes1.")
("ccLayerAndNot"
"ccLayerAndNot(
g_shapes1
g_shapes2
[ ?cellView d_cellViewId ]
[ ?lpp l_lpp ]
) 
=> l_surface / nil"
"(ICADVM20.1 Photonics Only) Returns a list of new surface shapes derived from the areas of shapes of the first input argument g_shapes1 that do not overlap any areas of shapes of the second input argument g_shapes2.")
("ccLayerOr"
"ccLayerOr(
g_shapes1
g_shapes2
[ ?cellView d_cellViewId ]
[ ?lpp l_lpp ]
) 
=> l_surface / nil"
"(ICADVM20.1 Photonics Only) Returns a list of new surface shapes derived by combining the areas of shapes of the first input argument g_shapes1 and the areas of shapes of the second input argument g_shapes2.")
("ccMirrorFacet"
"ccMirrorFacet(
o_facet
)
=> o_facet2 / nil"
"(ICADVM20.1 Photonics Only) Returns a mirrored or reversed copy of the given ccFacet. If the facet is viewed as a segment, it reverses the direction, which mean that it goes from the end of the original facet to its beginning. However, this function also updates the radius attribute in such a way that two G2-connected paths have mirrored facets at the connection point.")
("ccReversePolyCurve"
"ccReversePolyCurve(
o_polyCurve
)
=> o_polyCurve2 / nil"
"(ICADVM20.1 Photonics Only) Returns a reversed copy of the given polyCurve, which is the polyCurve with the same geometry but in the opposite direction, which is from the end of the original polyCurve to its beginning. 

This function can be used to turn positive-closed polyCurves into negative polyCurves, and negative-closed polyCurves into positive polyCurves.")
("ccSmoothenFig"
"ccSmoothenFig(
o_shape
n_radius
) 
=> o_surface / nil"
"(ICADVM20.1 Photonics Only) Returns the result of smoothening of the specified ccShape as a new transient ccSurface.")
("ccSmoothenPolyCurve"
"ccSmoothenPolyCurve(
o_polyCurve
n_radius
)
=> o_polyCurve2 | nil"
"(ICADVM20.1 Photonics Only) Returns a smoothened copy of the given ccPolyCurve.")
("ccTransformFacet"
"ccTransformFacet(
o_facet
l_transform
) 
=> o_facet2 | nil"
"(ICADVM20.1 Photonics Only) Returns a transformed copy of the given ccFacet object.")
("ccTransformPolyCurve"
"ccTransformPolyCurve(
o_polyCurve
l_transform
) 
=> o_polycurve2 | nil"
"(ICADVM20.1 Photonics Only) Returns a transformed copy of the given ccPolyCurve.")
("ccBendConnector"
"ccBendConnector(
l_port
n_radius
n_bangle 
n_rmin
n_gamma
) 
=> l_connector / nil"
"(ICADVM20.1 Photonics Only) Creates a bend connector making a circular turn from the specified starting port with the radius, bend angle, and gamma fraction given in ccWaypointConnector. The connector consists of a central circular arc and two apex clothoids matching its curvature at one end and with zero curvature at the other end. Gamma is the ratio of the circular bend angle to the total bend angle.")
("ccCreateConnectorWidthExpressionList"
"ccCreateConnectorWidthExpressionList(
n_startWidth
n_endWidth
S_taperStyle
o_polyCurve
[ ?startClamp n_startClampLength ]
[ ?endClamp n_endClampLength ]
)
=> l_segmentsWidths"
"(ICADVM20.1 Photonics Only) Creates a list of curved segments with the corresponding width expressions defining a tapered connector path of the specified tapering style with the specified start and end width around the centerline specified by the input polyCurve. 

The segments of the input polyCurve are assumed to be parametrized by the arc length in the same way as the segments created by the connector generation functions ccBendConnector, ccCurveConnector, and ccWaypointConnector. 

The tapering width function can optionally be clamped to have zero derivative at either or both the ends of the connector with the length of the clamping regions specified by the specified clamp lengths.")
("ccCurveConnector"
"ccCurveConnector(
l_port1
l_port2
n_rmin
[ ?method x_method ]
[ ?parameters l_parameters ]
) 
=> l_connector | nil"
"(ICADVM20.1 Photonics Only) Creates a curve connector with two specified ports and a minimum curvature radius. Depending on the input, the connector consists of different combinations of line, circle, and clothoid curve segments.")
("ccSpiralConnector"
"ccSpiralConnector(
n_lengthInnerSpiral0
n_lengthOuterSpiral1
x_numberOfTurns
n_minRadius
n_gamma 
[ ?portLocation t_location ]
)
=> l_connector / nil"
"(ICADVM20.1 Photonics Only) Creates a spiral connector that consists of an inner S-shaped figure of two joined circular bend connectors. Each endpoint of S is prolonged by a straight extension and then by N-turnings of a spiral circling around S.")
("ccTromboneConnector"
"ccTromboneConnector(
l_legs 
n_rmin
n_gamma 
) 
=> l_connector / nil"
"(ICADVM20.1 Photonics Only) Creates a trombone-shaped connector that consists of five legs of given lengths, smoothly connected by waypoint connectors with the given gamma ratio and the minimum curvature radius.")
("ccWaypointConnector"
"ccWaypointConnector(
l_port1   
l_port2   
l_points  
n_rmin
n_gamma   
) 
=> l_connector / nil"
"(ICADVM20.1 Photonics Only) Creates a waypoint connector between the specified points with the given minimum curvature radius and the given portion (gamma) of the circular bending angle in the overall bending angle.

If both ports are nil, then at least three waypoints must be specified as input. The connector starts at the first waypoint with the tangent given by the line between the first two waypoints and ends at the last waypoint with the tangent given by the line between the last two waypoints.

If both ports are not nil, specify the initial and the final points, tangents, and radiuses of the connector. 

If no waypoints are specified, the start point and the end point are connected by a curve connector. 

If a single waypoint is specified, it is connected to the start and the end point by a pair of curve connectors with zero curvature at the waypoint. 

If two waypoints are specified, they are connected to each other with a straight line and to the start and the end point with a pair of curve connectors with zero curvatures at the waypoints. 

If three or more waypoints are specified, they are connected to each other by a waypoint connector like in the case where both ports are nil and to the start and the end point by a pair of curve connectors with zero curvature at the waypoints.

It is an error to only specify one port as nil and the other port as not nil.

The waypoint connector consists of a sequence of lines, circles, and clothoids. If the calculation of the waypoint connector can only be partially completed, then the result will only contain segments between the starting point and the point where the calculation failed.")
("ccWideConnector"
"ccWideConnector(
g_connector
l_lengthWidths
n_clamp1        
n_clamp2        
)
=> l_segmentWidths"
"(ICADVM20.1 Photonics Only) Creates a specification of a path around the specified connector centerline with the width specified by a cubic spline function.")
("phoAddWaveguidePorts"
"phoAddWaveguidePorts( 
ccPath 
t_startPortName 
t_startPortDirection 
t_endPortName 
t_endPortDirection 
[ ?n_portPinWidth n_portPinWidth ]
)
=> l_port / nil"
"(ICADVM18.1 Photonics Only) Adds circular optical ports at both ends of a ccPath. The ports have the same layer-purpose pair as the ccPath. For both start and end ports, the net, terminal, and pin names use the specified port name. Terminal direction is taken from the corresponding portDirection argument.")
("phoCompose"
"phoCompose(
l_dbInstID
l_libCellView
)
=> t_dbInstId / nil"
"(ICADVM20.1 Photonics Only) Composes the specified list of waveguides into a composite of the specified master.")
("phoComputeModeProps"
"phoComputeModeProps(
o_occPath
n_waveLength
n_temperature
t_mode
[ valueFlags l_valueFlags ]
[ alpha n_alpha ]
)
=> l_values / nil"
"(ICADVM20.1 Photonics Only) Computes the path length and average values for the selected mode properties along the center line of the given path")
("phoHiCompose"
"phoHiCompose(
l_dbInstID
[ ?compositeMaster l_compositeMaster ]
)
=> d_InstID / nil"
"(ICADVM20.1 Photonics Only) Uses a list of waveguide building blocks that are abutted into a single chain and creates a composite waveguide using these building blocks. The instances used for building the composite waveguide could be bound or unbound at the time of waveguide creation, but all the source waveguide instances must originally be bound to the same schematic instance. The composite waveguide is created at the same location as the source waveguide instances and is bound to the same schematic instance as the source instances.")
("phoCreatePort"
"phoCreatePort(
d_cellViewId
l_lpp
t_x
t_y
t_netName
t_termName
t_pinName
n_width
n_angle
n_radius
[ n_portWidth ]
[ n_portHeight ]
=> d_portShape / nil"
"(ICADVM20.1 Photonics Only) Creates a physical connection point (port) for an optical net on layer type waveguide. The area of the optical port is used to trigger auto-abutment of the instances to ensure that the ports with matching attributes (layer, angle, or width) are positioned to avoid any cuts between the facets.")
("phoDrawCurveDeltaConnectorSymbol"
"phoDrawCurveDeltaConnectorSymbol(
d_cellViewID
f_mag
[ ?startPortName t_startPortName ]
[ ?startPortDirection t_startPortDirection ]
[ ?endPortName t_endPortName ]
[ ?endPortDirection t_endPortDirection ]
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Generates the symbol artwork for a photonics Curve Delta connector waveguide. The start port is defined as the side of the waveguide (in the layout), where the mathematical equation describing the centerline starts (usually starts at 0) and the end port is where it finishes. This concept is used to enable proper stitching in the composite waveguide.")
("phoGetConnectorAnchors"
"phoGetConnectorAnchors(
dbInstID
)
=> list( l_anchorStartDescription l_anchorEndDescription))"
"(ICADVM20.1 Photonics Only) Reads the supported optical nets connected to the instance terminals of an instance to return the information about the start and end anchor points for an associated connector waveguide. A connector waveguide has exactly two directed optical ports.")
("phoGenWaveguide"
"phoGenWaveguide(
o_path
[ ?excludeLayers l_excludeLayers ]
) => l_paths / nil"
"(ICADVM20.1 Photonics Only) Generates a list of derived ccShapes for the specified ccPath, using the waveguide definition of the layer-purpose pair of the specified ccPath. The derived shapes on the layers listed in excludeLayers are skipped during the generation. For derived shapes of type offset with inner value, the inner edge of the generated derived shape is coincident with the centerline of the path.")
("phoHiDecompose"
"phoHiDecompose(
l_dbCompWaveInstID
)
=> l_dbInstID / nil"
"(ICADVM20.1 Photonics Only)  Uses a list of composite waveguides or a single composite waveguide and flattens the waveguide to bring the instances inside to the current level. The newly separated waveguide building blocks are bound to the original schematic composite in a complex binding. The instances of the waveguide building blocks are abutted together into a chain and the chain has the same input and output connectivity as the original composite waveguide.")
("phoHiEditCompositeWG"
"phoHiEditCompositeWG(
)"
"(ICADVM20.1 Photonics Only) Opens the Composite Waveguide Editor for the currently selected instance. The editor is displayed only when a single composite waveguide instance is selected. The editor, once open, needs to be manually closed.")
("phoIsWaveguide"
"phoIsWaveguide(
[ ?masterID d_masterID ]
[ ?lcv l_lcv ]
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks whether the specified master cellview or the library cellview is of type waveguide.")
("phoTechDeleteModePropDataTable"
"phoTechDeleteModePropDataTable(
d_techDB
t_waveguideDefName
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Deletes the modeProp table for the specified waveguideDef from the given technology database.")
("phoTechGetModePropDataTableParamValues"
"phoTechGetModePropDataTableParamValues(
d_techDB
t_waveguideDefName
S_param
) 
=> l_values / nil"
"(ICADVM20.1 Photonics Only) Returns the list of values specified in the modeProp table for the given parameter.")
("phoTechHasModeProp"
"phoTechHasModeProp(
d_techDB
t_waveguideDefName
s_param
g_value
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks whether the specified parameter value is present in the modeProp table for the specified waveguide in the specified technology database.")
("phoTechHasModePropDataTable"
"phoTechHasModePropDataTable(
d_techDB
t_waveguideDefName
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Checks whether the given technology database contains a modeProp table for the given waveguideDef.")
("phoTechIsModePropLocalOnly"
"phoTechIsModePropLocalOnly(
d_tech
t_waveguideDefName
)
=> t / nil"
"(ICADVM18.1 Photonics Only) Retrieves the localOnly flag of the modeProp table for the specified waveguideDef. The table is searched only in the local technology database.")
("phoTechLoadModePropDataTable"
"phoTechLoadModePropDataTable(
d_techID
t_path(
[ ?waveguideDefName t_waveguideDefName ]
[ ?localOnly g_localOnly ]
[ ?overwrite g_overwrite ]
)
=> t / nil"
"(ICADVM20.1 Photonics Only) Loads the modeProp table from the specified data file for the given waveguide definition and stores it in the library data.dm file. If no waveguideDef is specified, the modeProp table is loaded for all the waveguide definitions encountered in the data file. ")
("pgssDRC"
"pgssDRC(
d_cellviewID
t_rulesFile
t_layerMap
t_objectMap
l_options
g_function
) 
=> t / nil"
"Launches Pegasus DRC and processes the generated shapes in accordance with the specified function. The pgssDRC SKILL function needs Pegasus license.")
("pvsApplyDRC"
"pvsApplyDRC
d_cellview
t_rulesFile
t_layerMap
t_objectMap
l_options
g_function
) 
=> t / nil"
"Launches Virtuoso IPVS and process generated shapes.")
("dbGetq, dbGet"
"dbGetq( d_object St_AttrOrPropName ) 
	=> g_value 

dbGet( d_object St_AttrOrPropName ) 
	=> g_value"
"Retrieves the value of an attribute or a property associated with a database object.")
("dbSetq, dbSet"
"dbSetq( d_object g_value St_AttrOrPropName ) 
	=> g_value / nil 

dbSet( d_object g_value St_AttrOrPropName ) 
	=> g_value / nil"
"Modifies the value of an attribute or a property associated with a database object.")
("ddAmUsingDM"
"ddAmUsingDM( 
b_objId 
) 
=> t / nil"
"Returns t if the library containing b_objId uses a Design Management system.")
("ddAutoCheckin"
"ddAutoCheckin( 
l_ddIds 
[ g_isBatch( { t | nil } ) ] 
)
=> l_list"
"Automatically checks in an object or list of objects. Objects in a temporary directory cannot be managed. The function skips objects that exist only in the temporary directory of the library and displays a warning for them.")
("ddAutoCheckout"
"ddAutoCheckout( 
l_ddIds 
[ g_isBatch( { t | nil } ) ] 
)
=> l_list"
"Automatically checks out an object or list of objects. Objects in a temporary directory cannot be managed; this function skips objects that exist only in the library's temporary directory and displays a warning for them.")
("ddAutoCtlGetVars"
"ddAutoCtlGetVars(
)
=> l_settings"
"Returns a list of four elements in the following order:

x_prompCkout
x_promptCkin
x_AutoCkout
x_AutoCkin

Each element is a value from 0 through 3 as in ddAutoCtlSetVars. Each element can have one of four values: 0 - none, 1 - views, 2 - files, 3 - both views and files.")
("ddAutoCtlSetVars"
"ddAutoCtlSetVars( 
x_promptCkout 
x_promptCkin 
x_AutoCkout 
x_AutoCkin 
)
=> t"
"Sets prompting and automatic check-in and check-out controls for files and views. Takes a list of four integers, each of which can be one of four values: 0 - none, 1 - views, 2 - files, 3 - both views and files. The integers are applied to indicate to the system to prompt for check out, prompt for check in, automatically check out, and automatically check in respectively.")
("ddCatRefresh"
"ddCatRefresh( 
b_catFiles 
)
=> t / nil"
"Given the DD ID of a category file, this function will purge the in-memory copy of the file and read it in again from disk. This will update the in-memory copy. Refresh is allowed only if the category was opened in read mode.")
("ddCheckin"
"ddCheckin( 
g_files 
t_description 
[ t_switches ] 
)
=> t / nil"
"Checks in the new version of the checked-out and modified data files. Builds a system command that invokes the gdmci command. ddCheckin makes it possible to integrate Cadence tools with other design management software.")
("ddCheckout"
"ddCheckout( 
g_files 
[ t_switches ] 
)
=> t / nil"
"Checks out a version of the files. No version of a cellview can be checked out by any user until any version that is currently checked out is checked in. Builds a system command that invokes the gdmco command. ddCheckout makes it possible to integrate Cadence tools with other design management software.")
("ddClearLibUnmanaged"
"ddClearLibUnmanaged( 
b_libId
) 
=> t / nil"
"Removes any DMTYPE entry from the cdsinfo.tag file in the library directory. This will allow the default value for DMTYPE to be used for this library.")
("ddCreateLib"
"ddCreateLib( 
t_libName 
[ t_libPath ] 
)
=> b_ddId"
"Searches for the named library in the library list.")
("ddDeleteObj"
"ddDeleteObj( 
b_objectId 
)
=> t / nil"
"Deletes b_objectId from the disk.")
("ddDeleteLocal"
"ddDeleteLocal( 
b_objectId 
)
=> t / nil"
"Removes b_objectId from the local work area only. If the objects are under design management, they are not removed from the repository.")
("ddDumpLibList"
"ddDumpLibList(
)
=> t"
"Prints information about the library list. It first prints the list of library files (cds.lib and lib.defs files) and then prints information about each library in the library list. This includes the path to the library and the path to TMP directories, if any.")
("ddGetCoManagedSet"
"ddGetCoManagedSet(
g_viewID
)
=> l_coManagedList / nil"
"Returns the list of comanaged files for the specified view.")
("ddGetCombineValue"
"ddGetCombineValue(
b_libID
)
=> l_libNames / nil"
"Returns a list of names of libraries in a combined library, if the library specified has the COMBINE attribute assigned.")
("ddGetDisplayValue"
"ddGetDisplayValue(
b_libID
)
=> t_attrName / nil"
"Returns the value of the DISPLAY attribute assigned to a library.")
("ddGetForcedLib"
"ddGetForcedLib() 
=> t_filePath / nil"
"Returns the path to the cds.lib file that was set by using either the -cdslib argument to the executable or by using ddSetForcedLib.")
("ddGetForcedLibEx"
"ddGetForcedLibEx(
g_boolean
)
=> t_filePath"
"Gets the cds.lib file that was set with the ddSetForcedLib or ddSetForcedLibEx functions or with the -cdslib command line option.")
("ddGetLibList"
"ddGetLibList( 
) 
=> l_libs/ nil"
"Generates a list of the libraries in the libList.")
("ddGetObj"
"ddGetObj( 
{ t_libName / nil } 
[ t_cellName / nil ] 
[ t_viewName / nil ] 
[ t_fileName / nil ] 
[ b_contextId / nil ] 
[ t_mode ] 
) 
=> b_ddId / nil"
"Finds libraries, cells, views, and files, and creates cells, views, and files (you use ddCreateLib to create libraries).")
("ddGetObjAccess"
"ddGetObjAccess( 
b_objId 
t_which 
) 
=> t_access / nil"
"Retrieves the UNIX access rights of the person specified by t_which to the object designated by b_objId.")
("ddGetObjAccessEx"
"ddGetObjAccessEx(
b_objId 
t_which 
x_pathType
) 
=> t_access / nil"
"Retrieves the UNIX access rights of the person specified by t_which to the object designated by b_objId. This function is similar to ddGetObjAccess except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjChildren"
"ddGetObjChildren( 
b_objId 
) 
=> l_children / nil"
"Returns the children of b_objId. This includes all the objects in both the temporary and master directories.")
("ddGetObjChildrenEx"
"ddGetObjChildrenEx(
b_objId 
x_pathType
) 
=> l_children / nil"
"Returns the children of b_objId. This function is similar to ddGetObjChildren except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjDMSys"
"ddGetObjDMSys( 
b_objId 
) 
=> t_sysName / nil"
"Returns the name of the Design Management system of b_objId.")
("ddGetObjFiles"
"ddGetObjFiles( 
b_objId 
) 
=> l_files / nil"
"Lists all the files found in the object. This includes files found in both the master and temporary directories.")
("ddGetObjFilesEx"
"ddGetObjFilesEx(
b_objId 
x_pathType
) 
=> l_files / nil"
"Lists all the files found in the object. This function is similar to ddGetObjFiles except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjGroup"
"ddGetObjGroup( 
b_objId 
) 
=> x_int / nil"
"Retrieves the UNIX group ID of b_objId as an integer.")
("ddGetObjGroupEx"
"ddGetObjGroupEx( 
b_objId 
x_pathType
) 
=> x_int / nil"
"Retrieves the UNIX group ID of b_objId as an integer. This function is similar to ddGetObjGroup except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjLastModify"
"ddGetObjLastModify( 
b_objId 
) 
=> t_time / nil"
"Returns the last-modified time from the directory or file associated with b_objId.")
("ddGetObjLastModifyEx"
"ddGetObjLastModifyEx(
b_objId 
x_pathType
) 
=> t_time / nil"
"Returns the last-modified time from the directory or file associated with b_objId. This function is similar to ddGetObjLastModify except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjLib"
"ddGetObjLib( 
b_objId 
) 
=> t_lib / nil"
"Finds the ID of the library object that contains it b_objId. If the object is a library, it returns the same ID.")
("ddGetObjName"
"ddGetObjName( 
b_objId 
) 
=> t_name / nil"
"Returns the name of b_objId.")
("ddGetObjOwner"
"ddGetObjOwner( 
b_objId 
) 
=> t_owner / nil"
"Retrieves the UNIX owner name of b_objId.")
("ddGetObjOwnerEx"
"ddGetObjOwnerEx(
b_objId 
x_pathType
) 
=> t_owner / nil"
"Retrieves the UNIX owner name of b_objId. This function is similar to ddGetObjOwner except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjParent"
"ddGetObjParent( 
b_objId 
) 
=> b_parent / nil"
"Returns the ID of the logical (often physical as well) owner-object od b_objId. For a file, it is the library, cell, or view. For a view, it is the cell. For the cell, it is the library. For the library, it is the library itself.")
("ddGetObjReadPath"
"ddGetObjReadPath( 
b_objId 
) 
=> t_path / nil"
"Returns the read path to b_objId.")
("ddGetObjReadPathEx"
"ddGetObjReadPathEx(
b_objId
x_pathType
)
=> t_path / nil"
"Returns the read path to b_objId. This function is similar to ddGetObjReadPath except that you can specify whether to look for the object in the temporary directory or the master directory with the x_pathType argument.")
("ddGetObjSize"
"ddGetObjSize( 
b_objId 
) 
=> x_size / -1"
"Returns the length of b_objId in bytes.")
("ddGetObjSizeEx"
"ddGetObjSizeEx( 
b_objId 
x_pathType
) 
=> x_size / -1"
"Returns the length of b_objId in bytes. This function is similar to ddGetObjSize except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetObjType"
"ddGetObjType( 
b_objId 
) 
=> s_ddType / nil"
"Returns the ddType of b_objId.")
("ddGetObjWritePath"
"ddGetObjWritePath( 
b_objId 
) 
=> t_path / nil"
"Returns the write path to b_objId.")
("ddGetObjWritePathEx"
"ddGetObjWritePathEx(
b_objId
x_pathType
)
=> t_path / nil"
"Returns the write path to b_objId. This function is similar to ddGetObjWritePath except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddGetPathDMSys"
"ddGetPathDMSys( 
t_path 
)
=> t_dmSysStrin / nil"
"Takes a string that is the path to a file or directory and either returns the string name of the design management system that manages that path or returns none if no design management system is in use for that path.")
("ddGetStartup"
"ddGetStartup( 
t_fileName 
[ b_contextId ] 
)
=> t_filePath / nil"
"Looks for t_fileName in each standard place, and if it is not there, in stdPlace/share/cdssetup.")
("ddGetTmpdirWarn"
"ddGetTmpdirWarn( 
) 
=> t / nil"
"Returns the current setting used to suppress or print a warning message for an ASSIGN statement with attribute TMP that appears in cds.lib files. The TMP attribute defines a temporary storage directory for a read-only or reference library. If you set the DD_TMPDIR_ON environment variable to NO, the temporary directory functionality is turned off and DDPI skips ASSIGN and UNASSIGN statements when parsing cds.lib files and, by default, prints the following warning: 
WARNING `<PATH_TO_CDSLIB_FILE>/cds.lib', Line 3: skipping: 'ASSIGN' lib1 TMP /tmp")
("ddGetTriggerList"
"ddGetTriggerList( 
t_triggerName 
) 
=> l_triggerFunc"
"Returns a list of functions registered to be executed when t_triggerName is activated.")
("ddGetUpdatedLib"
"ddGetUpdatedLib( 
) 
=> t_filePath"
"Returns the path to the cds.lib file that was last used by ddUpdateLibList. This is the same as ddGetForcedLib if a forced library was in effect.")
("ddIsId"
"ddIsId( 
b_objId 
) 
=> t / nil"
"Returns t if b_objId is an opaque ID known to the PI, and nil otherwise. Some dd functions will accept nil as the ID parameter, but this function returns nil if the argument is nil.")
("ddIsHiddenCell"
"ddIsHiddenCell( 
b_cellId 
) 
=> t / nil"
"Determines whether the specified cell is hidden. A cell is hidden if it is a member of the Hidden category or a member of a subcategory of the Hidden category.")
("ddIsObjLibMarked"
"ddIsObjLibMarked( 
b_objId 
) 
=> t / nil"
"Returns t if the library that owns b_objId is marked to be deleted or its path is changed.")
("ddIsObjReadable"
"ddIsObjReadable( 
b_objId 
) 
=> t / nil"
"Returns t if the object specified by b_objId can be read by the current process.")
("ddIsObjReadableEx"
"ddIsObjReadableEx(
b_objId
x_pathType
)
=> t / nil"
"Returns t if the object specified by b_objId can be read by the current process. This function is similar to ddIsObjReadable except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddIsObjWritable"
"ddIsObjWritable( 
b_objId 
) 
=> t / nil"
"Returns t if the object specified by b_objId can be modified by the current process.")
("ddIsObjWritableEx"
"ddIsObjWritableEx(
b_objId
x_pathType
)
=> t / nil"
"Returns t if the object specified by b_objId can be modified by the current process. This function is similar to ddIsObjWritable except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddIsPathManageable"
"ddIsPathManageable( 
t_path
) 
=> t / nil"
"Returns t if the supplied path is manageable (is in a location that is supported by a design management system).")
("ddIsPathManaged"
"ddIsPathManaged( 
t_path
) 
=> t / nil"
"Returns t if the specified path is currently managed by a design management system. A path is managed if the file associated with the path is checked in. You can use ddIsPathManaged to implement a check against creating a file when another user has already created it but the local user work area is not updated to reflect the creation.")
("ddLibIs5X"
"ddLibIs5X(
b_libId
)
=> t / nil"
"Determines if the library was created with the 5.X library structure.")
("ddLibHasTmpDir"
"ddLibHasTmpDir(
b_objId
)
=> t / nil"
"Checks if the library has a temporary directory. A temporary directory for a library is defined by putting a TMP attribute on the library with an ASSIGN statement in a cds.lib file.")
("ddLockDescribe"
"ddLockDescribe( 
b_lockId 
) 
=> t_message / nil"
"Fills a static string with a message.")
("ddLockFree"
"ddLockFree( 
b_lockId 
) 
=> t / nil"
"Releases any existing lock on the file specified by b_lockId.")
("ddLockGetStatus"
"ddLockGetStatus( 
b_lockId 
) 
=> x_sysId t_type x_value t_userName t_userHost t_fileHost t_filePath"
"Retrieves frequently needed information from the lock table: The lock-system ID, type, and value and the holder's user name and hostid.")
("ddLockPath"
"ddLockPath( 
t_filePath 
) 
=> b_lockId"
"Creates a handle that allows you to lock the file and returns a lock ID for the file. Once you call ddLockFree, all references to that lock ID become invalid.")
("ddLockSet"
"ddLockSet( 
b_lockId 
t_mode 
[ t_block ] 
[ t_message ] 
) 
=> t / nil"
"Gets the type of lock in t_mode for the file ID. If you have already locked the file, this function changes the lock type.")
("ddLockSetEx"
"ddLockSetEx(
b_lockId 
t_mode 
[ g_block ] 
[ t_message ] 
[ g_doErrMsgs] 
[ g_timeout ] 
) 
=> t / nil"
"An extension of ddLockSet with two additional arguments.")
("ddMapGetDataTypeFileName"
"ddMapGetDataTypeFileName( 
t_dataType 
) 
=> t_fileName / nil"
"Returns the pattern registered in the registry for t_dataType.")
("ddMapGetDataTypeList"
"ddMapGetDataTypeList( 
) 
=> l_list"
"Returns a list of names of the data types specified in the registry.")
("ddMapGetFileDataType"
"ddMapGetFileDataType( 
b_fileObjId 
) 
=> t_dataType / nil"
"Returns the name of the data type associated with b_fileObjId.")
("ddMapGetFileTool"
"ddMapGetFileTool( 
b_fileObjId 
) 
=> t_fileTool / nil"
"Looks up the data format registered in the registry for b_fileObjId's file name, and returns the tool name of the preferred editor (if there is one) or the default editor which is registered for that data format.")
("ddMapGetFileViewType"
"ddMapGetFileViewType( 
b_fileObjId 
) 
=> t_viewType / nil"
"Returns the name of the view type associated with b_fileObjId.")
("ddMapGetToolNameDataType"
"ddMapGetToolNameDataType( 
t_toolName 
) 
=> t_dataType / nil"
"Returns the name of the first data type in the registry which is associated with t_toolName.")
("ddMapGetToolNameList"
"ddMapGetToolNameList( 
) 
=> l_toolList"
"Retrieves a list of the names of the tools specified in the registry, in alphabetical order.")
("ddMapGetToolNameViewType"
"ddMapGetToolNameViewType( 
t_toolName 
) 
=> t_viewTypeName / nil"
"Returns the name of the first view type in the registry which is associated with t_toolName.")
("ddMapGetViewTypeFileName"
"ddMapGetViewTypeFileName( 
t_viewType 
) 
=> t_fileName / nil"
"Returns the pattern registered in the registry for a view alias or data type named t_viewType.")
("ddMapGetViewTypeList"
"ddMapGetViewTypeList( 
) 
=> l_list"
"Returns a list of names of view types defined in the registry, in alphabetical order. If a data type in the registry has a dfII_viewType property defined, the value of that property will be in the list. Otherwise, the data type name will be in the list.")
("ddMapIsFileNameKnown"
"ddMapIsFileNameKnown( 
t_fileName 
) 
=> t / nil"
"Returns t if the file name is registered as the pattern for some data format in the registry.")
("ddMapIsToolLegal"
"ddMapIsToolLegal( 
b_fileObjId 
t_toolName 
) 
=> t / nil"
"Returns t if t_toolName is either the preferred editor or the default editor for b_fileObjId.")
("ddMapIsToolNameKnown"
"ddMapIsToolNameKnown( 
t_toolName 
) 
=> t / nil"
"Returns t if t_toolName is defined in the registry.")
("ddMarkObjMaster"
"ddMarkObjMaster( 
b_objId 
) 
=> t / nil"
"Changes the master.tag file to designate the object as the new master. The master.tag file must be located with the file it designates, so you must be able to write a file to mark it master. The master.tag file is checked out of the Design Management system, if necessary.")
("ddNeedCheckout"
"ddNeedCheckout( 
b_objId 
) 
=> t / nil"
"Enable tools that need to provide automatic checkout behavior to decide if they need to call the functions ddCheckout and ddCheckin.")
("ddObjHasNamedObj"
"ddObjHasNamedObj( 
b_objId 
t_fileName 
) 
=> t / nil"
"Returns t if b_objId has a child object named t_fileName.")
("ddObjHasNamedObjEx"
"ddObjHasNamedObjEx(
b_objId
t_fileName 
x_pathType
)
=> t / nil"
"Returns t if b_objId has a child object named t_fileName. This function is similar to ddObjHasNamedObj except that you can specify whether to look for the object in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddObjIsInMaster"
"ddObjIsInMaster(
b_objId
)
=> t / nil"
"Checks if the object exists in the master directory.")
("ddObjIsInTmp"
"ddObjIsInTmp(
b_objId
)
=> t / nil"
"Checks if the object exists in the temporary directory. A temporary directory for a library is defined by putting a TMP attribute on the library with an ASSIGN statement in a cds.lib file. The library itself is considered the master directory.")
("ddProduceObjRelNames"
"ddProduceObjRelNames( 
b_objId 
g_consumer 
g_clientData 
) 
=> t / nil"
"Produces the names of all the objects that belong to a library, cell, or view and calls the given function with each name and any provided data structure.")
("ddProduceObjRelNamesEx"
"ddProduceObjRelNamesEx(
b_objId 
g_consumer 
g_clientData 
x_pathType
) 
=> t / nil"
"Produces the names of all the objects that belong to a library, cell, or view and calls the given function with each name and any provided data structure. This function is similar to ddProduceObjRelNames except that you can specify whether to look for the objects in the temporary directory or the master directory, or both, with the x_pathType argument.")
("ddRegHiddenCellsFunc"
"ddRegHiddenCellsFunc( 
s_hiddenCellsFunc 
[ t_libName] 
) 
=> t / nil"
"Registers a user-defined SKILL function that will be called to obtain a list of hidden cell names. Note that additionally the Virtuoso environment considers a cell to be hidden if it is a member of the Hidden category or its subcategories. ")
("ddRegTrigger"
"ddRegTrigger( 
t_triggerName 
s_triggerFunc 
[ x_priority ] 
) 
=> t / nil"
"Registers a function to be called when the triggering event occurs. Adds callbacks (triggers) to PI functions that change things. Each of these PI functions has a pre-trigger and an post-trigger.")
("ddReleaseObj"
"ddReleaseObj( 
b_objId 
) 
=> t / nil"
"When you find an object using write (w) or append (a) mode, and the object and its parents do not yet exist, ddGetObj creates the object and its parents in the file system. The effect of this action is to make them visible in the browser and to permit us to designate file as a Master. After you close the file, you should call ddReleaseObj, which then deletes the file if you did not save it yet.")
("ddSetForcedLib"
"ddSetForcedLib( 
t_path
) 
=> t / nil"
"If the given path is a valid path, the forcedLib is used for all future library updates/creates/deletes and t is returned. If the path is an empty string, the default cds.lib file is used for all future library updates/creates/deletes and t is returned. If a path is given that is not valid, nil is returned with no error message and the forcedLib will be unchanged.")
("ddSetForcedLibEx"
"ddSetForcedLibEx(
g_cdsLibFile
[ g_libDefsFile ]
)
=> t / nil"
"Sets the cds.lib file to be used instead of searching for them in the default locations. If no cds.lib is specified but a lib.defs file is specified, the function will use the specified lib.defs as a forced cds.lib file. Cadence recommends you to use the ddSetForcedLib function instead.")
("ddSetLibUnmanaged"
"ddSetLibUnmanaged( 
b_libId
) 
=> t / nil"
"Sets the DMTYPE entry of the cdsinfo.tag file in the library directory to none. This will guarantee that regardless of the default value for DMTYPE, this library will not be DM managed. If the library has a temporary directory, it will also not be managed.")
("ddSetLibDmType"
"ddSetLibDmType(
b_libId
t_dmType
)
=> t / nil"
"Sets the DMTYPE entry of the cdsinfo.tag file in the library.")
("ddSetTmpdirWarn"
"ddSetTmpdirWarn( 
g_doWarn 
) 
=> t / nil"
"Enables or disables printing of a warning message for an ASSIGN statement with attribute TMP which appears in cds.lib files. The TMP attribute defines a temporary storage directory for a read-only or reference library. If you set the DD_TMPDIR_ON environment variable to NO, the temporary directory functionality is turned off and DDPI skips ASSIGN and UNASSIGN statements when parsing cds.lib files. In that case, DDPI prints the following warning by default:
WARNING `<PATH_TO_CDSLIB_FILE>/cds.lib', Line 3: skipping: 'ASSIGN' lib1 TMP /tmp 
If you do not want the warning message to be printed, specify nil for the g_doWarn argument.")
("ddUnregHiddenCellsFunc"
"ddUnregHiddenCellsFunc( 
s_hiddenCellsFunc 
) 
=> t / nil"
"Unregisters a hidden cells function that was registered using ddRegHiddenCellsFunc. ")
("ddUnregTrigger"
"ddUnregTrigger( 
t_triggerName 
s_triggerFunc 
) 
=> t / nil"
"Removes a callback (trigger function) from a named list of trigger functions.")
("ddUpdateLibList"
"ddUpdateLibList(
) 
=> t / nil"
"Establishes and re-establishes a list of libraries in virtual memory to be used by ddGetObj.")
("ciwAddTranslatorItem"
"ciwAddTranslatorItem(
s_tag
t_itemText
t_callback
)
=> t / nil"
"Adds an entry for the Import or Export commands.")
("ciwCreateMenu"
"ciwCreateMenu(
ls_menuDef 
[ x_windowNum ]
) 
=> r_menu / nil"
"Creates a menu from the given menu definition. The menu created can be used as a pop-up menu. This function exists primarily for application support.")
("ciwCreatePulldown"
"ciwCreatePulldown(
ls_menuDef 
[ x_windowNum ]
) 
=> r_menu / nil"
"Creates a pulldown menu from the given menu definition. The ls_menuDef argument can either be a list defining the contents of a pulldown menu or the SKILL symbol that represents the list. This function exists primarily for application support.")
("ciwHiExit"
"ciwHiExit(
) 
=> t / nil"
"Exits the session.")
("ciwMenuInit"
"ciwMenuInit(
[ ?verbose g_verbose ]
[ ?reset g_reset ]
) 
=> t / nil"
"Initializes and installs the CIW pulldown menus based on the menu files found in the hierarchy. This function will be called instead of hiInstallCIWMenus. It can also be called from the CIW to debug the menu file contents.

If g_reset is specified as t, the CIW menus are reset. Calling ciwMenuInit without any arguments will initialize the CIW menus only if it has not already been done.")
("ciwMenuInstall"
"ciwMenuInstall(
r_window 
ls_bannerDef
) 
=> t / nil"
"Creates and installs into r_window a menu banner based on ls_bannerDef. Useful for applications that create and manage their own windows. This function exists primarily for application support.")
("ciwMenuLoadFile"
"ciwMenuLoadFile(
t_appName 
[ g_verbose ]
) 
=> t / nil"
"Reads menu files found in the DFII hierarchy using t_appName.")
("ciwRemoveTranslatorItem"
"ciwRemoveTranslatorItem(
s_tag
t_itemText
t_callback
)
=> t / nil"
"Removes an entry from the Import or Export commands.")
("ddsAboutDFII"
"ddsAboutDFII(
)
=> t / nil"
"Opens the product information dialog box, which indicates the product, the release number, and copyright information. This dialog box is used for the custom IC design tools.")
("ddsBrowserAction"
"ddsBrowserAction( 
s_action 
)
=> t / nil"
"Returns the Boolean value of the requested Library Browser option. This function explains how applications use the Library Browser preferences and the actions specified in the ddsSyncWithForm function. If you are integrating your own Library Browser, you must decide whether to support such actions; if so, you can use this function. This functionality provides applications the ability to support the user's need to see the Library Browser when a particular command is executed.")
("ddsCheckinPreferences"
"ddsCheckinPreferences(
)
=> t / nil"
"Sets the prompt behavior you choose for the current DFII design session for checking in design data. This function displays a form to set the auto checkin prompt preferences for properties, files, and cellviews. This process controls access to the design data files that design and team members store in a project data repository.")
("ddsCheckoutPreferences"
"ddsCheckoutPreferences(
) 
=> t / nil"
"Sets the prompt behaviors you select for the current DFII design session for checking out design data. This function displays a form to set the auto checkout prompt preferences for properties, files, and cellviews. This process controls access to the design data files that design and team members store in a project data repository.")
("ddsCheckSessionName"
"ddsCheckSessionName(
t_sessionName
)
=> t_sessionName"
"Checks to see if the current MPS session is also the default session for the user. If the given session name is the same as the effective user ID's name or if there is no session name, builds a unique session name using the process ID. This implies that the current process checks the session and returns the session name to use - either the given name if it is checked or a new unique name to use to perform the checking.")
("ddsCloseLibManager"
"ddsCloseLibManager(
) 
=> t / nil"
"Closes the Library Manager.")
("ddsEditProp"
"ddsEditProp( 
t_libName 
t_cellName 
t_viewName 
) 
=> propertyEditor"
"Invokes the property editor on the named object. Calls peEditProp after getting the ID for the named object.")
("ddsEndSyncWithForm"
"ddsEndSyncWithForm( 
)
=> t / nil"
"Terminates an application's form synchronization with the Library Browser and closes the Library Browser.")
("ddsFileBrowseCB"
"ddsFileBrowseCB( 
g_form
s_targetName
[ t_filter ] 
[ s_mode ] 
[ t_caption ] 
)
=> t / nil"
"Creates a file browser dialog for specifying file names through browsing.")
("ddsGetCurrentLib"
"ddsGetCurrentLib( 
) 
=> b_ddLibId / nil"
"Accesses the currently selected library in the Library Browser.")
("ddsGetCustomLibSelect"
"ddsGetCustomLibSelect(
) 
=> t_name / nil"
"Returns the name string passed to ddsRegCustomLibSelect if a custom Library Browser is registered to the system. If a custom Library Browser is not registered, nil is returned.")
("ddsGetServiceName"
"ddsGetServiceName(
)
=> t_serviceName"
"Returns a string that can be used as an MPS service name. The string is the name of the invoked program plus the process ID number.")
("ddsHiCloseData"
"ddsHiCloseData(
)
=> t / nil"
"Displays the Close and Purge Data form that prompts you to select one or more objects to close and purge form virtual memory.")
("ddsHiCreateLibrary"
"ddsHiCreateLibrary( 
) 
=> t / nil"
"Create new libraries from within DFII.")
("ddsHiDefragCellView"
"ddsHiDefragCellView(
) 
=> t / nil"
"Displays a form that prompts you to specify the data set (library name, cell name, view name) to be de-fragmented. De-fragmentation is an operation to remove the free space in a given cellview or cellviews in a specified library to regain more disk and memory space.")
("ddsHiDefragLib"
"ddsHiDefragLib(
) 
=> t / nil"
"Displays a form that prompts you to specify the library to be de-fragmented. Fragmentation is an operation to remove the free space in a given cellview or cellviews in a specified library to regain more disk and memory space.")
("ddsHiMakeReadOnly"
"ddsHiMakeReadOnly(
) 
=> t / nil"
"Displays a form that prompts you to select cellviews currently open in edit mode and change them to read only mode.")
("ddsHiOpenCdsLibEditor"
"ddsHiOpenCdsLibEditor( 
) 
=> t / nil"
"Brings up the Library Path Editor.")
("ddsHiPreferences"
"ddsHiPreferences( 
) 
=> t / nil"
"Invokes the Browser and CIW Preferences form.")
("ddsHiRefresh"
"ddsHiRefresh(
) 
=> t / nil"
"Opens a form listing the open technology files, properties, and cellviews that are not current with their corresponding files on disk.")
("ddsLEWhatsNewAtStartup"
"ddsLEWhatsNewAtStartup(
)
=> t / nil"
"Brings up the What's New window for Virtuoso Layout Editor.")
("ddsOnLineHelp"
"ddsOnLineHelp( 
s_tag 
) 
=> t / nil"
"Brings up online Help documentation for DFII tools.")
("ddsOpenConvertToolBox"
"ddsOpenConvertToolBox(
) 
=> t / nil"
"Displays the Conversion Tool Box user interface.")
("ddsOpenLibManager"
"ddsOpenLibManager( 
)
=> t / nil"
"Starts the library manager. The separate process, library manager, is invoked and connected to using mps.")
("ddsProgramName"
"ddsProgramName(
)
=> t_programName"
"Returns the name of the program minus any .exe extension.")
("ddsRefresh"
"ddsRefresh(
[ ?cellview { t | nil } ]
[ ?cdf { t | nil } ]
[ ?property { t | nil } ]
[ ?techfile { t | nil } ]
)
=> t / nil"
"Refreshes open cellviews, CDFs, property bags, and technology files that are not current with their corresponding files on disk.")
("ddsRegPreRefreshTrigger"
"ddsRegPreRefreshTrigger(
t_function
)
=> t / nil"
"Registers a user-defined SKILL function that is called before executing the Refresh command using CIW - File - Refresh or the ddsRefresh SKILL function.")
("ddsRegPostRefreshTrigger"
"ddsRegPostRefreshTrigger(
t_function
)
=> t / nil"
"Registers a user-defined SKILL function that is called after completion of the Refresh command using CIW - File - Refresh or the ddsRefresh SKILL function.")
("ddsRegCustomLibSelect"
"ddsRegCustomLibSelect( 
t_name 
s_sync 
s_update 
s_endSync 
s_curlLib
)
=> t / nil"
"ddserv only supports one customization at a given time. If you call this function more than once, the latest set of functions are registered. The ddsRegCustomSelect function performs an isCallable Check on each of its arguments to insure that the functions have been loaded into the system. If not, a message is generated.")
("ddsHiSaveData"
"ddsHiSaveData(
)
=> t / nil"
"Displays the Save Modified Data form that prompts you to select one or more objects to save from virtual memory.")
("ddsServSelect"
"ddsServSelect(
t_lib
t_cell
t_view
)
=> t"
"Processes a select request from the browser process if and only if a form is synchronized to it. It is the call logged in the cds.log file. The function sets the appropriate form field with the library, cell, and view values.")
("ddsSetLibManLCV"
"ddsSetLibManLCV(
t_lib
t_cell
t_view
)
=> t / nil"
"Allows the application to set the library name, cell name, or view name entries in the library manager from a DFII session.")
("ddsGetLibManLCV"
"ddsGetLibManLCV(
)
=> l_libCellView"
"Returns the library, cell, and view name entries currently selected in the library manager")
("ddsSyncWithForm"
"ddsSyncWithForm( 
g_form 
s_action 
s_libField 
[ s_cellField [ s_viewField [ l_viewTypes ] ] ] 
)
=> t / nil"
"Registers the given form and fields of that form for synchronization with the Library Browser. The Library Browser is seeded with the current values of the library, cell, and view names from the fields in the form if they are not blank. The field value is not updated by ddsSyncWithForm when its enabled or editable attribute is set to nil. From this point until ddsEndSyncWithForm, selections in the Library Browser seed the given form fields.")
("ddsUnregCustomLibSelect"
"ddsUnregCustomLibSelect( 
[ g_verbose ] 
) 
=> t"
"Un-registers the custom Library Browser interface during a session.")
("ddsUpdateSyncWithForm"
"ddsUpdateSyncWithForm( 
) 
=> t / nil"
"If an application has registered a form with the Library Browser by calling ddsSyncWithForm or dmbSyncWithForm, this function updates the Library Browser with the values currently in the respective form fields.")
("ddsViewDDProp"
"ddsViewDDProp( 
t_libName 
[ t_cellName [ t_viewName ] ]
) 
=> t_viewFile"
"Finds information about the specified object and any properties found in its property bag.")
("ddsWhatsNew"
"ddsWhatsNew(
)
=> t / nil"
"Brings up the What's New window.")
("dmbGetCurrentLib"
"dmbGetCurrentLib( 
) 
=> ddId / nil"
"Returns the ddId of the library currently selected in the Library Browser if a form is registered to it (otherwise, the Library Browser is hidden).")
("dmbLibBrowserFormDone"
"dmbLibBrowserFormDone( 
s_formtype 
) 
=> t"
"Terminates the synchronization between the last form registered and the Library Browser. Applications should ALWAYS call this function when they know their Library Browser/form interaction has terminated (using Cancel or OK). Leaving it hanging could result in unpredictable behavior which would degrade the usability of the system. 

Supplied for compatibility. Replace with ddsEndSyncWithForm.")
("dmbOpenLibBrowser"
"dmbOpenLibBrowser( 
)
=> t / nil"
"Invokes the library manager. The separate process, library manager, is invoked and connected to using mps. 

Supplied for compatibility. Replace with ddsOpenLibManager.")
("dmbSetBrowserInteractions"
"dmbSetBrowserInteractions(
[ ?openDesignOption { t | nil } ]
[ ?openPlaceInstanceOption {t | nil} ]
[ ?openOthersOption { t | nil } ]
)
=> t / nil"
"Specifies whether the Library Browser is automatically opened when certain types of forms appear. This function is provided for backward compatibility with only the 4.3.4 version.")
("dmbSyncWithForm"
"dmbSyncWithForm( 
s_form s_synctype 
s_libraryName 
s_cellName	
s_viewName 
[ s_versionNumber ] 
) 
=> t / nil"
"Establishes synchronization between a given form and the Library Browser. The given library, cell, and view fields are filled in as you select items in the Library Browser.")
("dmbSyncWithCellForm"
"dmbSyncWithCellForm( 
s_form 
s_synctype 
s_libraryName 
s_cellName 
[ s_viewName ] 
[ s_versionNumber ] 
)
=> t / nil"
"Establishes synchronization between a given form and the Library Browser. The given library, cell, and view fields are filled in as you select items in the Library Browser.")
("dmbUpdateBrowser"
"dmbUpdateBrowser( 
)
=> t / nil"
"Updates the library browser with the values currently in the registered form formFields. This function lets applications update the Library Browser based on what users type into a form.")
("ddCatOpen"
"ddCatOpen( 
g_ddId 
t_categoryName 
t_mode 
) 
=> b_objId / nil"
"Opens a category with the given name and uses the mode to get the object ID.")
("ddCatOpenEx"
"ddCatOpenEx( 
g_ddId 
t_categoryName 
t_mode 
x_keepEmpty 
)
=> b_objId / nil"
"Opens a category with the given name using the mode to get the object ID.")
("ddCatAddItem"
"ddCatAddItem( 
g_ddId 
t_name 
t_type 
) 
=> t / nil"
"Adds the specified name to the given category.")
("ddCatSubItem"
"ddCatSubItem( 
g_ddId 
t_name 
) 
=> t / nil"
"Removes the named item from the given category.

If the name is the name of a category (that is, removing a subcategory from another category), the  checks if it is referenced in any other category. If not, the category is moved to the library category list. This action ensures that the caller must do a ddCatRemove to remove category entries from a library. Changes are not written to disk until a ddCatSave is done.")
("ddCatSave"
"ddCatSave( 
g_ddId 
) 
=> t / nil"
"Writes the category information to disk. This writes out any changes made to the category to disk.")
("ddCatRemove"
"ddCatRemove( 
g_ddId 
) 
=> t / nil"
"Removes the category and its contents from disk. All references to the category are removed from the library.")
("ddCatClose"
"ddCatClose( 
g_ddId 
) 
=> t / nil"
"Closes the category and purges its information from virtual memory. Any edits since the last ddCatSave are lost.")
("ddCatGetCatName"
"ddCatGetCatName( 
g_ddId 
) 
=> t_categoryName / nil"
"Returns the category name of the given category ID.")
("ddCatGetCatMembers"
"ddCatGetCatMembers( 
g_ddId 
) 
=> l_memberList / nil"
"Returns the list of members of the given category. The function does not return the members (cells) that do not exist in the library.")
("ddCatGetLibCats"
"ddCatGetLibCats( 
g_ddId 
) 
=> l_categoryNames / nil"
"Returns the list of library-level categories.")
("ddCatFindCat"
"ddCatFindCat( 
g_ddId 
t_name 
t_mode 
) 
=> b_objId / nil"
"Returns the ID of a category with the given name in the given mode. Traverses category hierarchies. 

This function calls ddCatOpen to get the category ID to be returned. The caller must call ddCatClose to properly flush the information from virtual memory when done. The category is opened in the given mode.")
("ddCatGetCellsNotInCat"
"ddCatGetCellsNotInCat( 
g_ddId 
) 
=> l_cellNames / nil"
"Returns the names of cells that are not in any category. This information is derived from an existing library.")
("ddCatIsObjInCat"
"ddCatIsObjInCat( 
t_name 
b_ddId 
) 
=> t_type / ddcCatUnknownType"
"Searches for the named object in the given category.")
("dmAddCellToCategory"
"dmAddCellToCategory( 
g_categoryId 
l_cellList 
) 
=> t / nil"
"Adds the specified cells to the category.")
("dmCreateCellCategory"
"dmCreateCellCategory( 
g_libOrCatId 
t_categoryName 
l_cellList 
) 
=> t / nil"
"Creates a cell category and adds all specified cells to the category.")
("dmRemoveCellCategory"
"dmRemoveCellCategory( 
g_categoryId 
) 
=> t / nil"
"Removes a cell category from a library or from a parent cell category.")
("dmRemoveCellFromCategory"
"dmRemoveCellFromCategory( 
g_categoryId 
l_cellList 
) 
=> t / nil"
"Removes one or more cells from a cell category.")
("deRegApp"
"deRegApp(
[ ?viewType t_viewType ]
[ ?parentType t_parentType ]
[ ?appName t_appName ]
[ ?help t_help ]
[ ?dataTrigger s_dataTrigger ]
[ ?appTrigger s_appTrigger ]
[ ?enableTrigger s_enableTrigger ]
[ ?menuTrigger s_menuTrigger ]
[ ?postInstallTrigger s_postInstallTrigger ]
[ ?viewNameSwitchTrigger s_viewNameSwitchTrigger ]
[ ?widgetType t_widgetType ]
[ ?noCadenceMenu g_noCadenceMenu ]
[ ?windowBBoxProc s_function ]
[ ?appTitle t_appTitle ]
[ ?exclusive g_exclusive ]
) 
=> t / nil"
"Registers the characteristics and entry points of applications so that they can be called in the appropriate situations.")
("deUnRegApp"
"deUnRegApp( 
t_viewType 
) 
=> t / nil"
"Un-registers the view type.

Only one application can currently be registered for each view type. If a second registration is attempted, an error results. To re-register a view type with different procedures, the view type must first be unregistered with this routine.")
("deRegUserTriggers"
"deRegUserTriggers( 
t_viewType 
[ s_appTrigger [ s_menuTrigger [ s_postInstallTrigger ] ] ] 
) 
=> t / nil"
"Registers user application, user menu, and user post install triggers.")
("deUnRegUserTriggers"
"deUnRegUserTriggers( 
t_viewType 
) 
=> t / nil"
"Removes any user triggers associated with t_viewType.")
("deInheritEnabling"
"deInheritEnabling( 
t_viewType 
) 
=> t / nil"
"Enables t_viewType to depend on the enabling of its parent type. Thus, the user must have the parent application licensed in order to use the application. t_viewType must be a subclass of some other view type.")
("deUnInheritEnabling"
"deUnInheritEnabling( 
t_viewType 
) 
=> t / nil"
"Removes the inheritance of enabling for t_viewType.")
("deInheritMenus"
"deInheritMenus( 
t_viewType 
) 
=> t / nil"
"Causes t_viewType to inherit the menus defined by its parent class.")
("deUnInheritMenus"
"deUnInheritMenus( 
t_viewType 
) 
=> t / nil"
"Removes the inheritance of menus for t_viewType.")
("deRegProbeTrigger"
"deRegProbeTrigger( 
s_probeTrigger 
) 
=> t / nil"
"Registers a probe trigger, s_probeTrigger, to be called after creating a new window or installing a new design in an existing window.")
("deUnRegProbeTrigger"
"deUnRegProbeTrigger( 
)
=> t / nil"
"Removes the current probe trigger.")
("deGetProbeTrigger"
"deGetProbeTrigger( 
)
=> s_probeTrigger / nil"
"Returns the current probe trigger.")
("deGetAppInfo"
"deGetAppInfo( 
t_viewType 
) 
=> l_appInfo / nil"
"Returns the application registration information associated with t_viewType and its sub-view types.")
("deHiSetDefaultApplication"
"deHiSetDefaultApplication( 
)"
"Opens the Set Default Application form for the current cellview.")
("deSetWorkspace"
"deSetWorkspace( 
w_window
t_workspaceName
) 
=> t / nil"
"Sets a workspace name to a given window (as long as the workspace name is valid for that window).")
("deRegPlugin"
"deRegPlugin(
t_appName
s_className
s_superClass
[ ?appTitle t_appTitle ]
[ ?bindkeys l_bindkeys ]
[ ?group t_group ]
[ ?help t_help ]
[ ?pluggableMainApps g_pluggableMainApps ]
[ ?pluggableViewTypes l_pluggableViewTypes ]
[ ?shortDescription t_shortDescription ]
[ ?excludeViewTypes l_excludeViewTypes ]
)
=> l_appClassInfo"
"Registers the characteristics of plugins.")
("deInstallPlugin"
"deInstallPlugin(
w_windowID
S_plugin
)
=> stdobj / nil"
"Installs (or activates) the specified plugin in an application window associated with the given ID. For each session window, DE makes only one instance of a plugin. deInstallPlugin function installs a plugin in an application window. A session window can host multiple application windows. This means that if an instance of the plugin already exists in the specified window, the instance is returned. And, if there exists an instance in another tab of the same session window, the instance is shared.")
("deRemovePlugin"
"deRemovePlugin(
w_window
S_plugin
)
=> t / nil"
"Removes (or deactivates) the named plugin from the specified application window-session or tab window. If the ID is of a session window, the plugin is removed from all tab windows associated with the session window.")
("deFindPlugin"
"deFindPlugin(
S_plugin
g_window
)
=> stdobj / nil"
"Searches for and returns an instance of the specified plugin installed in the given application window")
("deBeginConfigurePlugins"
"deBeginConfigurePlugins(
w_window
)
=> nil"
"Lets applications issue a series of deInstallPlugin and deRemovePlugin calls to add or remove plugins in the specified application window. Using deBeginConfigurePlugins before adding or removing plugins helps in reducing calls to the hiApplyWinConfig SKILL function.

When deBeginConfigurePlugins is called, Design Editor postpones applying workspace in the specified application window until deEndConfigurePlugins is called in the same window.")
("deEndConfigurePlugins"
"deEndConfigurePlugins(
w_window
=> nil"
"Indicates an end to a series of calls for deInstallPlugin and deRemovePlugin marked by the deBeginConfigurePlugins in the same application window.")
("deFindAssistant"
"deFindAssistant(
t_assistant
w_sessionWindow
[ ?search_object_name { t | nil } ]
[ ?search_window_name { t | nil } ]
[ ?in_active_tab { t | nil } ]
)
=> w_dwindow / nil"
"Returns the dock window ID associated with the specified assistant name in the specified session window. By default, the function returns the assistant whose window name matches t_assistant in the currently active tab of w_sessionWindow. You can optionally widen the search to include object names in all tabs of the specified session window.")
("deGetPlugins"
"deGetPlugins(
w_window
[ g_activeOnly ]
)
=> l_stdobj / nil"
"Returns a list of all plugin instances installed in the given application window")
("deGetAppClassInfo"
"deGetAppClassInfo(
g_application
)
=> dpl_appClassInfo"
"Returns a copy of the registration information (DPL) associated with the given application")
("deoEnableTrigger"
"deoEnableTrigger(
g_application
[ l_args ]
)
=> t / nil"
"Determines if the application is enabled for use by the current user. The enable trigger will normally do any appropriate security checks necessary to make this determination. Design Editor calls the enable trigger before installing a plugin and then installs the plugin only if this trigger returns a non-nil value. The default deoEnableTrigger permits a plugin to be installed on top of an application as long as it is pluggable to the application.")
("deoExitTrigger"
"deoExitTrigger(
g_application
[ l_args ]
)
=> t / nil"
"When a plugin is being removed from a window, Design Editor calls the exit trigger before disabling all GUI components of the plugin and removes the plugin only if this trigger returns a non-nil value. The return value of the exit trigger is ignored if the window on which the plugin is installed is being closed. The default implementation is a no-op, and always returns t.")
("deoGetAssistantList"
"deoGetAssistantList(
g_application
)
=> l_assistNameandPlacement / nil"
"Returns a list of t_assistant_name and s_placement pairs (called an association list and contains a list of key and value pairs). The default implementation returns all assistants defined by this plugin and super-plugins.")
("deoGetBindkeys"
"deoGetBindkeys(
g_application
)
=> l_bindkeys / nil"
"Returns a copy of bindkeys defined for the plugin in the format that is acceptable by hiSetBindKeys(). When installing a plugin, DE calls hiSetBindKeys using the value of deoGetBindkeys method. A default implementation of deoGetBindkeys is provided by DE, which returns a list of bindkeys collectively defined by a plugin and its super-plugin(s) through deRegPlugin ?bindkeys argument. The bindkeys returned are ordered from generic to specific.")
("deoMenuTrigger"
"deoMenuTrigger(
g_application
l_args
)
=> l_menus"
"Returns a list of menus to be installed in the banner of a window. The menu trigger is called when the Design Editor installs and removes the plugin. Whenever there's an application switching event, deoMenuTrigger is called again for plugins that are pluggable to the application being switched into. For example, given a plugin whose pluggableViewTypes equals schematic, the plugin is pluggable to all schematic-based applications. So, if the plugin is currently installed in a VSE window then, if you launch VSE XL in the same window the menu trigger will be called again. Also push down, or return back into another schematic cell-view, the deoMenuTrigger is called again. The default deoMenuTrigger is a no-op. It returns args->bannerMenus as is.")
("deoOnTabSwitch"
"deoOnTabSwitch(
g_application
w_sessionWin
w_intoWin
g_outofWin
)
=> g_value"
"An event notification function called during HI calling post tab switch procedures. The order in which calls are made to all deoOnTabSwitch functions is not defined.")
("deoOnApplicationChange"
"deoOnApplicationChange(
g_application
l_args
)
=> g_value"
"An event notification function called when data or application changes in a window, such as when a user opens new data or installs a new application in a window, traverses down or up a design hierarchy, or opens another cellview. This function is called for all active plugins at the same time the DE change-application-trigger is called. The order in which calls are made to all deoOnApplicationChange functions is not defined.")
("deoPostInstallTrigger"
"deoPostInstallTrigger(
g_application
l_args
)
=> g_value"
"The post-install trigger is called after all other processing is done, including installation of banner menu, toolbar, assistant, bindkeys. This is provided for those applications that need to finish up any initialization that must occur after GUI is installed.")
("deoRequireToolbars"
"deoRequireToolbars(
g_plugin
)
=> l_toolbarNames"
"Returns a list of toolbar names (string) that are to be customized by the plugin. A plugin can customize toolbars of a main application, or those of another plugin. For a plugin to declare which toolbars need customization, re-define method deoRequireToolbars.")
("deoUpdateToolbar"
"deoUpdateToolbar(
g_plugin
t_name
o_toolbar
l_args
)
=> g_value"
"Customizes a toolbar that is requested by deoRequireToolbars. DE calls this method during installing and removing a plugin.")
("deoOnEvent"
"deoOnEvent(
g_app
s_event
@rest args
)"
"This event handler can be reimplemented in a subclass to receive various events.")
("deFileNew"
"deFileNew( 
) 
=> None"
"Opens the Create New File form.")
("deOpen"
"deOpen( 
[ l_fileSpec [ g_winSpec [ t_accessMode [ t_appName g_sessionWindow g_saveSessionHistory] ] ] ] 
) 
=> w_window / nil"
"Takes a design specification and a window specification and attempts to install the design in the specified window.")
("deFileOpen"
"deFileOpen( 
)
=> t / nil"
"Similar to deOpen(). Radio buttons on the Open form are displayed that allow selection between opening the cellview in a new tab, current tab, or a new window.")
("deNew"
"deNew( 
[ l_fileSpec ] 
[ g_winSpec ] 
[ t_accessMode ] 
[ t_appName ] 
) 
=> w_windowId / nil"
"Creates a new cellview and opens it in a window.")
("deNewCellView"
"deNewCellView( 
t_libName 
t_cellName 
t_viewName 
t_viewType 
g_winSpec 
)
=> w_windowId / nil"
"Creates a new cellview and opens it in a window.")
("deOpenCellView"
"deOpenCellView( 
t_libName 
t_cellName 
t_viewName 
t_viewType 
g_winSpec 
t_accessMode 
)
=> w_windowId / nil "
"Opens an existing cellview in a window.")
("deBack"
"deBack( 
[w_window [ numSteps] ] 
) 
=> w_window / nil"
"This API allows you to go back to a particular window event. It takes two optional integer arguments, w_window and numSteps. If deBack is called without any arguments it will open and display the cellview that was displayed prior to the current cellview in the current window.")
("deForward"
"deForward( 
[w_window [ numSteps] ] 
) 
=> w_window / nil"
"This API allows you to go forward to a particular window event. It takes two optional integer argument; w_window and numSteps. If the command is called without any arguments it will open and display the cellview that was displayed prior to the use of the last deBack command in the current window.")
("dePush"
"dePush( 
[ l_fileSpec [ g_winSpec [ t_accessMode [ t_appName ] ] ] ] 
) 
=> w_window / nil"
"The same as deOpen, except that if the window already exists, the current contents are not removed. Instead the new design is pushed on top of the existing one.")
("deSetHistoryOpenMode"
"deSetHistoryOpenMode( 
t_openMode
)
=> t / nil"
"Controls whether designs are opened from history in a new tab or a new window. The setting applies equally to opening a design from the CIW as well as from a session window.")
("deSwap"
"deSwap( 
[ l_fileSpec [ g_winSpec [ t_accessMode [ t_appName] ] ] ] 
) 
=> w_window / nil"
"This function is same as deOpen, except that if the window already exists, the current contents are not removed. Instead the current stack item is replaced with the new design.")
("deToggleAssistants"
"deToggleAssistants( 
[ w_sessionWindow ] ) 
=> t / nil"
"Toggles the visibility of the current assistants off or on to maximize the size of the design window.")
("deToggleAssistantVisibility"
"deToggleAssistantVisibility( 
t_assistantName
[ w_sessionWindow ]
) 
=> t / nil"
"Toggles the visibility of the given assistant in the given session window.")
("deToggleToolbars"
"deToggleToolbars( 
[ g_sessionWindow ] ) 
=> l_toolbar / nil"
"Toggles the currently visible toolbars off. If no visible toolbars are found, toggles the previously hidden toolbars on.")
("deFindToolbar"
"deFindToolbar( 
S_name
w_sessionWindow
)
=> o_instance / nil"
"Searches for and returns an instance of the specified toolbar installed in the given session window. This function also supports the Virtuoso design editor toolbars, such as Workspaces, Go, and Bookmarks.")
("deManageToolbar"
"deManageToolbar( 
w_sessionWindow
o_toolbar
[ g_appName ]
)
=> t / nil"
"Puts the toolbar handle on the given session window (under DE management) for the specified application. A managed toolbar is displayed as a menu item in Window-Toolbars and in the context menu of the session window.")
("deCustomizeToolbars"
"deCustomizeToolbars( 
[ ?app t_appName ]
[ ?toolbar t_toolbar ]
[ ?toolbarItem t_toolbarItem ]
)
=> t / nil"
"Invokes the Toolbar Manager graphical user interface for customizing toolbars in the Virtuoso environment.")
("deUnmanageToolbar"
"deUnmanageToolbar( 
w_sessionWindow
s_toolbar
[ g_appName ]
)
=> t / nil"
"Removes the toolbar from the given session window (under DE management) for the specified application. A toolbar should be removed using the deUnmanageToolbar function before it can be deleted.")
("deEditInPlace"
"deEditInPlace( 
w_window 
[ l_fileSpec [ t_accessMode [ t_appName ] ] ] 
) 
=> w_window / nil"
"Requires that w_window exists and has at least one stack element.")
("deReturn"
"deReturn( 
w_window [ x_level ] 
) 
=> x_level_new / nil"
"Pops the window stack one or more levels.")
("deCopy"
"deCopy( 
[ w_window [ g_winSpec ] ] 
) 
=> w_windowCopy / nil"
"Makes a complete copy of the given window, including its stack and the context data stored on it.")
("dataTrigger"
"dataTrigger( 
l_args 
) 
=> g_handle / nil"
"The data trigger is called after the DE has collected and verified all of the trigger arguments, checked for the proper application registration, and opened or validated a window for the design.")
("appTrigger"
"appTrigger( 
l_args 
) 
=> g_context / nil"
"The application trigger is responsible for any necessary banner setup (except for menus), installing the window popup menu, and other application-specific initialization. It is also responsible for managing the application context.")
("userAppTrigger"
"userAppTrigger( 
l_args 
) 
=> t / nil"
"After the application trigger is called, the user application trigger is called with the same argument list. The user application trigger allows clients to subclass existing application triggers, and thus add additional context to that already managed by the application. The user application trigger's return value is ignored, but should indicate t for success and nil for failure.")
("enableTrigger"
"enableTrigger( 
[ l_args ] 
)
=> t / nil"
"The enable trigger is a special routine loaded separately from the application context, normally by an autoload file.")
("menuTrigger"
"menuTrigger( 
l_args 
) 
=> l_menuList / nil"
"The menu trigger is called when an application is about to be installed as the current application in a window. At the time the menu trigger is called, all other triggers have already been called, and the window is about to be displayed (or if the window was a previously existing window, about to be refreshed).")
("userMenuTrigger"
"userMenuTrigger( 
l_args 
) 
=> l_menuList / nil"
"The user menu trigger is called just before the application menu trigger is called and performs the same function. This trigger allows the user to attach menus to an application. Although it is called prior to the application menu trigger, the menu list it returns is appended after the application menus.")
("postInstallTrigger"
"postInstallTrigger( 
l_args 
)
=> t / nil"
"The post-install trigger is called after all other processing is done, including installation of banner menus and the display of the window. It is available for applications to do any processing that cannot be done before this time, such as adding menu items to an existing menu.")
("userPostInstallTriggers"
"userPostInstallTrigger( 
l_args 
)
=> t / nil"
"Called immediately after the post-install trigger. It serves the same function but is intended for use only by the customer.")
("probeTrigger"
"probeTrigger( 
w_window 
s_action 
[ w_source ] 
) 
=> t / nil"
"The probe trigger is called when the Design Editor has installed a new design in a window, whether an existing one or a new one. It is also called when the window is closed. This trigger allows the probing mechanism to keep its data structures consistent without requiring each application to call it separately.")
("lbuiGetCheckedOutLicenses"
"lbuiGetCheckedOutLicenses( 
) 
=> l_list"
"Returns a list of the licenses consisting of each license feature name and the number of licenses (tokens) checked out.")
("lbuiPrintLicenseUseReport"
"lbuiPrintLicenseUseReport( 
[ ?products g_productID ]
[ ?filename ltx_fileName ]
)
=> g_report"
"Displays the license usage report (for example: user logins, host names, display time, number of licenses, and license version) in the CIW or the specified output log file.")
("iclicCheckOutAndLock"
"iclicCheckOutAndLock( 
t_feature 
) 
=> t_rfeature / nil"
"Checks out the specified layout license, layout option license, or an appropriate higher-tier license and locks it after successful checkout.")
("eliCheckOutAndLock"
"eliCheckOutAndLock( 
t_licenseName
) 
=> t / nil"
"Checks out and locks the specified license feature. Once the specified license feature is locked, it cannot be checked in until the session ends. Use this function in a scripted batch process to reduce runtime due to licensing.")
("deGetCellView"
"deGetCellView( 
[ w_window [ x_level ] ] 
) 
=> d_cellview / nil"
"Returns the cellview for the item on the window stack corresponding to x_level. A value of nil is returned if the stack is empty, x_level is not a valid stack level in w_window, or x_level is -1. If x_level is defaulted or nil then the current item on the stack is used.")
("deGetEditCellView"
"deGetEditCellView( 
[ w_window ] 
) 
=> d_cellview / nil"
"Returns the cellview for the item on the window stack corresponding to the current edit level. nil is returned if the stack is empty.")
("deSetCellView"
"deSetCellView( 
[ w_window [ d_cellview [ x_level ] ] ] 
) 
=> t / nil"
"Replaces the cellview for the current item on the window stack. nil is returned if the stack is empty. This routine is intended for use by data triggers executing the 'swap operation. It should never be called by an application outside of a data trigger.")
("deGetViewType"
"deGetViewType( 
w_window 
[ x_level ] 
) 
=> t_viewType / nil"
"Returns the view type of the item at x_level in w_window. nil is returned if the stack is empty. If x_level is not specified, the current level is assumed.")
("deGetEditViewType"
"deGetEditViewType( 
w_window 
) 
=> t_viewType / nil"
"Returns the t_viewType of the item at the current edit level in w_window.")
("deGetRootType"
"deGetRootType( 
[ w_window [ x_level ] ] 
) 
=> t_viewType / nil"
"Returns the root class t_viewType of the item at x_level in w_window. nil is returned if the stack is empty. If x_level is not specified, the current level is assumed.")
("deGetEditRootType"
"deGetEditRootType( 
[ w_window ] 
) 
=> t_viewType / nil"
"Returns the root class view type of the item at the current edit level in w_window.")
("deGetContext"
"deGetContext( 
[ w_window [ x_level ] ] 
) 
=> g_context / nil"
"Returns the context for the item on the window stack corresponding to x_level. A value of nil is returned if the stack is empty or x_level is -1. If x_level is not specified or is nil, the current item on the stack is used.")
("deGetEditContext"
"deGetEditContext( 
[ w_window ] 
) 
=> g_context / nil"
"Returns the context for the item on the window stack corresponding to the current edit level.")
("deIsEditInContext"
"deIsEditInContext( 
[ w_windowId ] 
)
=> t / nil "
"Tells whether the current edit cellview in the window is in the context of a Hierarchy Manager configuration.")
("deSetContext"
"deSetContext( 
[ w_window [ g_context [ x_level ] ] ] 
) 
=> t / nil"
"Replaces the context for the item at the specified level on the window stack. nil is returned if the stack is empty. This routine is intended for use by data triggers executing the 'swap operation. It should never be called by application code outside of a data trigger.")
("deGetMaxInContextLevel"
"deGetMaxInContextLevel( 
[ w_windowId ] 
) 
=> n_level "
"Gets the maximum level of the given window that is being edited in the context of the Hierarchy Manager configuration ID associated with the window. If the window has no configuration ID, 0 is returned.")
("deGetConfigId"
"deGetConfigId( 
[ w_windowId ] 
) 
=> g_hdbConfigId / nil "
"Gets the Hierarchy Manager configuration ID associated with the given window. ")
("deSetConfigId"
"deSetConfigId( 
w_windowId 
g_hdbConfigId 
) 
=> t / nil "
"Sets the Hierarchy Manager configuration ID associated with the given window. Also creates a path vector and sets the window path vector. If g_hdbConfigId is nil, the window path vector is destroyed, and the window configuration ID is set to nil. ")
("deGetVector"
"deGetVector( 
[ w_windowId ] 
) 
=> g_hdbPathVectorId / nil "
"Gets the Hierarchy Manager path vector associated with the given window. ")
("deGetEIP"
"deGetEIP( 
[ w_window [ x_level ] ] 
) 
=> t / nil"
"Returns the edit-in-place state for the item on the window stack corresponding to x_level. The edit-in-place state is t if that stack level was created by the deEditInPlace function and nil otherwise. f nil is returned if the stack is empty or x_level is -1. If x_level is not specified or is nil then the current item on the stack is used.")
("deGetPushed"
"deGetPushed( 
[ w_window [ x_level ] ] 
) 
=> t / nil"
"Returns the pushed state for the item on the window stack corresponding to x_level. The pushed state is t if that x_level is any level other than the current edit level and nil otherwise. nil is returned if the stack is empty or x_level is -1. If x_level is defaulted or is nil then the current item on the stack is used.")
("deGetProbeContext"
"deGetProbeContext( 
[ w_window ] 
)
=> g_probeContext / nil"
"Returns the probe context for the window.")
("deSetProbeContext"
"deSetProbeContext( 
[ w_window [ g_probeContext ] ] 
) 
=> t / nil"
"Sets the probe context for the window. This is normally executed only by the probing implementation in the probe trigger.")
("deGetEditLevel"
"deGetEditLevel( 
[ w_window ] 
) 
=> x_level / nil"
"Returns the current edit level of w_window. If the stack is empty, the routine returns -1. The current edit level is the level of the stack which is currently being displayed. This is normally the maximum edit level, unless deGoToLevel was executed.")
("deGetMaxEditLevel"
"deGetMaxEditLevel( 
[ w_window ] 
)
=> x_level / nil"
"Returns the highest edit level of w_window. If the stack is empty, returns -1.")
("deEnableApp"
"deEnableApp( 
w_window 
t_appName 
) 
=> t / nil"
"Enables the application registered with t_appName in w_window. It affects only the customizer menu in w_window. It is available to allow certain applications to be enabled depending on run-time state associated with a particular design.")
("deDisableApp"
"deDisableApp( 
w_window 
t_appName 
) 
=> t / nil"
"Enables the application registered with t_appName in w_window. It affects only the customizer menu in w_window. It is available to allow certain applications to be disabled depending on run-time state associated with a particular design.")
("deInstallApp"
"deInstallApp( 
w_window 
t_appName 
) 
=> t / nil"
"Switches the current application in w_window to t_appName. The enable trigger is called before switching, and if it returns nil, the switch is aborted. Otherwise, the application menus and bindkeys are installed as if the user had executed the corresponding customizer item.")
("deGetAllApplicationNames"
"deGetAllApplicationNames( 
t_rootViewType 
) 
=> l_app / nil"
"Returns a list of all applications that can be associated with the given root view type.")
("deGetAllRootTypes"
"deGetAllRootTypes( 
)
=> l_rootTypes / nil"
"Returns a list of all currently registered root view types.")
("deGetAllViewTypes"
"deGetAllViewTypes( 
)
=> l_viewTypes / nil"
"Returns a list of all fully registered view types and view sub types. Any view sub type for which some parent has not been registered will not appear in this list.")
("deGetRootViewTypeList"
"deGetRootViewTypeList( 
) 
=> l_rootViewTypes / nil"
"Returns a list of root view types, which have an associated tool as specified in the tool registry.")
("deMapUserTypeToViewType"
"deMapUserTypeToViewType( 
t_userType 
) 
=> t_viewType"
"Maps a user type to the dfII_viewType.")
("deMapViewTypeToUserType"
"deMapViewTypeToUserType( 
g_viewType 
) 
=> t_userType / nil"
"Maps the dfII_viewType to the user type.")
("deViewTypeIsRegistered"
"deViewTypeIsRegistered( 
t_viewType 
) 
=> t / nil "
"Returns a non-nil value if t_viewType is fully registered; that is, all ancestors up to and including the root type are currently registered.")
("deGetLowerTierApp"
"deGetLowerTierApp(
t_appName
[ x_lowerBy ]
)
=> l_lowertierAppNames"
"Returns a list of application names, which are x_lowerBy levels lower in tier in the same family of given t_appName. The default value for x_lowerBy is one.")