;SKILL Language Functions
("appendPath"
"appendPath( 
t_dirName1 ... [ t_dirNameN ]
) 
=> t_dirNameN / nil"
"Appends a new path to the end of the search path list. You can append as many paths as you want with this command.")
("path"
"path(
t_dirName1 ... [ t_dirNameN ]
) 
=> l_pathList / nil"
"Sets the search path for included files.")
("prependPath"
"prependPath(
t_dirName1 ... [ t_dirNameN ]
) 
=> undefined / nil"
"Adds a new path to the beginning of the search path list. You can add as many paths as you want with this command.")
("setup"
"setup(
[ ?numberNotation s_numberNotation ]
[ ?precision x_precision ]
[ ?reportStyle s_reportStyle ]
[ ?charsPerLine x_charsPerLine ] 
[ ?messageOn g_messageOn ] 
) 
=> t / nil"
"Specifies default values for parameters.")
("history"
"history(
[ x_number ] 
) 
=> t"
"Displays the command history. By default, it prints the last 20 commands from the current session and the most recently terminated session. More commands can be printed by giving a number as an argument.")
("ocnSetSilentMode"
"ocnSetSilentMode(
g_silentMode
) 
=> t"
"Filters out OCEAN warning and information  messages and allows only error messages to be written. This functionality is useful while running the OCEAN scripts when you might want to skip all OCEAN messages except errors.")
("ac"
"ac(
g_fromValue
g_toValue
g_ptsPerDec
) 
=> undefined / nil"
"Specifies an AC analysis.")
("analysis"
"analysis(
s_analysisType 
[ ?analysisOption1 g_analysisOptionValue1 ]... [ ?analysisOptionN g_analysisOptionValueN ]
) 
=> undefined / nil"
"Specifies the analysis to be simulated.")
;PREFORMATTED 7
;RESUME 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 7
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 8
;PREFORMATTED 9
;PREFORMATTED 9
;PREFORMATTED 9
;PREFORMATTED 9
;PREFORMATTED 9
;PREFORMATTED 9
;PREFORMATTED 9
("converge"
"converge( 
s_convName
t_netName1
f_value1 ... [ t_netNameN f_valueN ]
) 
=> undefined / nil"
"Sets convergence criteria on nets.")
("connectRules"
"connectRules(
t_ruleName
[ ?lib t_libName ] 
[ ?view t_viewName ] 
[ ?baseRule t_baseRule ]
[ ?moduleInfo l_moduleInfo ] 
[ ?resolutionInfo l_resolutionInfo ] 
[ ?commonParam l_commonParam ]
[ ?userDefined s_userDefined ]
)
=> t / nil"
"Sets connect rules for a given AMS OCEAN session required by the elaborator. To specify multiple connect rules, use this command multiple times. To add a connect rule to an OCEAN session, you can either choose a built-in rule from the connectLib library (by specifying t_ruleName, t_libName and t_viewName) or one of your own compiled built-in connect rules (by specifying t_ruleName, t_libName and t_viewName). To add a user defined connect rule to an OCEAN session specify s_userDefined. To modify an existing built-in rule, you need to specify t_baseRule (the name of the built-in rule that needs be modified), specify a new name (by specifying t_ruleName, t_libName and t_viewName) and also specify one or more of the optional arguments.")
("createFinalNetlist"
"createFinalNetlist(
) 
=> t / nil"
"Creates the final netlist for viewing purposes. The netlist also can be saved but is not required to run the simulator.")
("createNetlist"
"createNetlist(
[ ?recreateAll g_recreateAll ]
[ ?display g_display ] 
) 
=> t_filename / nil"
"Creates the simulator input file.")
("dc"
"dc( 
t_compName 
[ t_compParam ] 
g_fromValue
g_toValue
g_byValue 
) 
=> undefined / nil"
"Specifies a DC sweep analysis with limited options. If other analysis options are needed, use the analysis command.")
("definitionFile"
"definitionFile( 
t_fileName [ t_fileName2 ... t_fileNameN ]
) 
=> l_fileNames / nil"
"Specifies definitions files to be included in the simulator input file.")
("delete"
"delete( 
s_command 
[ g_commandArg1 ] [ g_commandArg2 ] ... 
) 
=> t / nil"
"Deletes all the information specified.")
("deleteOpPoint"
"deleteOpPoint"
"Deletes the specified operating point instance.")
("design"
"design( 
t_cktFile | t_lib t_cell t_view [ t_mode ] 
) 
=> t_cktFile / nil | (t_lib t_cell t_view) / nil"
"Specifies the directory path to the netlist of a design or the name of a design to be simulated.")
("desVar"
"desVar( 
t_desVar1 f_value1 ... [ t_desVarN f_valueN ]
) 
=> undefined / nil"
"Sets the values of design variables used in your design. You can set the values for as many design variables as you want.")
("discipline"
"discipline( 
g_discipline1 [ g_discipline2 ... ]
) 
=> t / nil"
"Adds discrete disciplines to the existing set of disciplines for a given 'ams' OCEAN session. You can use delete('discipline) to delete one or more specified disciplines. You can use ocnDisplay('discipline) to view the currently active disciplines in an OCEAN session.")
("displayNetlist"
"displayNetlist(
) 
=> t / nil"
"Displays the concatenated AMS complete design info file used in a given AMS OCEAN session. The concatenated file displays the cell-based netlisting of the cellviews used in the configuration along with the analog control file and the TCL file generated by AMS-ADE. This command is applicable for both solvers - Spectre and UltraSim.")
("envOption"
"envOption( 
s_envOption1 g_value1 ... [ s_envOptionN g_valueN ] 
) 
=> undefined / nil"
"Sets environment options.")
("evcdFile"
"evcdFile(
t_evcdFileName
) 
=> t_evcdFileName / nil"
"Sets an EVCD file for a given UltraSim OCEAN session. You also need to specify an EVCD info file while using this command. You can specify only one EVCD file for a session. You may use ocnDisplay('evcdFile) to view the currently active EVCD file.")
("evcdInfoFile"
"evcdInfoFile(
t_evcdInfoFileName 
) 
=> t_evcdInfoFileName / nil"
"Sets a EVCD info file for a given UltraSim OCEAN session. You also need to specify an EVCD file while using this command. You can specify only one EVCD info file for a session. You may use ocnDisplay('evcdInfoFile) to view the currently active EVCD info file.")
("forcenode"
"forcenode( 
t_netName1 f_value1 ... [ t_netNameN f_valueN ] 
) 
=> undefined / nil"
"Holds a node at a specified value.")
("globalSigAlias"
"globalSigAlias(
g_signalList1 [ g_signalList2 ... ]
) 
=> t / nil"
"Removes all the previous signal aliases and creates the specified aliases. The signal names in each of the signal lists are marked as aliases of each other. Each of the signal lists is a set of signal names that are to be aliased. The signal names should match the names that were specified using the globalSignal command. To unalias all signal, pecify nil instead of signal lists.")
("globalSignal"
"globalSignal( 
[ ?name t_signalName ] 
[ ?lang t_langName ] 
[ ?wireType t_wireType ] 
[ ?discipline t_discipline ]
[ ?ground t_ground ]
@Rest args
) 
=> t / nil"
"Adds or modifies a global signal for a given AMS OCEAN session needed by the elaborator. If the global signal already exists in the session, the values are updated. If it does not exist, a global signal with the specified name is added. In case of a vector signal, the range information can be appended with the name of the signal.")
("ic"
"ic( 
t_netName1 f_value1 ... [ t_netNameN f_valueN ] 
) 
=> undefined / nil"
"Sets initial conditions on nets in a transient analysis.")
("includeFile"
"includeFile(
t_fileName 
)
=> t_fileName / nil"
"Includes the specified file in the final netlist of the simulator for the current session.")
("modelFile"
"modelFile( 
[ g_modelFile1 [ g_modelFile2 ... ] ] 
) 
=> l_modelFile"
"Specifies model files to be included in the simulator input file.")
("nodeset"
"nodeset( 
t_netName1 f_value1 ... [ t_netNameN f_valueN ]
) 
=> undefined / nil"
"Sets the initial estimate for nets in a DC analysis, or sets the initial condition calculation for a transient analysis.")
("noise"
"noise( 
t_output 
t_source
)
=> undefined / nil"
"Specifies a noise analysis.")
("ocnCloseSession"
"ocnCloseSession(
)
=> t / nil"
"Closes the current OCEAN session without saving any settings made during the session. The command has no effect if no session is currently active.")
("ocnDisplay"
"ocnDisplay(
[ ?output t_filename | p_port ] 
s_command
[ g_commandArg1 ] [ g_commandArg2 ] ... 
) 
=> t / nil"
"Displays all the information specified.")
("ocnDspfFile"
"ocnDspfFile( 
t_dspfFile [ t_dspfFile1 ... t_dspfFileN ] 
) 
=> t_dspfFile(s) / nil"
"Sets the parasitic (dspf, spf) files to be used in a Spectre OCEAN session. You can use this command to specify a list of parasitic files to be included in the control file. You can use ocnDisplay('dspfFile) to view the currently active parasitic (dspf, spf) files in an OCEAN session.")
("ocnSpefFile"
"ocnSpefFile( 
t_SpefFile [ t_SpefFile1 ... t_SpefFileN ]
) 
=> t_SpecFile(s) / nil"
"Sets the parasitic (spef) files to be used in a Spectre OCEAN session. You can use this command to specify a list of parasitic files to be included in the control file. You can use ocnDisplay('SpefFile) to view the currently active parasitic (spef) files in an OCEAN session.")
("ocnPspiceFile"
"ocnPspiceFile( 
t_PSpiceFile
[ t_PSpiceFile1 ... t_PSpiceFileN ]
) 
=> t_PSpiceFile(s) / nil"
"Sets the PSpice files to be used in  a Spectre OCEAN session. Use this command to specify a list of PSpice files to be included in the control file.")
("ocnGetAdjustedPath"
"ocnGetAdjustedPath( 
t_libName
t_cellName 
t_viewName 
t_netName ) 
=> t_adjustedPath / nil"
"Reduces the given hierarchical net path to the shortest hierarchical name that is equivalent to this net.")
("ocnGetInstancesModelName"
"ocnGetInstancesModelName(
[ l_instance ]
) 
=> l_instance / nil"
"This function returns the model name used by the instance in opened simulation results.")
("off"
"off( 
s_command
[ g_commandArg1 ] [ g_commandArg2 ]
) 
=> t / nil"
"Turns off the specified information.")
("option"
"option( 
[ ?categ s_categ ]
s_option1 g_value1 [ s_option2 g_value2 ] ... ) 
=> undefined / nil"
"Specifies the values for built-in simulator options. You can specify values for as many options as you want.")
("restore"
"restore( 
s_analysisType
t_filename 
) 
=> undefined / nil"
"Tells the simulator to restore the state previously saved to a file with a store command.")
("resultsDir"
"resultsDir(
t_dirName 
) 
=> undefined / nil"
"Specifies the directory where the PSF files (results) are stored.")
;PREFORMATTED 64
;RESUME 64
("run"
"run(
[ ?jobName t_jobName ] 
[ ?drmsCmd t_drmsCmd ])
=> s_jobName / nil"
"Starts the simulation or specifies a time after which an analysis should start. If distributed processing is not available on the system or is not enabled, the arguments specific to distributed processing (see Arguments section below for list of arguments specific to distributed processing) are ignored and the simulation runs locally. If distributed processing is available and is enabled, the environment default values are used if not specified in the run command arguments. The environmental default values are stored in the .cdsenv file.")
("save"
"save(
[ ?categ s_categ ] s_saveType 
[ t_saveName1 ] ... [ t_saveNameN ] 
) 
=> undefined / nil"
"Specifies the outputs to be saved and printed during simulation.")
("saveOpPoint"
"saveOpPoint"
"Specifies the operating point parameters to be saved for a given instance.")
("saveOption"
"saveOption(
[ s_option1 g_optionValue1 ]...[ s_optionN g_optionValueN ]
)
=> undefined / nil"
"Specifies save options to be used by the simulator.")
;PREFORMATTED 74
;RESUME 74
("simulator"
"simulator( 
s_simulator
)
=> s_simulator / nil"
"Starts an OCEAN session and sets the simulator name for that session. The previous session (if any) is closed and all session information is cleared.")
("solver"
"solver( 
s_solver
)
=> s_solver / nil"
"Sets a solver for a given AMS OCEAN session. The valid values for solver are Spectre and UltraSim. You select Spectre if you want to use an accurate AMS-Spectre analog engine. You select UltraSim if you want to use the AMS-Ultrasim or FastSPICE(UltraSim) solver for a given AMS simulation.")
("stimulusFile"
"stimulusFile(
t_fileName [ t_fileName2 ... t_fileNameN ]
[ ?xlate g_xlate ]
) 
=> l_fileNames / nil"
"Specifies stimulus files to be used by the simulator.")
("store"
"store( 
s_analysisType 
t_filename
) 
=> t_filename / nil"
"Requests that the simulator store its node voltages to a file.")
("temp"
"temp( 
f_tempValue
) 
=> s_tempValue / nil"
"Specifies the circuit temperature.")
("tran"
"tran( 
g_fromValue
g_toValue
g_byValue
) 
=> g_byValue / nil"
"Specifies a transient analysis with limited options. If other analysis options are needed, use the analysis command.")
("vcdFile"
"vcdFile(
t_vcdFileName 
) 
=> t_vcdFileName / nil"
"Sets a VCD file for a given AMS or UltraSim OCEAN session. You also need to specify a VCD info file while using this command. You can specify only one VCD file for a session. You may use ocnDisplay('vcdFile) to view the currently active VCD file.")
("vcdInfoFile"
"vcdInfoFile(
t_vcdInfoFileName
) 
=> t_vcdInfoFileName / nil"
"Sets a VCD info file for a given AMS or UltraSim OCEAN session when you have set UltraSim as the solver. You also need to specify a VCD file while using this command. You can specify only one VCD info file for a session. You may use ocnDisplay('vcdInfoFile) to view the currently active VCD info file.")
("vecFile"
"vecFile( 
t_vecFile [ t_vecFile1 ... t_vecFileN ]
) 
=> t_vecFile(s) / nil"
"Sets the vector files to be used in an AMS or UltraSim OCEAN session. You use the vecFile command to specify a list of vector files which go to control file. You may use ocnDisplay('vecFile) to view the currently active vector files in an OCEAN session.")
("hlcheck"
"hlcheck(
t_value 
)
=> t / nil"
"Sets or gets the value of the hlcheck option used in the vec_include statement in a netlist. You may use the ocnDisplay('hlcheck) command to view the current value of hlcheck in an OCEAN session associated with vector files.")
("ocnAmsSetOSSNetlister"
"ocnAmsSetOSSNetlister(
)
=> t / nil"
"Sets the netlister mode to OSS-based for a given ams OCEAN session.")
("ocnAmsSetUNLNetlister"
"ocnAmsSetUnlNetlister(
)
=> t / nil"
"Sets the netlister mode to AMS Unified Netlister for a given ams OCEAN session.")
("dataTypes"
"dataTypes(
) 
=> l_dataTypes / nil"
"Returns the list of data types that are used in an analysis previously specified with selectResult.")
("deleteSubckt"
"deleteSubckt(
t_name
)
=> t / nil"
"Deletes the specified subcircuit instance saved using the saveSubckt command.")
("displaySubckt"
"displaySubckt(
t_args
t_outPort
)
=> t / nil"
"Prints the subcircuit information to the output file.")
("getData"
"getData(
t_name 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] )
=> x_number / o_waveform / nil"
"Returns the number or waveform for the signal name specified.")
("getResult"
"getResult (
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ]
) 
=> o_results / nil"
"Gets the data object for a specified analysis without overriding the status of any previously executed selectResult() or openResults() commands.")
("i"
"i( 
t_component
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> o_waveform / nil"
"Returns the current through the specified component.")
("ocnHelp"
"ocnHelp( 
[ ?output t_filename | p_port ]
[ s_command ]
) 
=> t / nil"
"Provides online help for the specified command.")
("ocnResetResults"
"ocnResetResults(
)
=> t"
"Unsets the results opened by the openResults command. Use this command to return to the state that existed prior to using the openResults command.")
("openResults"
"openResults( 
s_jobName | t_dirName 
[ g_enableCalcExpressions ] 
) 
=> t_dirName / nil"
"Opens simulation results stored in PSF files or opens the results from a specified job, depending on which parameter is called.")
("outputParams"
"outputParams(
t_compType 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
)
=> l_outputParams / nil"
"Returns the list of output parameters for the specified component.")
("outputs"
"outputs(
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
[ ?type t_signalType ]
) 
=> l_outputs / nil"
"Returns the names of the outputs whose results are stored for an analysis. You can plot these outputs or use them in calculations.")
("phaseNoise"
"phaseNoise(
g_harmonic S_signalResultName 
[ ?result s_noiseResultName [ ?resultsDir t_resultsDir ] ]
) 
=> o_waveform / nil"
"Returns the phase noise waveform which is calculated using information from two PSF data files.")
("pv"
"pv( 
t_name
t_param 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> g_value / nil"
"Returns the value of the specified component parameter. You can use the outputParams command to get the list of parameters for a particular component.")
("resultParam"
"resultParam( 
S_propertyName 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> L_value / nil"
"Returns the value of a header property from the selected result data.")
("results"
"results(
[ ?resultsDir t_resultsDir ] 
) 
=> l_results / nil"
"Returns a list of the type of results that can be selected.")
("saveSubckt"
"saveSubckt(
t_name
[ ?voltage g_voltage ]
[ ?current g_current ]
[ ?power g_power ] 
[ ?vDepth s_vDepth ]
[ ?iDepth s_iDepth ]
[ ?pwrDepth s_pwrDepth ]
[ ?compress g_compress ]
[ ?filterRC g_filterRC ]
[ ?ports g_ports ]
[ ?userOptions g_userOptions ]
)
=> t / nil"
"Saves and modifies the specified subcircuit instances and signals.")
("selectResult"
"selectResult(
S_resultsName 
[ n_sweepValue ]
) 
=> o_results / nil"
"Selects the results from a particular analysis whose data you want to examine.")
("sp"
"sp( 
x_iIndex 
x_jIndex 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ]
) 
=> o_waveform / nil"
"Returns S-parameters for N port networks.")
("sprobeData"
"sprobeData( 
t_ana 
t_sprobeInst 
[ ?type t_type ] 
[ ?dataDir t_dataDir ] 
) 
=> o_waveform / nil"
"Returns the waveform for the specified analysis and parameter type of the given sprobe instance.")
("sweepNames"
"sweepNames( 
[ o_waveForm ] 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] ) 
=> l_sweepName / nil"
"Returns the names of all the sweep variables for either a supplied waveform, a currently selected result (via selectResult()) or a specified result.")
("sweepValues"
"sweepValues( 
[ o_waveForm ]
) 
=> l_sweepValues / nil"
"Returns the list of sweep values of the outermost sweep variable of either the selected results or the supplied waveform. This command is particularly useful for parametric analyses.")
("sweepVarValues"
"sweepVarValues(
[ t_varName ]
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ]
)
=> l_sweepName / nil"
"Returns the list of sweep values for a particular swept variable name. This command is particularly useful for parametric analyses.")
("v"
"v( 
t_net
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> o_waveform / nil"
"Returns the voltage of the specified net.")
("vswr"
"vswr(
x_index 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> o_waveform / nil"
"Computes the voltage standing wave ratio.")
("zm"
"zm(
x_index 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
) 
=> o_waveform / nil"
"Computes the port input impedance.")
("zref"
"zref( 
x_portIndex
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ]
) 
=> f_impedance / nil"
"Returns the reference impedance for an N-port network.")
("addSubwindow"
"addSubwindow() 
=> x_subwindowID / nil"
"Adds a subwindow to the current Waveform window and returns the number for the new subwindow, which is found in the upper right corner.")
("addSubwindowTitle"
"addSubwindowTitle( 
x_windowtitle
) 
=> t / nil"
"Adds a title to the current subwindow in the active window. The current subwindow is defined using the currentSubwindow command.")
("addTitle"
"addTitle( 
x_windowtitle
) 
=> t / nil"
"Adds a title to the current active OCEAN window. The current window is defined using the currentWindow command.")
("addWaveLabel"
"addWaveLabel( 
x_waveIndex 
l_location 
t_label 
[ ?textOffset g_textOffset ] 
[ ?color x_color ]
[ ?justify t_justify ] 
[ ?fontStyle t_fontStyle ] 
[ ?height x_height ] 
[ ?orient t_orient ]
[ ?drafting g_drafting ] 
[ ?overBar g_overbar ]) 
=> s_labelId / nil"
"Attaches a label to the specified waveform curve in the current subwindow.")
("addWindowLabel"
"addWindowLabel(
l_location 
t_label
) 
=> s_labelId / nil"
"Displays a label in the current subwindow. The location for the label is specified with a list of two numbers between 0 and 1.")
("clearAll"
"clearAll() 
=> t / nil"
"Erases the contents of the current Waveform window and deletes the waveforms, title, date stamp, and labels stored in internal memory.")
("clearSubwindow"
"clearSubwindow() 
=> t / nil"
"Erases the contents of the current subwindow.")
("currentSubwindow"
"currentSubwindow( 
[ ?x_subwindow x_subwindow ]
) 
=> t / nil"
"Sets x_subwindow as the current subwindow.")
("currentWindow"
"currentWindow(
w_windowId 
) 
=> w_windowId / nil"
"Specifies w_windowId as the current Waveform window.")
("dbCompressionPlot"
"dbCompressionPlot(
o_wave 
x_harmonic
x_extrapolationPoint 
[ ?compression x_compression ] 
) 
=> t / nil"
"Plots the nth compression point plot. The x_compression argument is optional and defaults to 1 for 1dB compression, if omitted.")
("dcmatchSummary"
"dcmatchSummary(
[ ?resultsDir t_resultsDir ]
[ ?result S_resultName ] 
[ ?output t_fileName | p_port ] 
[ ?paramValues ln_paramValues ] 
[ ?deviceType ls_deviceType ]
[ ?variations ls_variations ] 
[ ?includeInst lt_includeInst ] 
[ ?excludeInst lt_excludeInst ] 
[ ?truncateData n_truncateData ]
[ ?truncateType s_truncateType ] 
[ ?sortType ls_sortType ]
) 
=> t_fileName / p_port/ nil"
"Prints a report showing the mismatch contribution of each component in a circuit. If you specify a directory with resultsDir, it is equivalent to temporarily using the openResults command. The dcmatchSummary command prints the results for that directory and resets the openResults command to its previous setting. If you specify a particular result with resultName, it is equivalent to temporarily using the selectResult command on the specified results. The dcmatchSummary command prints the results and resets the selectResult command to its previous setting.")
("deleteSubwindow"
"deleteSubwindow() 
=> t / nil"
"Deletes the current subwindow from the current Waveform window.")
("deleteWaveform"
"deleteWaveform(
{ x_index | all_string } 
) 
=> t / nil"
"Deletes the specified waveform curve or all the waveform curves from the current subwindow of a Waveform window.")
("displayMode"
"displayMode( 
t_mode
) 
=> t / nil"
"Sets the display mode of the current subwindow.")
("getAsciiWave"
"getAsciiWave( 
t_filename
x_xColumn 
x_yColumn 
[ ?xskip x_x_skip ]
[ ?yskip x_yskip ]
[ ?formatFloat g_formatFloat ]
[ ?xName t_xName ]
[ ?xUnits t_xUnits ]
[ ?yName t_yName ]
[ ?yUnits t_yUnits ]
)
=> o_wave / nil"
"Reads in an ASCII file of data and generates a waveform object from the specified data. The X-axis data must be real numbers. The Y-axis data can be real or complex values. Complex values are represented as (real imag) or complex(real imag). This function skips blank lines and comment lines. Comments are defined as lines beginning with a semicolon.")
("graphicsOff"
"graphicsOff() 
=> t / nil"
"Disables the redrawing of the current Waveform window.")
("graphicsOn"
"graphicsOn() 
=> t / nil"
"Enables the redrawing of the current Waveform window.")
("hardCopy"
"hardCopy(
w_windowId
) 
=> t / nil"
"Sends a Waveform window plot to a printer or a file. To plot to a printer specify a printer name using the ?hcPrinterName argument of the hardCopyOptions command. To plot to a file, specify a file name using the ?hcOutputFile argument of the hardCopyOptions command.")
("hardCopyOptions"
"hardCopyOptions( 
[ ?hcCopyNum x_hcCopyNum ]
[ ?hcOffsetHeight x_hcOffsetHeight ] 
[ ?hcOffsetWidth x_hcOffsetWidth ]
[ ?hcOrientation s_hcOrientation ]
[ ?hcOutputFile g_hcOutputFile ]
[ ?hcPrinterName s_hcPrinterName ] 
[ ?hcTmpDir t_hcTmpDir ]
[ ?hcPaperSize s_hcPaperSize ]
[ ?hcMakeExactCopy g_hcMakeExactCopy ]
[ ?hcQuality x_hcQuality ]
[ ?hcOptimizeForWindows g_hcOptimizeForWindows ]
[ ?hcImageWidth x_hcImageWidth ]
[ ?hcImageHeight x_hcImageHeight ]
[ ?hcImageSizeUnits s_hcImageSizeUnits ]
[ ?hcImageResolution x_ImageResolution ]
[ ?hcResolutionUnits s_hcResolutionUnits ]
[ ?hcImageAspectRatio x_hcImageAspectRatio ]
[ ?hcUseExistingBackground g_hcUseExistingBackground ]
[ ?hcDisplayTitle g_hcDisplayTitle ]
[ ?hcDisplayLegend g_hcDisplayLegend ]
[ ?hcDisplayAxes g_hcDisplayAxes ]
[ ?hcDisplayGrids g_hcDisplayGrids ]
[ ?hcSaveEachSubwindowSeparately g_hcSaveEachSubwindowSeparately ]
)
=> g_value / nil"
"Sets the graph window hardcopy plotting options.")
("ip3Plot"
"ip3Plot( 
o_wave
x_sigHarmonic
x_refHarmonic 
x_extrapolationPoint 
) 
=> t / nil"
"Plots the IP3 curves.")
("newWindow"
"newWindow() 
=> w_windowID / nil"
"Creates a new Waveform window and returns the window ID.")
("noiseSummary"
"noiseSummary(
s_type 
[ ?result s_resultName [ ?resultsDir t_resultsDir ] ] 
[ ?frequency f_frequency ] 
[ ?weight f_weight ]
[ ?output t_fileName | p_port ]
[ ?noiseUnit t_noiseUnit ]
[ ?truncateData x_truncateData ]
[ ?truncateType s_truncateType ] 
[ ?digits x_digits ] 
[ ?percentDecimals x_percentDecimals ]
[ ?from f_from ]
[ ?to f_to ] 
[ ?deviceType ls_deviceType ] 
[ ?weightFile t_weightFile ] 
[ ?paramValues ls_paramValues ]
[ ?hierLevel s_hierLevel ]
[ ?sort ls_sort ]
[ ?includeInsts ls_includeInsts ]
[ ?excludeInsts ls_excludeInsts ]
[ ?combineIteratedInsts g_combineIteratedInsts ]
[ ?suffixNotation t_suffixNotation ]
) 
=> t / nil"
"Prints a report showing the noise contribution of each component in a circuit.")
;PREFORMATTED 40
;RESUME 40
;PREFORMATTED 40
;RESUME 40
("ocnGenNoiseSummary"
"ocnGenNoiseSummary(
x_hierLevel
s_resultName
t_resultsDir
)
=> t / nil"
"Generates a noise summary report at the end of a simulation run. This report contains a summary of noise contribution of each component for the specified hierarchy level.")
("ocnPrint"
"ocnPrint( 
[ ?output t_filename | p_port ]
[ ?precision x_precision ] 
[ ?numberNotation s_numberNotation ] 
[ ?numSpaces x_numSpaces ] 
[ ?width x_width ] 
[ ?from x_from ] 
[ ?to x_to ] 
[ ?step x_step ]
[ ?linLog t_linLog ] 
o_waveform1 [ o_waveform2 ... ] 
) 
=> t / nil"
"Prints the text data of the waveforms specified in the list of waveforms.")
("ocnPrintTMIReliabilityResults"
"ocnPrintTMIReliabilityResults(
t_psfdir 
[ ?resultType t_resultType ]
[ ?threshold t_threshold ]
[ ?exportFile t_exportFilePath ]
[ ?sortRule  t_sortRule ]
) t / nil"
"Prints simulation results for reliability analysis run in the OCEAN mode.")
("ocnPrintTMIResultTypeList"
"ocnPrintTMIResultTypeList(
t_psfdir 
[ ?netlistFilePreName t_prefixOfNetlistFile ]
) t_resultTypes / nil"
"Returns a list of valid result types.")
("ocnSetAttrib"
"ocnSetAttrib( 
[ ?XAxisLabel xLabel ] 
[ ?YAxisLabel yLabel ] 
[ ?XScale xscale ] 
[ ?YScale yscale ] 
[ ?XLimit xlimit ] 
[ ?YLimit ylimit ]
[ ?YRange yrange ]
[ ?Origin origin ] 
)
=> t / nil"
"Sets the waveform window plotting attributes.")
("ocnWriteLsspToFile"
"ocnWriteLsspToFile(
filename t_filename 
net1 input_node_name 
term1 input_src_terminal 
net2 output_node_name 
term2 output_src_terminal
[ ?format t_format ]
[ ?datafmt t_data_format ]
[ ?port1 port1_name ]
[ ?port2 port2_name ]
[ ?result1 result1_name ]
[ ?result2 result2_name ]
)
=> nil"
"Writes the large signal S-Parameter results to a file in Touchstone or Spectre format.")
("ocnYvsYplot"
"ocnYvsYplot(
[ ?wavex o_wavex ?wavey o_wavey ]
[ ?exprx o_exprx ?expry o_expry ]
[ ?titleList l_titleList ]
[ ?colorList l_colorList ]
) 
=> wave / nil"
"Plots a wave against another wave or an expression against another expression.")
("plot"
"plot(
o_waveform1 [ o_waveform2 ... ] 
[ ?expr l_exprList ]
[ ?strip x_stripNumber ] 
) 
=> t / nil"
"Plots waveforms in the current subwindow. If there is no Virtuoso Visualization and Analysis XL window, this command opens one.")
("plotStyle"
"plotStyle( 
S_style 
) 
=> t / nil"
"Sets the plotting style for all the waveforms in the current subwindow.")
("printGraph"
"printGraph( 
[ ?window x_window ]
[ ?printerName s_hcPrinterName ]
[ ?horizontalMargin x_horizontalMargin ]
[ ?verticalMargin x_verticalMargin ]
[ ?numCopy x_numCopy ]
[ ?paperSize x_paperSize ]
[ ?orientation s_orientation ]
[ ?fileName s_fileName ]
[ ?tempDir s_tempDir ]
[ ?matchWindow g_matchWindow ]
[ ?numGraphsPerPage x_numGraphsPerPage ]
[ ?printMarkerTable g_printMarkerTable ]
[ ?markerTableLocation s_markerTableLocation ]
[ ?enableHeader g_enableHeader ]
[ ?enableFooter g_enableFooter ]
[ ?headerLeftText s_headerLeftText ]
[ ?headerCenterText s_headerCenterText ]
[ ?headerRightText s_headerRightText ]
[ ?footerLeftText s_footerLeftText ]
[ ?footerCenterText s_footerCenterText ]
[ ?footerRightText s_footerRightText ]
[ ?printColor g_printColor ]
[ ?doubleSidedPrint g_doubleSidedPrint ]
[ ?duplexMode s_duplexMode ]
[ ?pageOrder s_pageOrder ]
)
=> t / nil"
"Prints the graph plotted in the specified window.")
("pzFrequencyAndRealFilter"
"pzFrequencyAndRealFilter(
o_wave 
[ ?freqfilter f_fval ]
[ ?realfilter f_rval] )
=> o_waveform / nil"
"Returns a filtered Pole or Zero waveform from the pole zero simulation data. Filtering is done on the basis of given maximum frequency and minimum real value.")
("pzPlot"
"pzPlot( 
[ ?resultsDir t_resultsDir ] 
[ ?result S_resultName ] 
[ ?plot S_toPlot ]
[ ?freqfilter f_fval ] 
[ ?realfilter f_rval ])
=> t / nil"
"Plots a report showing the poles and zeros of the network. If you specify a directory with resultsDir, the pzPlot command plots the results for that directory. The S_toPlot option can be used to plot only poles, only zeros or both poles and zeros information.")
("pzSummary"
"pzSummary( 
[ ?resultsDir t_resultsDir ] 
[ ?result S_resultName ] 
[ ?print S_toPrint ] 
[ ?freqfilter f_fval ] 
[ ?realfilter f_rval ] 
[ ?output t_output]
) 
=> t / nil"
"Prints a report with the poles and zeros of the network. If you specify a directory with resultsDir, the pzSummary command prints the results for that directory. Use the S_toPrint option to print only poles, only zeros or both poles and zeros information.")
("removeLabel"
"removeLabel(
l_id 
) 
=> t / nil"
"Removes the label, or all the labels identified in a list, from the current subwindow.")
("report"
"report(
[ ?output t_filename | p_port ] 
[ ?type t_type ]
[ ?name t_name ] 
[ ?param t_param ]
[ ?format s_reportStyle ]
[ ?report s_reportStyle ]
[ ?maxLineWidth charsPerLine ]
) 
=> t / nil"
"Prints a report of the information contained in an analysis previously specified with selectResult.")
("saveGraphImage"
"saveGraphImage( 
[ ?window x_window ]
[ ?fileName x_fileName ]
[ ?exactCopy g_exactCopy ]
[ ?quality x_quality ]
[ ?msOptimize g_msOptimize ]
[ ?width x_width ]
[ ?height x_height ]
[ ?units s_units ]
[ ?resolution x_resolution ]
[ ?resolutionUnits s_resolutionUnits ]
[ ?aspectRatio g_aspectRatio ]
[ ?enableTitle g_enableTitle ]
[ ?enableLegend g_enableLegend ]
[ ?enableAxes g_enableAxes ]
[ ?enableGrids g_enableGrids ]
[ ?backgroundColor s_backgroundColor ]
[ ?saveAllSubwindows g_saveAllSubwindows ]
[ ?saveEachSubwindowSeparately g_saveEachSubwindowSeparately ]
)
=> x_fileName / nil"
"Saves the graph as an image.")
("xLimit"
"xLimit( 
l_minMax 
) 
=> t / nil"
"Sets the X axis display limits for the current subwindow. This command does not take effect if the display mode is set to smith.")
("yLimit"
"yLimit(
l_minMax
[ ?stripNumber x_stripNumber ]
) 
=> t / nil"
"Sets the Y axis display limits for the waveforms associated with a particular Y axis and strip in the current subwindow.")
("vm"
"vm( t_net [?resultsDir t_resultsDir][?result s_resultname]) => o_waveform/nil"
"Aliased to mag(v()). Gets the magnitude of the voltage of a net.")
("vdb"
"vdb( t_net [?resultsDir t_resultsDir][?result s_resultname]) => o_waveform/nil"
"Aliased to db20(v()). Gets the power gain in decibels from net in to net out.")
("vp"
"vp( t_net [?resultsDir t_resultsDir][?result s_resultname]) => o_waveform/nil"
"Aliased to phase(v()). Gets the phase of the voltage of a net.")
("vr"
"vr( t_net [?resultsDir t_resultsDir][?result s_resultname]) => o_waveform/nil"
"Aliased to real(v()). Gets the real part of a complex number representing the voltage of a net.")
("vim"
"vim( t_net [?resultsDir t_resultsDir][?result s_resultname]) => o_waveform/nil"
"Aliased to imag(v()). Gets the imaginary part of a complex number representing the voltage of a net.")
("im"
"im( t_component [?resultsDir t_resultsDir][?result s_resultName]) => o_waveform/nil"
"Aliased to mag(i()). Gets the magnitude of the AC current through a component.")
("ip"
"ip( t_component [?resultsDir t_resultsDir][?result s_resultName]) => o_waveform/nil"
"Aliased to phase(i()). Gets the phase of the AC current through a component.")
("ir"
"ir( t_component [?resultsDir t_resultsDir][?result s_resultName]) => o_waveform/nil"
"Aliased to real(i()). Gets the real part of a complex number representing the AC current through a component.")
("iim"
"iim( t_component [?resultsDir t_resultsDir][?result s_resultName]) => o_waveform/nil"
"Aliased to imag(i()). Gets the imaginary part of a complex number representing the AC current through a component.")
("abs"
"abs( 
n_number
) 
=> n_result"
"Returns the absolute value of a floating-point number or integer.")
("acos"
"acos( n_number
) 
=> f_result"
"Returns the arc cosine of a floating-point number or integer.")
("add1"
"add1( 
n_number 
) 
=> n_result"
"Adds 1 to a floating-point number or integer.")
("asin"
"asin( 
n_number 
) 
=> f_result"
"Returns the arc sine of a floating-point number or integer.")
("atan"
"atan( 
n_number
) 
=> f_result"
"Returns the arc tangent of a floating-point number or integer.")
("cos"
"cos( 
n_number
) 
=> f_result"
"Returns the cosine of a floating-point number or integer.")
("exp"
"exp( 
n_number 
) 
=> f_result"
"Raises e to a given power.")
("int"
"int( 
n_arg
) 
=> x_result"
"Returns the largest integer not larger than the given argument.")
("linRg"
"linRg(
n_from n_to n_by 
) 
=> l_range / nil"
"Returns a list of numbers in the linear range from n_from to n_to incremented by n_by.")
("log"
"log( 
n_number
) 
=> f_result"
"Returns the natural logarithm of a floating-point number or integer.")
("logRg"
"logRg(
n_from n_to n_by 
) 
=> l_range / nil"
"Returns a list of numbers in the log10 range from n_from to n_to advanced by n_by.")
("max"
"max( 
n_num1 n_num2 [ n_num3 ... ] 
) 
=> n_result"
"Returns the maximum of the values passed in. Requires a minimum of two arguments.")
("min"
"min(
n_num1 n_num2 [ n_num3 ... ] 
) 
=> n_result"
"Returns the minimum of the values passed in. Requires a minimum of two arguments.")
("mod"
"mod( 
x_integer1 
x_integer2
) 
=> x_result"
"Returns the integer remainder of dividing two integers. The remainder is either zero or has the sign of the dividend.")
("random"
"random( 
[ x_number ] 
) 
=> x_result"
"Returns a random integer between 0 and x_number minus 1.")
("round"
"round(
n_arg 
) 
=> x_result"
"Rounds a floating-point number to its closest integer value.")
("sin"
"sin( 
n_number
) 
=> f_result"
"Returns the sine of a floating-point number or integer.")
("sqrt"
"sqrt(
n_number 
) 
=> f_result"
"Returns the square root of a floating-point number or integer.")
("srandom"
"srandom(
x_number 
) 
=> t"
"Sets the seed of the random number generator to a given number.")
("sub1"
"sub1( 
n_number
) 
=> n_result"
"Subtracts 1 from a floating-point number or integer.")
("tan"
"tan(
n_number
) 
=> f_result"
"Returns the tangent of a floating-point number or integer.")
("xor"
"xor( 
g_in1 
g_in2 
) 
=> g_res"
"Returns the XOR value of the boolean inputs.")
("average"
"average( 
o_waveform 
[ ?overall t_overall ]
) 
=> n_average / o_waveformAverage / nil"
"Computes the average of a waveform over its entire range.")
("abs_jitter"
"abs_jitter"
"Calculates the absolute jitter values in the intput waveform for the given threshold. The output waveform can be expressed in degrees, radians, or unit intervals (UI). The absolute jitter can be plotted as a function of cycle number, crossing time, or reference clock time.")
("analog2Digital"
"analog2Digital"
"Returns the digital form of the analog input, which can be a waveform, list or family of waveforms, or a string representation of expression(s).")
("awvCreateBus"
"awvCreateBus"
"Creates a bus with the given digital signals and radix.")
("awvPlaceXMarker"
"awvPlaceXMarker( 
w_windowId 
n_xLoc 
[ ?subwindow x_subwindowId ]
[ ?label t_label ] 
) 
=> t_xLoc / t / nil"
"Places a vertical marker at a specific x-coordinate in the optionally specified subwindow of the specified window.")
("awvPlaceYMarker"
"awvPlaceYMarker(
w_windowId 
n_yLoc 
[ ?subwindow x_subwindowId ]
[ ?label t_label ]
) 
=> t_yLoc / t / nil"
"Places a horizontal marker at a specific y-coordinate in the optionally specified subwindow of the specified window.")
("awvRefreshOutputPlotWindows"
"awvRefreshOutputPlotWindows(
s_session
)"
"Refreshes all existing plot windows (with new simulation data, if any) attached with the session s_session.")
("b1f"
"b1f( 
o_s11
o_s12 
o_s21 
o_s22
) 
=> o_waveform / nil"
"Returns the alternative stability factor in terms of the supplied parameters.")
("bandwidth"
"bandwidth( 
o_waveform 
n_db 
t_type
) 
=> n_value / o_waveform / nil"
"Calculates the bandwidth of a waveform.")
("clip"
"clip(
o_waveform 
n_from 
n_to 
) 
=> o_waveform / nil"
"Restricts the waveform to the range defined by n_from and n_to.")
("clipX"
"clipX"
"Restricts the waveform to the range defined by n_from and n_to.")
("closeResults"
"closeResults"
"Closes the simulation results stored in the input results directory. The function closes all the internal resources opened by the tool that are related to the results directory. It is recommended that you must call this function before deleting a results directory, moving the directory to any other location, or renaming a results directory.")
("compare"
"compare( 
o_waveform1
o_waveform1 
[ f_abstol [ f_reltol ] ]
) 
=> o_comparisonWaveform / nil"
"Compares the two given waveforms based on the specified values for absolute and relative tolerances. This function compares only the sections of the two waveforms where the X or independent axes overlap.")
("compression"
"compression( 
o_waveform  
[ ?x f_x ]  
[ ?y f_y ]  
[ ?compression f_compression ]  
[ ?io s_measure ] 
[ ?tanSlope t_tanSlope ]
) 
=> f_compPoint / nil"
"Performs an nth compression point measurement on a power waveform.")
;PREFORMATTED 56
;RESUME 56
;PREFORMATTED 56
;RESUME 56
;PREFORMATTED 56
;RESUME 56
("compressionVRI"
"compressionVRI( 
o_vport 
x_harm 
[ ?iport o_iport ]
[ ?rport f_rport ] 
[ ?epoint f_epoint ] 
[ ?gcomp f_gcomp ] 
[ ?measure s_measure ] 
[ ?format format ]
)
=> o_waveform / n_number / nil"
"Performs an nth compression point measurement on a power waveform.")
;PREFORMATTED 59
;RESUME 59
("compressionVRICurves"
"compressionVRICurves( 
o_vport 
x_harm 
[ ?iport o_iport ] 
[ ?rport f_rport ] 
[ ?epoint f_epoint ]
[ ?gcomp f_gcomp ] 
[ ?format format ]
) 
=> o_waveform / nil"
"Constructs the waveforms associated with an nth compression measurement.")
;PREFORMATTED 62
;RESUME 62
("complex"
"complex( 
f_real 
f_imaginary
) 
=> o_complex"
"Creates a complex number of which the real part is equal to the real argument, and the imaginary part is equal to the imaginary argument.")
("complexp"
"complexp(
g_value 
) 
=> t / nil"
"Checks if an object is a complex number. The suffix p is added to the name of a function to indicate that it is a predicate function.")
("conjugate"
"conjugate(
{ o_waveform | n_x }
) 
=> o_waveform / n_y / nil"
"Returns the conjugate of a waveform or number.")
("convolve"
"convolve( 
o_waveform1
o_waveform2
n_from 
n_to 
t_type 
n_by 
) 
=> o_waveform /n_number /nil"
"Computes the convolution of two waveforms.")
("cPwrContour"
"cPwrContour( 
o_iwave 
o_vwave 
x_harm 
[ ?iwaveLoad o_iwaveLoad ] 
[ ?vwaveLoad o_vwaveLoad ] 
[ ?maxPower f_maxPower ] 
[ ?minPower f_minPower ] 
[ ?numCont x_numCont ]
[ ?refImp f_refImp ]
[ ?closeCont g_closeCont ] 
[ ?modifier s_modifier ]
[ ?ifam ifam ]
[ ?vfam vfam ]
) 
=> o_waveform / nil"
"Constructs constant power contours for Z-Smith plotting. The trace of each contour correlates to reference reflection coefficients that all result in the same power level.")
;PREFORMATTED 70
;RESUME 70
;PREFORMATTED 70
;RESUME 70
;PREFORMATTED 70
;RESUME 70
("cReflContour"
"cReflContour( 
o_iwave 
o_vwave 
x_harm 
[ ?iwaveLoad o_iwaveLoad ] 
[ ?vwaveLoad o_vwaveLoad ] 
[ ?maxRefl f_maxRefl ] 
[ ?minRefl f_minRefl ] 
[ ?numCont x_numCont ] 
[ ?refImp f_refImp ] 
[ ?closeCont g_closeCont ] 
) 
=> o_waveform / nil"
"Constructs constant reflection coefficient magnitude contours for Z-Smith plotting. The trace of each contour correlates to reference reflection coefficients that all result in the same reflection coefficient magnitude.")
;PREFORMATTED 73
;RESUME 73
;PREFORMATTED 73
;RESUME 73
;PREFORMATTED 73
;RESUME 73
("cross"
"cross( 
o_waveform 
n_crossVal
x_n 
s_crossType 
[ g_multiple [ s_Xname ] ]
) 
=> o_waveform / g_value / nil"
"Computes the X-axis value at which a particular crossing of the specified edge type of the threshold value occurs.")
("db10"
"db10(
{ o_waveform | n_number }
) 
=> o_waveform / n_number / nil"
"Returns 10 times the log10 of the specified waveform object or number. This function can also be written as dB10.")
("db20"
"db20(
{o_waveform | n_number} 
) 
=> o_waveform / n_number / nil"
"Returns 20 times the log10 of the specified waveform object or number. This function can also be written as dB20.")
("dbm"
"dbm(
{ o_waveform | n_number }
) 
=> o_waveform n_number / nil"
"Returns 10 times the log10 of the specified waveform object plus 30. This function can also be written as dBm.")
("delay"
"delay( 
[ ?wf1 o_waveform1 ]
[ ?value1 n_value1 ]
[ ?edge1 s_edge1 ]
[ ?nth1 x_nth1 ]
[ ?td1 n_td1 ]
[ ?wf2 o_waveform2 ]
[ ?value2 n_value2 ] 
[ ?edge2 s_edge2 ] 
[ ?nth2 x_nth2 
[ ?td2 n_td2 ] 
[ ?td2r0 n_td2r0 ]}
[ ?stop n_stop ]
[ ?histoDisplay g_histoDisplay ]
[ ?noOfHistoBins x_noOfHistoBins ]
[ ?period1 period1 ]
[ ?period2 period2 ]
[ ?multiple multiple ]
[ ?xName xName ]
@rest args 
) 
=> o_waveform / n_value / nil"
"Calculates the delay between a trigger event and a target event.")
("delayMeasure"
"delayMeasure"
"Calculates the delay between a trigger event and a target event.")
("deriv"
"deriv( 
o_waveform 
) 
=> o_waveform / nil"
"Computes the derivative of a waveform with respect to the X axis.")
("dft"
"dft(
o_waveform 
n_from 
n_to 
x_num 
[ t_windowName ] 
[ n_param1 ] 
[ n_adcSpan ]
) 
=> o_waveform / nil"
"Computes the discrete Fourier transform and fast Fourier transform of the input waveform.")
("dftbb"
"dftbb( 
o_waveform1 
o_waveform2 
f_timeStart 
f_timeEnd 
x_num 
[ ?windowName t_windowName ]
[ ?smooth x_smooth ]
[ ?cohGain f_cohGain ]
[ ?spectrumType s_spectrumType ]
) 
=> o_waveformComplex / nil"
"Computes the discrete Fourier transform (fast Fourier transform) of a complex signal.")
("dnl"
"dnl( 
o_dacSignal
o_sample | o_pointList | n_interval 
[ ?mode t_mode ] 
[ ?threshold n_threshold ] 
[ ?crossType t_crossType ] 
[ ?delay f_delay ] 
[ ?method t_method ]
[ ?units x_units ] 
[ ?nbsamples n_nbsamples ] 
)
=> n_dnl / nil"
"Computes the differential non-linearity of a transient simple or parametric waveform.")
("dutyCycle"
"dutyCycle( 
o_waveform 
[ ?threshold n_threshold ] 
[ ?xName t_xName ] 
[ ?outputType t_outputType ] 
[ ?mode mode ]
) 
=> o_waveform / f_average / nil"
"Computes the duty cycle for a given waveform as a function of time or cycle.")
("evmQAM"
"evmQAM( 
o_waveformI 
o_waveformQ 
n_tDelay 
n_samplingT 
x_levels 
g_normalize 
[ ?percent d_percent ]
) 
=> o_waveform / nil"
"Processes the I and Q waveform outputs from the transient simulation run to calculate the Error Vector Magnitude (EVM) for multi-mode modulations. The function plots the I versus Q scatterplot. EVM is a useful measurement to describe the overall signal amplitude and phase modulated signal quality. It is based on a statistical error distribution normalized from an ideal digital modulation. Quadrature Amplitude Modulation (QAM) is a typical modulation scheme where EVM is useful. The EVM is calculated by detecting the I and Q signal levels corresponding to the four possible I and Q symbol combinations and calculating the difference between the actual signal level and the ideal signal level.")
("evmQpsk"
"evmQpsk( 
o_waveform1 
o_waveform2 
n_tDelay 
n_sampling 
g_autoLevelDetect 
n_voltage 
n_offset 
g_normalize 
[ ?percent d_percent ]
)
=> o_waveform / nil"
"Processes the I and Q waveform outputs from the transient simulation run to calculate the Error Vector Magnitude (EVM) and plot the I versus Q scatterplot. EVM is a useful measurement to describe the overall signal amplitude and phase modulated signal quality. It is based on a statistical error distribution normalized from an ideal digital modulation. Quadrature Phase Shift Keying (QPSK) is a typical modulation scheme where EVM is useful. The EVM is calculated by detecting the I and Q signal levels corresponding to the four possible I and Q symbol combinations and calculating the difference between the actual signal level and the ideal signal level.")
("eyeDiagram"
"eyeDiagram( 
o_waveform 
n_start 
n_stop 
n_period 
[ ?advOptions t_advOptions ]
[ ?intensityPlot g_intensityPlot ]
) 
=> o_waveform / nil"
"Returns an eye-diagram plot of the input waveform signal. It returns the waveform object of the eye-diagram plot. Using an advanced option, the function also calculates the maximum vertical and horizontal opening of the eye formed when the input waveform is folded by the specified period to form the eye.")
("eyeHeightAtXY"
"eyeHeightAtXY( 
o_eyeDiagram 
f_x
f_y
)
=> f_eyeHeight / nil"
"Calculates the eye height at the specified point (x,y) inside the eye diagram. Eye height is the difference of two intercepts made with the innermost traces of the eye in the y-axis direction.")
("eyeWidthAtXY"
"eyeWidthAtXY( 
o_eyeDiagram 
f_x
f_y
)
=> f_eyeWidth / nil"
"Calculates the eye width at the specified point (x,y) inside the eye diagram. Eye width is the difference of two intercepts made with the innermost traces of the eye in the x-axis direction.")
("eyeAperture"
"eyeAperture"
"Returns the aperture of the input eye diagram signal.")
("eyeMeasurement"
"eyeMeasurement(
o_waveform
[ ?sample n_sample ]
[ ?auto g_auto ]
[ ?horizThreshold n_horizThreshold ]
[ ?sample n_sample ]
[ ?xTypePercent0 g_xTypePercent0 ]
[ ?startx0 n_startx0 ] 
[ ?starty0 n_starty0 ]
[ ?yTypePercent0 g_yTypePercent0 ]
[ ?endx0 n_endx0 ]
[ ?endy0 n_endy0 ]
[ ?xTypePercent1 g_xTypePercent1 ]
[ ?startx1 n_startx1 ]
[ ?starty1 n_starty1 ]
[ ?yTypePercent1 g_yTypePercent1 ]
[ ?endx1 n_endx1 ]
[ ?endy1 n_endy1 ]
[ ?noOfBins n_noOfBins ]
[ ?measure t_measure ]
) 
=> o_waveform / nil"
"Evaluates the measurements for the eye diagram plot.")
("edgeTriggeredEyeDiagram"
"edgeTriggeredEyeDiagram(
o_waveform 
n_start 
n_stop 
o_triggerWave 
n_threshold 
s_edgeType 
n_triggerOffset 
[ ?intensityPlot g_intensityPlot ]
) 
=> o_waveform / nil"
"Desription")
("flip"
"flip( 
o_waveform 
) 
=> o_waveform / nil"
"Returns a waveform with the X vector values negated.")
("fourEval"
"fourEval( 
o_waveform 
n_from 
n_to 
n_by 
[ ?baseBand g_baseBand ]
) 
=> o_waveform / nil"
"Evaluates the Fourier series represented by an expression. ")
("fallTime"
"fallTime(
o_waveform 
n_initVal 
g_initType 
n_finalVal
g_finalType 
n_theta1
n_theta2 
[ g_multiple [ s_Xname ][ g_histoDisplay ][ x_noOfHistoBins ] ] 
) 
=> o_waveform / n_value / nil"
"Returns the fall time measured between theta1 (percent high) to theta2 (percent low) of the difference between the initial value and the final value.")
("freq"
"freq( 
o_waveform 
t_crossType 
[ ?threshold n_threshold ] 
[ ?mode t_mode ]
[ ?xName xName ]
[ ?histoDisplay g_histoDisplay ]
[ ?noOfHistoBins x_noOfHistoBins ] 
) 
=> o_outputWave / nil"
"Computes the frequency of the input waveform(s) as a function of time or cycle.")
("freq_jitter"
"freq_jitter( 
o_waveform 
t_crossType 
[ ?mode t_mode ] 
[ ?threshold n_threshold ]
[ ?binSize n_binSize ]
[ ?xName t_xName ]
[ ?outputType t_outputType ]
) 
=> o_waveform / f_val / nil"
"Calculates the frequency jitter.")
("frequency"
"frequency( 
o_waveform 
) 
=> o_waveform / n_value / nil"
"Computes the reciprocal of the average time between two successive midpoint crossings of the rising waveform.")
("ga"
"ga(
o_s11 
o_s12
o_s21 
o_s22 
[ ?gs n_gs ] 
) 
=> o_waveform / nil"
"Returns the available gain in terms of the supplied parameters and the optional source reflection coefficient (Gs).")
("gac"
"gac( 
o_s11 
o_s12 
o_s21 
o_s22
g_level
g_frequency 
) 
=> o_waveform / nil"
"Computes the available gain circles.")
("gainBwProd"
"gainBwProd( 
o_waveform 
) 
=> o_waveform / n_value / nil"
"Calculates the gain-bandwidth product of a waveform representing the frequency response of interest over a sufficiently large frequency range.")
("gainMargin"
"gainMargin(
o_waveform 
[ g_stable ]
) 
=> o_waveform / n_value / nil"
"Computes the gain margin of the loop gain of an amplifier.")
("gmax"
"gmax( 
o_s11
o_s12 
o_s21 
o_s22 
) 
=> o_waveform / nil"
"Returns the maximum power gain in terms of the supplied parameters.")
("gmin"
"gmin( 
o_Gopt 
o_Bopt 
f_zref 
) 
=> o_gminWave / nil"
"Returns the optimum noise reflection coefficient in terms of o_Gopt, o_Bopt, and f_zref.")
("gmsg"
"gmsg( 
o_s11 
o_s12
o_s21 
o_s22 
) 
=> o_waveform / nil"
"Returns the maximum stable power gain in terms of the supplied parameters.")
("gmux"
"gmux( 
o_s11 
o_s12 
o_s21 
o_s22 
) 
=> o_waveform / nil"
"Returns the maximum unilateral power gain in terms of the supplied parameters.")
("gp"
"gp(
o_s11 
o_s12
o_s21 
o_s22
[ ?gl n_gl ]
) 
=> o_waveform / nil"
"Computes the power gain in terms of the S-parameters.")
("gpc"
"gpc( 
o_s11 
o_s12
o_s21
o_s22 
g_level 
g_frequency
) 
=> o_waveform / nil"
"Computes the power gain circles.")
("groupDelay"
"groupDelay( 
o_waveform 
) 
=> o_waveform / nil"
"Computes the group delay of a waveform.")
("gt"
"gt( 
o_s11 
o_s12 
o_s21
o_s22 
[ ?gs n_gs ]
[ ?gl n_gl ]
) 
=> o_waveform / nil"
"Returns the transducer gain in terms of the supplied parameters and the optional source reflection coefficient (Gs) and the input reflection coefficient (Gl).")
("harmonic"
"harmonic( 
o_waveform 
h_index
) 
=> o_waveform / g_value / nil"
"Returns the waveform for a given harmonic index.")
("harmonicFreqList"
"harmonicFreqList( 
[ ?resultsDir t_resultsDir ] 
[ ?result S_resultName ]
) 
=> n_list / nil"
"Returns a list of lists, with each sublist containing a harmonic index and the minimum and maximum frequency values that the particular harmonic ranges between.")
("harmonicList"
"harmonicList(
[ ?resultsDir t_resultsDir ] 
[ ?result S_resultName ] 
)
=> n_list"
"Returns the list of harmonic indices available in the resultName or current result data.")
("histo"
"histo( 
o_waveform 
x_bins 
n_min 
n_max 
)
=> o_histoWaveform / nil"
"Returns a waveform that represents the statistical distribution of input data in the form of a histogram. The height of the bars (or bins) in the histogram represents the frequency of the occurrence of values within a specific period. Using the histo function, the range for capturing these frequencies can be specified through the n_min and n_max values.")
("histogram2D"
"histogram2D(
o_waveform 
x_nbins 
s_type 
g_setAnnotation 
g_setDensityEstimator)
=> o_waveform / nil"
"Returns a waveform that represents the statistical distribution of input data in the form of a histogram. The height of the bars (or bins) in the histogram represents the frequency of the occurrence of values within a specific period.")
("iinteg"
"iinteg( 
o_waveform 
) 
=> o_waveform / nil"
"Computes the indefinite integral of a waveform with respect to the X-axis variable.")
("imag"
"imag( 
{ o_waveform | n_input }
) 
=> o_waveformImag / n_numberImag / nil"
"Returns the imaginary part of a waveform representing a complex number or returns the imaginary part of a complex number.")
("inl"
"inl( 
o_dacSignal
o_sample | o_pointList | n_interval
[ ?mode t_mode ] 
[ ?threshold n_threshold ] 
[ ?crossType t_crossType ] 
[ ?delay f_delay ] 
[ ?units x_units ] 
[ ?nbsamples n_nbsamples ] 
)
=> n_inl / nil"
"Computes the integral non-linearity of a transient simple or parametric waveform.")
("integ"
"integ( 
o_waveform
[ n_intial_limit , n_final_limit ] 
) 
=> o_waveform / n_value / nil"
"Computes the definite integral of the waveform with respect to a range specified on the X-axis of the waveform. The result is the value of the area under the curve over the range specified on the X-axis.")
("intersect"
"intersect( 
o_waveform1
o_waveform2 
) 
=> o_wave / nil"
"Returns a waveform containing the points of intersection for two waveforms passed as arguments.")
("ipn"
"ipn( 
o_spurious 
o_reference 
[ f_ordspur f_ordref f_epspur f_epref g_psweep s_measure ]
) 
=> o_waveform / f_number / nil"
"Performs an intermodulation nth-order intercept measurement.")
;PREFORMATTED 173
;RESUME 173
;PREFORMATTED 173
;RESUME 173
("ipnVRI"
"ipnVRI( 
o_vport 
x_harmspur 
x_harmref 
[ ?iport o_iport ]
[ ?rport f_rport ]
[ ?ordspur f_ordspur ]|[ ?epoint f_epoint ]
[ ?psweep g_psweep ]
[ ?epref f_epref ] 
[ ?ordref f_ordref ]
[ ?measure s_measure ]
) 
=> o_waveform / f_number / nil"
"Performs an intermodulation nth-order intercept point measurement.")
;PREFORMATTED 176
;RESUME 176
("ipnVRICurves"
"ipnVRICurves( 
o_vport 
x_harmspur 
x_harmref 
[ ?iport o_iport ]
[ ?rport f_rport ]
[ ?ordspur f_ordspur ]
[ ?epoint f_epoint ]
[ ?psweep g_psweep ]
[ ?epref f_epref ]
[ ?ordref f_ordref ]
) 
=> o_waveform / nil"
"Constructs the waveforms associated with an ipn measurement.")
;PREFORMATTED 179
;RESUME 179
("kf"
"kf(
o_s11
o_s12 
o_s21 
o_s22 
)
=> o_waveform / nil"
"Returns the stability factor in terms of the supplied parameters.")
("ln"
"ln(
{ o_waveform | n_number }
) 
=> o_waveform / f_number / nil"
"Gets the base-e (natural) logarithm of a waveform or number.")
("log10"
"log10(
{ o_waveform | n_number } 
) 
=> o_waveform / n_number / nil"
"Gets the base-10 logarithm of a waveform or a number.")
("lsb"
"lsb( 
o_s11 
o_s12
o_s21 
o_s22 
g_frequency 
) 
=> o_waveform / nil"
"Computes the load stability circles.")
("lshift"
"lshift( 
o_waveform 
n_delta
) 
=> o_waveform / nil"
"Shifts the waveform to the left by the delta value.")
("mag"
"mag( 
{ o_waveform | n_number }
) 
=> o_waveform / n_number / nil"
"Gets the magnitude of a waveform or number.")
("nc"
"nc( 
o_Fmin 
o_Gmin
o_rn 
g_level 
g_frequency 
) 
=> o_waveform / nil"
"Computes the noise circles.")
("normalQQ"
"normalQQ(
o_waveform 
)
=> o_waveform / nil"
"Returns a quantile-quantile plot of the sample quantiles versus theoretical quantiles from a normal distribution. If the distribution is normal, the plot is close to a linear waveform.")
("overshoot"
"overshoot( 
o_waveform 
n_initVal 
g_initType 
n_finalVal 
g_finalType 
[ g_multiple [ s_Xname ] ]
[ g_histoDisplay ]
[ x_noOfHistoBins ] 
) 
=> o_waveform / n_value /nil"
"Computes the percentage by which an expression overshoots a step going from the initial value to the final value you enter.")
("pavg"
"pavg"
"Computes the periodic average of a family of signals for each time point.")
("peak"
"peak( 
o_waveform 
[ ?from f_from ]
[ ?to f_to ]
[ ?xtol f_xtol ]
[ ?ytol f_ytol ]
[ ?withLast g_withLast ] 

) 
=> o_waveform / nil"
"Detects the peaks in the input waveform and returns the X and Y coordinates of these peak points in the form of a waveform.")
("peakToPeak"
"peakToPeak( 
o_waveform 
[ ?overall type_overall ]
) 
=> o_waveform / n_value / nil"
"Returns the difference between the maximum and minimum values of a waveform.")
("period_jitter"
"period_jitter( 
o_waveform 
t_crossType 
[ ?mode t_mode ] 
[ ?threshold n_threshold ] 
[ ?binSize n_binSize ] 
[ ?xName t_xName ] 
[ ?outputType t_outputType ] 
) 
=> o_waveform / f_val / nil"
"Computes the period jitter. It returns a waveform or a value representing deviation from the average period.")
("phase"
"phase(
{ o_waveform | n_number }
) 
=> o_waveform / n_number / nil"
"Gets the phase of the waveform or number. The phase command is similar to the phaseDegUnwrapped command and returns the unwrapped phase in degrees.")
("phaseDeg"
"phaseDeg(
{ o_waveform | n_number } 
) 
=> o_waveform / n_number / nil"
"Calculates the wrapped phase in degrees of a waveform and returns a waveform.")
("phaseDegUnwrapped"
"phaseDegUnwrapped(
{ o_waveform | n_number }
) 
=> o_waveform / n_number / nil"
"Calculates the unwrapped phase in degrees of a waveform and returns a waveform.")
("phaseMargin"
"phaseMargin( 
o_waveform 
) 
=> o_waveform / n_value / nil"
"Computes the phase margin of the loop gain of an amplifier.")
("phaseRad"
"phaseRad( 
{ o_waveform | n_number }
) 
=> o_waveform / n_number / nil"
"Calculates the wrapped (discontinuous) phase in radians of a waveform.")
("phaseRadUnwrapped"
"phaseRadUnwrapped( 
o_waveform 
) 
=> o_waveform / nil"
"Calculates the unwrapped (continuous) phase in radians of a waveform and returns a waveform.")
("PN"
"PN"
"Calculates the transient phase noise of the input waveforms in decibels (dBc/Hz). Phase noise is defined as the power spectral density of the absolute jitter of an input waveform.")
("pow"
"pow( 
{ o_waveformBase | n_numberBas } 
{ o_waveformExpn | n_numberExpn }
) 
=> o_waveform / n_result / nil"
"Takes the exponent of a given waveform or number.")
("prms"
"prms"
"Computes the periodic root mean square of a family of signals for each time point, which is the square root of the periodic average of the square of the input waveform.")
("psd"
"psd( 
o_waveform 
f_timeStart 
f_timeEnd 
x_num 
[ ?windowName t_windowName ]
[ ?smooth x_smooth ]
[ ?cohGain f_cohGain ]
[ ?windowsize x_windowsize ]
[ ?detrending t_detrending ]
) 
=> o_waveformReal / nil"
"Returns an estimate for the power spectral density of o_waveform. If x_windowsize is not a power of 2, it is forced to the next higher power of 2. If x_num is less than x_windowsize, x_num is forced to x_windowsize.")
;PREFORMATTED 216
;RESUME 216
("psdbb"
"psdbb( 
o_waveform1 
o_waveform2 
f_timeStart 
f_timeEnd 
x_num 
[ ?windowName t_windowName ]
[ ?smooth x_smooth ]
[ ?cohGain f_cohGain ]
[ ?windowsize x_windowsize ]
[ ?detrending t_detrending ]
) 
=> o_waveformReal / nil"
"Returns an estimate for the power spectral density of o_waveform1+j*o_waveform2. If x_windowsize is not a power of 2, it is forced to the next higher power of 2. If x_num is less than x_windowsize, x_num is forced to x_windowsize.")
;PREFORMATTED 221
;RESUME 221
("pstddev"
"pstddev"
"Computes the periodic standard deviation of a family of signals for each time point.")
("pzbode"
"pzbode(
f_transferGain
f_minfrequency
f_maxfrequency
x_nponits 
[ ?poles o_waveform1 ]
[ ?zeros o_waveform2 ]
)
=> o_waveform / nil"
"Calculates and plots the transfer function of a circuit from pole zero simulation data.")
("pzfilter"
"pzfilter(
[ o_PoleWaveform ]
[ o_ZeroWaveform ]
[ ?maxfreq t_maxfreq ]
[ ?reldist n_reldist ]
[ ?absdist n_absdist ]
[ ?minq n_minq ]
[ ?output_type o_output ] 
)
=> o_waveform / nil"
"Returns the filtered Pole and Zero waveforms.")
("rapidIPNCurves"
"rapidIPNCurves( 
o_result
[ ?resultsDir t_resultsDir ]
[ ?resistance n_resistance ]
@Rest args
) 
=> o_waveformReal / nil"
"Plots IPN curves.")
("rapidIIPN"
"rapidIIPN( 
o_result
[ ?resultsDir t_resultsDir ]
[ ?resistance n_resistance ]
@Rest args 
) 
=> o_waveform / nil"
"Plots the input IPN curves.")
("real"
"real(
{ o_waveform | n_input } 
) 
=> o_waveformReal / n_numberReal / nil"
"Returns the real part of a waveform representing a complex number, or returns the real part of a complex number.")
("riseTime"
"riseTime(
o_waveform 
n_initVal
g_initType 
n_finalVal 
g_finalType
n_theta1
n_theta2 
[ g_multiple [ s_Xname ] [ g_histoDisplay ] [ x_noOfHistoBins ] ]
) 
=> o_waveform / n_value / nil"
"Returns the rise time measured between theta1 (percent low) to theta2 (percent high) of the difference between the initial value and the final value.")
("rms"
"rms(
o_waveform 
) 
=> o_waveform / n_value / nil"
"Returns the root-mean-square value of a waveform.")
("rmsNoise"
"rmsNoise( 
n_from 
n_to 
) 
=> o_waveform / n_value / nil"
"Computes the integrated root-mean-square noise over the specified bandwidth.")
("rmsVoltage"
"rmsVoltage( 
t_net 
[ t_net1 ] 
) 
=> f_voltage / nil"
"Calculates the root-mean-square voltage between two nets for fast and regular envelop analysis.")
("rmsTerminalVoltage"
"rmsTerminalVoltage(
t_terminal 
[ t_terminal1 ]
)
=> f_voltage / nil"
"Calculates the root-mean-square voltage between two terminals for fast and regular envlp analysis.")
("root"
"root(
o_waveform 
n_rootVal
x_n )

=> o_waveform / n_value / l_value / nil"
"Returns the nth X value at which the Y value equals the specified Y value (rootVal).")
("rshift"
"rshift( 
o_waveform
n_delta
) 
=> o_waveform / nil"
"Shifts the waveform to the right by the n_delta value.")
("sample"
"sample( 
o_waveform 
n_from 
n_to
t_type
n_by 
) 
=> o_waveform / n_number / nil"
"Samples a waveform at the specified interval.")
("settlingTime"
"settlingTime( 
o_waveform 
n_initVal 
g_initType
n_finalVal 
g_finalType
n_theta 
[ g_multiple [ s_Xname ] ] 
) 
=> o_waveform / n_value / nil"
"The settling time is the time by which the signal settles within the specified Percent of step (theta) of the difference between the Final Value and Initial Value from the Final Value.")
("slewRate"
"slewRate( 
o_waveform
n_initVal 
g_initType
n_finalVal 
g_finalType 
n_theta1
n_theta2
[ g_multiple [ s_Xname ] ]
[ g_histoDisplay ] [ x_noOfHistoBins ]
) 
=> o_waveform / n_value / nil"
"Computes the average rate at which an expression changes from theta1 (percent low) to theta2 (percent high) of the difference between the initial value and final value.")
("smithType"
"smithType( 
x_mode
) 
=> t / nil"
"Sets the Smith display mode type for the active graph.")
("spectralPower"
"spectralPower(
o_current 
o_voltage 
) 
=> o_power / nil"
"Returns the spectral power given the spectral current and voltage.")
("spectrumMeas:"
"spectrumMeas(
o_waveform 
n_from
n_to
x_numSamples
x_noiseBins 
n_startFreq
n_endFreq 
t_windowName
n_adcSpan 
t_measType 
) 
=> o_spectrumWaveform / g_value / nil"
"Calculates Signal-to-Noise-and-Distortion Ratio (SINAD), Spurious Free Dynamic Range (SFDR), Effective Number of Bits (ENOB), and Signal-to-Noise Ratio (without distortion) by using discrete fourier transform of any given input signal.")
("spectrumMeasurement"
"spectrumMeasurement( 
o_waveform 
g_isTimeWave
n_from 
n_to 
x_numSamples
n_startFreq
n_endFreq
x_signalBins 
t_windowName 
n_satLvl 
g_isNoiseAnalysis
x_noOfHarmonics
t_measType
) 
=> g_value / nil"
"Calculates Signal-to-Noise-and-Distortion Ratio (SINAD), Spurious Free Dynamic Range (SFDR), Effective Number of Bits (ENOB), and Signal-to-Noise Ratio (without distortion) by using Fast Fourier Transform (FFT) of any given input signal.")
("ssb"
"ssb( 
o_s11 
o_s12
o_s21
o_s22
g_frequency
) 
=> o_waveform / nil"
"Computes the source stability circles.")
("stddev"
"stddev( 
o_waveform 
[ ?overall overall ]
) 
=> n_stddev / o_waveformStddev / nil"
"Computes the standard deviation of a waveform (or a family of waveforms) over its entire range. Standard deviation (stddev) is defined as the square-root of the variance where variance is the integral of the square of the difference of the expression f(x) from average (f(x)), divided by the range of x.")
("tangent"
"tangent( 
o_waveform 
[ ?x n_x ] 
[ ?y n_y ] 
[ ?slope n_slope ] 
[ ?ckm ckm ]
) 
=> o_waveform / nil"
"Returns the tangent to a waveform through the point (n_x, n_y) with the given slope.")
("thd"
"thd(
o_waveform 
n_from
n_to
x_num
n_fund
) 
=> o_waveform / n_thdValue / nil"
"The thd function computes the percentage of total harmonic content of a signal with respect to the fundamental frequency expressed as a voltage percentage.")
("thd_fd"
"thd_fd(
t_name
t_result
)
=> n_thdValue / nil"
"The thd_fd function returns the total harmonic distortion of the input waveform.")
("unityGainFreq"
"unityGainFreq( 
o_gainFreqWaveform 
) 
=> n_frequency / nil"
"Computes and reports the frequency at which the gain is unity.")
("value"
"value( 
o_waveform 
[ ?scale scale ]
[ ?period n_period ]
[ ?xName s_xName] 
[ ?histoDisplay g_histoDisplay ]
[ ?noOfHistoBins x_noOfHistoBins ]
@Rest args
) 
=> o_waveform / g_value / nil"
"Returns the Y value of a waveform for a given X value.")
("xmax"
"xmax(
o_waveform 
x_numberOfPeaks 
) 
=> o_waveform / g_value / l_value / nil"
"Computes the value of the independent variable (X) at which the Y value attains its maximum value.")
("xmin"
"xmin(
o_waveform 
x_numberOfValleys 
) 
=> o_waveform / g_value / l_value / nil"
"Computes the value of the independent variable (X) at which the Y value attains its minimum value.")
("xval"
"xval(
o_waveform
) 
=> o_waveform / nil"
"Returns a waveform whose X vector and Y vector are equal to the input waveform's X vector.")
("ymax"
"ymax( 
o_waveform 
[ ?overall overall ]
) 
=> n_max / o_waveformMax / nil"
"Computes the maximum value of the waveform's Y vector.")
("ymin"
"ymin( 
o_waveform 
[ ?overall overall ]
) 
=> n_min / o_waveformMin / nil"
"Computes the minimum value of a waveform's Y vector.")
("ifreq"
"ifreq( 
s_ana
t_terminal 
[ freq n_freq ]
) 
=> o_waveform / nil"
"Returns the current of the terminal at a specified frequency or at all frequencies in the frequency domain.")
("ih"
"ih( 
s_ana
t_terminal 
[ harmonic x_hlist ]
) 
=> o_waveform / nil"
"Returns the current of the terminal at a specified harmonic or at all harmonics in the frequency domain.")
("itime"
"itime(
s_ana 
t_terminal 
[ time n_time ]
) 
=> o_waveform / nil"
"Returns the current of the terminal at a specified time point or at all time points in the time domain.")
("pir"
"pir( 
s_ana 
t_branch1
t_branch2
n_resistance 
[ harmonic x_hlist ]
) 
=> o_waveform / nil"
"Returns the spectral power from current and resistance for a specified harmonic list or for all harmonic points.")
("pmNoise"
"pmNoise( 
s_ana
[ freq n_freq ]
s_modifier 
g_dsb
) 
=> o_waveform / n_pnoise / nil"
"Returns the modulated phase noise at a specified frequency or for the entire spectrum.")
("pn"
"pn( 
s_ana 
[ freq n_freq ]
) 
=> o_waveform / n_pn / nil"
"Returns the phase noise at a specified frequency or at all frequency points.")
("pvi"
"pvi( 
s_ana 
t_pos 
t_neg 
t_branch1 
t_branch2 
[ harmonic x_hlist ]
) 
=> o_waveform / nil"
"Returns the spectral power from voltage and current for a specified harmonic list or for all harmonics.")
("pvr"
"pvr( 
s_ana 
t_pos
t_neg 
n_resistance 
[ harmonic x_hlist ]
) 
=> o_waveform / nil"
"Returns the spectral power at a specified harmonic list or at all harmonics with resistor and voltage on the positive and negative nodes.")
("spm"
"spm( 
s_ana 
x_index1 
x_index2 
[ ?port1 x_port1 ] 
[ ?port2 x_port2 ]
) 
=> o_waveform / nil"
"Returns the waveform for s-parameters.")
("totalNoise"
"totalNoise( 
s_ana 
n_sfreq 
n_efreq 
[ instances l_instances ]
) 
=> n_totalNoise / nil"
"Returns the total noise in a specified frequency limit.")
("vfreq"
"vfreq(
s_ana
t_net
[ freq x_freq ]
) 
=> o_waveform / nil"
"Returns the voltage of a net at a specified frequency or at all frequencies in the frequency domain.")
("vfreqterm"
"vfreqterm( 
s_ana 
t_terminal
[ freq x_freq ]
)
=> o_waveform | g_value | nil"
"Returns the voltage of a terminal at a specified frequency or at all frequencies in the frequency domain.")
("vh"
"vh( 
s_ana 
t_net 
[ harmonic x_hlist ] 
) 
=> o_waveform / nil"
"Returns the voltage on a net at a specified harmonic or at all harmonics in the frequency domain.")
("vhterm"
"vhterm( 
s_ana 
t_terminal 
[ harmonic x_hlist ]
)
=> o_waveform | g_value | nil"
"Returns the voltage on a terminal at the specified harmonic or at all the harmonics in the frequency domain.")
("vtime"
"vtime( 
s_ana 
t_net 
[ time n_time ] 
) 
=> o_waveform / nil"
"Returns the voltage of a net at a specified time point or at all time points in the time domain.")
("vtimeterm"
"vtimeterm( 
s_ana 
t_terminal
[ time n_time ]
)
=> o_waveform | g_value | nil"
"Returns the voltage of a terminal at a specified time point or at all time points in the time domain.")
("ypm"
"ypm( 
s_ana
x_index1
x_index2 
) 
=> o_waveform / nil"
"Returns the waveform for y-parameters.")
("zpm"
"zpm( 
s_ana 
x_index1
x_index2 
) 
=> o_waveform / nil"
"Returns the waveform for z-parameters.")
("loadStability"
"loadStability"
"Computes the load stability circles.")
("sourceStability"
"sourceStability"
"Computes the source stability circles.")
("paramAnalysis"
"paramAnalysis(
t_desVar 
[ ?start n_start ] 
[ ?stop n_stop ] 
[ ?center n_center ] 
[ ?span n_span ] 
[ ?step f_step ] 
[ ?lin n_lin ] 
[ ?log n_log ]  
[ ?dec n_dec ] 
[ ?oct n_oct ] 
[ ?times n_times ] 
[ ?spanPercent n_spanPercent ] 
[ ?sweepType t_sweepType ]
[ ?values l_values ] 
[ o_paramAnalysis ]
) 
=> undefined / nil"
"Sets up a parametric analysis.")
;PREFORMATTED 6
;RESUME 6
;PREFORMATTED 6
;RESUME 6
("paramRun"
"paramRun(
[ s_paramAnalysis ] 
) 
=> t / nil"
"Runs the specified parametric analysis.")
("deleteJob"
"deleteJob( 
t_jobName 
[ t_jobName2 t_jobName3 ... t_jobNameN ]
) 
=> t / nil"
"Removes a job or series of jobs from the text-based job monitor.")
("digitalHostMode"
"digitalHostMode(
{ 'local | 'remote } 
) 
=> t / nil"
"For mixed-signal simulation, specifies whether the digital simulator will run locally or on a remote host.")
("digitalHostName"
"digitalHostName( 
t_name
) 
=> t / nil"
"For mixed-signal simulation, specifies the name of the remote host for the digital simulator.")
("hostMode"
"hostMode( 
{ 'local | 'remote | 'distributed } 
) 
=> t / nil"
"Sets the simulation host mode.")
("hostName"
"hostName( 
t_name 
) 
=> t / nil"
"Specifies the name of the remote host.")
("killJob"
"killJob( 
t_jobName [ t_jobName2 t_jobName3 ... t_jobNameN ]
) 
=> t / nil"
"Stops processing of a job or a series of jobs.")
("monitor"
"monitor(
[ ?taskMode s_taskMode ] 
) 
=> t / nil"
"Monitors the jobs submitted to the distributed system.")
("remoteDir"
"remoteDir(
t_path
) 
=> t / nil"
"Specifies the project directory on the remote host to be used for remote simulation.")
("resumeJob"
"resumeJob(
t_jobName [ t_jobName2 t_jobName3 ... t_jobNameN ]
) 
=> t / nil"
"Resumes the processing of a previously suspended job or series of jobs. The resumeJob command applies only to jobs that are suspended.")
("suspendJob"
"suspendJob(
t_jobName [ t_jobName2 t_jobName3 ... t_jobNameN ]
) 
=> t / nil"
"Suspends the processing of a job or series of jobs. The suspendJob command applies only to jobs that are pending or running.")
("wait"
"wait(
[ ?queue t_queueName ] 
jobName [ jobName2 jobName3 ... jobNameN ]
) 
=> t / nil"
"Postpones processing of a script until the specified jobs complete. This command is ignored if distributed processing is not available.")
("if"
"if(
g_condition 
g_thenExpression 
[ g_elseExpression ] 
) 
=> g_result
if( 
g_condition 
then g_thenExpr1 ... 
[ else g_elseExpr1 ... ] 
) 
=> g_result"
"Evaluates g_condition, typically a relational expression, and runs g_thenExpression if the condition is true (that is, its value is non-nil); otherwise, runs g_elseExpression.")
("unless"
"unless( 
g_condition 
g_expr1 ... 
) 
=> g_result / nil"
"Evaluates a condition. If the result is true (non-nil), it returns nil; otherwise it evaluates the body expressions in sequence and returns the value of the last expression.")
("when"
"when(
g_condition 
g_expr1 ... 
) 
=> g_result / nil"
"Evaluates a condition.")
("for"
"for(
s_loopVar 
x_initialValue 
x_finalValue 
g_expr1 
[ g_expr2 ... ] 
) 
=> t"
"Evaluates the sequence g_expr1 g_expr2 ... for each loop variable value, beginning with x_initialValue and ending with x_finalValue.")
;PREFORMATTED 7
;RESUME 7
("foreach"
"foreach( 
s_formalVar 
g_exprList 
g_expr1 [ g_expr2 ... ]
) 
=> l_valueList"
"Evaluates one or more expressions for each element of a list of values.")
("while"
"while(
g_condition 
g_expr1 ...
) 
=> t"
"Repeatedly evaluates g_condition and the sequence of expressions 
g_expr1 ... if the condition is true.")
("case"
"case( 
g_selectionExpr
l_clause1 [ l_clause2 ... ]
) 
=> g_result / nil"
"Evaluates the selection expression, matches the resulting selector values sequentially against comparators defined in clauses, and runs the expressions in the matching clause.")
;PREFORMATTED 13
;RESUME 13
("cond"
"cond( 
l_clause1 ... 
) 
=> g_result / nil"
"Examines conditional clauses from left to right until either a clause is satisfied or there are no more clauses remaining.")
;PREFORMATTED 14
;RESUME 15
("close"
"close(
p_port
) 
=> t"
"Drains, closes, and frees a port.")
("fscanf"
"fscanf( 
p_inputPort
t_formatString 
[ s_var1 ... ]  
) 
=> x_items / nil"
"Reads input from a port according to format specifications and returns the number of items read in.")
("gets"
"gets( 
s_variableName 
[ p_inputPort ]
) 
=> t_string / nil"
"Reads a line from the input port and stores the line as a string in the variable. This is a macro.")
("infile"
"infile( 
S_fileName 
) 
=> p_inport / nil"
"Opens an input port ready to read a file.")
("load"
"load(
t_fileName 
[ t_password ]
) 
=> t"
"Opens a file and repeatedly calls lineread to read in the file, immediately evaluating each form after it is read in.")
;PREFORMATTED 8
;RESUME 8
("newline"
"newline(
[ p_outputPort ]
) 
=> nil"
"Prints a newline (backslash n) character and then flushes the output port.")
("outfile"
"outfile( 
S_fileName
[ t_mode ] 
) 
=> p_outport / nil"
"Opens an output port ready to write to a file.")
("pfile"
"pfile(
[ S_fileName | p_port ]
) 
=> p_port / nil"
"Opens an output port ready to write to a file or returns the name of an existing port indicating that it is available.")
("printf"
"printf( 
t_formatString
[ g_arg1 ... ]
) 
=> t"
"Writes formatted output to poport, which is the standard output port.")
("println"
"println(
g_value
[ p_outputPort ]
)
=> nil"
"Prints a SKILL object using the default format for the data type of the value, and then prints a newline character.")