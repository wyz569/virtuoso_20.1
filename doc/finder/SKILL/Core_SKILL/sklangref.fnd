;SKILL Language Functions
("append"
"append( 
l_list1 
l_list2 
) 
=> l_result 

append( 
o_table 
g_assoc 
) 
=> o_table 	

append( 
o_table1 
o_table2 
) 
=> o_newTable"
"Creates a list containing the elements of l_list1 followed by the elements of l_list2 or returns the original association table including new entries.")
("append1"
"append1( 
l_list 
g_arg 
) 
=> l_result"
"Adds new arguments to the end of a list.")
("caar, caaar, caadr, cadr, caddr, cdar, cddr, ..."
"ca|d[ a | d ][ a | d ][ a | d ] r( 
l_list 
) 
=> g_result"
"Performs operations on a list using repeated applications of car and cdr. For example, caaar is equivalent to car( car( car( l_list))). The possible combinations are caaaar, caaadr, caadar, caaddr, caar, caddar, cadddr, cadr, cdaaar, cdaadr, cdaar, cdadar, cdaddr, cdadr, cdar, cddaar, cddadr, cddar, cdddar, cddddr, cdddr, cddr, caaar, caadr, cadar, caddr, cdadr, cadaar, cadadr, caddar, cadddr, cdaaar, cdaadr, cdadar, cdaddr, cddaar, cddadr, cdddar, and cddddr.")
("car"
"car( 
l_list 
) 
=> g_result"
"Returns the first element of a list. car is nondestructive, meaning that it returns the first element of a list but does not modify the list that was its argument.")
("cdr"
"cdr( 
l_list 
) 
=> l_result"
"Returns the tail of the list, that is, the list without its first element.")
("cons"
"cons( 
g_element 
l_list 
) 
=> l_result"
"Adds an element to the beginning of a list.")
("constar"
"constar( 
[ g_arg1 ... ] 
l_list 
) 
=> l_result"
"Adds elements to the beginning of a list.")
("copy"
"copy( 
l_arg 
) 
=> l_result"
"Returns a copy of a list, that is, a list with all the top-level cells duplicated.")
("dtpr"
"dtpr( 
g_value 
) 
=> t / nil"
"Checks if an object is a non-empty list.")
("last"
"last( 
l_arg 
) 
=> l_result"
"Returns the last list cell in a list.")
("lconc"
"lconc( 
l_tconc 
l_list 
) 
=> l_result"
"Uses a tconc structure to efficiently splice a list to the end of another list.")
("length"
"length( 
laot_arg 
) 
=> x_result / 0"
"Determines the length of a list, array, association table, or string.")
("lindex"
"lindex( 
l_list 
g_element 
[ ?all g_all ]
) 
=> x_result / l_result / nil"
"Returns the index number of the given element in l_list.")
("list"
"list( 
[ g_arg1 
g_arg2 ... ] 
) 
=> l_result / nil"
"Creates a list with the given elements.")
("listp"
"listp( 
g_value 
) 
=> t / nil"
"Checks if an object is a list.")
("nconc"
"nconc( 
l_arg1 
l_arg2 
[ l_arg3 ... ] 
) 
=> l_result"
"Equivalent to a destructive append where the first argument is modified.")
("ncons"
"ncons( 
g_element 
) 
=> l_result"
"Builds a list containing an element. Equivalent to cons( g_element nil ).")
("nth"
"nth( 
x_index0 
l_list 
) 
=> g_result / nil"
"Returns an index-selected element of a list, assuming a zero-based index.")
("nthcdr"
"nthcdr( 
x_count 
l_list 
) 
=> l_result"
"Applies cdr to a list a given number of times.")
("nthelem"
"nthelem( 
x_index1 
l_list 
) 
=> g_result / nil"
"Returns the indexed element of the list, assuming a one-based index.")
("pairp"
"pairp( 
g_obj 
) 
=> t / nil"
"Checks if an object is a cons object, that is, a non-empty list.")
("range"
"range( 
n_num1 
n_num2 
) 
=> l_result"
"Returns a list whose first element is n_num1 and whose tail is n_num2. Prefix form of the : operator.")
("remd"
"remd( 
g_x 
l_arg 
) 
=> l_result"
"Removes all top-level elements equal to a SKILL object from a list. This is a destructive removal, which means that the original list itself is modified. Therefore, any other reference to that list will also see the changes.")
("remdq"
"remdq( 
g_x 
l_arg 
) 
=> l_result"
"Removes all top-level elements that are identical to a SKILL object using eq from a list. This is a destructive removal, which means that the original list itself is modified. Therefore, any other reference to that list will also see the changes.")
("remove"
"remove( 
g_x 
l_arg 
) 
=> l_result

remove( 
g_key 
o_table 
) 
=> g_value"
"Returns a copy of a list with all top-level elements equal to a SKILL object removed. Can also be used to remove an entry from an association table, in which case the removal is destructive, that is, any other reference to the table will also see the changes. remove uses equal for comparison. remove can also be used with an association table to identify and remove an entry corresponding to the key specified in the function.")
("removeListDuplicates"
"removeListDuplicates( 
l_list 
) 
=> l_newList"
"Removes duplicate entries from a SKILL list and returns a new list with the duplicates removed.")
("remq"
"remq( 
g_x 
l_arg 
) 
=> l_result"
"Returns a copy of a list with all top-level elements that are identical to a SKILL object removed. Uses eq.")
("reverse"
"reverse( 
l_arg 
) 
=> l_result"
"Returns a copy of the given list with the elements in reverse order.")
("rplaca"
"rplaca( 
l_arg1 
g_arg2 
) 
=> l_result"
"Replaces the first element of a list with an object. This function does not create a new list; it alters the input list. Same as setcar.")
("rplacd"
"rplacd( 
l_arg1 
l_arg2 
) 
=> l_result"
"Replaces the tail of a list with the elements of a second list. This function does not create a new list; it alters the input list. Same as setcdr.")
("setcar"
"setcar( 
l_arg1 
g_arg2 
) 
=> l_result"
"Replaces the first element of a list with an object. Same as rplaca.")
("setcdr"
"setcdr( 
l_arg1 
l_arg2 
) 
=> l_result"
"Replaces the tail of a list with the elements of a second list. Same as rplacd.")
("tailp"
"tailp( 
l_arg1 
l_arg2 
) 
=> l_arg1 / nil"
"Returns arg1 if a list cell eq to arg1 is found by cdr down arg2 zero or more times, nil otherwise.")
("tconc"
"tconc( 
l_ptr 
g_x 
) 
=> l_result"
"Creates a list cell whose car points to a list of the elements being constructed and whose cdr points to the last list cell of the list being constructed.")
("xcons"
"xcons( 
l_list 
g_element 
) 
=> l_result"
"Adds an element to the beginning of a list. Equivalent to cons but the order of the arguments is reversed.")
("xCoord"
"xCoord( 
l_list 
) 
=> g_result"
"Returns the first element of a list. Does not modify the argument list.")
("yCoord"
"yCoord( 
l_list 
) 
=> g_result"
"Returns the tail of the list, that is, the list without its first element.")
("arrayp"
"arrayp( 
g_value 
) 
=> t / nil"
"Checks if an object is an array.")
("arrayref"
"arrayref( 
g_collection 
g_index 
) 
=> g_element"
"Returns the element in a collection that is in an array or a table of the given index.")
("assoc, assv, assq"
"assv( 
g_key 
l_alist 
) 
=> l_association / nil"
"The assoc, assq, and assv functions find the first list in l_alist whose car field is g_key and return that list. assq uses eq to compare g_key with the car fields of the lists in alist. assoc uses equal. assv uses eqv.")
("declare"
"declare( 
s_arrayName 
[ x_sizeOfArray ] 
) 
=> a_newArray"
"Creates an array with a specified number of elements. This is a syntax form. All elements of the array are initialized to unbound.")
("defprop"
"defprop( 
s_id 
g_value 
s_name 
) 
=> g_value"
"Adds properties to symbols but none of its arguments are evaluated. This is a syntax form.")
("defstruct"
"defstruct( 
s_name 
s_slot1 
[ s_slot2.. ] 
) 
=> t"
"Creates a defstruct, a named structure that is a collection of one or more variables.")
("defstructp"
"defstructp( 
g_object 
[ S_name ] 
) 
=> t / nil"
"Checks if an object is an instance of a particular defstruct.")
("defvar"
"defvar( 
s_varName 
[ g_value ] 
) 
=> g_value / nil"
"Defines a global variable and assigns it a value. You can also use the defun or define syntax form to define global variables in SKILL++ mode.")
("makeTable"
"makeTable( 
S_name 
[ g_default_value ] 
) 
=> o_table"
"Creates an empty association table.")
("makeVector"
"makeVector( 
x_size 
[ g_init_val ] 
)
=> a_vectorArray"
"Creates an array (vector) with the specified number of elements, and optionally initializes each entry.")
("setarray"
"setarray( 
a_array 
x_index 
g_value 
) 
=> g_value

setarray( 
o_table 
g_key 
g_value 
) 
=> g_value"
"Assigns the given value to the specified element of an array or to the specified key of a table. Normally this function is invoked implicitly using the array-subscription syntax, such as, x[i] = v.")
("tablep"
"tablep( 
g_object 
) 
=> t / nil"
"Checks if an object is an association table.")
("type, typep"
"type( 
s_object 
) 
=> s_type 

typep( 
s_object 
) 
=> s_type"
"Returns a symbol whose name denotes the type of a SKILL object. The functions type and typep are identical.")
("vector"
"vector( 
g_value ... 
)
=> a_vectorArray"
"Returns a vector or array, filled with the arguments in the given order. The vector function is analogous to the list function.")
("vectorp"
"vectorp( 
g_value 
) 
=> t / nil"
"Checks if an object is a vector. Behaves the same as arrayp.")
("alphaNumCmp"
"alphaNumCmp( 
S_arg1 
S_arg2 
[ g_arg3 ] 
) 
=> 1 / 0 / -1"
"Compares two string or symbol names alphanumerically or numerically.")
("concat"
"concat( 
Sx_arg1 
[ Sx_arg2 ... ] 
) 
=> s_result"
"Concatenates strings, symbols, or integers into a single symbol.")
("copy_<name>"
"copy_<name>( 
r_defstruct 
) 
=> r_defstruct"
"Creates and returns a copy of a structure. This function is created by the defstruct function where <name> is the name of the defstruct.")
("copyDefstructDeep"
"copyDefstructDeep( 
r_object 
) 
=> r_defstruct"
"Performs a deep or recursive copy on defstructs with other defstructs as sub-elements, making copies of all the defstructs encountered.")
("get"
"get( 
sl_id 
S_name 
) 
=> g_result / nil"
"Returns the value of a property in a property list (including disembodied property list), association table, structure, database object, and a standard object (instance of a user defined subclass of standardObject). get has no infix operator syntax.")
("getSG"
"getSG(
g_obj
S_prop
)
=> g_propValue"
"Evaluates and then retrieves the value of the specified attribute or property. It is a lambda implementation of getSGq().")
("getq"
"getq( 
sl_id 
S_name 
) 
=> g_result / nil

sl_id->S_name 
=> g_result / nil"
"Returns the value of a property in a property list. Same as get except that the second argument is not evaluated. This is a syntax form.")
("getqq"
"getqq( 
s_id 
S_name 
) 
=> g_result / nil

sl_id.S_name 
=> g_result / nil"
"Returns the value of a property in a symbol's property list. Same as get except that neither argument is evaluated. This is a syntax form.")
("importSkillVar"
"importSkillVar( 
s_variable ... 
) 
=> t / nil"
"(SKILL++ mode) Tells the compiler that the given variable names should be treated as SKILL global variables in SKILL++ code.")
("integerp"
"integerp( 
g_obj 
) 
=> t / nil"
"Checks if an object is an integer. This function is the same as fixp.")
("make_<name>"
"make_<name>( 
... 
) 
=> r_defstruct"
"Creates an instance of a defstruct specified by <name>.")
("otherp"
"otherp( 
g_value 
) 
=> t / nil"
"Checks if an object is a user type object, such as an association table or a window.")
("plist"
"plist( 
s_symbolName 
) 
=> l_propertyList / nil"
"Returns the property list associated with a symbol.")
("popf"
"popf( 
g_place
) 
=> g_result"
"A pop that uses the setf function. It returns the value for g_place that is removed.")
("postArrayDec"
"postArrayDec( 
g_array 
g_index 
) 
=> n_oldValue"
"Takes an array or an associated table element with an index g_index, decrements its value by one, stores the new value back into the array, and returns the original value. Prefix form of s--.")
("postArrayInc"
"postArrayInc( 
g_array 
g_index 
) 
=> n_oldValue"
"Takes an array or an associated table element with an index g_index, increments its value by one, stores the new value back into the array, and returns the original value. Prefix form of s++.")
("postArraySet"
"postArraySet( 
g_array 
g_index 
n_modifier 
) 
=> n_oldValue"
"Takes an array or an associated table element with an index g_index, adds an n_modifier value to its original value, stores the new value back into the array, and returns the original value.")
("postdecrement"
"postdecrement( 
s_var 
) 
=> n_result"
"Takes a variable, decrements its value by one, stores the new value back into the variable, and returns the original value. Prefix form of s--. The name of the variable must be a symbol and the value must be a number.")
("postincrement"
"postincrement( 
s_var 
) 
=> n_result"
"Takes a variable, increments its value by one, stores the new value back into the variable, and returns the original value. Prefix form of s++. The name of the variable must be a symbol and the value must be a number.")
("preArrayDec"
"preArrayDec( 
g_array 
g_index 
) 
=> n_newValue"
"Takes an array or an associated table element with an index g_index, decrements its value by one, stores the new value back into the array, and returns the updated value. Prefix form of --s.")
("preArrayInc"
"preArrayInc( 
g_array 
g_index 
) 
=> n_newValue"
"Takes an array or an associated table element with an index g_index, increments its value by one, stores the new value back into the array, and returns the updated value. Prefix form of ++s.")
("preArraySet"
"preArraySet( 
g_array 
g_index 
n_modifier 
) 
=> n_newValue"
"Takes array or an associated table element with an index g_index, adds an n_modifier value to its original value, stores the new value back into the array, and returns the updated value.")
("predecrement"
"predecrement( 
s_var 
) 
=> n_result"
"Takes a variable, decrements its value by one, stores the new value back into the variable, and returns the new value. Prefix form of --s. The name of the variable must be a symbol and the value must be a number.")
("preincrement"
"preincrement( 
s_var 
) 
=> n_result"
"Takes a variable, increments its value by one, stores the new value back into the variable, and returns the new value. Prefix form of ++s. The name of the variable must be a symbol and the value must be a number.")
("pushf"
"pushf( 
g_obj
g_place
) 
=> g_newPlaceValue"
"A push that uses the setf function. It modifies the contents of the original storage location.")
("putprop"
"putprop( 
sl_id 
g_value 
S_name 
) 
=> g_value"
"Adds properties to symbols or disembodied property lists.")
("putpropq"
"putpropq( 
sl_id 
g_value 
S_name 
) 
=> g_value

sl_id->S_name = g_value 
=> g_value"
"Adds properties to symbols or disembodied property lists. Identical to putprop except that S_name is not evaluated. If the property already exists, the old value is replaced with a new one.")
("putpropqq"
"putpropqq( 
s_id 
g_value 
S_name 
) 
=> g_value

s_id.S_name = g_value 
=> g_value"
"Adds properties to symbols. Identical to putprop except that sl_id and S_name are not evaluated. If the property already exists, the old value is replaced with a new one.")
("quote"
"quote( 
g_expr 
) 
=> g_result"
"Returns the name of the variable or the expression. Prefix form of the ' operator. Quoting is used to prevent expressions from being evaluated.")
("remprop"
"remprop( 
sl_id 
S_name 
) 
=> l_result / nil"
"Removes a property from a property list and returns the property's former value.")
("rotatef"
"rotatef( 
[ gplace1 ]
[ gplace2 ]
.....
[ gplacen ]
) 
=> g_newPlaceValues"
"Modifies the value of each place by rotating the values from one place to another in a cyclic order.")
("set"
"set( 
s_variableName 
g_newValue 
[ e_environment ]
) 
=> g_result"
"Sets a variable to a new value. Similar to setq but the first argument for set is evaluated.")
("setf"
"setf( 
g_place 
g_value 
) 
=> g_result

setf( 
g_place := g_value
=> g_result"
"Assigns a new value to an existing storage location, destroying the value that was previously in that location. setf is the same as the assignment (:=) operator. This is a syntax form.")
("setf_<helper>"
"setf_<helper>( 
g_new
[ g_cell ]
) 
=> g_result"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with the expander name. For a list of the helper functions, see setf Helper Functions.")
("setguard"
"setguard( 
s_symbol 
g_guard 
) 
=> u_guard"
"Mainly enforces disciplined use of a symbol as a global variable by associating it with a guarding function that is either a symbol that identifies the name of the guarding function or a lambda form (just like the first argument to the apply function). If the guarding function is nil, the symbol is unguarded. The guarding function is called with two arguments whenever a new value is assigned to the symbol: the symbol and the value to be assigned to it. The result of the guarding function determines the setguard return value that gets assigned to the symbol.")
("setplist"
"setplist( 
s_atom 
l_plist 
) 
=> l_plist"
"Sets the property list of an object to a new property list; the old property list attached to the object is lost.")
("setq"
"setq( 
s_variableName 
g_newValueExp 
) 
=> g_result

setq( 
s_variableName = g_newValue 
) 
=> g_result"
"Sets a variable to a new value. setq is the same as the assignment (=) operator. This is a syntax form.")
("setSG"
"setSG(
g_obj
S_prop
g_value
)
=>g_propValue"
"Evaluates and then sets the value for the specified attribute or property. It is a lambda implementation of setSGq().")
("symbolp"
"symbolp( 
g_value 
) 
=> t / nil"
"Checks if an object is a symbol.")
("symeval"
"symeval( 
s_symbol 
[ e_environment ] 
) 
=> g_result"
"Returns the value of the named variable.")
("symstrp"
"symstrp( 
g_value 
) 
=> t / nil"
"Checks if an object is either a symbol or a string.")
("charToInt"
"charToInt( 
s_char 
) 
=> x_ascii"
"Returns the ASCII code of the first character of the given symbol. In SKILL, a single character symbol can be used as a character value.")
("intToChar"
"intToChar( 
x_ascii 
) 
=> s_char"
"Returns the single-character symbol whose ASCII code is the given integer value.")
("listToVector"
"listToVector( 
l_list 
) 
=> a_vectorArray"
"Returns a vector (array) filled with the elements from the given list.")
("stringToFunction"
"stringToFunction( 
t_string 
[ s_langMode ] 
) 
=> u_function"
"Wraps and converts a string of SKILL code into a parameterless SKILL function.")
("stringToSymbol"
"stringToSymbol( 
t_string 
) 
=> s_symbolName"
"Converts a string to a symbol of the same name.")
("stringToTime"
"stringToTime( 
t_time 
) 
=> x_time"
"Given a date and time string, returns an integer time value representation. The time argument must be in the format as returned by the timeToString function, such as: Dec 28 16:57:06 1996.")
("symbolToString"
"symbolToString( 
s_symbolName 
) 
=> t_string"
"Converts a symbol to a string of the same name. Same as get_pname.")
("tableToList"
"tableToList( 
o_table 
) 
=> l_assoc_list"
"Converts the contents of an association table to an association list. Use this function interactively to look at the contents of a table.")
("timeToString"
"timeToString( 
x_time 
) 
=> t_time / nil"
"Takes an integer UNIX time value, returns a formatted string that the value denotes. The string is always in a form like: Dec 28 16:57:06 1994.")
("timeToTm"
"timeToTm( 
x_time 
) 
=> r_tm"
"Given an integer time value, returns a tm structure.")
("tmToTime"
"tmToTime( 
r_tm 
) 
=> x_time"
"Given a tm structure, returns the integer value of the time it represents.")
("vectorToList"
"vectorToList( 
a_vectorArray 
)
=> l_list"
"Returns a list containing the elements of an array.")
("blankstrp"
"blankstrp( 
t_string 
) 
=> t / nil"
"Checks if the given string is empty or has blank space characters only and returns true. If there are non-space characters blankstrp returns nil.")
("buildString"
"buildString( 
l_strings 
[ S_glueCharacters ] 
) 
=> t_string"
"Concatenates a list of strings with specified separation characters.")
("getchar"
"getchar( 
S_arg 
x_index 
) 
=> s_char / nil"
"Returns an indexed character of a string or the print name if the string is a symbol. Unlike the C library, the getc and getchar SKILL functions are totally unrelated.")
("index"
"index( 
t_string1 
S_string2 
) 
=> t_result / nil"
"Returns a string consisting of the remainder of string1 beginning with the first occurrence of string2.")
("lowerCase"
"lowerCase( 
S_string 
) 
=> t_result"
"Returns a string that is a copy of the given argument with uppercase alphabetic characters replaced by their lowercase equivalents.")
("lsprintf"
"lsprintf( 
t_formatString
[ g_arg1 ... ] 
) 
=> t_string"
"Returns a string according to the provided format. lsprintf is a lambda version of the sprintf function that can be used as an argument with apply or funcall.")
("nindex"
"nindex( 
t_string1 
S_string2 ) 
=> x_result / nil"
"Finds the symbol or string, S_string2, in t_string1 and returns the character index, starting from one, of the first point at which the S_string2 matches part of t_string1.")
("outstringp"
"outstringp( 
g_port 
) 
=> t / nil"
"Checks whether the specified value is an outstring port.")
("parseString"
"parseString( 
S_string 
[ S_breakCharacters ] 
[ g_insertEmptyString ] 
) 
=> l_strings"
"Breaks a string into a list of substrings with break characters.")
("pcreCompile"
"pcreCompile( 
t_pattern 
[ x_options ] 
) 
=> o_comPatObj / nil"
"Compiles a regular expression string pattern (t_pattern) into an internal representation that you can use in a pcreExecute function call. The compilation method is PCRE/Perl-compatible. You can use a second (optional) argument to specify independent option bits for controlling pattern compilation. You can set and unset the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and PCRE_EXTENDED independent option bits from within the pattern. The content of the options argument specifies the initial setting at the start of compilation. You can set the PCRE_ANCHORED option at matching time and at compile time.")
("pcreExecute"
"pcreExecute( 
o_comPatObj 
S_subject 
[ x_options ] 
) 
=> t / nil"
"Matches the subject string or symbol (S_subject) against a previously compiled pattern set up by the last pcreCompile call (o_comPatObj). The matching algorithm is PCRE/Perl-compatible. You can use a third (optional) argument to specify independent option bits for controlling pattern matching. You can use this function in conjunction with pcreCompile to match several subject strings or symbols against a single pattern.")
("pcreGenCompileOptBits"
"pcreGenCompileOptBits( 
[ ?caseLess  g_setCaseLessp ]
[ ?multiLine g_setMultiLinep ]
[ ?dotAll    g_setDotAllp ]
[ ?extended  g_setExtendedp ]
[ ?anchored  g_setAnchoredp ]
[ ?dollar_endonly g_setDollarEndonlyp ]
[ ?ungreedy  g_setUngreedyp ]
[ ?no_auto_capture g_setNoAutoCapturep ]
[ ?firstline g_setFirstlinep ]
) 
=> x_resultOptBits"
"Generates bitwise inclusive OR-bor()-of zero or more independent option bits that affect compilation so that you can specify them symbolically in the pcreCompile function. If you call pcreGenCompileOptBits with no arguments, the function returns a zero (options have their default settings).")
("pcreGenExecOptBits"
"pcreGenExecOptBits( 
[ ?anchored g_setAnchoredp ]
[ ?notbol   g_setNotbolp ]
[ ?noteol   g_setNoteolp ]
[ ?notempty g_setNotemptyp ]
[ ?partial  g_setPartialp ]
)
=> x_resultOptBits"
"Generates bitwise inclusive OR-bor()-of zero or more independent option bits that affect pattern matching so that you can specify them symbolically in the pcreExecute function. If you call pcreGenExecOptBits with no arguments, the function returns a zero (options have their default settings).")
("pcreGetRecursionLimit"
"pcreGetRecursionLimit()
=> x_value"
"Returns the PCRE maximum recursion depth (stack depth) that is set by the pcreSetRecursionLimit() function. The default value is 10000000.")
("pcreListCompileOptBits"
"pcreListCompileOptBits()
=> t"
"Displays information about the options used with pcreGenCompileOptBits. See the description of pcreGenCompileOptBits for more information.")
("pcreListExecOptBits"
"pcreListExecOptBits()
=> t"
"Displays information about the options used with pcreGenExecOptBits. See the description of pcreGenExecOptBits for more information.")
("pcreMatchAssocList"
"pcreMatchAssocList( 
g_pattern 
l_subjects 
[ x_compOptBits ] 
[ x_execOptBits ]
) 
=> l_results / nil / error message(s)"
"Matches the keys of an association list of subjects (strings or symbols) against a regular expression pattern (g_pattern) and returns an association list of those elements that match. The keys are the first elements of each key/value pair in the association list. You can use optional arguments to specify independent option bits for controlling pattern compiling and matching. The compiling and matching algorithms are PCRE/Perl-compatible.")
("pcreMatchList"
"pcreMatchList( 
g_pattern 
l_subjects 
[ x_compOptBits ] 
[ x_execOptBits ]
) 
=> l_results / nil / error message(s)"
"Matches a list of subjects (strings or symbols) against a regular expression pattern (g_pattern) and returns a list of those elements that match. You can use optional arguments to specify independent option bits for controlling pattern compiling and matching. The compiling and matching algorithms are PCRE/Perl-compatible.")
("pcreMatchp"
"pcreMatchp( 
g_pattern 
S_subject 
[ x_compOptBits ] 
[ x_execOptBits ] 
) 
=> t / nil"
"Checks to see whether the subject string or symbol (S_subject) matches the specified regular expression pattern (g_pattern). You can use optional arguments to specify independent option bits for controlling pattern compiling and matching. The compiling and matching algorithms are PCRE/Perl-compatible. For greater efficiency when matching a number of subjects against a single pattern, you should use pcreCompile and pcreExecute.")
("pcreObjectp"
"pcreObjectp( 
g_arg 
) 
=> t / nil"
"Checks to see whether the given argument is a pcreObject or not.")
("pcrePrintLastMatchErr"
"pcrePrintLastMatchErr( 
o_patMatchObj 
) 
=> t / nil"
"Prints the error message associated with the last failed matching operation (that is, when pcreExecute returns nil).")
("pcreReplace"
"pcreReplace( 
o_comPatObj 
t_source 
t_replacement 
x_index 
[ x_options ] ) 
=> t_result / t_source"
"Replaces one or all occurrences of a previously-compiled regular expression in the given source string with the specified replacement string. The integer index indicates which of the matching substrings to replace. If the index is less than or equal to zero, the function applies the replacement string to all matching substrings. You can use an optional argument to specify independent option bits for controlling pattern matching. The matching algorithm is PCRE/Perl-compatible.")
("pcreSetRecursionLimit"
"pcreSetRecursionLimit(
x_maxDepth
)
=> t"
"Sets the maximum recursion depth for SKILL/PCRE match algorithms. The maximum recursion depth needs to be set for systems that have a low stack depth, in order to prevent crashes while using SKILL PCRE functions.")
("pcreSubpatCount"
"pcreSubpatCount( 
o_pcreObj
) 
=> x_count"
"Counts the subpatterns in a PCRE pattern.")
("pcreSubstitute"
"pcreSubstitute( 
[o_pcreObject]
t_string 
) 
=> t_result / nil"
"If o_pcreObject is not provided, pcreSubstitute copies the input string and substitutes all pattern tags in it using the corresponding matched strings from the last pcreExecute/pcreMatch* operation.")
("readstring"
"readstring( 
t_string 
) 
=> g_result / nil"
"Returns the first expression in a string. Subsequent expressions in the string are ignored. The expression is not processed in any way.")
("rexCompile"
"rexCompile( 
t_pattern 
) 
=> t / nil"
"Compiles a regular expression string pattern into an internal representation to be used by succeeding calls to rexExecute.")
("rexExecute"
"rexExecute( 
S_target 
) 
=> t / nil"
"Matches a string or symbol against the previously compiled pattern set up by the last rexCompile call.")
("rexMagic"
"rexMagic( 
[ g_state ] 
) 
=> t / nil"
"Turns on or off the special interpretation associated with the meta-characters in regular expressions.")
("rexMatchAssocList"
"rexMatchAssocList( 
t_pattern 
l_targets 
) 
=> l_results / nil"
"Returns a new association list created out of those elements of the given association list whose key matches a regular expression pattern. The supplied regular expression pattern overwrites the previously compiled pattern and is used for subsequent matching until the next new pattern is provided.")
("rexMatchList"
"rexMatchList( 
t_pattern 
l_targets 
) 
=> l_results / nil"
"Creates a new list of those strings or symbols in the given list that match a regular expression pattern. The supplied regular expression pattern overwrites the previously compiled pattern and is used for subsequent matching until the next new pattern is provided.")
("rexMatchp"
"rexMatchp( 
t_pattern 
S_target 
) 
=> t / nil"
"Checks to see if a string or symbol matches a given regular expression pattern. The supplied regular expression pattern overwrites the previously compiled pattern and is used for subsequent matching until the next new pattern is provided.")
("rexReplace"
"rexReplace( 
t_source 
t_replacement 
x_index 
) 
=> t_result"
"Returns a copy of the source string in which the specified substring instances that match the last compiled regular expression are replaced with the given string.")
("rexSubstitute"
"rexSubstitute( 
t_string 
) 
=> t_result / nil"
"Substitutes the pattern tags in the argument string with previously matched (sub)strings.")
("rindex"
"rindex( 
t_string1 
S_string2 
) 
=> t_result / nil"
"Returns a string consisting of the remainder of string1 beginning with the last occurrence of string2.")
("sprintf"
"sprintf( 
{s_Var | nil } 
t_formatString 
[ g_arg1 ... ] 
) 
=> t_string"
"Formats the output and assigns the resultant string to the variable given as the first argument.")
("strcat"
"strcat( 
S_string1 
[ S_string2 ... ] 
) 
=> t_result"
"Takes input strings or symbols and concatenates them.")
("strcmp"
"strcmp( 
t_string1 
t_string2 
) 
=> 1 / 0 / -1"
"Compares two argument strings alphabetically.")
("stringp"
"stringp( 
g_value 
) 
=> t / nil"
"Checks if an object is a string.")
("strlen"
"strlen( 
t_string 
) 
=> x_length"
"Returns the number of characters in a string.")
("strncat"
"strncat( 
t_string1 
t_string2 
x_max 
) 
=> t_result"
"Creates a new string by appending a maximum number of characters from t_string2 to t_string1.")
("strncmp"
"strncmp( 
t_string1 
t_string2 
x_max 
) 
=> 1 / 0 / -1"
"Compares two argument strings alphabetically only up to a maximum number of characters.")
("strpbrk"
"strpbrk( 
t_str1
t_str2
) 
=> t_subStr / nil"
"Returns a substring of the first occurence in t_str1 of any character from the string pointed to by t_str2")
("subst"
"subst( 
g_x 
g_y 
l_arg 
) 
=> l_result"
"Substitutes one object for another object in a list.")
("substring"
"substring( 
S_string 
x_index 
[ x_length ] 
) 
=> t_result / nil"
"Creates a new substring from an input string, starting at an index point and continuing for a given length.")
("upperCase"
"upperCase( 
S_string 
) 
=> t_result"
"Returns a string that is a copy of the given argument with the lowercase alphabetic characters replaced by their uppercase equivalents.")
("abs"
"abs( 
n_number 
) 
=> n_result"
"Returns the absolute value of a floating-point number or integer.")
("add1"
"add1( 
n_number 
) 
=> n_result"
"Adds one to a floating-point number or integer.")
("atof"
"atof( 
t_string [t]
) 
=> f_result / nil"
"Converts a string into a floating-point number. Returns nil if the given string does not denote a number.")
("atoi"
"atoi( 
t_string [t]
) 
=> x_result / nil"
"Converts a string into an integer. Returns nil if the given string does not denote an integer.")
("ceiling"
"ceiling( 
n_number 
) 
=> x_integer"
"Returns the smallest integer not smaller than the given argument.")
("defMathConstants"
"defMathConstants( 
s_id 
) 
=> s_id"
"Associates a set of predefined math constants as properties of the given symbol.")
("difference"
"difference( 
n_op1 
n_op2 
[ n_op3 ... ] 
) 
=> n_result"
"Returns the result of subtracting one or more operands from the first operand. Prefix form of the - arithmetic operator.")
("evenp"
"evenp( 
g_general 
) 
=> t / nil"
"Checks if a number is an even integer.")
("exp"
"exp( 
n_number 
) 
=> f_result"
"Raises e to a given power.")
("expt"
"expt( 
n_base 
n_power 
) 
=> n_result"
"Returns the result of raising a base number to a power. Prefix form of the ** exponentiation operator.")
("fix"
"fix( 
n_arg 
) 
=> x_result"
"Returns the largest integer not larger than the given argument.")
("fixp"
"fixp( 
g_value 
) 
=> t / nil"
"Checks if an object is an integer, that is, a fixed number.")
("fix2"
"fix2( 
n_value 
) 
=> x_result / nil"
"This function is a version of the fix function that works for rounding issue in floating-point calculations. The function returns the largest integer not larger than the given argument.")
("float"
"float( 
n_arg 
) 
=> f_result"
"Converts a number into its equivalent floating-point number.")
("floatp"
"floatp( 
g_value 
) 
=> t / nil"
"Checks if an object is a floating-point number. Same as realp.")
("floor"
"floor( 
n_number 
) 
=> x_integer"
"Returns the largest integer not larger than the given argument.")
("int"
"int( 
g_value
) 
=> x_result"
"Rounds off the number value to the nearest integer. The int function works as an overloadable arithmetic operator adopted from DFII to the SKILL Core language. The argument (g_value) is specified on the number class (numberp arguments).")
("isInfinity"
"isInfinity( 
f_flownum 
) 
=> t / nil"
"Checks if the given flownum argument represents infinity (positive or negative).")
("isNaN"
"isNaN( 
f_flownum 
) 
=> t / nil"
"Checks if the given flownum argument represents NaN (not-a-number), nil otherwise.")
("leftshift"
"leftshift( 
x_val 
x_num 
) 
=> x_result"
"Returns the integer result of shifting a value a specified number of bits to the left. Prefix form of the << arithmetic operator. leftshift is logical (that is, vacated bits are 0-filled).")
("log"
"log( 
n_number 
) 
=> f_result"
"Returns the natural logarithm of a floating-point number or integer.")
("log10"
"log10( 
n_number 
) 
=> f_result"
"Returns the base 10 logarithm of a floating-point number or integer.")
("max"
"max( 
n_num1 
[ n_num2 ... ]
) 
=> n_result"
"Returns the maximum of the values passed in. Requires a minimum of one argument.")
("min"
"min( 
n_num1 
[ n_num2 ... ] 
)
=> n_result"
"Returns the minimum of the values passed in. Requires a minimum of one argument.")
("minus"
"minus( 
n_op 
) 
=> n_result"
"Returns the negative of a number. Prefix form of the - unary operator.")
("minusp"
"minusp( 
g_general 
) 
=> t / nil"
"Checks if a value is a negative number. Same as negativep.")
("mod"
"mod( 
x_integer1 
x_integer2 
) 
=> x_result"
"Returns the integer remainder of dividing two integers. The remainder is either zero or has the sign of the dividend.")
("modf"
"modf( 
f_flonum1
f_flonum2 
) 
=> f_result"
"Returns the floating-point remainder of the division of f_flonum1 by f_flonum2.")
("modulo"
"modulo( 
x_integer1 
x_integer2 
)
=> x_integer"
"Returns the remainder of dividing two integers. The remainder always has the sign of the divisor.")
("nearlyEqual"
"nearlyEqual( 
n_val1 n_val2 
[f_relTolerance [f_absTolerance]] 
) 
=> t / nil"
"Checks if one value (n_val1) is approximately equal to another value (n_val2).")
("negativep"
"negativep( 
n_num 
) 
=> t / nil"
"Checks if a value is a negative number. Same as minusp.")
("oddp"
"oddp( 
g_value 
) 
=> t / nil"
"Checks if an object is an odd integer.")
("onep"
"onep( 
g_value 
) 
=> t / nil"
"Checks if the given object is equal to one.")
("plus"
"plus( 
n_op1 
n_op2 
[ n_op3 ... ] 
) 
=> n_result"
"Returns the result of adding one or more operands to the first operand. Prefix form of the + arithmetic operator.")
("plusp"
"plusp( 
g_value 
) 
=> t / nil"
"Checks if the given object is a positive number.")
("quotient"
"quotient( 
n_op1 
n_op2 
[ n_op3 ... ] 
) 
=> n_result"
"Returns the result of dividing the first operand by one or more operands. Prefix form of the / arithmetic operator.")
("random"
"random( 
[ x_number ] 
) 
=> x_result"
"Returns a random integer between zero and a given number minus one.")
("realp"
"realp( 
g_obj 
) 
=> t / nil"
"Checks if a value is a real number. Same as floatp.")
("remainder"
"remainder( 
x_integer1 
x_integer2 
) 
=> x_integer"
"Returns the remainder of dividing two integers. The remainder is either zero or has the sign of the dividend. Same as mod.")
("rightshift"
"rightshift( 
x_val 
x_num 
) 
=> x_result"
"Returns the integer result of shifting a value a specified number of bits to the right. Prefix form of the >> arithmetic operator. rightshift is logical (that is, vacated bits are 0-filled).")
("round"
"round( 
n_arg 
) 
=>  x_result"
"Rounds a floating-point number to its closest integer value.")
("round2"
"round2( 
n_arg 
) 
=>  x_result"
"This function is a version of the round function that rounds the result in floating-point calculations to its closest integer value.")
("sort"
"sort( 
l_data 
u_comparefn 
) 
=> l_result"
"Sorts a list according to the specified comparison function; defaults to an alphabetical sort when u_comparefn is nil. This function does not create a new list. It returns the altered input list. This is a destructive operation. The l_data list is modified in place and no new storage is allocated. Pointers previously pointing to l_data may not be pointing at the head of the sorted list.")
("sortcar"
"sortcar( 
l_data 
u_comparefn 
) 
=> l_result"
"Similar to sort except that only the car of each element in a list is used for comparison by the sort function. This function does not create a new list. It returns the altered input list.")
("sqrt"
"sqrt( 
n_number 
) 
=> f_result"
"Returns the square root of a floating-point number or integer.")
("srandom"
"srandom( 
x_number 
) 
=> t"
"Sets the seed of the random number generator to a given number.")
("sub1"
"sub1( 
n_number 
) 
=> n_result"
"Subtracts one from a floating-point number or integer.")
("times"
"times( 
n_op1 
n_op2 
[ n_op3 ... ] 
) 
=> n_result"
"Returns the result of multiplying the first operand by one or more operands. Prefix form of the * arithmetic operator.")
("truncate"
"truncate( 
n_number 
) 
=> x_integer"
"Truncates a given number to an integer.")
("xdifference"
"xdifference( 
x_op1 
x_op2 
[ x_opt3 ] 
) 
=> x_result"
"Returns the integer result of subtracting one or more operands from the first operand. xdifference is an integer-only arithmetic function while difference can handle integers and floating-point numbers. xdifference runs slightly faster than difference in integer arithmetic calculation.")
("xplus"
"xplus( 
x_op1 
x_op2 
[ x_opt3 ] 
) 
=> x_result"
"Returns the integer result of adding one or more operands to the first operand. xplus is an integer-only arithmetic function while plus can handle integers and floating-point numbers. xplus runs slightly faster than plus in integer arithmetic calculation.")
("xquotient"
"xquotient( 
x_op1 
x_op2 
[ x_opt3 ] 
) 
=> x_result"
"Returns the integer result of dividing the first operand by one or more operands. xquotient is an integer-only arithmetic function while quotient can handle integers and floating-point numbers. xquotient runs slightly faster than quotient in integer arithmetic calculation.")
("xtimes"
"xtimes( 
x_op1 
x_op2 
[ x_opt3 ] 
) 
=> x_result"
"Returns the integer result of multiplying the first operand by one or more operands. xtimes is an integer-only arithmetic function while times can handle integers and floating-point numbers. xtimes runs slightly faster than times in integer arithmetic calculation.")
("zerop"
"zerop( 
g_value 
) 
=> t / nil"
"Checks if an object is equal to zero.")
("zxtd"
"zxtd( 
x_number 
x_bits 
) 
=> x_result"
"Zero-extends the number represented by the rightmost specified number of bits in the given integer.")
("band"
"band( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean AND operation on each parallel pair of bits in each operand. Prefix form of the & bitwise operator.")
("bitfield"
"bitfield( 
x_val 
x_msb 
x_lsb 
) 
=> x_result"
"Returns the value of a specified set of bits of a specified integer. Prefix form of the <:> operator.")
("bitfield1"
"bitfield1( 
x_val 
x_bitPosition 
) 
=> x_result"
"Returns the value of a specified bit of a specified integer. Prefix form of the <> operator.")
("bnand"
"bnand( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean NAND operation on each parallel pair of bits in each operand. Prefix form of the ~& bitwise operator.")
("bnor"
"bnor( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean NOR operation on each parallel pair of bits in each operand. Prefix form of the ~| bitwise operator.")
("bnot"
"bnot( 
x_op 
) 
=> x_result"
"Returns the integer result of the Boolean NOT operation on each parallel pair of bits in each operand. Prefix form of the ~ (one's complement) unary operator.")
("bor"
"bor( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean OR operation on each parallel pair of bits in each operand. Prefix form of the | bitwise operator.")
("bxnor"
"bxnor( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean XNOR operation on each parallel pair of bits in each operand. Prefix form of the ~^ bitwise operator.")
("bxor"
"bxor( 
x_op1 
x_op2 
[ x_op3 ... ] 
) 
=> x_result"
"Returns the integer result of the Boolean XOR operation on each parallel pair of bits in each operand. Prefix form of the ^ bitwise operator.")
("setqbitfield"
"setqbitfield( 
s_var 
x_val 
x_msb 
x_lsb 
) 
=> x_result"
"Sets a value into a set of bits in the bit field specified by the variable s_var, stores the new value back into the variable, and then returns the new value. Prefix form of the <:>= operator.")
("setqbitfield1"
"setqbitfield1( 
s_var 
x_val 
x_bitPosition 
) 
=> x_result"
"Sets a value into a single bit in the bit field specified by the variable s_var, stores the new value back into the variable, and then returns the new value. Prefix form of the <>= operator.")
("asin"
"asin( 
n_number 
) 
=> f_result"
"Returns the arc sine of a floating-point number or integer.")
("atan"
"atan( 
n_number 
) 
=> f_result"
"Returns the arc tangent of a floating-point number or integer.")
("atan2"
"atan2(
n_y
n_x
) 
=> f_result"
"Computes the principal value of the arc tangent of n_y/n_x, using the signs of both arguments to determine the quadrant of the return value.")
("cos"
"cos( 
n_number 
) 
=> f_result"
"Returns the cosine of a floating-point number or integer.")
("sin"
"sin( 
n_number 
) 
=> f_result"
"Returns the sine of a floating-point number or integer.")
("tan"
"tan( 
n_number 
) 
=> f_result"
"Returns the tangent of a floating-point number or integer.")
("acos"
"acos( 
n_number 
) 
=> f_result"
"Returns the arc cosine of a floating-point number or integer.")
("alphalessp"
"alphalessp( 
S_arg1 
S_arg2 
) 
=> t / nil"
"Compares two string or symbol names alphabetically.")
("and"
"and( 
g_arg1 
g_arg2 
[ g_arg3... ] 
) 
=> nil / g_val"
"Evaluates from left to right its arguments to see if the result is nil. As soon as an argument evaluates to nil, and returns nil without evaluating the rest of the arguments. Otherwise, and evaluates the next argument. If all arguments except for the last evaluate to non-nil, and returns the value of the last argument as the result of the function call. Prefix form of the && binary operator.")
("compareTime"
"compareTime( 
t_time1 
t_time2 
) 
=> x_difference"
"Compares two string arguments, representing a clock-calendar time.")
("eq"
"eq( 
g_arg1 
g_arg2 
) 
=> t / nil"
"Checks addresses when testing for equality.")
("equal"
"equal( 
g_arg1 
g_arg2 
) 
=> t / nil"
"Checks contents of strings and lists when testing for equality.")
("eqv"
"eqv( 
g_general1 
g_general2 
) 
=> t / nil"
"Tests for the equality between two strings or two numbers of the same type (for example, both numbers are integers). Except for numbers, eqv is like eq.")
("geqp"
"geqp( 
n_num1 
n_num2 
) 
=> t / nil"
"This predicate function checks if the first argument is greater than or equal to the second argument. Prefix form of the >= operator.")
("greaterp"
"greaterp( 
n_num1 
n_num2 
) 
=> t / nil"
"This predicate function checks if the first argument is greater than the second argument. Prefix form of the > operator.")
("leqp"
"leqp( 
n_num1 
n_num2 
) 
=> t / nil"
"This predicate function checks if the first argument is less than or equal to the second argument. Prefix form of the <= operator.")
("lessp"
"lessp( 
n_num1 
n_num2 
) 
=> t / nil"
"This predicate function checks if the first argument is less than the second argument. Prefix form of the < operator.")
("member, memq, memv"
"member( 
g_obj 
g_arg 
) 
=> l_sublist / t / nil"
"Returns the largest sublist of l_list whose first element is g_obj or checks whether the key g_obj exists in the association table. For comparison, member uses the equal function, memq uses the eq function, and memv uses eqv.")
("neq"
"neq( 
g_arg1 
g_arg2 
) 
=> t / nil"
"Checks if two arguments are not identical using the eq function and returns t if they are not. That is, g_arg1 and g_arg2 are tested to see if they are at the same address in memory.")
("nequal"
"nequal( 
g_arg1 
g_arg2 
) 
=> t / nil"
"Checks if two arguments are not logically equivalent using the equal function and returns t if they are not.")
("null"
"null( 
g_value 
) 
=> t / nil"
"Checks if an object is equal to nil.")
("numberp"
"numberp( 
g_value 
) 
=> t / nil"
"Checks if a data object is a number, that is, either an integer or floating-point number.")
("or"
"or( 
g_arg1 
g_arg2 
[ g_arg3... ] 
) 
=> nil / g_val"
"Evaluates from left to right its arguments to see if the result is non-nil. As soon as an argument evaluates to non-nil, or returns that value without evaluating the rest of the arguments. If all arguments except the last evaluate to nil, or returns the value of the last argument as the result of the function call. Prefix form of the || binary operator.")
("sxtd"
"sxtd( 
x_number 
x_bits 
) 
=> x_result"
"Sign-extends the number represented by the rightmost specified number of bits in the given integer.")
("case"
"case( 
g_keyForm 
l_clause1 
[ l_clause2 ... ] 
) 
=> g_result / nil"
"Branches to one of the clauses depending on the value of the given expression. caseq() evaluates g_keyForm and matches the resulting value sequentially against the clauses until it finds a match. Once a match is found it stops searching the clauses, evaluates the forms in the matching clause, and returns the resulting value. This is a syntax function.")
("caseq"
"caseq( 
g_keyForm 
l_clause1 
[ l_clause2 ... ] 
) 
=> g_result / nil"
"Works like the case() function, but uses eq() to find a matching clause instead of the equal() function. The keys used with caseq() should therefore not be strings or lists. In case you want to use a string value or a list, SKILL recommends using the case() function. See eq for details on the difference between the eq() and equal() functions.")
("catch"
"catch(
s_tag
g_form
) 
=> g_result"
"Establishes a control transfer or a return point for the throw and err functions. The return point is identified with a s_tag. So, when a particular tag/exception is caught, catch evaluates g_form. If the forms execute normally (without error), the value of the last body form is returned from the catch. There can also be nested catch blocks and s_tag can be t (the value t  the catch function catch any condition thrown by throw).")
("cond"
"cond( 
l_clause1 ... 
) 
=> g_result"
"Examines conditional clauses from left to right until either a clause is satisfied or there are no more clauses remaining. This is a syntax function.")
("decode"
"decode( 
g_keyForm 
l_clause1 
[ l_clause2 ... ] 
) 
=> g_result / nil"
"Branches to one of the clauses depending on the value of the given expression. decode() evaluates g_keyForm and matches the resulting value sequentially against the clauses until it finds a match. Once a match is found it stops searching the clauses, evaluates the forms in the matching clause, and returns the resulting value.")
("do"
"do( 
( 
( 
s_var1 
g_initExp1 
[ g_stepExp1 ] 
)
( 
s_var2 
g_initExp2 
[ g_stepExp2 ] 
) ... 
)
( 
g_terminationExp 
g_terminationExp1 ... 
)
            g_loopExp1 
            g_loopExp2 ... 
)
=> g_value"
"Iteratively executes one or more expressions. Used in SKILL++ mode only.")
("exists"
"exists( 
s_formalVar 
l_valueList 
g_predicateExpr 
)
=> g_result

exists( 
s_key 
o_table 
g_predicateExpr 
)
=> t / nil"
"Returns the first tail of l_valueList whose car satisfies a predicate expression. Also verifies whether an entry in an association table satisfies a predicate expression. This is a syntax form.")
("existss"
"existss( 
s_formalVar 
l_valueList 
g_predicateExpr 
)
=> g_result

existss( 
s_key 
o_table 
g_predicateExpr 
)
=> t / nil"
"Returns the first tail of l_valueList whose car satisfies a predicate expression. Also verifies whether an entry in an association table satisfies a predicate expression. In the SKILL++ mode, this function always locally wraps the loop or iterator local variable (s_formalVar) in a let block while compiling the code. Local wrapping preserves the lexical scope of the loop variable. This function may work slower than its non-wrapped counterpart exists. This is a syntax form.")
("for"
"for( 
s_loopVar
x_initialValue
x_finalValue
g_expr1
[ g_expr2 ... ]
)
=> t"
"Evaluates the sequence g_expr1, g_expr2 ... for each loop variable value, beginning with x_initialValue and ending with x_finalValue. This is a syntax form.")
("fors"
"fors( 
s_loopVar
x_initialValue
x_finalValue
g_expr1
[ g_expr2 ... ]
)
=> t"
"Evaluates the sequence g_expr1, g_expr2 ... for each loop variable value, beginning with x_initialValue and ending with x_finalValue. In the SKILL++ mode, this function always locally wraps the loop or iterator local variable (s_loopVar) in a let() block while compiling the code. Local wrapping preserves the lexical scope of the loop variable. This function may work slower than its non-wrapped counterpart for. This is a syntax form.")
("forall"
"forall(
s_formalVar
l_valueList
g_predicateExpr
)
=> t / nil
forall(
s_key
o_table
g_predicateExpr
)
=> t / nil"
"Checks if g_predicateExpr evaluates to non-nil for every element in l_valueList. This is a syntax form.")
("foralls"
"foralls( 
s_formalVar
l_valueList
g_predicateExpr
)
=> t / nil
foralls(
s_key
o_table
g_predicateExpr
)
=> t / nil"
"Checks if g_predicateExpr evaluates to non-nil for every element in l_valueList. In the SKILL++ mode, this function always locally wraps the loop or iterator local variable (s_formalVar) in a let block while compiling the code. Local wrapping preserves the lexical scope of the loop variable. This function may work slower than its non-wrapped counterpart forall. This is a syntax form.")
("foreach"
"foreach( 
s_formalVar 
g_exprList 
g_expr1 
[ g_expr2 ... ] 
)
=> l_valueList / l_result

foreach( 
( 
s_formalVar1... 
s_formalVarN 
) 
g_exprList1... 
g_exprListN 
g_expr1 
[ g_expr2 ... ] 
)
=> l_valueList / l_result

foreach( 
s_formalVar 
g_exprTable 
g_expr1 
[ g_expr2 ... ] 
)
=> o_valueTable / l_result"
"Evaluates one or more expressions for each element of a list of values. This is a syntax form.")
("foreachs"
"foreachs( 
s_formalVar 
g_exprList 
g_expr1 
[ g_expr2 ... ] 
)
=> l_valueList / l_result

foreachs( 
( 
s_formalVar1... 
s_formalVarN 
) 
g_exprList1... 
g_exprListN 
g_expr1 
[ g_expr2 ... ] 
)
=> l_valueList / l_result

foreachs( 
s_formalVar 
g_exprTable 
g_expr1 
[ g_expr2 ... ] 
)
=> o_valueTable / l_result"
"Evaluates one or more expressions for each element of a list of values. In the SKILL++ mode, this function always locally wraps the loop or iterator local variable, s_formalVar,in a let block while compiling the code. Local wrapping preserves the lexical scope of the loop variable. This function may work slower than its non-wrapped counterpart foreach. This is a syntax form.")
("if"
"if( 
g_condition 
g_thenExpression 
[ g_elseExpression ] 
) 
=> g_result

if( 
g_condition 
then g_thenExpr1 ... 
[ else g_elseExpr1 ... ] 
) 
=> g_result"
"Selectively evaluates two groups of one or more expressions. This is a syntax form.")
("go"
"go( 
s_label 
)"
"Transfers control to the statement following the label argument. This is a syntax form.")
("map"
"map( 
u_func 
l_arg1 
[ l_arg2 ... ] 
) 
=> l_arg1"
"Applies the given function to successive sublists of the argument lists and returns the first argument list. All of the lists should have the same length. This function is not the same as the standard Scheme map function. To get the behavior of the standard Scheme map function, use mapcar instead.")
("mapc"
"mapc( 
u_func 
l_arg1 
[ l_arg2 ... ] 
) 
=> l_arg1"
"Applies a function to successive elements of the argument lists and returns the first argument list. All of the lists should have the same length. mapc returns l_arg1.")
("mapcan"
"mapcan( 
u_func 
l_arg1 
[ l_arg2 ... ] 
) 
=> l_result"
"Applies a function to successive elements of the argument lists and returns the result of appending these intermediate results. All of the lists should have the same length.")
("mapcar"
"mapcar( 
u_func 
l_arg1 
[ l_arg2 ... ] 
) 
=> l_result"
"Applies a function to successive elements of the argument lists and returns the list of the corresponding results.")
("mapcon"
"mapcon( 
u_func 
l_arg1 
[l_arg2] 
) 
=> l_result"
"Applies the function u_func to successive sublists of the lists and returns a concatenated list.")
("mapinto"
"mapinto( 
l_resultSequence 
g_function 
({l_sequences}*)
) 
=> l_resultSequence"
"Applies g_function to the elements of l_sequences and destructively modifies the l_resultSequence. The first argument is a sequence that receives the results of the mapping. If l_resultSequence and the other argument sequences are not all of the same length, the mapping stops when the shortest of l_resultSequence or l_sequences is exhausted.")
("maplist"
"maplist( 
u_func 
l_arg1 
[ l_arg2 ... ] 
) 
=> l_result"
"Applies a function to successive sublists of the argument lists and returns a list of the corresponding results. All of the lists should have the same length.")
("not"
"not( 
g_obj 
) 
=> t / nil"
"Same as the ! operator. Returns t if the object is nil, and returns nil otherwise.")
("regExitAfter"
"regExitAfter( 
s_name 
) 
=> t / nil"
"Registers the action to be taken after the exit function has performed its bookkeeping tasks but before it returns control to the operating system.")
("regExitBefore"
"regExitBefore( 
s_name 
) 
=> t"
"Registers the action to be taken before the exit function is executed. If the function registered returns the ignoreExit symbol, the exit is aborted.")
("remExitProc"
"remExitProc( 
s_name 
) 
=> t"
"Removes a registered exit procedure.")
("return"
"return( 
[ g_result ] 
) 
=> g_result / nil"
"Forces the enclosing prog to exit and returns the given value. The return statement has meaning only when used inside a prog statement.")
("setof"
"setof( 
s_formalVar 
l_valueList 
g_predicateExpression 
)
=> l_result

setof( 
s_formalVar 
o_table 
g_predicateExpression 
)
=> l_result"
"Returns a new list containing only those elements in a list or the keys in an association table that satisfy an expression. This is a syntax form.")
("setofs"
"setofs( 
s_formalVar 
l_valueList 
g_predicateExpression 
)
=> l_result

setofs( 
s_formalVar 
o_table 
g_predicateExpression 
)
=> l_result"
"Returns a new list containing only those elements in a list or the keys in an association table that satisfy an expression. In the SKILL++ mode, this function always locally wraps the loop or iterator local variable (s_formalVar) in a let block while compiling the code. Local wrapping preserves the lexical scope of the loop variable. This function may work slower than its non-wrapped counterpart setof. This is a syntax form.")
("throw"
"throw(
s_tag
g_value
) 
=>"
"Transfers the control back to the return point established in a catch block. The argument value is used as the value to be passed. The throw function should always be used inside catch(. . . g_form . . .).")
("unless"
"unless( 
g_condition 
g_expr1 ... 
) 
=> g_result / nil"
"Evaluates a condition. If the result is true (non-nil), it returns nil; otherwise evaluates the body expressions in sequence and returns the value of the last expression. This is a syntax form.")
("when"
"when( 
g_condition 
g_expr1 ... 
) 
=> g_result / nil"
"Evaluates a condition. If the result is non-nil, evaluates the sequence of expressions and returns the value of the last expression. This is a syntax form.")
("while"
"while( 
g_condition 
g_expr1 ... 
) 
=> t"
"Repeatedly evaluates a condition and sequence of expressions until the condition evaluates to false. This is a syntax form.")
("close"
"close( 
p_port 
) 
=> t"
"Drains, closes, and frees a port.")
("compress"
"compress( 
t_sourceFile 
t_destFile 
) 
=> t / error message"
"Reduces the size of a SKILL file, which must be SKILL source code, and places the output into another file.")
("display"
"display( 
g_obj 
[ p_port ] 
) 
=> t / nil"
"Writes a representation of an object to the given port.")
("drain"
"drain( 
[ p_outputPort ] 
) 
=> t / nil"
"Writes out all characters that are in the output buffer of a port.")
("ed"
"ed( 
[ t_fileName ] 
) 
=> t / nil"
"Edits the named file.")
("edi"
"edi( 
[ t_fileName ] 
) 
=> t / nil"
"Edits the named file, then includes the file into SKILL.")
("edit"
"edit( 
S_object 
[ g_loadFlag ] 
) 
=> x_childId"
"Edits a file, function, or variable. This function only works if you are in graphical mode. This is an nlambda function.")
("edl"
"edl( 
[ t_fileName ] 
) 
=> t / nil"
"Edits the named file, then loads the file into SKILL.")
("encrypt"
"encrypt( 
t_sourceFile 
t_destFile 
[ t_password ] 
) 
=> t"
"Encrypts a SKILL file and places the output into another file.")
("expandMacroDeep"
"expandMacroDeep(
g_form
)
=> g_expandedForm"
"This function recursively expands all macros specified in g_form.")
("fileLength"
"fileLength( 
S_name 
) 
=> x_size / 0"
"Determines the number of bytes in a file.")
("fileSeek"
"fileSeek( 
p_port 
x_offset 
x_whence 
) 
=> t / nil"
"Sets the position for the next operation to be performed on the file opened on a port. The position is specified in bytes.")
("fileTell"
"fileTell( 
p_port 
) 
=> x_offset"
"Returns the current offset in bytes for the file opened on a port.")
("fileTimeModified"
"fileTimeModified( 
t_filename 
) 
=> x_time / nil"
"Gets the time a given file was last modified.")
("fprintf"
"fprintf( 
p_port 
t_formatString 
[ g_arg1 ... ] 
) 
=> t"
"Writes formatted output to a port.")
("fscanf, scanf, sscanf"
"fscanf( 
p_inputPort 
t_formatString 
[ s_var1 ... ] 
) 
=> x_items / nil

scanf( 
t_formatString 
[ s_var1 ... ] 
) 
=> x_items / nil

sscanf( 
t_sourceString 
t_formatString 
[ s_var1 ... ] 
) 
=> x_items / nil"
"The main difference between these functions is the source of input. fscanf reads input from a port according to format specifications and returns the number of items read in. scanf takes its input from piport implicitly. scanf only works in standalone SKILL when the piport is not the CIW. sscanf reads its input from a string instead of a port. Another difference is that whereas sscanf supports the width while reading floating-point numbers from the input string, fscanf and scanf do not.")
("get_filename"
"get_filename( 
p_port 
) 
=> s_result"
"Returns the file name of a port.")
("getc"
"getc( 
[ p_inputPort ] 
) 
=> s_char"
"Reads and returns a single character from an input port. Unlike the C library, the getc and getchar SKILL functions are totally unrelated.")
("getDirFiles"
"getDirFiles( 
S_name 
) 
=> l_strings"
"Returns a list of the names of all files and directories, including . and .., in a directory.")
("getOutstring"
"getOutstring( 
s_port) 
=> t_string / nil"
"Retrieves the content of the outstring port (while it is open).")
("gets"
"gets( 
g_variableName 
[ p_inputPort ] 
) 
=> t_string / nil"
"Reads a line from the input port and stores the line as a string in the variable. This is a macro.")
("include"
"include(
t_file)
=> t / error"
"Loads the file with name t_file in SKILL regardless of any errors in the file.")
("infile"
"infile( 
S_fileName 
) 
=> p_inport / nil"
"Opens an input port ready to read a file. Always remember to close the port when you are done.")
("info"
"info( 
t_formatString 
[ g_args1... ]
) 
=> nil"
"Prints the formatted output to poport according to the specification.")
("inportp"
"inportp( 
g_obj 
) 
=> t / nil"
"Checks if an object is an input port.")
("instring"
"instring( 
t_string 
) 
=> p_port"
"Opens a string for reading, just as infile would open a file.")
("isExecutable"
"isExecutable( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if you have permission to execute a file or search a directory.")
("isFile"
"isFile( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if a file exists and that it is not a directory.")
("isFileEncrypted"
"isFileEncrypted( 
S_name 
) 
=> t / nil"
"Checks if a file exists and is encrypted.")
("isFileName"
"isFileName( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if a file or directory exists.")
("isLargeFile"
"    isLargeFile(
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if a file is a large file (with size greater than 2GB).")
("isLink"
"isLink( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if a path exists and if it is a symbolic link.")
("isPortAtEOF"
"isPortAtEOF(
p_port
)
=> t / nil"
"Takes an input port and returns t if end-of-file (EOF) has previously been detected while reading the input port; it returns nil otherwise.")
("isReadable"
"isReadable( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if you have permission to read a file or list a directory. Uses the current SKILL path for relative paths. A path that is anchored to the current directory, for example, ./, ../, or ../../.., and so on, is not considered as a relative path.")
("isWritable"
"isWritable( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if you have permission to write to a file or update a directory. Uses the current SKILL path for relative paths. A path that is anchored to the current directory, for example, ./, ../, or ../../.., and so on, is not considered as a relative path.")
("lineread"
"lineread( 
[ p_inputPort ] 
) 
=> t / nil / l_results"
"Parses the next line in the input port into a list that you can further manipulate. It is used by the interpreter's top level to read in all input and understands SKILL and SKILL++ syntax.")
("linereadstring"
"linereadstring( 
t_string 
) 
=> g_value / nil"
"Executes lineread on a string and returns the first form read in. Anything after the first form is ignored.")
("load"
"load( 
t_fileName 
[ t_password ] 
) 
=> t"
"Opens a file, repeatedly calls lineread to read in the file, immediately evaluating each form after it is read in. Uses the file extension to determine the language mode (.il/.ile for SKILL and .ils/.ilse for SKILL++) for processing the language expressions contained in the file. By default, the loaded code is evaluated in dynamic scoping. However, if the extension is .ils/.ilse, lexical scoping is used. For a SKILL++ file, the loaded code is always evaluated in the top level environment.")
("loadi"
"loadi( 
t_fileName 
[ t_password ] 
) 
=> t"
"Identical to load, except that loadi ignores errors encountered during the load, prints an error message, and then continues loading.")
("loadPort"
"loadPort( 
p_port 
[?langMode g_langMode]
[?password g_password]
[?ignoreErrors g_ignoreErrors])
) 
=> t"
"Loads a SKILL file from p_port.")
("loadstring"
"loadstring( 
t_string 
[ s_langMode ] 
) 
=> t"
"Opens a string for reading, then parses and executes expressions stored in the string, just as load does in loading a file.")
("outstring"
"outstring( 
) 
=> p_openedPort / nil"
"Takes no arguments and returns an opened output port for strings (or an outport). After a port is opened, it can be used with functions, such as fprintf, println, and close that write to an output port. You need to use the getOutstring function to retrieve the content of output port (while it is open).")
("makeTempFileName"
"makeTempFileName( 
S_nameTemplate 
) 
=> t_name"
"Appends a string suffix to the last component of a path template so that the resulting composite string does not duplicate any existing file name.")
("newline"
"newline( 
[ p_outputPort ] 
) 
=> nil"
"Prints a newline (\n) character and then flushes the output port.")
("numOpenFiles"
"numOpenFiles( 
) 
=> ( x_current x_maximum )"
"Returns the number of files now open and the maximum number of files that a process can open. The numbers are returned as a two-element list.")
("openportp"
"openportp( 
g_obj 
) 
=> t / nil"
"Checks if the given argument is a port object and it is open (for input or output), nil otherwise.")
("outfile"
"outfile( 
S_fileName 
[ t_mode ] 
[ g_openHiddenFile ]
) 
=> p_outport / nil"
"Opens an output port ready to write to a file.")
("outportp"
"outportp( 
g_obj 
) 
=> t / nil"
"Checks if an object is an output port.")
("portp"
"portp( 
g_value 
) 
=> t / nil"
"Checks if an object is an input or output port.")
("pprint"
"pprint( 
g_value 
[ p_outputPort ] 
) 
=> nil"
"Identical to print except that it pretty prints the value whenever possible.")
("print"
"print( 
g_value 
[ p_outputPort ] 
) 
=> nil"
"Prints a SKILL object using the default format for the data type of the value.")
("printf"
"printf( 
t_formatString 
[ g_arg1 ... ] 
) 
=> t"
"Writes formatted output to poport.")
("printlev"
"printlev( 
g_value 
x_level 
x_length 
[ p_outputPort ] 
) 
=> nil"
"Prints a list with a limited number of elements and levels of nesting.")
("println"
"println( 
g_value 
[ p_outputPort ] 
) 
=> nil"
"Prints a SKILL object using the default format for the data type of the value, then prints a newline character.")
("putc"
"=> s_symbol"
"Puts the x_symbol to p_port (to complement getc function)")
("read"
"read( 
[ p_inputPort ] 
) 
=> g_result / nil / t"
"Parses and returns the next expression from an input port.")
("readTable"
"readTable( 
S_fileName 
o_table 
) 
=> t / nil"
"Reads and appends the contents of a file to an existing association table.")
("renameFile"
"renameFile( 
S_old 
S_new 
) 
=> t / nil"
"The renameFile() function changes the name of a file or directory.The S_old argument points to the pathname of the file or directory to be renamed. The S_new argument points to the new pathname of the file or directory. If the SKILL path is nil, renameFile() would search the current directory. Otherwise, the SKILL path would be searched first for S_old. A path that is anchored to the current directory, for example, ./, ../, or ../../.., and so on, is not considered as a relative path.")
("simplifyFilename"
"simplifyFilename( 
t_name 
[ g_dontResolveLinks ]
) 
=> t_result"
"Expands the name of a file to its full path.")
("simplifyFilenameUnique"
"simplifyFilenameUnique( 
t_path 
) 
=> t_fullPath / error message"
"Returns the full path for the given t_path without links and a trailing slash / at the end of the result string. The function returns an error if the given t_path is incorrect.")
("truename"
"truename( 
t_string 
) 
=> t_truename"
"Tries to find the specified file (t_string) and returns the full path to the file.")
("which"
"which( 
t_fileName 
) 
=> t_fullPath / nil"
"Returns the absolute path of the given context file, or regular file or directory.")
("write"
"write( 
g_value 
[ p_outputPort ] 
) 
=> nil"
"Prints a SKILL object using the default format for the data type of the value.")
("writeTable"
"writeTable( 
S_fileName 
o_table 
) 
=> t / nil"
"Writes the contents of an association table to a file with one key/value pair per line.")
("arglist"
"arglist( 
g_function 
) 
=> l_argumentList"
"Returns the number and types of arguments expected for a function. Also checks if the specified function is a binary object,")
("assert"
"assert( 
g_expression 
) 
=> nil"
"Enables you to insert assertions into the SKILL code, either at the top-level or within a function. It evaluates the expression (g_expression) and returns nil if the expression value is non-nil. Otherwise, throws an error and returns the unevaluated expression.")
("atom"
"atom( 
g_arg 
) 
=> t / nil"
"Checks if an object is an atom.")
("bcdp"
"bcdp( 
g_value 
) 
=> t / nil"
"Checks if an object is a binary primitive function.")
("booleanp"
"booleanp( 
g_obj 
) 
=> t / nil"
"Checks if an object is a boolean. Returns t if the object is t or nil. Returns nil otherwise.")
("boundp"
"boundp( 
s_arg 
[ e_environment ] 
) 
=> t / nil"
"Checks if the variable named by a symbol is bound, that is, has been assigned a value. The single argument form of boundp only works in SKILL mode.")
("describe"
"describe( 
[ s_symbol ] 
) 
=> t"
"Prints information about the symbol s_symbol. If the symbol has a function definition, information on the argument list and other available details will be printed. If the symbol has a variable definition, information about its value and function will be printed. If the function is called without any arguments, the help message will be printed.")
("fdoc"
"fdoc( 
s_function 
) 
=> t_doc / nil"
"Returns the documentation string for the function bound to the symbol s_function. SKILL switch saveInlineDoc must be set to save and retrieve the doc string.")
("gc"
"gc( 
[ t_string ] 
) 
=> nil"
"Forces a garbage collection. This function is also called by the system.")
("gensym"
"gensym( 
[ S_arg ] 
) 
=> s_result"
"Returns a new symbol based on the input argument.")
("getMuffleWarnings"
"getMuffleWarnings( 
) 
=> l_list"
"Returns a list of warnings that were called and suppressed by the preceding muffleWarnings command.")
("getSkillVersion"
"getSkillVersion( 
[g_printSubVersion]
) 
=> t_version"
"Returns the major version if the argument is left blank; otherwise, returns the current subversion (or tarkit version) of SKILL that is running in the build")
("get_pname"
"get_pname( 
s_arg 
) 
=> t_result"
"Returns the print name of a symbol as a string.")
("get_string"
"get_string( 
S_arg 
) 
=> t_result"
"Converts the argument to a string if it is a symbol. Otherwise it returns the string itself.")
("getVersion"
"getVersion( 
[ g_opt ] 
) 
=> t_[sub]version"
"Returns the version number of the Cadence software you are currently using. If you specify the optional argument g_opt, as t (or a non-nil value), the subversion number of the Cadence software currently used is returned. By default, the full version number, including the hotfix version, of the Cadence software currently used is returned.")
("getWarn"
"getWarn( 
) 
=> t_warning"
"Returns the buffered warning if it has not already been printed.")
("help"
"help( 
[ S_name ] 
) 
=> t / nil"
"Retrieves and prints the cdsFinder documentation strings for the given function name (a symbol). If the given name is a string, it is interpreted as a regular expression, and the entire cdsFinder database is searched for functions whose name or documentation string contains or matches the given string. Help is an nlambda function.")
("inScheme"
"inScheme( 
g_form 
) 
=> g_result"
"Evaluates a form as top-level SKILL++ code, disregarding the surrounding evaluation context.")
("inSkill"
"inSkill( 
g_form 
) 
=> g_result"
"Evaluates a form as top-level SKILL code, disregarding the surrounding evaluation context.")
("isVarImported"
"isVarImported( 
s_var 
) 
=> t / nil"
"Checks if the specified variable was imported into SKILL++ or not.")
("makeSymbol"
"makeSymbol( 
S_createSymbol 
[ t_namespaceArg ]
) 
=> s_result"
"Creates a symbol corresponding to the specified symbol or character string. In IC6.1.6 and later releases, optionally specify the namespace name (t_namespace) in which you want to create the symbol.")
("measureTime"
"measureTime( 
g_expression ... 
) 
=> l_result"
"Measures the time needed to evaluate an expression and returns a list with performance data (n_utime, n_stime, n_clockTime, and x_pageFaults) for the executed expressions. This is a syntax form.")
("muffleWarnings"
"muffleWarnings( 
g_expr1 ... 
) 
=> g_general"
"Returns the result of the last expression evaluated. If the last expression evaluated calls the warn function (either SKILL warn() or C-level ilWarn*), the related message is not printed out.")
("needNCells"
"needNCells( 
{s_cellType | S_userType} 
x_cellCount 
)
=> t / nil"
"Ensures that there is enough memory available for the specified number of SKILL objects (cells).")
("restoreFloat"
"restoreFloat( 
t_string 
) 
=> f_number"
"Restores a floating point number (f_number) from its serialized string (t_string) representation.")
("saveFloat"
"saveFloat( 
f_number 
) 
=> t_string"
"Serializes the given floating point number (f_number) to string (t_string).")
("schemeTopLevelEnv"
"schemeTopLevelEnv( 
) 
=> e_envobj"
"Returns the top level SKILL++ environment as an environment object.")
("setPrompts"
"setPrompts(
s_prompt1
s_prompt2
)
=> t / nil"
"Sets the prompt text string for the CIW. The first prompt is used to indicate the topmost top-level. The second prompt is used whenever a nested top-level is entered.")
("sstatus"
"sstatus( 
s_name 
g_switchValue 
) 
=> g_switchValue"
"Sets the internal system variable named to a given value. This is a syntax form.")
("status"
"status( 
s_name 
) 
=> g_switchValue"
"Returns the value of the internal system variable named. This nlambda function also works in SKILL++ mode.")
("theEnvironment"
"theEnvironment( 
[ u_funobj ] 
) 
=> e_environment / nil"
"(SKILL++ mode only) Returns the top level environment if called from a SKILL++ top-level. Returns the enclosing lexical environment if called within a SKILL++ function. Returns the associated environment if passed a SKILL++ function object. Otherwise returns nil.")
("unbindVar"
"unbindVar( 
s_varName 
) 
=> t"
"Resets a SKILL or Scheme variable so that its value becomes unbound..")
("addDefstructClass"
"addDefstructClass( 
s_name 
) 
=> u_classObject"
"Creates a class for the defstruct.")
("alias"
"alias( 
s_aliasName 
s_functionName 
)
=> s_aliasName"
"Defines a symbol as an alias for a function. This is an nlambda function.")
("apply"
"apply( 
slu_func 
[g_arg ...]
l_args
)
=> g_result"
"Applies the given function to the given argument list.")
("argc"
"argc(
) 
=> n / 0 / -1 / -2"
"Returns the number of arguments passed to a SKILL script. Used to enhance the SKILL script environment. This function works only for scripting with SKILL standalone executable (skill).")
("argv"
"argv( 
[ x_int ] 
) 
=> g_result"
"Returns the arguments passed to a SKILL script. Used to enhance the SKILL script environment. This function works only for scripting with SKILL standalone executable (skill).")
("begin"
"SKILL mode
begin( 
g_exp1 
[ g_exp2 ... 
g_expN ] 
) 
=> g_result
SKILL++ mode
begin( 
	def1 
	[ def2 ... 
		defN ] 
) 
=> g_result"
"In the SKILL mode, begin is a syntax form used to group a sequence of expressions. Evaluates expressions from left to right and returns the value of the last expression. Equivalent to progn. This expression type is used to sequence side effects such as input and output. Whereas, in the SKILL++ mode, begin is a syntax form used to group either a sequence of expressions or a sequence of definitions.")
("clearExitProcs"
"clearExitProcs( 
[ g_tcovItem ]
) 
=> t"
"Removes all registered exit procedures. When the optional argument g_tcovItem is set to t, it removes all exit procedures except those needed for the ilTCov reports.")
("declareLambda"
"declareLambda( 
s_name1 ... 
s_nameN 
) 
=> s_nameN"
"Tells the evaluator that certain (forward referenced) functions are of lambda type (as opposed to nlambda or macro).")
("declareNLambda"
"declareNLambda( 
s_name1 ... 
s_nameN 
) 
=> s_nameN"
"Tells the evaluator that certain (forward referenced) functions are of nlambda type (as opposed to lambdas or macros).")
("declareSQNLambda"
"declareSQNLambda( 
s_functionName ... 
) 
=> nil"
"Declares the given nlambda functions to be solely-quoting nlambdas.")
("defdynamic"
"defdynamic( 
s_varName 
g_Value
[ t_docString ]
) 
=> g_value"
"This syntax form sets the dynamic variable s_varName to g_value. In SKILL, this function works as a defvar. In Scheme, g_value is evaluated in the current lexical scope.")
("defglobalfun"
"defglobalfun( 
s_funcName 
( l_formalArglist ) 
g_expr1 ... 
)
=> s_funcName"
"Defines a global function with the name and formal argument list you specify.")
("define"
"define( 
s_var 
g_expression 
) 
=> s_var

define( 
( 
s_var 
[ s_formalVar1 ... ] 
) 
g_body ... 
) 
=> s_var"
"(SKILL++ mode only) Is a syntax form used to provide a definition for a global or local variable. The define syntax form has two variations.")
("define_syntax"
"define_syntax( 
s_name 
g_expander ... 
)
=> s_name"
"Creates a syntax rule using the syntax_rule expander form.")
("defmacro"
"defmacro( 
s_macroName 
( l_formalArglist ) 
g_expr1 ... 
)
=> s_macroName"
"Defines a macro which can take a list of formal arguments including @optional, @key, and @rest (instead of the more restrictive format as required by using mprocedure).")
("defsetf"
"defsetf( 
s_accessFn 
s_updateFn 
)
=> setf_<s_accessFn>"
"defsetf is a macro that allows you to extend generalized variables. It creates a setf_*() macro which is used in setf to update a value which can be accessed by s_accessFn().")
("defun"
"defun( 
s_funcName 
( l_formalArglist ) 
g_expr1 ... 
)
=> s_funcName"
"Defines a function with the name and formal argument list you specify. This is a syntax form.")
("defUserInitProc"
"defUserInitProc( 
t_contextName 
u_func 
[ autoInit ]
)
=> ( t_contextName s_procName )"
"Registers a user-defined function that the system calls immediately after autoloading a context.")
("destructuringBind"
"destructuringBind( 
l_lambdaList 
l_expression 
[ g_body ] 
) 
=> g_result"
"Enables you to bind variables in a lambda-list to the values of these variables. The list of values is obtained by evaluating the l_expression. The destructuringBind macro then evaluates the g_body form.")
("dynamic"
"dynamic( 
s_varName 
) 
=> g_value / error"
"This syntax form returns the value of the dynamic variable s_varName. If s_varName is not a dynamic variable, it returns an error.")
("dynamicLet"
"dynamicLet( 
(
[(s_var1 g_init1)
(s_var2 g_init2)
...]
) 
=> g_result"
"Evaluates the init forms (g_init1, g_init2, ...) in the current lexical environment, and then binds the variables (s_var1, s_var2, ...) in parallel. The variables are bound as SKILL dynamic variables for the duration of the body forms.")
("err"
"err( 
[ g_value ] 
) 
=> none"
"Causes an error.")
("error"
"error( 
[ S_message1 
[ S_message2 ] ... ] 
) 
=> none"
"Prints error messages and calls err.")
("errset"
"errset( 
g_expr 
[ g_errprint ] 
) 
=> l_result / nil"
"Encapsulates the execution of an expression in an environment safe from the error mechanism. This is a syntax form.")
("errsetstring"
"errsetstring( 
t_string 
[ g_errprint ] 
[ s_langMode ] 
) 
=> l_value / nil"
"Reads and evaluates an expression stored in a string. Same as evalstring except that it calls errset to catch any errors that might occur during the parsing and evaluation.")
("eval"
"eval( 
g_expression 
[ e_environment ] 
) 
=> g_result"
"Evaluates an argument and returns its value. If an environment argument is given, g_expression is treated as SKILL++ code, and the expression is evaluated in the given (lexical) environment. Otherwise g_expression is treated as SKILL code.")
("evalstring"
"evalstring( 
t_string 
[ s_langMode ] 
) 
=> g_value / nil"
"Reads and evaluates an expression stored in a string.")
("expandMacro"
"expandMacro( 
g_form 
) 
=> g_expandedForm"
"Expands one level of macro call for a form.")
("fboundp"
"fboundp( 
s_functionName 
) 
=> g_definition / nil"
"Returns the function binding, if defined, for a specified function name.")
("flet"
"flet( 
l_bindings 
[g_body] 
) 
=> g_result"
"Enables you to define local functions with LET semantics.")
("funcall"
"funcall( 
slu_func 
[ arg ... ] 
) 
=> g_result"
"Applies the given function to the given arguments.")
("getd"
"getd( 
s_functionName 
) 
=> g_definition / nil"
"Returns the function binding for a function name.")
("getFnWriteProtect"
"getFnWriteProtect( 
s_name 
) 
=> t / nil"
"Checks if the given function is write-protected.")
("getFunType"
"getFunType( 
u_functionObject 
) 
=> s_functionObject_type"
"Returns a symbol denoting the function type for a given function object.")
("getVarWriteProtect"
"getVarWriteProtect( 
s_name 
) 
=> t / nil"
"(SKILL mode only) Checks if a variable is write-protected. Does not work in SKILL++ mode. In SKILL++ mode, use getFnWriteProtect instead.")
("globalProc"
"globalProc( 
s_funcName( 
l_formalArglist 
) 
g_expr1 ... 
)
=> s_funcName"
"Defines a global function using a formal argument list.")
("isCallable"
"isCallable( 
s_function 
) 
=> t / nil"
"Checks if a function is defined or is autoloadable from a context.")
("isMacro"
"isMacro( 
s_symbolName 
) 
=> t / nil"
"Checks if the given symbol denotes a macro.")
("labels"
"labels( 
l_bindings 
[ g_body ] 
) 
=> g_result"
"Enables you to define local functions with LET semantics.")
("lambda"
"lambda( 
( s_formalArgument ) 
g_expr1 ... 
) 
=> U_result"
"Defines a function without a name. This is a syntax form.")
("let"
"SKILL mode
let( 
l_bindings 
g_expr1 ... 
) 
=> g_result 
SKILL++ mode
let( 
[ s_var ]
	(
		( s_var1 s_initExp1 )
		( s_var2 s_initExp2 )
	...
	)
body
)
=> g_result"
"In the SKILL mode, this function provides a faster alternative to prog for binding local variables only. This is a syntax form. In the SKILL++ mode, this function declares a lexical scope. This includes a collection of local variables, as well as body expressions to be evaluated. This becomes a named let if the optional s_var is given.")
("letrec"
"letrec(
	(
		( s_var1 s_initExp1 )
		( s_var2 s_initExp2 )
	... 
	)
body
) 
=> g_result"
"(SKILL++ mode) A letrec expression can be used in SKILL++ mode only. All the bindings are in effect while their initial values are being computed, thus allowing mutually recursive definitions. Use letrec to declare recursive local functions.")
("letseq"
"letseq(
	(
		( s_var1 initExp1 )
		( s_var2 initExp2 ) 
		...
	)
body
)
=> g_result"
"A letseq expression can be used in both SKILL and SKILL++ modes. The bindings and evaluations are performed sequentially.")
("mprocedure"
"mprocedure( 
s_macroName( 
s_formalArgument 
) 
g_expr1 ... 
)
=> s_funcName"
"Defines a macro with the given name that takes a single formal argument. This is a syntax form.")
("nlambda"
"nlambda( 
( 
s_formalArgument 
) 
g_expr1 ... 
) 
=> u_result"
"(SKILL mode only) Allows nlambda functions to be defined without having names. In all other respects, nlambda is identical to nprocedure. This is a syntax form that is not supported in SKILL++ mode.")
("nprocedure"
"nprocedure( 
s_funcName( 
s_formalArgument 
) 
g_expr1 ... 
)
=> s_funcName"
"(SKILL mode only) Defines an nlambda function with a function name and a single formal argument. This is a syntax form that is not supported in SKILL++ mode.")
("procedure"
"procedure( 
s_funcName( 
l_formalArglist 
) 
g_expr1 ... 
)
=> s_funcName"
"Defines a function using a formal argument list. The body of the procedure is a list of expressions to evaluate.")
("procedurep"
"procedurep( 
g_obj 
) 
=> t / nil"
"Checks if an object is a procedure, or function, object.")
("prog"
"prog( 
l_localVariables 
[ 
[ s_label ] 
g_expr1 
] ... 
)
=> g_result / nil"
"Allows for local variable bindings and permits abrupt exits on control jumps. This is a syntax form.")
("prog1"
"prog1( 
g_expr1 
[ g_expr2 ... ] 
) 
=> g_result"
"Evaluates expressions from left to right and returns the value of the first expression. This is a syntax form.")
("prog2"
"prog2( 
g_expr1 
g_expr2 
[ g_expr3... ] 
) 
=> g_result"
"Evaluates expressions from left to right and returns the value of the second expression. This is a syntax form.")
("progn"
"progn( 
g_expr1 ... 
) 
=> g_result"
"Evaluates expressions from left to right and returns the value of the last expression. This is a syntax form.")
("putd"
"putd( 
s_functionName 
u_functionDef 
) 
=> u_functionDef"
"Assigns a new function binding, which must be a function, a lambda expression, or nil, to a function name. If you just want to define a function, use procedure or defun.")
("setf_dynamic"
"setf_dynamic( 
g_value 
s_name 
) 
=> g_value"
"Evaluates g_value in the current lexical scope and updates the SKILL variable named s_name.")
("setFnWriteProtect"
"setFnWriteProtect( 
s_name 
) 
=> t / nil"
"Prevents a named function from being redefined.")
("setVarWriteProtect"
"setVarWriteProtect( 
s_name 
) 
=> t / nil"
"(SKILL mode only) Sets the write-protection on a variable to prevent its value from being updated. Does not work in SKILL++ mode.")
("unalias"
"unalias( 
s_aliasName1 ... 
)
=> l_result"
"Undefines the aliases specified in an argument list and returns a list containing the aliases undefined by the call. This is nlambda function also works in SKILL++ mode.")
("unwindProtect"
"unwindProtect( 
[ g_protectedForm ] 
[ g_cleanupForm ]
) 
=> g_result"
"Evaluates the g_protectedForm expression and then executes the SKILL g_cleanupForm expression. Even if the evaluation of g_protectedForm is interrupted or encounters an error, the g_cleanupForm expression is still executed. You can therefore use g_cleanupForm to close open file handles, reset variables, and restore the state to a known value.")
("warn"
"warn( 
t_formatString 
[ g_arg1 ... ] 
) 
=> nil"
"Buffers a warning message with given arguments inserted using the same format specification as sprintf, printf, and fprintf.")
("cdsGetInstPath"
"cdsGetInstPath( 
[ t_name ] 
) 
=> t_string"
"Returns the absolute path of the Cadence installation directory as a string. cdsGetInstPath is for the cds root hierarchy and is meant to be used by all Virtuoso and non-Virtuoso applications.")
("cdsGetToolsPath"
"cdsGetToolsPath( 
[ t_subDirPath ] 
) 
=> t_cdsToolsPath"
"Returns the absolute path of the Cadence installation tools directory as a string after resolving the tools directory appropriately. This function is provided for multiple platform support mainly to simplify access to a common Cadence installation hierarchy for all Unix platforms.")
("cdsPlat"
"cdsPlat()
=> t_plat"
"Returns the platform for the Cadence software that is currently running; one of the following strings: sun4v, sol86, hppa, ibmrs, wint, lnx86, or lni64.")
("changeWorkingDir"
"changeWorkingDir( 
[ S_name ] 
) 
=> t"
"Changes the working directory to S_name.")
("cputime"
"cputime( 
) 
=> x_result"
"Returns the total amount of CPU time (user plus system) used in units of 60ths of a second.")
("createDir"
"createDir( 
S_name 
) 
=> t / nil"
"Creates a directory.")
("createDirHier"
"createDirHier( 
t_pathName 
) 
=> t / nil"
"Creates all directories specified in the given SKILL path that do not already exist")
("csh"
"csh( 
[ t_command ] 
) 
=> t / nil"
"Starts the UNIX C-shell as a child process to execute a command string.")
("deleteDir"
"deleteDir( 
S_name 
) 
=> t / nil"
"Deletes a directory.")
("deleteFile"
"deleteFile( 
S_name 
) 
=> t / nil"
"Deletes a file.")
("exit"
"exit( 
[ x_status ] 
) 
=> nil"
"Causes SKILL to exit with a given process status (defaults to 0), whether in interactive or batch mode.")
("getCurrentTime"
"getCurrentTime( 
) 
=> t_timeString"
"Returns a string representation of the current time.")
("getInstallPath"
"getInstallPath( 
) 
=> l_string"
"Returns the absolute path of the Cadence DFII installation directory where the DFII products are installed on your system as a list of a single string.")
("getLogin"
"getLogin( 
) 
=> t_loginName"
"Returns the user's login name as")
("getPrompts"
"getPrompts( 
) 
=> l_strings"
"Returns the current values of the first level and second level prompt text strings, respectively.")
("getShellEnvVar"
"getShellEnvVar( 
t_UnixShellVariableName 
) 
=> t_value / nil"
"Returns the value of a UNIX environment variable, if it has been set. This function expands the environment variable name specified in the argument.")
("getSkillPath"
"getSkillPath( 
) 
=> l_strings / nil"
"Returns the current SKILL path.")
("getTempDir"
"getTempDir( 
) 
=> t_TempDir"
"Returns the system temp directory as a string.")
("getWorkingDir"
"getWorkingDir( 
) 
=> t_currentDir"
"Returns the current working directory as a string.")
("isDir"
"isDir( 
S_name 
[ tl_path ] 
) 
=> t / nil"
"Checks if a path exists and if it is a directory name.")
("prependInstallPath"
"prependInstallPath( 
S_name 
) 
=> t_string"
"Prepends the Cadence DFII installation path to a file or directory and returns the resulting path as a string.")
("setShellEnvVar"
"setShellEnvVar( 
t_varName_or_nameValuePair 
[ t_varValue ] 
) 
=> t / nil"
"Sets or updates the value of the UNIX environment variable. This function expands the environment variable name specified in the argument.")
("setSkillPath"
"setSkillPath( 
{tl_paths | nil }
) 
=> l_strings / nil"
"Sets the internal SKILL path used by some file-related functions in resolving relative path names.")
("sh, shell"
"sh( 
[ t_command ] 
) 
=> t / nil 

shell( 
[ t_command ] 
) 
=> t / nil"
"Starts the UNIX Bourne shell sh as a child process to execute a command string.")
("system"
"system( 
t_command 
) 
=> x_result"
"Spawns a separate UNIX process to execute a command.")
("unsetShellEnvVar"
"unsetShellEnvVar( 
t_envVarName 
) 
=> t / nil"
"Removes an environment variable from the environment of the calling process. This function expands the environment variable name specified in the argument. If the environment variable (t_envVarName) does not exist in the current environment, the environment is left unchanged.")
("vi, vii, vil"
"vi( 
[ S_fileName ] 
) 
=> t / nil"
"Edits a file using the vi editor. This is an nlambda function. Edits the named file using the vi editor, and optionally includes (vii) or loads (vil) the file into SKILL after exiting the editor. These functions are just variants of ed, edi, and edl with explicit request for using the vi editor.")
("makeNamespace"
"makeNamespace( 
t_name 
) 
=> o_namespace / nil"
"Creates a SKILL namespace with the given t_name. A namespace or its parts can be saved in a context and loaded with the context.")
("findNamespace"
"findNamespace( 
t_name 
) 
=> o_namespace / nil"
"Returns the namespace object with the given name.")
("useNamespace"
"useNamespace(
t_namespace
) 
=> t / nil"
"Sets the given namespace for use and imports its symbols into the current namespace.")
("unuseNamespace"
"unuseNamespace(
t_namespace
) 
=> t / nil"
"Unsets the given namespace.")
("importSymbol"
"importSymbol(
l_symbolList
[t_namespace]
)
=> t / nil"
"Imports symbols into the given namespace. By default, this function imports into the IL (or default) namespace.")
("findSymbol"
"findSymbol(
t_name
[ ?namespace t_namespace ]
)
=> s_symbolName / nil"
"Searches for a symbol that is specified as a string in the given namespace and returns its corresponding SKILL symbol.")
("addToExportList"
"addToExportList(
l_symbols
) 
=> t"
"Adds the specified symbols to the namespace export list. This function does not throw any errors if a symbol is already exported.")
("getSymbolNamespace"
"getSymbolNamespace(
s_name
)
=> o_namespace"
"Returns the namespace where the symbol was created.")
("removeFromExportList"
"removeFromExportList(
l_symbolList
)
=> t"
"Removes symbols referenced in l_symbolList from the export list of its namespace. This function will not throw an error, if some of the symbols are not exported. If a symbol from l_symbolList was imported by useNamespace it will not removed by unuseNamespace.")
("addToNamespace"
"addToNamespace(
t_namespaceName
l_symbolList
) 
=> t"
"Adds and imports the given list of symbol names to the export list of the namespace t_namespaceName.")
("shadow"
"shadow(
l_symbols
[t_namespace] 
)
=> t"
"Adds symbols s_symbol to the shadow list of the default namespace. The symbols which are added to the shadow list are not overridden by import.")
("shadowImport"
"shadowImport(
l_symbols 
[t_namespace]
)
=> t"
"Adds symbols to the namespace shadow list.")
("removeShadowImport"
"shadowImport(
l_symbols 
[t_namespace]
)
=> t"
"Removes the specified symbols from the namespace shadow list.")
("unimportSymbol"
"unimportSymbol(
l_symbolList
[ t_namespace ]
)
=> t"
"Unimports symbols from the given namespace. By default, this function unimports from the IL (or default) namespace.")
("setf_arrayref"
"setf_arrayref"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with arrayref.")
("setf_caaar"
"setf_caaar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with caar.")
("setf_caadr"
"setf_caadr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with caadr.")
("setf_caar"
"setf_caar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with caar.")
("setf_cadar"
"setf_cadar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cadar.")
("setf_caddr"
"setf_caddr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with caddr.")
("setf_cadr"
"setf_cadr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cadr.")
("setf_car"
"setf_car"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with car.")
("setf_cdaar"
"set_cdaar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cdaar.")
("setf_cdadr"
"setf_cdadr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cdadr.")
("setf_cdar"
"setf_cdar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cdar.")
("setf_cddar"
"setf_cddar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cddar.")
("setf_cdddr"
"setf_cdddr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cdddr.")
("setf_cddr"
"setf_cddr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cddr.")
("setf_cdr"
"setf_cdr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with cdr.")
("setf_get"
"setf_get"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with get.")
("setf_getSG"
"setf_getSG"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getSG.")
("setf_getSGq"
"setf_getSGq"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getSGq.")
("setf_getShellEnvVar"
"setf_getShellEnvVar"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getShellEnvVar.")
("setf_getd"
"setf_getd"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getd.")
("setf_getq"
"setf_getq"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getq.")
("setf_getqq"
"setf_getqq"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with getqq.")
("setf_last"
"setf_last"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with last.")
("setf_leftEdge"
"setf_leftEdge"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with leftEdge.")
("setf_lowerLeft"
"setf_lowerLeft"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with lowerLeft.")
("setf_nth"
"setf_nth"
"An expander function for setf, which returns the result of the corresponding setf operation to support setf(nth(...) ...) expressions. In the function, replace helper with nth.")
("setf_nthcdr"
"setf_nthcdr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with nthedr.")
("setf_nthedr"
"setf_nthedr"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with nthcdr.")
("setf_nthelem"
"setf_nthelem"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with nthelem.")
("setf_rightEdge"
"setf_rightEdge"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with rightEdge.")
("setf_slotValue"
"setf_slotValue"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with slotValue.")
("setf_topEdge"
"setf_topEdge"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with topEdge.")
("setf_bottomEdge"
"setf_bottomEdge"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with bottomEdge.")
("setf_upperRight"
"setf_upperRight"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with upperRight.")
("setf_xCoord"
"setf_xCoord"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with xCoord.")
("setf_yCoord"
"setf_yCoord"
"An expander function for setf, which returns the result of the corresponding setf operation. In the function, replace helper with yCoord.")